var TripleBuilder =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@tweenjs/tween.js/dist/tween.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/@tweenjs/tween.js/dist/tween.esm.js ***!
  \**********************************************************/
/*! exports provided: default, Easing, Group, Interpolation, Sequence, Tween, VERSION, add, getAll, nextId, now, remove, removeAll, update */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Easing", function() { return Easing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Group", function() { return Group; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interpolation", function() { return Interpolation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sequence", function() { return Sequence; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tween", function() { return Tween; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAll", function() { return getAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nextId", function() { return nextId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "now", function() { return now$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeAll", function() { return removeAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "update", function() { return update; });
/**
 * The Ease class provides a collection of easing functions for use with tween.js.
 */
var Easing = {
    Linear: {
        None: function (amount) {
            return amount;
        },
    },
    Quadratic: {
        In: function (amount) {
            return amount * amount;
        },
        Out: function (amount) {
            return amount * (2 - amount);
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount;
            }
            return -0.5 * (--amount * (amount - 2) - 1);
        },
    },
    Cubic: {
        In: function (amount) {
            return amount * amount * amount;
        },
        Out: function (amount) {
            return --amount * amount * amount + 1;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount;
            }
            return 0.5 * ((amount -= 2) * amount * amount + 2);
        },
    },
    Quartic: {
        In: function (amount) {
            return amount * amount * amount * amount;
        },
        Out: function (amount) {
            return 1 - --amount * amount * amount * amount;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount * amount;
            }
            return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
        },
    },
    Quintic: {
        In: function (amount) {
            return amount * amount * amount * amount * amount;
        },
        Out: function (amount) {
            return --amount * amount * amount * amount * amount + 1;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount * amount * amount;
            }
            return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
        },
    },
    Sinusoidal: {
        In: function (amount) {
            return 1 - Math.cos((amount * Math.PI) / 2);
        },
        Out: function (amount) {
            return Math.sin((amount * Math.PI) / 2);
        },
        InOut: function (amount) {
            return 0.5 * (1 - Math.cos(Math.PI * amount));
        },
    },
    Exponential: {
        In: function (amount) {
            return amount === 0 ? 0 : Math.pow(1024, amount - 1);
        },
        Out: function (amount) {
            return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
        },
        InOut: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            if ((amount *= 2) < 1) {
                return 0.5 * Math.pow(1024, amount - 1);
            }
            return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
        },
    },
    Circular: {
        In: function (amount) {
            return 1 - Math.sqrt(1 - amount * amount);
        },
        Out: function (amount) {
            return Math.sqrt(1 - --amount * amount);
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
        },
    },
    Elastic: {
        In: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
        },
        Out: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
        },
        InOut: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            amount *= 2;
            if (amount < 1) {
                return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
            }
            return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
        },
    },
    Back: {
        In: function (amount) {
            var s = 1.70158;
            return amount * amount * ((s + 1) * amount - s);
        },
        Out: function (amount) {
            var s = 1.70158;
            return --amount * amount * ((s + 1) * amount + s) + 1;
        },
        InOut: function (amount) {
            var s = 1.70158 * 1.525;
            if ((amount *= 2) < 1) {
                return 0.5 * (amount * amount * ((s + 1) * amount - s));
            }
            return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);
        },
    },
    Bounce: {
        In: function (amount) {
            return 1 - Easing.Bounce.Out(1 - amount);
        },
        Out: function (amount) {
            if (amount < 1 / 2.75) {
                return 7.5625 * amount * amount;
            }
            else if (amount < 2 / 2.75) {
                return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
            }
            else if (amount < 2.5 / 2.75) {
                return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
            }
            else {
                return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
            }
        },
        InOut: function (amount) {
            if (amount < 0.5) {
                return Easing.Bounce.In(amount * 2) * 0.5;
            }
            return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
        },
    },
};

var now;
// Include a performance.now polyfill.
// In node.js, use process.hrtime.
// eslint-disable-next-line
// @ts-ignore
if (typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime) {
    now = function () {
        // eslint-disable-next-line
        // @ts-ignore
        var time = process.hrtime();
        // Convert [seconds, nanoseconds] to milliseconds.
        return time[0] * 1000 + time[1] / 1000000;
    };
}
// In a browser, use self.performance.now if it is available.
else if (typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined) {
    // This must be bound, because directly assigning this function
    // leads to an invocation exception in Chrome.
    now = self.performance.now.bind(self.performance);
}
// Use Date.now if it is available.
else if (Date.now !== undefined) {
    now = Date.now;
}
// Otherwise, use 'new Date().getTime()'.
else {
    now = function () {
        return new Date().getTime();
    };
}
var now$1 = now;

/**
 * Controlling groups of tweens
 *
 * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
 * In these cases, you may want to create your own smaller groups of tween
 */
var Group = /** @class */ (function () {
    function Group() {
        this._tweens = {};
        this._tweensAddedDuringUpdate = {};
    }
    Group.prototype.getAll = function () {
        var _this = this;
        return Object.keys(this._tweens).map(function (tweenId) {
            return _this._tweens[tweenId];
        });
    };
    Group.prototype.removeAll = function () {
        this._tweens = {};
    };
    Group.prototype.add = function (tween) {
        this._tweens[tween.getId()] = tween;
        this._tweensAddedDuringUpdate[tween.getId()] = tween;
    };
    Group.prototype.remove = function (tween) {
        delete this._tweens[tween.getId()];
        delete this._tweensAddedDuringUpdate[tween.getId()];
    };
    Group.prototype.update = function (time, preserve) {
        if (time === void 0) { time = now$1(); }
        if (preserve === void 0) { preserve = false; }
        var tweenIds = Object.keys(this._tweens);
        if (tweenIds.length === 0) {
            return false;
        }
        // Tweens are updated in "batches". If you add a new tween during an
        // update, then the new tween will be updated in the next batch.
        // If you remove a tween during an update, it may or may not be updated.
        // However, if the removed tween was added during the current batch,
        // then it will not be updated.
        while (tweenIds.length > 0) {
            this._tweensAddedDuringUpdate = {};
            for (var i = 0; i < tweenIds.length; i++) {
                var tween = this._tweens[tweenIds[i]];
                var autoStart = !preserve;
                if (tween && tween.update(time, autoStart) === false && !preserve) {
                    delete this._tweens[tweenIds[i]];
                }
            }
            tweenIds = Object.keys(this._tweensAddedDuringUpdate);
        }
        return true;
    };
    return Group;
}());

/**
 *
 */
var Interpolation = {
    Linear: function (v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = Interpolation.Utils.Linear;
        if (k < 0) {
            return fn(v[0], v[1], f);
        }
        if (k > 1) {
            return fn(v[m], v[m - 1], m - f);
        }
        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
    },
    Bezier: function (v, k) {
        var b = 0;
        var n = v.length - 1;
        var pw = Math.pow;
        var bn = Interpolation.Utils.Bernstein;
        for (var i = 0; i <= n; i++) {
            b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
        }
        return b;
    },
    CatmullRom: function (v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = Interpolation.Utils.CatmullRom;
        if (v[0] === v[m]) {
            if (k < 0) {
                i = Math.floor((f = m * (1 + k)));
            }
            return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
        }
        else {
            if (k < 0) {
                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
            }
            if (k > 1) {
                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
            }
            return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
        }
    },
    Utils: {
        Linear: function (p0, p1, t) {
            return (p1 - p0) * t + p0;
        },
        Bernstein: function (n, i) {
            var fc = Interpolation.Utils.Factorial;
            return fc(n) / fc(i) / fc(n - i);
        },
        Factorial: (function () {
            var a = [1];
            return function (n) {
                var s = 1;
                if (a[n]) {
                    return a[n];
                }
                for (var i = n; i > 1; i--) {
                    s *= i;
                }
                a[n] = s;
                return s;
            };
        })(),
        CatmullRom: function (p0, p1, p2, p3, t) {
            var v0 = (p2 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            var t2 = t * t;
            var t3 = t * t2;
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
        },
    },
};

/**
 * Utils
 */
var Sequence = /** @class */ (function () {
    function Sequence() {
    }
    Sequence.nextId = function () {
        return Sequence._nextId++;
    };
    Sequence._nextId = 0;
    return Sequence;
}());

var mainGroup = new Group();

/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */
var Tween = /** @class */ (function () {
    function Tween(_object, _group) {
        if (_group === void 0) { _group = mainGroup; }
        this._object = _object;
        this._group = _group;
        this._isPaused = false;
        this._pauseStart = 0;
        this._valuesStart = {};
        this._valuesEnd = {};
        this._valuesStartRepeat = {};
        this._duration = 1000;
        this._initialRepeat = 0;
        this._repeat = 0;
        this._yoyo = false;
        this._isPlaying = false;
        this._reversed = false;
        this._delayTime = 0;
        this._startTime = 0;
        this._easingFunction = Easing.Linear.None;
        this._interpolationFunction = Interpolation.Linear;
        this._chainedTweens = [];
        this._onStartCallbackFired = false;
        this._id = Sequence.nextId();
        this._isChainStopped = false;
        this._goToEnd = false;
    }
    Tween.prototype.getId = function () {
        return this._id;
    };
    Tween.prototype.isPlaying = function () {
        return this._isPlaying;
    };
    Tween.prototype.isPaused = function () {
        return this._isPaused;
    };
    Tween.prototype.to = function (properties, duration) {
        // TODO? restore this, then update the 07_dynamic_to example to set fox
        // tween's to on each update. That way the behavior is opt-in (there's
        // currently no opt-out).
        // for (const prop in properties) this._valuesEnd[prop] = properties[prop]
        this._valuesEnd = Object.create(properties);
        if (duration !== undefined) {
            this._duration = duration;
        }
        return this;
    };
    Tween.prototype.duration = function (d) {
        this._duration = d;
        return this;
    };
    Tween.prototype.start = function (time) {
        if (this._isPlaying) {
            return this;
        }
        // eslint-disable-next-line
        this._group && this._group.add(this);
        this._repeat = this._initialRepeat;
        if (this._reversed) {
            // If we were reversed (f.e. using the yoyo feature) then we need to
            // flip the tween direction back to forward.
            this._reversed = false;
            for (var property in this._valuesStartRepeat) {
                this._swapEndStartRepeatValues(property);
                this._valuesStart[property] = this._valuesStartRepeat[property];
            }
        }
        this._isPlaying = true;
        this._isPaused = false;
        this._onStartCallbackFired = false;
        this._isChainStopped = false;
        this._startTime = time !== undefined ? (typeof time === 'string' ? now$1() + parseFloat(time) : time) : now$1();
        this._startTime += this._delayTime;
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat);
        return this;
    };
    Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {
        for (var property in _valuesEnd) {
            var startValue = _object[property];
            var startValueIsArray = Array.isArray(startValue);
            var propType = startValueIsArray ? 'array' : typeof startValue;
            var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
            // If `to()` specifies a property that doesn't exist in the source object,
            // we should not set that property in the object
            if (propType === 'undefined' || propType === 'function') {
                continue;
            }
            // Check if an Array was provided as property value
            if (isInterpolationList) {
                var endValues = _valuesEnd[property];
                if (endValues.length === 0) {
                    continue;
                }
                // handle an array of relative values
                endValues = endValues.map(this._handleRelativeValue.bind(this, startValue));
                // Create a local copy of the Array with the start value at the front
                _valuesEnd[property] = [startValue].concat(endValues);
            }
            // handle the deepness of the values
            if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {
                _valuesStart[property] = startValueIsArray ? [] : {};
                // eslint-disable-next-line
                for (var prop in startValue) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStart[property][prop] = startValue[prop];
                }
                _valuesStartRepeat[property] = startValueIsArray ? [] : {}; // TODO? repeat nested values? And yoyo? And array values?
                // eslint-disable-next-line
                // @ts-ignore FIXME?
                this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property]);
            }
            else {
                // Save the starting value, but only once.
                if (typeof _valuesStart[property] === 'undefined') {
                    _valuesStart[property] = startValue;
                }
                if (!startValueIsArray) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
                }
                if (isInterpolationList) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
                }
                else {
                    _valuesStartRepeat[property] = _valuesStart[property] || 0;
                }
            }
        }
    };
    Tween.prototype.stop = function () {
        if (!this._isChainStopped) {
            this._isChainStopped = true;
            this.stopChainedTweens();
        }
        if (!this._isPlaying) {
            return this;
        }
        // eslint-disable-next-line
        this._group && this._group.remove(this);
        this._isPlaying = false;
        this._isPaused = false;
        if (this._onStopCallback) {
            this._onStopCallback(this._object);
        }
        return this;
    };
    Tween.prototype.end = function () {
        this._goToEnd = true;
        this.update(Infinity);
        return this;
    };
    Tween.prototype.pause = function (time) {
        if (time === void 0) { time = now$1(); }
        if (this._isPaused || !this._isPlaying) {
            return this;
        }
        this._isPaused = true;
        this._pauseStart = time;
        // eslint-disable-next-line
        this._group && this._group.remove(this);
        return this;
    };
    Tween.prototype.resume = function (time) {
        if (time === void 0) { time = now$1(); }
        if (!this._isPaused || !this._isPlaying) {
            return this;
        }
        this._isPaused = false;
        this._startTime += time - this._pauseStart;
        this._pauseStart = 0;
        // eslint-disable-next-line
        this._group && this._group.add(this);
        return this;
    };
    Tween.prototype.stopChainedTweens = function () {
        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
            this._chainedTweens[i].stop();
        }
        return this;
    };
    Tween.prototype.group = function (group) {
        this._group = group;
        return this;
    };
    Tween.prototype.delay = function (amount) {
        this._delayTime = amount;
        return this;
    };
    Tween.prototype.repeat = function (times) {
        this._initialRepeat = times;
        this._repeat = times;
        return this;
    };
    Tween.prototype.repeatDelay = function (amount) {
        this._repeatDelayTime = amount;
        return this;
    };
    Tween.prototype.yoyo = function (yoyo) {
        this._yoyo = yoyo;
        return this;
    };
    Tween.prototype.easing = function (easingFunction) {
        this._easingFunction = easingFunction;
        return this;
    };
    Tween.prototype.interpolation = function (interpolationFunction) {
        this._interpolationFunction = interpolationFunction;
        return this;
    };
    Tween.prototype.chain = function () {
        var tweens = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            tweens[_i] = arguments[_i];
        }
        this._chainedTweens = tweens;
        return this;
    };
    Tween.prototype.onStart = function (callback) {
        this._onStartCallback = callback;
        return this;
    };
    Tween.prototype.onUpdate = function (callback) {
        this._onUpdateCallback = callback;
        return this;
    };
    Tween.prototype.onRepeat = function (callback) {
        this._onRepeatCallback = callback;
        return this;
    };
    Tween.prototype.onComplete = function (callback) {
        this._onCompleteCallback = callback;
        return this;
    };
    Tween.prototype.onStop = function (callback) {
        this._onStopCallback = callback;
        return this;
    };
    /**
     * @returns true if the tween is still playing after the update, false
     * otherwise (calling update on a paused tween still returns true because
     * it is still playing, just paused).
     */
    Tween.prototype.update = function (time, autoStart) {
        if (time === void 0) { time = now$1(); }
        if (autoStart === void 0) { autoStart = true; }
        if (this._isPaused)
            return true;
        var property;
        var elapsed;
        var endTime = this._startTime + this._duration;
        if (!this._goToEnd && !this._isPlaying) {
            if (time > endTime)
                return false;
            if (autoStart)
                this.start(time);
        }
        this._goToEnd = false;
        if (time < this._startTime) {
            return true;
        }
        if (this._onStartCallbackFired === false) {
            if (this._onStartCallback) {
                this._onStartCallback(this._object);
            }
            this._onStartCallbackFired = true;
        }
        elapsed = (time - this._startTime) / this._duration;
        elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
        var value = this._easingFunction(elapsed);
        // properties transformations
        this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
        if (this._onUpdateCallback) {
            this._onUpdateCallback(this._object, elapsed);
        }
        if (elapsed === 1) {
            if (this._repeat > 0) {
                if (isFinite(this._repeat)) {
                    this._repeat--;
                }
                // Reassign starting values, restart by making startTime = now
                for (property in this._valuesStartRepeat) {
                    if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {
                        this._valuesStartRepeat[property] =
                            // eslint-disable-next-line
                            // @ts-ignore FIXME?
                            this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
                    }
                    if (this._yoyo) {
                        this._swapEndStartRepeatValues(property);
                    }
                    this._valuesStart[property] = this._valuesStartRepeat[property];
                }
                if (this._yoyo) {
                    this._reversed = !this._reversed;
                }
                if (this._repeatDelayTime !== undefined) {
                    this._startTime = time + this._repeatDelayTime;
                }
                else {
                    this._startTime = time + this._delayTime;
                }
                if (this._onRepeatCallback) {
                    this._onRepeatCallback(this._object);
                }
                return true;
            }
            else {
                if (this._onCompleteCallback) {
                    this._onCompleteCallback(this._object);
                }
                for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                    // Make the chained tweens start exactly at the time they should,
                    // even if the `update()` method was called way past the duration of the tween
                    this._chainedTweens[i].start(this._startTime + this._duration);
                }
                this._isPlaying = false;
                return false;
            }
        }
        return true;
    };
    Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {
        for (var property in _valuesEnd) {
            // Don't update properties that do not exist in the source object
            if (_valuesStart[property] === undefined) {
                continue;
            }
            var start = _valuesStart[property] || 0;
            var end = _valuesEnd[property];
            var startIsArray = Array.isArray(_object[property]);
            var endIsArray = Array.isArray(end);
            var isInterpolationList = !startIsArray && endIsArray;
            if (isInterpolationList) {
                _object[property] = this._interpolationFunction(end, value);
            }
            else if (typeof end === 'object' && end) {
                // eslint-disable-next-line
                // @ts-ignore FIXME?
                this._updateProperties(_object[property], start, end, value);
            }
            else {
                // Parses relative end values with start as base (e.g.: +10, -3)
                end = this._handleRelativeValue(start, end);
                // Protect against non numeric properties.
                if (typeof end === 'number') {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _object[property] = start + (end - start) * value;
                }
            }
        }
    };
    Tween.prototype._handleRelativeValue = function (start, end) {
        if (typeof end !== 'string') {
            return end;
        }
        if (end.charAt(0) === '+' || end.charAt(0) === '-') {
            return start + parseFloat(end);
        }
        else {
            return parseFloat(end);
        }
    };
    Tween.prototype._swapEndStartRepeatValues = function (property) {
        var tmp = this._valuesStartRepeat[property];
        var endValue = this._valuesEnd[property];
        if (typeof endValue === 'string') {
            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
        }
        else {
            this._valuesStartRepeat[property] = this._valuesEnd[property];
        }
        this._valuesEnd[property] = tmp;
    };
    return Tween;
}());

var VERSION = '18.6.4';

/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */
var nextId = Sequence.nextId;
/**
 * Controlling groups of tweens
 *
 * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
 * In these cases, you may want to create your own smaller groups of tweens.
 */
var TWEEN = mainGroup;
// This is the best way to export things in a way that's compatible with both ES
// Modules and CommonJS, without build hacks, and so as not to break the
// existing API.
// https://github.com/rollup/rollup/issues/1961#issuecomment-423037881
var getAll = TWEEN.getAll.bind(TWEEN);
var removeAll = TWEEN.removeAll.bind(TWEEN);
var add = TWEEN.add.bind(TWEEN);
var remove = TWEEN.remove.bind(TWEEN);
var update = TWEEN.update.bind(TWEEN);
var exports = {
    Easing: Easing,
    Group: Group,
    Interpolation: Interpolation,
    now: now$1,
    Sequence: Sequence,
    nextId: nextId,
    Tween: Tween,
    VERSION: VERSION,
    getAll: getAll,
    removeAll: removeAll,
    add: add,
    remove: remove,
    update: update,
};

/* harmony default export */ __webpack_exports__["default"] = (exports);


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/three/build/three.module.js":
/*!**************************************************!*\
  !*** ./node_modules/three/build/three.module.js ***!
  \**************************************************/
/*! exports provided: ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveAnimationBlendMode, AdditiveBlending, AgXToneMapping, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, AttachedBindMode, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BackSide, BasicDepthPacking, BasicShadowMap, BatchedMesh, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CineonToneMapping, CircleGeometry, ClampToEdgeWrapping, Clock, Color, ColorKeyframeTrack, ColorManagement, CompressedArrayTexture, CompressedCubeTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, ConstantAlphaFactor, ConstantColorFactor, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CustomToneMapping, CylinderGeometry, Cylindrical, Data3DTexture, DataArrayTexture, DataTexture, DataTextureLoader, DataUtils, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DetachedBindMode, DirectionalLight, DirectionalLightHelper, DiscreteInterpolant, DisplayP3ColorSpace, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, EqualCompare, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeGeometry, FileLoader, Float16BufferAttribute, Float32BufferAttribute, FloatType, Fog, FogExp2, FramebufferTexture, FrontSide, Frustum, GLBufferAttribute, GLSL1, GLSL3, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, KeepStencilOp, KeyframeTrack, LOD, LatheGeometry, Layers, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LineSegments, LinearDisplayP3ColorSpace, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, LinearTransfer, Loader, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, MathUtils, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeutralToneMapping, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, NormalAnimationBlendMode, NormalBlending, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronGeometry, OneFactor, OneMinusConstantAlphaFactor, OneMinusConstantColorFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, P3Primaries, PCFShadowMap, PCFSoftShadowMap, PMREMGenerator, Path, PerspectiveCamera, Plane, PlaneGeometry, PlaneHelper, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBFormat, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, Rec709Primaries, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RenderTarget, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingGeometry, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, SRGBTransfer, Scene, ShaderChunk, ShaderLib, ShaderMaterial, ShadowMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, SphereGeometry, Spherical, SphericalHarmonics3, SplineCurve, SpotLight, SpotLightHelper, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronGeometry, Texture, TextureLoader, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedInt5999Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLCoordinateSystem, WebGLCubeRenderTarget, WebGLMultipleRenderTargets, WebGLRenderTarget, WebGLRenderer, WebGLUtils, WebGPUCoordinateSystem, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, createCanvasElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ACESFilmicToneMapping", function() { return ACESFilmicToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddEquation", function() { return AddEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddOperation", function() { return AddOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdditiveAnimationBlendMode", function() { return AdditiveAnimationBlendMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdditiveBlending", function() { return AdditiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AgXToneMapping", function() { return AgXToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaFormat", function() { return AlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysCompare", function() { return AlwaysCompare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysDepth", function() { return AlwaysDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysStencilFunc", function() { return AlwaysStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AmbientLight", function() { return AmbientLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationAction", function() { return AnimationAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationClip", function() { return AnimationClip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationLoader", function() { return AnimationLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationMixer", function() { return AnimationMixer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationObjectGroup", function() { return AnimationObjectGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationUtils", function() { return AnimationUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArcCurve", function() { return ArcCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrayCamera", function() { return ArrayCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrowHelper", function() { return ArrowHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AttachedBindMode", function() { return AttachedBindMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Audio", function() { return Audio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioAnalyser", function() { return AudioAnalyser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioContext", function() { return AudioContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioListener", function() { return AudioListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioLoader", function() { return AudioLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxesHelper", function() { return AxesHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BackSide", function() { return BackSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicDepthPacking", function() { return BasicDepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicShadowMap", function() { return BasicShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BatchedMesh", function() { return BatchedMesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bone", function() { return Bone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BooleanKeyframeTrack", function() { return BooleanKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box2", function() { return Box2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box3", function() { return Box3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box3Helper", function() { return Box3Helper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxGeometry", function() { return BoxGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxHelper", function() { return BoxHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferAttribute", function() { return BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometry", function() { return BufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometryLoader", function() { return BufferGeometryLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ByteType", function() { return ByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cache", function() { return Cache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Camera", function() { return Camera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CameraHelper", function() { return CameraHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasTexture", function() { return CanvasTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CapsuleGeometry", function() { return CapsuleGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CatmullRomCurve3", function() { return CatmullRomCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CineonToneMapping", function() { return CineonToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleGeometry", function() { return CircleGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClampToEdgeWrapping", function() { return ClampToEdgeWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Clock", function() { return Clock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorKeyframeTrack", function() { return ColorKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorManagement", function() { return ColorManagement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedArrayTexture", function() { return CompressedArrayTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedCubeTexture", function() { return CompressedCubeTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTexture", function() { return CompressedTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTextureLoader", function() { return CompressedTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConeGeometry", function() { return ConeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConstantAlphaFactor", function() { return ConstantAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConstantColorFactor", function() { return ConstantColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeCamera", function() { return CubeCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeReflectionMapping", function() { return CubeReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeRefractionMapping", function() { return CubeRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTexture", function() { return CubeTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTextureLoader", function() { return CubeTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVReflectionMapping", function() { return CubeUVReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve", function() { return CubicBezierCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve3", function() { return CubicBezierCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicInterpolant", function() { return CubicInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceBack", function() { return CullFaceBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFront", function() { return CullFaceFront; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFrontBack", function() { return CullFaceFrontBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceNone", function() { return CullFaceNone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Curve", function() { return Curve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CurvePath", function() { return CurvePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomBlending", function() { return CustomBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomToneMapping", function() { return CustomToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderGeometry", function() { return CylinderGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cylindrical", function() { return Cylindrical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Data3DTexture", function() { return Data3DTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataArrayTexture", function() { return DataArrayTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture", function() { return DataTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTextureLoader", function() { return DataTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataUtils", function() { return DataUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementStencilOp", function() { return DecrementStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementWrapStencilOp", function() { return DecrementWrapStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLoadingManager", function() { return DefaultLoadingManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthFormat", function() { return DepthFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthStencilFormat", function() { return DepthStencilFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthTexture", function() { return DepthTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DetachedBindMode", function() { return DetachedBindMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLight", function() { return DirectionalLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLightHelper", function() { return DirectionalLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiscreteInterpolant", function() { return DiscreteInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DisplayP3ColorSpace", function() { return DisplayP3ColorSpace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DodecahedronGeometry", function() { return DodecahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DoubleSide", function() { return DoubleSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstAlphaFactor", function() { return DstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstColorFactor", function() { return DstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicCopyUsage", function() { return DynamicCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicDrawUsage", function() { return DynamicDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicReadUsage", function() { return DynamicReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgesGeometry", function() { return EdgesGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseCurve", function() { return EllipseCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualCompare", function() { return EqualCompare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualDepth", function() { return EqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualStencilFunc", function() { return EqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularReflectionMapping", function() { return EquirectangularReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularRefractionMapping", function() { return EquirectangularRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Euler", function() { return Euler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() { return EventDispatcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudeGeometry", function() { return ExtrudeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileLoader", function() { return FileLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float16BufferAttribute", function() { return Float16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32BufferAttribute", function() { return Float32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FloatType", function() { return FloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fog", function() { return Fog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FogExp2", function() { return FogExp2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FramebufferTexture", function() { return FramebufferTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontSide", function() { return FrontSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Frustum", function() { return Frustum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLBufferAttribute", function() { return GLBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLSL1", function() { return GLSL1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLSL3", function() { return GLSL3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterCompare", function() { return GreaterCompare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterDepth", function() { return GreaterDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualCompare", function() { return GreaterEqualCompare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualDepth", function() { return GreaterEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualStencilFunc", function() { return GreaterEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterStencilFunc", function() { return GreaterStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridHelper", function() { return GridHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Group", function() { return Group; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HalfFloatType", function() { return HalfFloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLight", function() { return HemisphereLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLightHelper", function() { return HemisphereLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IcosahedronGeometry", function() { return IcosahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageBitmapLoader", function() { return ImageBitmapLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageLoader", function() { return ImageLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageUtils", function() { return ImageUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementStencilOp", function() { return IncrementStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementWrapStencilOp", function() { return IncrementWrapStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferAttribute", function() { return InstancedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferGeometry", function() { return InstancedBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedInterleavedBuffer", function() { return InstancedInterleavedBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedMesh", function() { return InstancedMesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16BufferAttribute", function() { return Int16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32BufferAttribute", function() { return Int32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8BufferAttribute", function() { return Int8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntType", function() { return IntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBuffer", function() { return InterleavedBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBufferAttribute", function() { return InterleavedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interpolant", function() { return Interpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateDiscrete", function() { return InterpolateDiscrete; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateLinear", function() { return InterpolateLinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateSmooth", function() { return InterpolateSmooth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InvertStencilOp", function() { return InvertStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeepStencilOp", function() { return KeepStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyframeTrack", function() { return KeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LOD", function() { return LOD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LatheGeometry", function() { return LatheGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Layers", function() { return Layers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessCompare", function() { return LessCompare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessDepth", function() { return LessDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualCompare", function() { return LessEqualCompare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualDepth", function() { return LessEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualStencilFunc", function() { return LessEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessStencilFunc", function() { return LessStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Light", function() { return Light; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LightProbe", function() { return LightProbe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return Line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line3", function() { return Line3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineBasicMaterial", function() { return LineBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve", function() { return LineCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve3", function() { return LineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineDashedMaterial", function() { return LineDashedMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineLoop", function() { return LineLoop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineSegments", function() { return LineSegments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearDisplayP3ColorSpace", function() { return LinearDisplayP3ColorSpace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearFilter", function() { return LinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearInterpolant", function() { return LinearInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapLinearFilter", function() { return LinearMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapNearestFilter", function() { return LinearMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapLinearFilter", function() { return LinearMipmapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapNearestFilter", function() { return LinearMipmapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearSRGBColorSpace", function() { return LinearSRGBColorSpace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearToneMapping", function() { return LinearToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearTransfer", function() { return LinearTransfer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Loader", function() { return Loader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoaderUtils", function() { return LoaderUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoadingManager", function() { return LoadingManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopOnce", function() { return LoopOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopPingPong", function() { return LoopPingPong; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopRepeat", function() { return LoopRepeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceAlphaFormat", function() { return LuminanceAlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceFormat", function() { return LuminanceFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUSE", function() { return MOUSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Material", function() { return Material; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaterialLoader", function() { return MaterialLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MathUtils", function() { return MathUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix3", function() { return Matrix3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix4", function() { return Matrix4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaxEquation", function() { return MaxEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mesh", function() { return Mesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshBasicMaterial", function() { return MeshBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDepthMaterial", function() { return MeshDepthMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDistanceMaterial", function() { return MeshDistanceMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshLambertMaterial", function() { return MeshLambertMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshMatcapMaterial", function() { return MeshMatcapMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshNormalMaterial", function() { return MeshNormalMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhongMaterial", function() { return MeshPhongMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhysicalMaterial", function() { return MeshPhysicalMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshStandardMaterial", function() { return MeshStandardMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshToonMaterial", function() { return MeshToonMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MinEquation", function() { return MinEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MirroredRepeatWrapping", function() { return MirroredRepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MixOperation", function() { return MixOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyBlending", function() { return MultiplyBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyOperation", function() { return MultiplyOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestFilter", function() { return NearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapLinearFilter", function() { return NearestMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapNearestFilter", function() { return NearestMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapLinearFilter", function() { return NearestMipmapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapNearestFilter", function() { return NearestMipmapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeutralToneMapping", function() { return NeutralToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverCompare", function() { return NeverCompare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverDepth", function() { return NeverDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverStencilFunc", function() { return NeverStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoBlending", function() { return NoBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoColorSpace", function() { return NoColorSpace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoToneMapping", function() { return NoToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalAnimationBlendMode", function() { return NormalAnimationBlendMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalBlending", function() { return NormalBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualCompare", function() { return NotEqualCompare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualDepth", function() { return NotEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualStencilFunc", function() { return NotEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberKeyframeTrack", function() { return NumberKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Object3D", function() { return Object3D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectLoader", function() { return ObjectLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectSpaceNormalMap", function() { return ObjectSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctahedronGeometry", function() { return OctahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneFactor", function() { return OneFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusConstantAlphaFactor", function() { return OneMinusConstantAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusConstantColorFactor", function() { return OneMinusConstantColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstAlphaFactor", function() { return OneMinusDstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstColorFactor", function() { return OneMinusDstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcAlphaFactor", function() { return OneMinusSrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcColorFactor", function() { return OneMinusSrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrthographicCamera", function() { return OrthographicCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "P3Primaries", function() { return P3Primaries; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFShadowMap", function() { return PCFShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFSoftShadowMap", function() { return PCFSoftShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PMREMGenerator", function() { return PMREMGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PerspectiveCamera", function() { return PerspectiveCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Plane", function() { return Plane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneGeometry", function() { return PlaneGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneHelper", function() { return PlaneHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLight", function() { return PointLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLightHelper", function() { return PointLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Points", function() { return Points; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointsMaterial", function() { return PointsMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolarGridHelper", function() { return PolarGridHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyhedronGeometry", function() { return PolyhedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PositionalAudio", function() { return PositionalAudio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyBinding", function() { return PropertyBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyMixer", function() { return PropertyMixer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve", function() { return QuadraticBezierCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve3", function() { return QuadraticBezierCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quaternion", function() { return Quaternion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionKeyframeTrack", function() { return QuaternionKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionLinearInterpolant", function() { return QuaternionLinearInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RED_GREEN_RGTC2_Format", function() { return RED_GREEN_RGTC2_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RED_RGTC1_Format", function() { return RED_RGTC1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REVISION", function() { return REVISION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBADepthPacking", function() { return RGBADepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAFormat", function() { return RGBAFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAIntegerFormat", function() { return RGBAIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x10_Format", function() { return RGBA_ASTC_10x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x5_Format", function() { return RGBA_ASTC_10x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x6_Format", function() { return RGBA_ASTC_10x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x8_Format", function() { return RGBA_ASTC_10x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x10_Format", function() { return RGBA_ASTC_12x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x12_Format", function() { return RGBA_ASTC_12x12_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_4x4_Format", function() { return RGBA_ASTC_4x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x4_Format", function() { return RGBA_ASTC_5x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x5_Format", function() { return RGBA_ASTC_5x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x5_Format", function() { return RGBA_ASTC_6x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x6_Format", function() { return RGBA_ASTC_6x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x5_Format", function() { return RGBA_ASTC_8x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x6_Format", function() { return RGBA_ASTC_8x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x8_Format", function() { return RGBA_ASTC_8x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_BPTC_Format", function() { return RGBA_BPTC_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ETC2_EAC_Format", function() { return RGBA_ETC2_EAC_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_2BPPV1_Format", function() { return RGBA_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_4BPPV1_Format", function() { return RGBA_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT1_Format", function() { return RGBA_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT3_Format", function() { return RGBA_S3TC_DXT3_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT5_Format", function() { return RGBA_S3TC_DXT5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBFormat", function() { return RGBFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_BPTC_SIGNED_Format", function() { return RGB_BPTC_SIGNED_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_BPTC_UNSIGNED_Format", function() { return RGB_BPTC_UNSIGNED_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC1_Format", function() { return RGB_ETC1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC2_Format", function() { return RGB_ETC2_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_2BPPV1_Format", function() { return RGB_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_4BPPV1_Format", function() { return RGB_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_S3TC_DXT1_Format", function() { return RGB_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGFormat", function() { return RGFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGIntegerFormat", function() { return RGIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RawShaderMaterial", function() { return RawShaderMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ray", function() { return Ray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Raycaster", function() { return Raycaster; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rec709Primaries", function() { return Rec709Primaries; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RectAreaLight", function() { return RectAreaLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedFormat", function() { return RedFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedIntegerFormat", function() { return RedIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReinhardToneMapping", function() { return ReinhardToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderTarget", function() { return RenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RepeatWrapping", function() { return RepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReplaceStencilOp", function() { return ReplaceStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReverseSubtractEquation", function() { return ReverseSubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RingGeometry", function() { return RingGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SIGNED_RED_GREEN_RGTC2_Format", function() { return SIGNED_RED_GREEN_RGTC2_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SIGNED_RED_RGTC1_Format", function() { return SIGNED_RED_RGTC1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGBColorSpace", function() { return SRGBColorSpace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGBTransfer", function() { return SRGBTransfer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scene", function() { return Scene; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderChunk", function() { return ShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderLib", function() { return ShaderLib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderMaterial", function() { return ShaderMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMaterial", function() { return ShadowMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeGeometry", function() { return ShapeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapePath", function() { return ShapePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeUtils", function() { return ShapeUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShortType", function() { return ShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Skeleton", function() { return Skeleton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkeletonHelper", function() { return SkeletonHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkinnedMesh", function() { return SkinnedMesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Source", function() { return Source; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sphere", function() { return Sphere; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereGeometry", function() { return SphereGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spherical", function() { return Spherical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphericalHarmonics3", function() { return SphericalHarmonics3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplineCurve", function() { return SplineCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLight", function() { return SpotLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLightHelper", function() { return SpotLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sprite", function() { return Sprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteMaterial", function() { return SpriteMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaFactor", function() { return SrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaSaturateFactor", function() { return SrcAlphaSaturateFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcColorFactor", function() { return SrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticCopyUsage", function() { return StaticCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticDrawUsage", function() { return StaticDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticReadUsage", function() { return StaticReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StereoCamera", function() { return StereoCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamCopyUsage", function() { return StreamCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamDrawUsage", function() { return StreamDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamReadUsage", function() { return StreamReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StringKeyframeTrack", function() { return StringKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractEquation", function() { return SubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractiveBlending", function() { return SubtractiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOUCH", function() { return TOUCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TangentSpaceNormalMap", function() { return TangentSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TetrahedronGeometry", function() { return TetrahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Texture", function() { return Texture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureLoader", function() { return TextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusGeometry", function() { return TorusGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnotGeometry", function() { return TorusKnotGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Triangle", function() { return Triangle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleFanDrawMode", function() { return TriangleFanDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleStripDrawMode", function() { return TriangleStripDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrianglesDrawMode", function() { return TrianglesDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TubeGeometry", function() { return TubeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UVMapping", function() { return UVMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16BufferAttribute", function() { return Uint16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32BufferAttribute", function() { return Uint32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8BufferAttribute", function() { return Uint8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedBufferAttribute", function() { return Uint8ClampedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uniform", function() { return Uniform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsGroup", function() { return UniformsGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsLib", function() { return UniformsLib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsUtils", function() { return UniformsUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedByteType", function() { return UnsignedByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedInt248Type", function() { return UnsignedInt248Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedInt5999Type", function() { return UnsignedInt5999Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedIntType", function() { return UnsignedIntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort4444Type", function() { return UnsignedShort4444Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort5551Type", function() { return UnsignedShort5551Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShortType", function() { return UnsignedShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VSMShadowMap", function() { return VSMShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector2", function() { return Vector2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector3", function() { return Vector3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector4", function() { return Vector4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorKeyframeTrack", function() { return VectorKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VideoTexture", function() { return VideoTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGL3DRenderTarget", function() { return WebGL3DRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLArrayRenderTarget", function() { return WebGLArrayRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLCoordinateSystem", function() { return WebGLCoordinateSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLCubeRenderTarget", function() { return WebGLCubeRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLMultipleRenderTargets", function() { return WebGLMultipleRenderTargets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTarget", function() { return WebGLRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderer", function() { return WebGLRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLUtils", function() { return WebGLUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGPUCoordinateSystem", function() { return WebGPUCoordinateSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeGeometry", function() { return WireframeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WrapAroundEnding", function() { return WrapAroundEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroCurvatureEnding", function() { return ZeroCurvatureEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroFactor", function() { return ZeroFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroSlopeEnding", function() { return ZeroSlopeEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroStencilOp", function() { return ZeroStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCanvasElement", function() { return createCanvasElement; });
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = '164';

const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const CullFaceFrontBack = 3;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const ConstantColorFactor = 211;
const OneMinusConstantColorFactor = 212;
const ConstantAlphaFactor = 213;
const OneMinusConstantAlphaFactor = 214;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const AgXToneMapping = 6;
const NeutralToneMapping = 7;
const AttachedBindMode = 'attached';
const DetachedBindMode = 'detached';

const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipMapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const NearestMipMapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipMapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedInt248Type = 1020;
const UnsignedInt5999Type = 35902;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBAIntegerFormat = 1033;

const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const RGB_BPTC_SIGNED_Format = 36494;
const RGB_BPTC_UNSIGNED_Format = 36495;
const RED_RGTC1_Format = 36283;
const SIGNED_RED_RGTC1_Format = 36284;
const RED_GREEN_RGTC2_Format = 36285;
const SIGNED_RED_GREEN_RGTC2_Format = 36286;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;

// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
const NoColorSpace = '';
const SRGBColorSpace = 'srgb';
const LinearSRGBColorSpace = 'srgb-linear';
const DisplayP3ColorSpace = 'display-p3';
const LinearDisplayP3ColorSpace = 'display-p3-linear';

const LinearTransfer = 'linear';
const SRGBTransfer = 'srgb';

const Rec709Primaries = 'rec709';
const P3Primaries = 'p3';

const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;

const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;

const NeverCompare = 512;
const LessCompare = 513;
const EqualCompare = 514;
const LessEqualCompare = 515;
const GreaterCompare = 516;
const NotEqualCompare = 517;
const GreaterEqualCompare = 518;
const AlwaysCompare = 519;

const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const StreamDrawUsage = 35040;
const StaticReadUsage = 35045;
const DynamicReadUsage = 35049;
const StreamReadUsage = 35041;
const StaticCopyUsage = 35046;
const DynamicCopyUsage = 35050;
const StreamCopyUsage = 35042;

const GLSL1 = '100';
const GLSL3 = '300 es';

const WebGLCoordinateSystem = 2000;
const WebGPUCoordinateSystem = 2001;

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

class EventDispatcher {

	addEventListener( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		const listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	}

	hasEventListener( type, listener ) {

		if ( this._listeners === undefined ) return false;

		const listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	}

	removeEventListener( type, listener ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			const index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	}

	dispatchEvent( event ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			// Make a copy, in case listeners are removed while iterating.
			const array = listenerArray.slice( 0 );

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

			event.target = null;

		}

	}

}

const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];

let _seed = 1234567;


const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function generateUUID() {

	const d0 = Math.random() * 0xffffffff | 0;
	const d1 = Math.random() * 0xffffffff | 0;
	const d2 = Math.random() * 0xffffffff | 0;
	const d3 = Math.random() * 0xffffffff | 0;
	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

	// .toLowerCase() here flattens concatenated strings to save heap memory space.
	return uuid.toLowerCase();

}

function clamp( value, min, max ) {

	return Math.max( min, Math.min( max, value ) );

}

// compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function euclideanModulo( n, m ) {

	return ( ( n % m ) + m ) % m;

}

// Linear mapping from range <a1, a2> to range <b1, b2>
function mapLinear( x, a1, a2, b1, b2 ) {

	return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

}

// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function inverseLerp( x, y, value ) {

	if ( x !== y ) {

		return ( value - x ) / ( y - x );

	} else {

		return 0;

	}

}

// https://en.wikipedia.org/wiki/Linear_interpolation
function lerp( x, y, t ) {

	return ( 1 - t ) * x + t * y;

}

// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function damp( x, y, lambda, dt ) {

	return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

}

// https://www.desmos.com/calculator/vcsjnyz7x4
function pingpong( x, length = 1 ) {

	return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

}

// http://en.wikipedia.org/wiki/Smoothstep
function smoothstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * ( 3 - 2 * x );

}

function smootherstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

}

// Random integer from <low, high> interval
function randInt( low, high ) {

	return low + Math.floor( Math.random() * ( high - low + 1 ) );

}

// Random float from <low, high> interval
function randFloat( low, high ) {

	return low + Math.random() * ( high - low );

}

// Random float from <-range/2, range/2> interval
function randFloatSpread( range ) {

	return range * ( 0.5 - Math.random() );

}

// Deterministic pseudo-random float in the interval [ 0, 1 ]
function seededRandom( s ) {

	if ( s !== undefined ) _seed = s;

	// Mulberry32 generator

	let t = _seed += 0x6D2B79F5;

	t = Math.imul( t ^ t >>> 15, t | 1 );

	t ^= t + Math.imul( t ^ t >>> 7, t | 61 );

	return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;

}

function degToRad( degrees ) {

	return degrees * DEG2RAD;

}

function radToDeg( radians ) {

	return radians * RAD2DEG;

}

function isPowerOfTwo( value ) {

	return ( value & ( value - 1 ) ) === 0 && value !== 0;

}

function ceilPowerOfTwo( value ) {

	return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

}

function floorPowerOfTwo( value ) {

	return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

}

function setQuaternionFromProperEuler( q, a, b, c, order ) {

	// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

	// rotations are applied to the axes in the order specified by 'order'
	// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
	// angles are in radians

	const cos = Math.cos;
	const sin = Math.sin;

	const c2 = cos( b / 2 );
	const s2 = sin( b / 2 );

	const c13 = cos( ( a + c ) / 2 );
	const s13 = sin( ( a + c ) / 2 );

	const c1_3 = cos( ( a - c ) / 2 );
	const s1_3 = sin( ( a - c ) / 2 );

	const c3_1 = cos( ( c - a ) / 2 );
	const s3_1 = sin( ( c - a ) / 2 );

	switch ( order ) {

		case 'XYX':
			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
			break;

		case 'YZY':
			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
			break;

		case 'ZXZ':
			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
			break;

		case 'XZX':
			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
			break;

		case 'YXY':
			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
			break;

		case 'ZYZ':
			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
			break;

		default:
			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

	}

}

function denormalize( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint32Array:

			return value / 4294967295.0;

		case Uint16Array:

			return value / 65535.0;

		case Uint8Array:

			return value / 255.0;

		case Int32Array:

			return Math.max( value / 2147483647.0, - 1.0 );

		case Int16Array:

			return Math.max( value / 32767.0, - 1.0 );

		case Int8Array:

			return Math.max( value / 127.0, - 1.0 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

function normalize( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint32Array:

			return Math.round( value * 4294967295.0 );

		case Uint16Array:

			return Math.round( value * 65535.0 );

		case Uint8Array:

			return Math.round( value * 255.0 );

		case Int32Array:

			return Math.round( value * 2147483647.0 );

		case Int16Array:

			return Math.round( value * 32767.0 );

		case Int8Array:

			return Math.round( value * 127.0 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

const MathUtils = {
	DEG2RAD: DEG2RAD,
	RAD2DEG: RAD2DEG,
	generateUUID: generateUUID,
	clamp: clamp,
	euclideanModulo: euclideanModulo,
	mapLinear: mapLinear,
	inverseLerp: inverseLerp,
	lerp: lerp,
	damp: damp,
	pingpong: pingpong,
	smoothstep: smoothstep,
	smootherstep: smootherstep,
	randInt: randInt,
	randFloat: randFloat,
	randFloatSpread: randFloatSpread,
	seededRandom: seededRandom,
	degToRad: degToRad,
	radToDeg: radToDeg,
	isPowerOfTwo: isPowerOfTwo,
	ceilPowerOfTwo: ceilPowerOfTwo,
	floorPowerOfTwo: floorPowerOfTwo,
	setQuaternionFromProperEuler: setQuaternionFromProperEuler,
	normalize: normalize,
	denormalize: denormalize
};

class Vector2 {

	constructor( x = 0, y = 0 ) {

		Vector2.prototype.isVector2 = true;

		this.x = x;
		this.y = y;

	}

	get width() {

		return this.x;

	}

	set width( value ) {

		this.x = value;

	}

	get height() {

		return this.y;

	}

	set height( value ) {

		this.y = value;

	}

	set( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	}

	add( v ) {

		this.x += v.x;
		this.y += v.y;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	}

	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	}

	roundToZero() {

		this.x = Math.trunc( this.x );
		this.y = Math.trunc( this.y );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y;

	}

	cross( v ) {

		return this.x * v.y - this.y * v.x;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	angle() {

		// computes the angle in radians with respect to the positive x-axis

		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		return angle;

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( clamp( theta, - 1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	}

	rotateAround( center, angle ) {

		const c = Math.cos( angle ), s = Math.sin( angle );

		const x = this.x - center.x;
		const y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;

	}

}

class Matrix3 {

	constructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		Matrix3.prototype.isMatrix3 = true;

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( n11 !== undefined ) {

			this.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );

		}

	}

	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrix3Column( this, 0 );
		yAxis.setFromMatrix3Column( this, 1 );
		zAxis.setFromMatrix3Column( this, 2 );

		return this;

	}

	setFromMatrix4( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	}

	invert() {

		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	}

	transpose() {

		let tmp;
		const m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	}

	getNormalMatrix( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).invert().transpose();

	}

	transposeIntoArray( r ) {

		const m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	}

	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

		const c = Math.cos( rotation );
		const s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

		return this;

	}

	//

	scale( sx, sy ) {

		this.premultiply( _m3.makeScale( sx, sy ) );

		return this;

	}

	rotate( theta ) {

		this.premultiply( _m3.makeRotation( - theta ) );

		return this;

	}

	translate( tx, ty ) {

		this.premultiply( _m3.makeTranslation( tx, ty ) );

		return this;

	}

	// for 2D Transforms

	makeTranslation( x, y ) {

		if ( x.isVector2 ) {

			this.set(

				1, 0, x.x,
				0, 1, x.y,
				0, 0, 1

			);

		} else {

			this.set(

				1, 0, x,
				0, 1, y,
				0, 0, 1

			);

		}

		return this;

	}

	makeRotation( theta ) {

		// counterclockwise

		const c = Math.cos( theta );
		const s = Math.sin( theta );

		this.set(

			c, - s, 0,
			s, c, 0,
			0, 0, 1

		);

		return this;

	}

	makeScale( x, y ) {

		this.set(

			x, 0, 0,
			0, y, 0,
			0, 0, 1

		);

		return this;

	}

	//

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

	clone() {

		return new this.constructor().fromArray( this.elements );

	}

}

const _m3 = /*@__PURE__*/ new Matrix3();

function arrayNeedsUint32( array ) {

	// assumes larger values usually on last

	for ( let i = array.length - 1; i >= 0; -- i ) {

		if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

	}

	return false;

}

const TYPED_ARRAYS = {
	Int8Array: Int8Array,
	Uint8Array: Uint8Array,
	Uint8ClampedArray: Uint8ClampedArray,
	Int16Array: Int16Array,
	Uint16Array: Uint16Array,
	Int32Array: Int32Array,
	Uint32Array: Uint32Array,
	Float32Array: Float32Array,
	Float64Array: Float64Array
};

function getTypedArray( type, buffer ) {

	return new TYPED_ARRAYS[ type ]( buffer );

}

function createElementNS( name ) {

	return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

}

function createCanvasElement() {

	const canvas = createElementNS( 'canvas' );
	canvas.style.display = 'block';
	return canvas;

}

const _cache = {};

function warnOnce( message ) {

	if ( message in _cache ) return;

	_cache[ message ] = true;

	console.warn( message );

}

/**
 * Matrices converting P3 <-> Rec. 709 primaries, without gamut mapping
 * or clipping. Based on W3C specifications for sRGB and Display P3,
 * and ICC specifications for the D50 connection space. Values in/out
 * are _linear_ sRGB and _linear_ Display P3.
 *
 * Note that both sRGB and Display P3 use the sRGB transfer functions.
 *
 * Reference:
 * - http://www.russellcottrell.com/photo/matrixCalculator.htm
 */

const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /*@__PURE__*/ new Matrix3().set(
	0.8224621, 0.177538, 0.0,
	0.0331941, 0.9668058, 0.0,
	0.0170827, 0.0723974, 0.9105199,
);

const LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /*@__PURE__*/ new Matrix3().set(
	1.2249401, - 0.2249404, 0.0,
	- 0.0420569, 1.0420571, 0.0,
	- 0.0196376, - 0.0786361, 1.0982735
);

/**
 * Defines supported color spaces by transfer function and primaries,
 * and provides conversions to/from the Linear-sRGB reference space.
 */
const COLOR_SPACES = {
	[ LinearSRGBColorSpace ]: {
		transfer: LinearTransfer,
		primaries: Rec709Primaries,
		toReference: ( color ) => color,
		fromReference: ( color ) => color,
	},
	[ SRGBColorSpace ]: {
		transfer: SRGBTransfer,
		primaries: Rec709Primaries,
		toReference: ( color ) => color.convertSRGBToLinear(),
		fromReference: ( color ) => color.convertLinearToSRGB(),
	},
	[ LinearDisplayP3ColorSpace ]: {
		transfer: LinearTransfer,
		primaries: P3Primaries,
		toReference: ( color ) => color.applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB ),
		fromReference: ( color ) => color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ),
	},
	[ DisplayP3ColorSpace ]: {
		transfer: SRGBTransfer,
		primaries: P3Primaries,
		toReference: ( color ) => color.convertSRGBToLinear().applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB ),
		fromReference: ( color ) => color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ).convertLinearToSRGB(),
	},
};

const SUPPORTED_WORKING_COLOR_SPACES = new Set( [ LinearSRGBColorSpace, LinearDisplayP3ColorSpace ] );

const ColorManagement = {

	enabled: true,

	_workingColorSpace: LinearSRGBColorSpace,

	get workingColorSpace() {

		return this._workingColorSpace;

	},

	set workingColorSpace( colorSpace ) {

		if ( ! SUPPORTED_WORKING_COLOR_SPACES.has( colorSpace ) ) {

			throw new Error( `Unsupported working color space, "${ colorSpace }".` );

		}

		this._workingColorSpace = colorSpace;

	},

	convert: function ( color, sourceColorSpace, targetColorSpace ) {

		if ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

			return color;

		}

		const sourceToReference = COLOR_SPACES[ sourceColorSpace ].toReference;
		const targetFromReference = COLOR_SPACES[ targetColorSpace ].fromReference;

		return targetFromReference( sourceToReference( color ) );

	},

	fromWorkingColorSpace: function ( color, targetColorSpace ) {

		return this.convert( color, this._workingColorSpace, targetColorSpace );

	},

	toWorkingColorSpace: function ( color, sourceColorSpace ) {

		return this.convert( color, sourceColorSpace, this._workingColorSpace );

	},

	getPrimaries: function ( colorSpace ) {

		return COLOR_SPACES[ colorSpace ].primaries;

	},

	getTransfer: function ( colorSpace ) {

		if ( colorSpace === NoColorSpace ) return LinearTransfer;

		return COLOR_SPACES[ colorSpace ].transfer;

	},

};


function SRGBToLinear( c ) {

	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

}

function LinearToSRGB( c ) {

	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

}

let _canvas;

class ImageUtils {

	static getDataURL( image ) {

		if ( /^data:/i.test( image.src ) ) {

			return image.src;

		}

		if ( typeof HTMLCanvasElement === 'undefined' ) {

			return image.src;

		}

		let canvas;

		if ( image instanceof HTMLCanvasElement ) {

			canvas = image;

		} else {

			if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

			_canvas.width = image.width;
			_canvas.height = image.height;

			const context = _canvas.getContext( '2d' );

			if ( image instanceof ImageData ) {

				context.putImageData( image, 0, 0 );

			} else {

				context.drawImage( image, 0, 0, image.width, image.height );

			}

			canvas = _canvas;

		}

		if ( canvas.width > 2048 || canvas.height > 2048 ) {

			console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

			return canvas.toDataURL( 'image/jpeg', 0.6 );

		} else {

			return canvas.toDataURL( 'image/png' );

		}

	}

	static sRGBToLinear( image ) {

		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

			const canvas = createElementNS( 'canvas' );

			canvas.width = image.width;
			canvas.height = image.height;

			const context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height );

			const imageData = context.getImageData( 0, 0, image.width, image.height );
			const data = imageData.data;

			for ( let i = 0; i < data.length; i ++ ) {

				data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

			}

			context.putImageData( imageData, 0, 0 );

			return canvas;

		} else if ( image.data ) {

			const data = image.data.slice( 0 );

			for ( let i = 0; i < data.length; i ++ ) {

				if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

					data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

				} else {

					// assuming float

					data[ i ] = SRGBToLinear( data[ i ] );

				}

			}

			return {
				data: data,
				width: image.width,
				height: image.height
			};

		} else {

			console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
			return image;

		}

	}

}

let _sourceId = 0;

class Source {

	constructor( data = null ) {

		this.isSource = true;

		Object.defineProperty( this, 'id', { value: _sourceId ++ } );

		this.uuid = generateUUID();

		this.data = data;
		this.dataReady = true;

		this.version = 0;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

			return meta.images[ this.uuid ];

		}

		const output = {
			uuid: this.uuid,
			url: ''
		};

		const data = this.data;

		if ( data !== null ) {

			let url;

			if ( Array.isArray( data ) ) {

				// cube texture

				url = [];

				for ( let i = 0, l = data.length; i < l; i ++ ) {

					if ( data[ i ].isDataTexture ) {

						url.push( serializeImage( data[ i ].image ) );

					} else {

						url.push( serializeImage( data[ i ] ) );

					}

				}

			} else {

				// texture

				url = serializeImage( data );

			}

			output.url = url;

		}

		if ( ! isRootObject ) {

			meta.images[ this.uuid ] = output;

		}

		return output;

	}

}

function serializeImage( image ) {

	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

		// default images

		return ImageUtils.getDataURL( image );

	} else {

		if ( image.data ) {

			// images of DataTexture

			return {
				data: Array.from( image.data ),
				width: image.width,
				height: image.height,
				type: image.data.constructor.name
			};

		} else {

			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
			return {};

		}

	}

}

let _textureId = 0;

class Texture extends EventDispatcher {

	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {

		super();

		this.isTexture = true;

		Object.defineProperty( this, 'id', { value: _textureId ++ } );

		this.uuid = generateUUID();

		this.name = '';

		this.source = new Source( image );
		this.mipmaps = [];

		this.mapping = mapping;
		this.channel = 0;

		this.wrapS = wrapS;
		this.wrapT = wrapT;

		this.magFilter = magFilter;
		this.minFilter = minFilter;

		this.anisotropy = anisotropy;

		this.format = format;
		this.internalFormat = null;
		this.type = type;

		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		this.colorSpace = colorSpace;

		this.userData = {};

		this.version = 0;
		this.onUpdate = null;

		this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
		this.pmremVersion = 0; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)

	}

	get image() {

		return this.source.data;

	}

	set image( value = null ) {

		this.source.data = value;

	}

	updateMatrix() {

		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.source = source.source;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;
		this.channel = source.channel;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );
		this.center.copy( source.center );
		this.rotation = source.rotation;

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy( source.matrix );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.colorSpace = source.colorSpace;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		this.needsUpdate = true;

		return this;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		const output = {

			metadata: {
				version: 4.6,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			image: this.source.toJSON( meta ).uuid,

			mapping: this.mapping,
			channel: this.channel,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,

			wrap: [ this.wrapS, this.wrapT ],

			format: this.format,
			internalFormat: this.internalFormat,
			type: this.type,
			colorSpace: this.colorSpace,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			generateMipmaps: this.generateMipmaps,
			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;

		if ( ! isRootObject ) {

			meta.textures[ this.uuid ] = output;

		}

		return output;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	transformUv( uv ) {

		if ( this.mapping !== UVMapping ) return uv;

		uv.applyMatrix3( this.matrix );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}

					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}

					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

		return uv;

	}

	set needsUpdate( value ) {

		if ( value === true ) {

			this.version ++;
			this.source.needsUpdate = true;

		}

	}

	set needsPMREMUpdate( value ) {

		if ( value === true ) {

			this.pmremVersion ++;

		}

	}

}

Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;

class Vector4 {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		Vector4.prototype.isVector4 = true;

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

	}

	get width() {

		return this.z;

	}

	set width( value ) {

		this.z = value;

	}

	get height() {

		return this.w;

	}

	set height( value ) {

		this.w = value;

	}

	set( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setW( w ) {

		this.w = w;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z, this.w );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	}

	add( v ) {

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	}

	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		this.w *= v.w;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z, w = this.w;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	setAxisAngleFromQuaternion( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		const s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			this.x = 1;
			this.y = 0;
			this.z = 0;

		} else {

			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;

		}

		return this;

	}

	setAxisAngleFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		let angle, x, y, z; // variables for result
		const epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			const xx = ( m11 + 1 ) / 2;
			const yy = ( m22 + 1 ) / 2;
			const zz = ( m33 + 1 ) / 2;
			const xy = ( m12 + m21 ) / 4;
			const xz = ( m13 + m31 ) / 4;
			const yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			( m13 - m31 ) * ( m13 - m31 ) +
			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	}

	roundToZero() {

		this.x = Math.trunc( this.x );
		this.y = Math.trunc( this.y );
		this.z = Math.trunc( this.z );
		this.w = Math.trunc( this.w );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;
		this.w = v1.w + ( v2.w - v1.w ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;
		yield this.w;

	}

}

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
class RenderTarget extends EventDispatcher {

	constructor( width = 1, height = 1, options = {} ) {

		super();

		this.isRenderTarget = true;

		this.width = width;
		this.height = height;
		this.depth = 1;

		this.scissor = new Vector4( 0, 0, width, height );
		this.scissorTest = false;

		this.viewport = new Vector4( 0, 0, width, height );

		const image = { width: width, height: height, depth: 1 };

		options = Object.assign( {
			generateMipmaps: false,
			internalFormat: null,
			minFilter: LinearFilter,
			depthBuffer: true,
			stencilBuffer: false,
			resolveDepthBuffer: true,
			resolveStencilBuffer: true,
			depthTexture: null,
			samples: 0,
			count: 1
		}, options );

		const texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );

		texture.flipY = false;
		texture.generateMipmaps = options.generateMipmaps;
		texture.internalFormat = options.internalFormat;

		this.textures = [];

		const count = options.count;
		for ( let i = 0; i < count; i ++ ) {

			this.textures[ i ] = texture.clone();
			this.textures[ i ].isRenderTargetTexture = true;

		}

		this.depthBuffer = options.depthBuffer;
		this.stencilBuffer = options.stencilBuffer;

		this.resolveDepthBuffer = options.resolveDepthBuffer;
		this.resolveStencilBuffer = options.resolveStencilBuffer;

		this.depthTexture = options.depthTexture;

		this.samples = options.samples;

	}

	get texture() {

		return this.textures[ 0 ];

	}

	set texture( value ) {

		this.textures[ 0 ] = value;

	}

	setSize( width, height, depth = 1 ) {

		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

			this.width = width;
			this.height = height;
			this.depth = depth;

			for ( let i = 0, il = this.textures.length; i < il; i ++ ) {

				this.textures[ i ].image.width = width;
				this.textures[ i ].image.height = height;
				this.textures[ i ].image.depth = depth;

			}

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.width = source.width;
		this.height = source.height;
		this.depth = source.depth;

		this.scissor.copy( source.scissor );
		this.scissorTest = source.scissorTest;

		this.viewport.copy( source.viewport );

		this.textures.length = 0;

		for ( let i = 0, il = source.textures.length; i < il; i ++ ) {

			this.textures[ i ] = source.textures[ i ].clone();
			this.textures[ i ].isRenderTargetTexture = true;

		}

		// ensure image object is not shared, see #20328

		const image = Object.assign( {}, source.texture.image );
		this.texture.source = new Source( image );

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;

		this.resolveDepthBuffer = source.resolveDepthBuffer;
		this.resolveStencilBuffer = source.resolveStencilBuffer;

		if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

		this.samples = source.samples;

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

class WebGLRenderTarget extends RenderTarget {

	constructor( width = 1, height = 1, options = {} ) {

		super( width, height, options );

		this.isWebGLRenderTarget = true;

	}

}

class DataArrayTexture extends Texture {

	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		super( null );

		this.isDataArrayTexture = true;

		this.image = { data, width, height, depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

}

class WebGLArrayRenderTarget extends WebGLRenderTarget {

	constructor( width = 1, height = 1, depth = 1, options = {} ) {

		super( width, height, options );

		this.isWebGLArrayRenderTarget = true;

		this.depth = depth;

		this.texture = new DataArrayTexture( null, width, height, depth );

		this.texture.isRenderTargetTexture = true;

	}

}

class Data3DTexture extends Texture {

	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in DataTexture3D directly.
		//
		//	const texture = new THREE.DataTexture3D( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839

		super( null );

		this.isData3DTexture = true;

		this.image = { data, width, height, depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

}

class WebGL3DRenderTarget extends WebGLRenderTarget {

	constructor( width = 1, height = 1, depth = 1, options = {} ) {

		super( width, height, options );

		this.isWebGL3DRenderTarget = true;

		this.depth = depth;

		this.texture = new Data3DTexture( null, width, height, depth );

		this.texture.isRenderTargetTexture = true;

	}

}

class Quaternion {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this.isQuaternion = true;

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( t === 0 ) {

			dst[ dstOffset + 0 ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
			return;

		}

		if ( t === 1 ) {

			dst[ dstOffset + 0 ] = x1;
			dst[ dstOffset + 1 ] = y1;
			dst[ dstOffset + 2 ] = z1;
			dst[ dstOffset + 3 ] = w1;
			return;

		}

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				const sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			const tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		const x0 = src0[ srcOffset0 ];
		const y0 = src0[ srcOffset0 + 1 ];
		const z0 = src0[ srcOffset0 + 2 ];
		const w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 ];
		const y1 = src1[ srcOffset1 + 1 ];
		const z1 = src1[ srcOffset1 + 2 ];
		const w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get w() {

		return this._w;

	}

	set w( value ) {

		this._w = value;
		this._onChangeCallback();

	}

	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}

	copy( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	}

	setFromEuler( euler, update = true ) {

		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;

		const c1 = cos( x / 2 );
		const c2 = cos( y / 2 );
		const c3 = cos( z / 2 );

		const s1 = sin( x / 2 );
		const s2 = sin( y / 2 );
		const s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update === true ) this._onChangeCallback();

		return this;

	}

	setFromAxisAngle( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		const halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			const s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	}

	setFromUnitVectors( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		let r = vFrom.dot( vTo ) + 1;

		if ( r < Number.EPSILON ) {

			// vFrom and vTo point in opposite directions

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	}

	angleTo( q ) {

		return 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );

	}

	rotateTowards( q, step ) {

		const angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		const t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	}

	identity() {

		return this.set( 0, 0, 0, 1 );

	}

	invert() {

		// quaternion is assumed to have unit length

		return this.conjugate();

	}

	conjugate() {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	}

	dot( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	}

	lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}

	length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}

	normalize() {

		let l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	}

	multiply( q ) {

		return this.multiplyQuaternions( this, q );

	}

	premultiply( q ) {

		return this.multiplyQuaternions( q, this );

	}

	multiplyQuaternions( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	}

	slerp( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		const x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize(); // normalize calls _onChangeCallback()

			return this;

		}

		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	}

	slerpQuaternions( qa, qb, t ) {

		return this.copy( qa ).slerp( qb, t );

	}

	random() {

		// sets this quaternion to a uniform random unit quaternnion

		// Ken Shoemake
		// Uniform random rotations
		// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.

		const theta1 = 2 * Math.PI * Math.random();
		const theta2 = 2 * Math.PI * Math.random();

		const x0 = Math.random();
		const r1 = Math.sqrt( 1 - x0 );
		const r2 = Math.sqrt( x0 );

		return this.set(
			r1 * Math.sin( theta1 ),
			r1 * Math.cos( theta1 ),
			r2 * Math.sin( theta2 ),
			r2 * Math.cos( theta2 ),
		);

	}

	equals( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	}

	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		this._onChangeCallback();

		return this;

	}

	toJSON() {

		return this.toArray();

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

	*[ Symbol.iterator ]() {

		yield this._x;
		yield this._y;
		yield this._z;
		yield this._w;

	}

}

class Vector3 {

	constructor( x = 0, y = 0, z = 0 ) {

		Vector3.prototype.isVector3 = true;

		this.x = x;
		this.y = y;
		this.z = z;

	}

	set( x, y, z ) {

		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	}

	add( v ) {

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	}

	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	}

	multiplyVectors( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	}

	applyEuler( euler ) {

		return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

	}

	applyAxisAngle( axis, angle ) {

		return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	}

	applyNormalMatrix( m ) {

		return this.applyMatrix3( m ).normalize();

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	}

	applyQuaternion( q ) {

		// quaternion q is assumed to have unit length

		const vx = this.x, vy = this.y, vz = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// t = 2 * cross( q.xyz, v );
		const tx = 2 * ( qy * vz - qz * vy );
		const ty = 2 * ( qz * vx - qx * vz );
		const tz = 2 * ( qx * vy - qy * vx );

		// v + q.w * t + cross( q.xyz, t );
		this.x = vx + qw * tx + qy * tz - qz * ty;
		this.y = vy + qw * ty + qz * tx - qx * tz;
		this.z = vz + qw * tz + qx * ty - qy * tx;

		return this;

	}

	project( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	}

	unproject( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	}

	transformDirection( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	}

	roundToZero() {

		this.x = Math.trunc( this.x );
		this.y = Math.trunc( this.y );
		this.z = Math.trunc( this.z );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	}

	// TODO lengthSquared?

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	}

	cross( v ) {

		return this.crossVectors( this, v );

	}

	crossVectors( a, b ) {

		const ax = a.x, ay = a.y, az = a.z;
		const bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	}

	projectOnVector( v ) {

		const denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		const scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	}

	projectOnPlane( planeNormal ) {

		_vector$c.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector$c );

	}

	reflect( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( clamp( theta, - 1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	}

	setFromSpherical( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	}

	setFromSphericalCoords( radius, phi, theta ) {

		const sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	}

	setFromCylindrical( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	}

	setFromCylindricalCoords( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	}

	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	}

	setFromMatrixScale( m ) {

		const sx = this.setFromMatrixColumn( m, 0 ).length();
		const sy = this.setFromMatrixColumn( m, 1 ).length();
		const sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	}

	setFromMatrixColumn( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	}

	setFromMatrix3Column( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	}

	setFromEuler( e ) {

		this.x = e._x;
		this.y = e._y;
		this.z = e._z;

		return this;

	}

	setFromColor( c ) {

		this.x = c.r;
		this.y = c.g;
		this.z = c.b;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

	randomDirection() {

		// https://mathworld.wolfram.com/SpherePointPicking.html

		const theta = Math.random() * Math.PI * 2;
		const u = Math.random() * 2 - 1;
		const c = Math.sqrt( 1 - u * u );

		this.x = c * Math.cos( theta );
		this.y = u;
		this.z = c * Math.sin( theta );

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;

	}

}

const _vector$c = /*@__PURE__*/ new Vector3();
const _quaternion$4 = /*@__PURE__*/ new Quaternion();

class Box3 {

	constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

		this.isBox3 = true;

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromArray( array ) {

		this.makeEmpty();

		for ( let i = 0, il = array.length; i < il; i += 3 ) {

			this.expandByPoint( _vector$b.fromArray( array, i ) );

		}

		return this;

	}

	setFromBufferAttribute( attribute ) {

		this.makeEmpty();

		for ( let i = 0, il = attribute.count; i < il; i ++ ) {

			this.expandByPoint( _vector$b.fromBufferAttribute( attribute, i ) );

		}

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	setFromObject( object, precise = false ) {

		this.makeEmpty();

		return this.expandByObject( object, precise );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	}

	getCenter( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	expandByObject( object, precise = false ) {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix( false, false );

		const geometry = object.geometry;

		if ( geometry !== undefined ) {

			const positionAttribute = geometry.getAttribute( 'position' );

			// precise AABB computation based on vertex data requires at least a position attribute.
			// instancing isn't supported so far and uses the normal (conservative) code path.

			if ( precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true ) {

				for ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {

					if ( object.isMesh === true ) {

						object.getVertexPosition( i, _vector$b );

					} else {

						_vector$b.fromBufferAttribute( positionAttribute, i );

					}

					_vector$b.applyMatrix4( object.matrixWorld );
					this.expandByPoint( _vector$b );

				}

			} else {

				if ( object.boundingBox !== undefined ) {

					// object-level bounding box

					if ( object.boundingBox === null ) {

						object.computeBoundingBox();

					}

					_box$4.copy( object.boundingBox );


				} else {

					// geometry-level bounding box

					if ( geometry.boundingBox === null ) {

						geometry.computeBoundingBox();

					}

					_box$4.copy( geometry.boundingBox );

				}

				_box$4.applyMatrix4( object.matrixWorld );

				this.union( _box$4 );

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			this.expandByObject( children[ i ], precise );

		}

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	}

	intersectsBox( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	}

	intersectsSphere( sphere ) {

		// Find the point on the AABB closest to the sphere center.
		this.clampPoint( sphere.center, _vector$b );

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	intersectsPlane( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		let min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= - plane.constant && max >= - plane.constant );

	}

	intersectsTriangle( triangle ) {

		if ( this.isEmpty() ) {

			return false;

		}

		// compute box center and extents
		this.getCenter( _center );
		_extents.subVectors( this.max, _center );

		// translate triangle to aabb origin
		_v0$2.subVectors( triangle.a, _center );
		_v1$7.subVectors( triangle.b, _center );
		_v2$4.subVectors( triangle.c, _center );

		// compute edge vectors for triangle
		_f0.subVectors( _v1$7, _v0$2 );
		_f1.subVectors( _v2$4, _v1$7 );
		_f2.subVectors( _v0$2, _v2$4 );

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		let axes = [
			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
		];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

			return false;

		}

		// test 3 face normals from the aabb
		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

			return false;

		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors( _f0, _f1 );
		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

		return satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents );

	}

	clampPoint( point, target ) {

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		return this.clampPoint( point, _vector$b ).distanceTo( point );

	}

	getBoundingSphere( target ) {

		if ( this.isEmpty() ) {

			target.makeEmpty();

		} else {

			this.getCenter( target.center );

			target.radius = this.getSize( _vector$b ).length() * 0.5;

		}

		return target;

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	applyMatrix4( matrix ) {

		// transform of empty box is an empty box.
		if ( this.isEmpty() ) return this;

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		this.setFromPoints( _points );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

const _points = [
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3()
];

const _vector$b = /*@__PURE__*/ new Vector3();

const _box$4 = /*@__PURE__*/ new Box3();

// triangle centered vertices

const _v0$2 = /*@__PURE__*/ new Vector3();
const _v1$7 = /*@__PURE__*/ new Vector3();
const _v2$4 = /*@__PURE__*/ new Vector3();

// triangle edge vectors

const _f0 = /*@__PURE__*/ new Vector3();
const _f1 = /*@__PURE__*/ new Vector3();
const _f2 = /*@__PURE__*/ new Vector3();

const _center = /*@__PURE__*/ new Vector3();
const _extents = /*@__PURE__*/ new Vector3();
const _triangleNormal = /*@__PURE__*/ new Vector3();
const _testAxis = /*@__PURE__*/ new Vector3();

function satForAxes( axes, v0, v1, v2, extents ) {

	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

		_testAxis.fromArray( axes, i );
		// project the aabb onto the separating axis
		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
		// project all 3 vertices of the triangle onto the separating axis
		const p0 = v0.dot( _testAxis );
		const p1 = v1.dot( _testAxis );
		const p2 = v2.dot( _testAxis );
		// actual test, basically see if either of the most extreme of the triangle points intersects r
		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

			// points of the projected triangle are outside the projected half-length of the aabb
			// the axis is separating and we can exit
			return false;

		}

	}

	return true;

}

const _box$3 = /*@__PURE__*/ new Box3();
const _v1$6 = /*@__PURE__*/ new Vector3();
const _v2$3 = /*@__PURE__*/ new Vector3();

class Sphere {

	constructor( center = new Vector3(), radius = - 1 ) {

		this.isSphere = true;

		this.center = center;
		this.radius = radius;

	}

	set( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	}

	setFromPoints( points, optionalCenter ) {

		const center = this.center;

		if ( optionalCenter !== undefined ) {

			center.copy( optionalCenter );

		} else {

			_box$3.setFromPoints( points ).getCenter( center );

		}

		let maxRadiusSq = 0;

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		}

		this.radius = Math.sqrt( maxRadiusSq );

		return this;

	}

	copy( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	}

	isEmpty() {

		return ( this.radius < 0 );

	}

	makeEmpty() {

		this.center.set( 0, 0, 0 );
		this.radius = - 1;

		return this;

	}

	containsPoint( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	}

	distanceToPoint( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	}

	intersectsSphere( sphere ) {

		const radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	}

	intersectsBox( box ) {

		return box.intersectsSphere( this );

	}

	intersectsPlane( plane ) {

		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	}

	clampPoint( point, target ) {

		const deltaLengthSq = this.center.distanceToSquared( point );

		target.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );

		}

		return target;

	}

	getBoundingBox( target ) {

		if ( this.isEmpty() ) {

			// Empty sphere produces empty bounding box
			target.makeEmpty();
			return target;

		}

		target.set( this.center, this.center );
		target.expandByScalar( this.radius );

		return target;

	}

	applyMatrix4( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	}

	translate( offset ) {

		this.center.add( offset );

		return this;

	}

	expandByPoint( point ) {

		if ( this.isEmpty() ) {

			this.center.copy( point );

			this.radius = 0;

			return this;

		}

		_v1$6.subVectors( point, this.center );

		const lengthSq = _v1$6.lengthSq();

		if ( lengthSq > ( this.radius * this.radius ) ) {

			// calculate the minimal sphere

			const length = Math.sqrt( lengthSq );

			const delta = ( length - this.radius ) * 0.5;

			this.center.addScaledVector( _v1$6, delta / length );

			this.radius += delta;

		}

		return this;

	}

	union( sphere ) {

		if ( sphere.isEmpty() ) {

			return this;

		}

		if ( this.isEmpty() ) {

			this.copy( sphere );

			return this;

		}

		if ( this.center.equals( sphere.center ) === true ) {

			 this.radius = Math.max( this.radius, sphere.radius );

		} else {

			_v2$3.subVectors( sphere.center, this.center ).setLength( sphere.radius );

			this.expandByPoint( _v1$6.copy( sphere.center ).add( _v2$3 ) );

			this.expandByPoint( _v1$6.copy( sphere.center ).sub( _v2$3 ) );

		}

		return this;

	}

	equals( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$a = /*@__PURE__*/ new Vector3();
const _segCenter = /*@__PURE__*/ new Vector3();
const _segDir = /*@__PURE__*/ new Vector3();
const _diff = /*@__PURE__*/ new Vector3();

const _edge1 = /*@__PURE__*/ new Vector3();
const _edge2 = /*@__PURE__*/ new Vector3();
const _normal$1 = /*@__PURE__*/ new Vector3();

class Ray {

	constructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {

		this.origin = origin;
		this.direction = direction;

	}

	set( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	}

	copy( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	}

	at( t, target ) {

		return target.copy( this.origin ).addScaledVector( this.direction, t );

	}

	lookAt( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	}

	recast( t ) {

		this.origin.copy( this.at( t, _vector$a ) );

		return this;

	}

	closestPointToPoint( point, target ) {

		target.subVectors( point, this.origin );

		const directionDistance = target.dot( this.direction );

		if ( directionDistance < 0 ) {

			return target.copy( this.origin );

		}

		return target.copy( this.origin ).addScaledVector( this.direction, directionDistance );

	}

	distanceToPoint( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	}

	distanceSqToPoint( point ) {

		const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

		// point behind the ray

		if ( directionDistance < 0 ) {

			return this.origin.distanceToSquared( point );

		}

		_vector$a.copy( this.origin ).addScaledVector( this.direction, directionDistance );

		return _vector$a.distanceToSquared( point );

	}

	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		_segDir.copy( v1 ).sub( v0 ).normalize();
		_diff.copy( this.origin ).sub( _segCenter );

		const segExtent = v0.distanceTo( v1 ) * 0.5;
		const a01 = - this.direction.dot( _segDir );
		const b0 = _diff.dot( this.direction );
		const b1 = - _diff.dot( _segDir );
		const c = _diff.lengthSq();
		const det = Math.abs( 1 - a01 * a01 );
		let s0, s1, sqrDist, extDet;

		if ( det > 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						const invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );

		}

		return sqrDist;

	}

	intersectSphere( sphere, target ) {

		_vector$a.subVectors( sphere.center, this.origin );
		const tca = _vector$a.dot( this.direction );
		const d2 = _vector$a.dot( _vector$a ) - tca * tca;
		const radius2 = sphere.radius * sphere.radius;

		if ( d2 > radius2 ) return null;

		const thc = Math.sqrt( radius2 - d2 );

		// t0 = first intersect point - entrance on front of sphere
		const t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		const t1 = tca + thc;

		// test to see if t1 is behind the ray - if so, return null
		if ( t1 < 0 ) return null;

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if ( t0 < 0 ) return this.at( t1, target );

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at( t0, target );

	}

	intersectsSphere( sphere ) {

		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	distanceToPlane( plane ) {

		const denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;

	}

	intersectPlane( plane, target ) {

		const t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, target );

	}

	intersectsPlane( plane ) {

		// check if the ray lies on the plane first

		const distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		const denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	}

	intersectBox( box, target ) {

		let tmin, tmax, tymin, tymax, tzmin, tzmax;

		const invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		const origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		if ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;

		if ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, target );

	}

	intersectsBox( box ) {

		return this.intersectBox( box, _vector$a ) !== null;

	}

	intersectTriangle( a, b, c, backfaceCulling, target ) {

		// Compute the offset origin, edges, and normal.

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors( b, a );
		_edge2.subVectors( c, a );
		_normal$1.crossVectors( _edge1, _edge2 );

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		let DdN = this.direction.dot( _normal$1 );
		let sign;

		if ( DdN > 0 ) {

			if ( backfaceCulling ) return null;
			sign = 1;

		} else if ( DdN < 0 ) {

			sign = - 1;
			DdN = - DdN;

		} else {

			return null;

		}

		_diff.subVectors( this.origin, a );
		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

		// b1 < 0, no intersection
		if ( DdQxE2 < 0 ) {

			return null;

		}

		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

		// b2 < 0, no intersection
		if ( DdE1xQ < 0 ) {

			return null;

		}

		// b1+b2 > 1, no intersection
		if ( DdQxE2 + DdE1xQ > DdN ) {

			return null;

		}

		// Line intersects triangle, check if ray does.
		const QdN = - sign * _diff.dot( _normal$1 );

		// t < 0, no intersection
		if ( QdN < 0 ) {

			return null;

		}

		// Ray intersects triangle.
		return this.at( QdN / DdN, target );

	}

	applyMatrix4( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	}

	equals( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

class Matrix4 {

	constructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		Matrix4.prototype.isMatrix4 = true;

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( n11 !== undefined ) {

			this.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );

		}

	}

	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	clone() {

		return new Matrix4().fromArray( this.elements );

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	}

	copyPosition( m ) {

		const te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	}

	setFromMatrix3( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ], 0,
			me[ 1 ], me[ 4 ], me[ 7 ], 0,
			me[ 2 ], me[ 5 ], me[ 8 ], 0,
			0, 0, 0, 1

		);

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}

	makeBasis( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	}

	extractRotation( m ) {

		// this method does not support reflection matrices

		const te = this.elements;
		const me = m.elements;

		const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
		const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
		const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromEuler( euler ) {

		const te = this.elements;

		const x = euler.x, y = euler.y, z = euler.z;
		const a = Math.cos( x ), b = Math.sin( x );
		const c = Math.cos( y ), d = Math.sin( y );
		const e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromQuaternion( q ) {

		return this.compose( _zero, q, _one );

	}

	lookAt( eye, target, up ) {

		const te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	}

	transpose() {

		const te = this.elements;
		let tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	}

	setPosition( x, y, z ) {

		const te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	}

	invert() {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

	scale( v ) {

		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	}

	getMaxScaleOnAxis() {

		const te = this.elements;

		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	}

	makeTranslation( x, y, z ) {

		if ( x.isVector3 ) {

			this.set(

				1, 0, 0, x.x,
				0, 1, 0, x.y,
				0, 0, 1, x.z,
				0, 0, 0, 1

			);

		} else {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

		}

		return this;

	}

	makeRotationX( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationY( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	}

	makeRotationZ( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationAxis( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos( angle );
		const s = Math.sin( angle );
		const t = 1 - c;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeScale( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeShear( xy, xz, yx, yz, zx, zy ) {

		this.set(

			1, yx, zx, 0,
			xy, 1, zy, 0,
			xz, yz, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	compose( position, quaternion, scale ) {

		const te = this.elements;

		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x,	y2 = y + y, z2 = z + z;
		const xx = x * x2, xy = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;

		const sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	}

	decompose( position, quaternion, scale ) {

		const te = this.elements;

		let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1$4.copy( this );

		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;

		_m1$4.elements[ 0 ] *= invSX;
		_m1$4.elements[ 1 ] *= invSX;
		_m1$4.elements[ 2 ] *= invSX;

		_m1$4.elements[ 4 ] *= invSY;
		_m1$4.elements[ 5 ] *= invSY;
		_m1$4.elements[ 6 ] *= invSY;

		_m1$4.elements[ 8 ] *= invSZ;
		_m1$4.elements[ 9 ] *= invSZ;
		_m1$4.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1$4 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	}

	makePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {

		const te = this.elements;
		const x = 2 * near / ( right - left );
		const y = 2 * near / ( top - bottom );

		const a = ( right + left ) / ( right - left );
		const b = ( top + bottom ) / ( top - bottom );

		let c, d;

		if ( coordinateSystem === WebGLCoordinateSystem ) {

			c = - ( far + near ) / ( far - near );
			d = ( - 2 * far * near ) / ( far - near );

		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

			c = - far / ( far - near );
			d = ( - far * near ) / ( far - near );

		} else {

			throw new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );

		}

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a; 	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b; 	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c; 	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	}

	makeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {

		const te = this.elements;
		const w = 1.0 / ( right - left );
		const h = 1.0 / ( top - bottom );
		const p = 1.0 / ( far - near );

		const x = ( right + left ) * w;
		const y = ( top + bottom ) * h;

		let z, zInv;

		if ( coordinateSystem === WebGLCoordinateSystem ) {

			z = ( far + near ) * p;
			zInv = - 2 * p;

		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

			z = near * p;
			zInv = - 1 * p;

		} else {

			throw new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );

		}

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;		te[ 8 ] = 0; 		te[ 12 ] = - x;
		te[ 1 ] = 0; 		te[ 5 ] = 2 * h;	te[ 9 ] = 0; 		te[ 13 ] = - y;
		te[ 2 ] = 0; 		te[ 6 ] = 0;		te[ 10 ] = zInv;	te[ 14 ] = - z;
		te[ 3 ] = 0; 		te[ 7 ] = 0;		te[ 11 ] = 0;		te[ 15 ] = 1;

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

}

const _v1$5 = /*@__PURE__*/ new Vector3();
const _m1$4 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
const _x = /*@__PURE__*/ new Vector3();
const _y = /*@__PURE__*/ new Vector3();
const _z = /*@__PURE__*/ new Vector3();

const _matrix$2 = /*@__PURE__*/ new Matrix4();
const _quaternion$3 = /*@__PURE__*/ new Quaternion();

class Euler {

	constructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {

		this.isEuler = true;

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get order() {

		return this._order;

	}

	set order( value ) {

		this._order = value;
		this._onChangeCallback();

	}

	set( x, y, z, order = this._order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._order );

	}

	copy( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m, order = this._order, update = true ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements;
		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update === true ) this._onChangeCallback();

		return this;

	}

	setFromQuaternion( q, order, update ) {

		_matrix$2.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix$2, order, update );

	}

	setFromVector3( v, order = this._order ) {

		return this.set( v.x, v.y, v.z, order );

	}

	reorder( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion$3.setFromEuler( this );

		return this.setFromQuaternion( _quaternion$3, newOrder );

	}

	equals( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	}

	fromArray( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

	*[ Symbol.iterator ]() {

		yield this._x;
		yield this._y;
		yield this._z;
		yield this._order;

	}

}

Euler.DEFAULT_ORDER = 'XYZ';

class Layers {

	constructor() {

		this.mask = 1 | 0;

	}

	set( channel ) {

		this.mask = ( 1 << channel | 0 ) >>> 0;

	}

	enable( channel ) {

		this.mask |= 1 << channel | 0;

	}

	enableAll() {

		this.mask = 0xffffffff | 0;

	}

	toggle( channel ) {

		this.mask ^= 1 << channel | 0;

	}

	disable( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	}

	disableAll() {

		this.mask = 0;

	}

	test( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

	isEnabled( channel ) {

		return ( this.mask & ( 1 << channel | 0 ) ) !== 0;

	}

}

let _object3DId = 0;

const _v1$4 = /*@__PURE__*/ new Vector3();
const _q1 = /*@__PURE__*/ new Quaternion();
const _m1$3 = /*@__PURE__*/ new Matrix4();
const _target = /*@__PURE__*/ new Vector3();

const _position$3 = /*@__PURE__*/ new Vector3();
const _scale$2 = /*@__PURE__*/ new Vector3();
const _quaternion$2 = /*@__PURE__*/ new Quaternion();

const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

const _addedEvent = { type: 'added' };
const _removedEvent = { type: 'removed' };

const _childaddedEvent = { type: 'childadded', child: null };
const _childremovedEvent = { type: 'childremoved', child: null };

class Object3D extends EventDispatcher {

	constructor() {

		super();

		this.isObject3D = true;

		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DEFAULT_UP.clone();

		const position = new Vector3();
		const rotation = new Euler();
		const quaternion = new Quaternion();
		const scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation._onChange( onRotationChange );
		quaternion._onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;

		this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.animations = [];

		this.userData = {};

	}

	onBeforeShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

	onAfterShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

	onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	applyMatrix4( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	}

	applyQuaternion( q ) {

		this.quaternion.premultiply( q );

		return this;

	}

	setRotationFromAxisAngle( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	}

	setRotationFromEuler( euler ) {

		this.quaternion.setFromEuler( euler, true );

	}

	setRotationFromMatrix( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	}

	setRotationFromQuaternion( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	}

	rotateOnAxis( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	}

	rotateOnWorldAxis( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	}

	rotateX( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	}

	rotateY( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	}

	rotateZ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	}

	translateOnAxis( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$4.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1$4.multiplyScalar( distance ) );

		return this;

	}

	translateX( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	}

	translateY( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	}

	translateZ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	}

	localToWorld( vector ) {

		this.updateWorldMatrix( true, false );

		return vector.applyMatrix4( this.matrixWorld );

	}

	worldToLocal( vector ) {

		this.updateWorldMatrix( true, false );

		return vector.applyMatrix4( _m1$3.copy( this.matrixWorld ).invert() );

	}

	lookAt( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		const parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position$3.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1$3.lookAt( _position$3, _target, this.up );

		} else {

			_m1$3.lookAt( _target, _position$3, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1$3 );

		if ( parent ) {

			_m1$3.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1$3 );
			this.quaternion.premultiply( _q1.invert() );

		}

	}

	add( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
			return this;

		}

		if ( object && object.isObject3D ) {

			object.removeFromParent();
			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

			_childaddedEvent.child = object;
			this.dispatchEvent( _childaddedEvent );
			_childaddedEvent.child = null;

		} else {

			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

		}

		return this;

	}

	remove( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		const index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

			_childremovedEvent.child = object;
			this.dispatchEvent( _childremovedEvent );
			_childremovedEvent.child = null;

		}

		return this;

	}

	removeFromParent() {

		const parent = this.parent;

		if ( parent !== null ) {

			parent.remove( this );

		}

		return this;

	}

	clear() {

		return this.remove( ... this.children );

	}

	attach( object ) {

		// adds object as a child of this, while maintaining the object's world transform

		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

		this.updateWorldMatrix( true, false );

		_m1$3.copy( this.matrixWorld ).invert();

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1$3.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix4( _m1$3 );

		object.removeFromParent();
		object.parent = this;
		this.children.push( object );

		object.updateWorldMatrix( false, true );

		object.dispatchEvent( _addedEvent );

		_childaddedEvent.child = object;
		this.dispatchEvent( _childaddedEvent );
		_childaddedEvent.child = null;

		return this;

	}

	getObjectById( id ) {

		return this.getObjectByProperty( 'id', id );

	}

	getObjectByName( name ) {

		return this.getObjectByProperty( 'name', name );

	}

	getObjectByProperty( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			const child = this.children[ i ];
			const object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	}

	getObjectsByProperty( name, value, result = [] ) {

		if ( this[ name ] === value ) result.push( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].getObjectsByProperty( name, value, result );

		}

		return result;

	}

	getWorldPosition( target ) {

		this.updateWorldMatrix( true, false );

		return target.setFromMatrixPosition( this.matrixWorld );

	}

	getWorldQuaternion( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, target, _scale$2 );

		return target;

	}

	getWorldScale( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, _quaternion$2, target );

		return target;

	}

	getWorldDirection( target ) {

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	}

	raycast( /* raycaster, intersects */ ) {}

	traverse( callback ) {

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	}

	traverseVisible( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	}

	traverseAncestors( callback ) {

		const parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	}

	updateMatrix() {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	}

	updateMatrixWorld( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			const child = children[ i ];

			if ( child.matrixWorldAutoUpdate === true || force === true ) {

				child.updateMatrixWorld( force );

			}

		}

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		const parent = this.parent;

		if ( updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			this.matrixWorld.copy( this.matrix );

		} else {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		}

		// update children

		if ( updateChildren === true ) {

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				const child = children[ i ];

				if ( child.matrixWorldAutoUpdate === true ) {

					child.updateWorldMatrix( false, true );

				}

			}

		}

	}

	toJSON( meta ) {

		// meta is a string when called from JSON.stringify
		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		const output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {},
				skeletons: {},
				animations: {},
				nodes: {}
			};

			output.metadata = {
				version: 4.6,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		const object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( this.frustumCulled === false ) object.frustumCulled = false;
		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		if ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();
		object.up = this.up.toArray();

		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		// object specific properties

		if ( this.isInstancedMesh ) {

			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();
			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

		}

		if ( this.isBatchedMesh ) {

			object.type = 'BatchedMesh';
			object.perObjectFrustumCulled = this.perObjectFrustumCulled;
			object.sortObjects = this.sortObjects;

			object.drawRanges = this._drawRanges;
			object.reservedRanges = this._reservedRanges;

			object.visibility = this._visibility;
			object.active = this._active;
			object.bounds = this._bounds.map( bound => ( {
				boxInitialized: bound.boxInitialized,
				boxMin: bound.box.min.toArray(),
				boxMax: bound.box.max.toArray(),

				sphereInitialized: bound.sphereInitialized,
				sphereRadius: bound.sphere.radius,
				sphereCenter: bound.sphere.center.toArray()
			} ) );

			object.maxGeometryCount = this._maxGeometryCount;
			object.maxVertexCount = this._maxVertexCount;
			object.maxIndexCount = this._maxIndexCount;

			object.geometryInitialized = this._geometryInitialized;
			object.geometryCount = this._geometryCount;

			object.matricesTexture = this._matricesTexture.toJSON( meta );

			if ( this.boundingSphere !== null ) {

				object.boundingSphere = {
					center: object.boundingSphere.center.toArray(),
					radius: object.boundingSphere.radius
				};

			}

			if ( this.boundingBox !== null ) {

				object.boundingBox = {
					min: object.boundingBox.min.toArray(),
					max: object.boundingBox.max.toArray()
				};

			}

		}

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isScene ) {

			if ( this.background ) {

				if ( this.background.isColor ) {

					object.background = this.background.toJSON();

				} else if ( this.background.isTexture ) {

					object.background = this.background.toJSON( meta ).uuid;

				}

			}

			if ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {

				object.environment = this.environment.toJSON( meta ).uuid;

			}

		} else if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			const parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				const shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

						const shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.isSkinnedMesh ) {

			object.bindMode = this.bindMode;
			object.bindMatrix = this.bindMatrix.toArray();

			if ( this.skeleton !== undefined ) {

				serialize( meta.skeletons, this.skeleton );

				object.skeleton = this.skeleton.uuid;

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				const uuids = [];

				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( let i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		//

		if ( this.animations.length > 0 ) {

			object.animations = [];

			for ( let i = 0; i < this.animations.length; i ++ ) {

				const animation = this.animations[ i ];

				object.animations.push( serialize( meta.animations, animation ) );

			}

		}

		if ( isRootObject ) {

			const geometries = extractFromCache( meta.geometries );
			const materials = extractFromCache( meta.materials );
			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const shapes = extractFromCache( meta.shapes );
			const skeletons = extractFromCache( meta.skeletons );
			const animations = extractFromCache( meta.animations );
			const nodes = extractFromCache( meta.nodes );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
			if ( shapes.length > 0 ) output.shapes = shapes;
			if ( skeletons.length > 0 ) output.skeletons = skeletons;
			if ( animations.length > 0 ) output.animations = animations;
			if ( nodes.length > 0 ) output.nodes = nodes;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			const values = [];
			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

	}

	clone( recursive ) {

		return new this.constructor().copy( this, recursive );

	}

	copy( source, recursive = true ) {

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.rotation.order = source.rotation.order;
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;

		this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.animations = source.animations.slice();

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( let i = 0; i < source.children.length; i ++ ) {

				const child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

}

Object3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

const _v0$1 = /*@__PURE__*/ new Vector3();
const _v1$3 = /*@__PURE__*/ new Vector3();
const _v2$2 = /*@__PURE__*/ new Vector3();
const _v3$2 = /*@__PURE__*/ new Vector3();

const _vab = /*@__PURE__*/ new Vector3();
const _vac = /*@__PURE__*/ new Vector3();
const _vbc = /*@__PURE__*/ new Vector3();
const _vap = /*@__PURE__*/ new Vector3();
const _vbp = /*@__PURE__*/ new Vector3();
const _vcp = /*@__PURE__*/ new Vector3();

class Triangle {

	constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

		this.a = a;
		this.b = b;
		this.c = c;

	}

	static getNormal( a, b, c, target ) {

		target.subVectors( c, b );
		_v0$1.subVectors( a, b );
		target.cross( _v0$1 );

		const targetLengthSq = target.lengthSq();
		if ( targetLengthSq > 0 ) {

			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		}

		return target.set( 0, 0, 0 );

	}

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	static getBarycoord( point, a, b, c, target ) {

		_v0$1.subVectors( c, a );
		_v1$3.subVectors( b, a );
		_v2$2.subVectors( point, a );

		const dot00 = _v0$1.dot( _v0$1 );
		const dot01 = _v0$1.dot( _v1$3 );
		const dot02 = _v0$1.dot( _v2$2 );
		const dot11 = _v1$3.dot( _v1$3 );
		const dot12 = _v1$3.dot( _v2$2 );

		const denom = ( dot00 * dot11 - dot01 * dot01 );

		// collinear or singular triangle
		if ( denom === 0 ) {

			target.set( 0, 0, 0 );
			return null;

		}

		const invDenom = 1 / denom;
		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set( 1 - u - v, v, u );

	}

	static containsPoint( point, a, b, c ) {

		// if the triangle is degenerate then we can't contain a point
		if ( this.getBarycoord( point, a, b, c, _v3$2 ) === null ) {

			return false;

		}

		return ( _v3$2.x >= 0 ) && ( _v3$2.y >= 0 ) && ( ( _v3$2.x + _v3$2.y ) <= 1 );

	}

	static getInterpolation( point, p1, p2, p3, v1, v2, v3, target ) {

		if ( this.getBarycoord( point, p1, p2, p3, _v3$2 ) === null ) {

			target.x = 0;
			target.y = 0;
			if ( 'z' in target ) target.z = 0;
			if ( 'w' in target ) target.w = 0;
			return null;

		}

		target.setScalar( 0 );
		target.addScaledVector( v1, _v3$2.x );
		target.addScaledVector( v2, _v3$2.y );
		target.addScaledVector( v3, _v3$2.z );

		return target;

	}

	static isFrontFacing( a, b, c, direction ) {

		_v0$1.subVectors( c, b );
		_v1$3.subVectors( a, b );

		// strictly front facing
		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

	}

	set( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	}

	setFromPointsAndIndices( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	}

	setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

		this.a.fromBufferAttribute( attribute, i0 );
		this.b.fromBufferAttribute( attribute, i1 );
		this.c.fromBufferAttribute( attribute, i2 );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	}

	getArea() {

		_v0$1.subVectors( this.c, this.b );
		_v1$3.subVectors( this.a, this.b );

		return _v0$1.cross( _v1$3 ).length() * 0.5;

	}

	getMidpoint( target ) {

		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	}

	getNormal( target ) {

		return Triangle.getNormal( this.a, this.b, this.c, target );

	}

	getPlane( target ) {

		return target.setFromCoplanarPoints( this.a, this.b, this.c );

	}

	getBarycoord( point, target ) {

		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	}

	getInterpolation( point, v1, v2, v3, target ) {

		return Triangle.getInterpolation( point, this.a, this.b, this.c, v1, v2, v3, target );

	}

	containsPoint( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	}

	isFrontFacing( direction ) {

		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

	}

	intersectsBox( box ) {

		return box.intersectsTriangle( this );

	}

	closestPointToPoint( p, target ) {

		const a = this.a, b = this.b, c = this.c;
		let v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors( b, a );
		_vac.subVectors( c, a );
		_vap.subVectors( p, a );
		const d1 = _vab.dot( _vap );
		const d2 = _vac.dot( _vap );
		if ( d1 <= 0 && d2 <= 0 ) {

			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy( a );

		}

		_vbp.subVectors( p, b );
		const d3 = _vab.dot( _vbp );
		const d4 = _vac.dot( _vbp );
		if ( d3 >= 0 && d4 <= d3 ) {

			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy( b );

		}

		const vc = d1 * d4 - d3 * d2;
		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			v = d1 / ( d1 - d3 );
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy( a ).addScaledVector( _vab, v );

		}

		_vcp.subVectors( p, c );
		const d5 = _vab.dot( _vcp );
		const d6 = _vac.dot( _vcp );
		if ( d6 >= 0 && d5 <= d6 ) {

			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy( c );

		}

		const vb = d5 * d2 - d1 * d6;
		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			w = d2 / ( d2 - d6 );
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy( a ).addScaledVector( _vac, w );

		}

		const va = d3 * d6 - d5 * d4;
		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			_vbc.subVectors( c, b );
			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

		}

		// face region
		const denom = 1 / ( va + vb + vc );
		// u = va * denom
		v = vb * denom;
		w = vc * denom;

		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

	}

	equals( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

}

const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };

function hue2rgb( p, q, t ) {

	if ( t < 0 ) t += 1;
	if ( t > 1 ) t -= 1;
	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
	if ( t < 1 / 2 ) return q;
	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
	return p;

}

class Color {

	constructor( r, g, b ) {

		this.isColor = true;

		this.r = 1;
		this.g = 1;
		this.b = 1;

		return this.set( r, g, b );

	}

	set( r, g, b ) {

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string

			const value = r;

			if ( value && value.isColor ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

		} else {

			this.setRGB( r, g, b );

		}

		return this;

	}

	setScalar( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	}

	setHex( hex, colorSpace = SRGBColorSpace ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {

		this.r = r;
		this.g = g;
		this.b = b;

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0
		h = euclideanModulo( h, 1 );
		s = clamp( s, 0, 1 );
		l = clamp( l, 0, 1 );

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			const q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setStyle( style, colorSpace = SRGBColorSpace ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		let m;

		if ( m = /^(\w+)\(([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			let color;
			const name = m[ 1 ];
			const components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)

						handleAlpha( color[ 4 ] );

						return this.setRGB(
							Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255,
							Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255,
							Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255,
							colorSpace
						);

					}

					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)

						handleAlpha( color[ 4 ] );

						return this.setRGB(
							Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100,
							Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100,
							Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100,
							colorSpace
						);

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)

						handleAlpha( color[ 4 ] );

						return this.setHSL(
							parseFloat( color[ 1 ] ) / 360,
							parseFloat( color[ 2 ] ) / 100,
							parseFloat( color[ 3 ] ) / 100,
							colorSpace
						);

					}

					break;

				default:

					console.warn( 'THREE.Color: Unknown color model ' + style );

			}

		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

			// hex color

			const hex = m[ 1 ];
			const size = hex.length;

			if ( size === 3 ) {

				// #ff0
				return this.setRGB(
					parseInt( hex.charAt( 0 ), 16 ) / 15,
					parseInt( hex.charAt( 1 ), 16 ) / 15,
					parseInt( hex.charAt( 2 ), 16 ) / 15,
					colorSpace
				);

			} else if ( size === 6 ) {

				// #ff0000
				return this.setHex( parseInt( hex, 16 ), colorSpace );

			} else {

				console.warn( 'THREE.Color: Invalid hex color ' + style );

			}

		} else if ( style && style.length > 0 ) {

			return this.setColorName( style, colorSpace );

		}

		return this;

	}

	setColorName( style, colorSpace = SRGBColorSpace ) {

		// color keywords
		const hex = _colorKeywords[ style.toLowerCase() ];

		if ( hex !== undefined ) {

			// red
			this.setHex( hex, colorSpace );

		} else {

			// unknown color
			console.warn( 'THREE.Color: Unknown color ' + style );

		}

		return this;

	}

	clone() {

		return new this.constructor( this.r, this.g, this.b );

	}

	copy( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	}

	copySRGBToLinear( color ) {

		this.r = SRGBToLinear( color.r );
		this.g = SRGBToLinear( color.g );
		this.b = SRGBToLinear( color.b );

		return this;

	}

	copyLinearToSRGB( color ) {

		this.r = LinearToSRGB( color.r );
		this.g = LinearToSRGB( color.g );
		this.b = LinearToSRGB( color.b );

		return this;

	}

	convertSRGBToLinear() {

		this.copySRGBToLinear( this );

		return this;

	}

	convertLinearToSRGB() {

		this.copyLinearToSRGB( this );

		return this;

	}

	getHex( colorSpace = SRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		return Math.round( clamp( _color.r * 255, 0, 255 ) ) * 65536 + Math.round( clamp( _color.g * 255, 0, 255 ) ) * 256 + Math.round( clamp( _color.b * 255, 0, 255 ) );

	}

	getHexString( colorSpace = SRGBColorSpace ) {

		return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );

	}

	getHSL( target, colorSpace = ColorManagement.workingColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		const r = _color.r, g = _color.g, b = _color.b;

		const max = Math.max( r, g, b );
		const min = Math.min( r, g, b );

		let hue, saturation;
		const lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			const delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		target.h = hue;
		target.s = saturation;
		target.l = lightness;

		return target;

	}

	getRGB( target, colorSpace = ColorManagement.workingColorSpace ) {

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		target.r = _color.r;
		target.g = _color.g;
		target.b = _color.b;

		return target;

	}

	getStyle( colorSpace = SRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

		const r = _color.r, g = _color.g, b = _color.b;

		if ( colorSpace !== SRGBColorSpace ) {

			// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
			return `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;

		}

		return `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`;

	}

	offsetHSL( h, s, l ) {

		this.getHSL( _hslA );

		return this.setHSL( _hslA.h + h, _hslA.s + s, _hslA.l + l );

	}

	add( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	}

	addColors( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	}

	addScalar( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	}

	sub( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	}

	multiply( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	}

	multiplyScalar( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	}

	lerp( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	}

	lerpColors( color1, color2, alpha ) {

		this.r = color1.r + ( color2.r - color1.r ) * alpha;
		this.g = color1.g + ( color2.g - color1.g ) * alpha;
		this.b = color1.b + ( color2.b - color1.b ) * alpha;

		return this;

	}

	lerpHSL( color, alpha ) {

		this.getHSL( _hslA );
		color.getHSL( _hslB );

		const h = lerp( _hslA.h, _hslB.h, alpha );
		const s = lerp( _hslA.s, _hslB.s, alpha );
		const l = lerp( _hslA.l, _hslB.l, alpha );

		this.setHSL( h, s, l );

		return this;

	}

	setFromVector3( v ) {

		this.r = v.x;
		this.g = v.y;
		this.b = v.z;

		return this;

	}

	applyMatrix3( m ) {

		const r = this.r, g = this.g, b = this.b;
		const e = m.elements;

		this.r = e[ 0 ] * r + e[ 3 ] * g + e[ 6 ] * b;
		this.g = e[ 1 ] * r + e[ 4 ] * g + e[ 7 ] * b;
		this.b = e[ 2 ] * r + e[ 5 ] * g + e[ 8 ] * b;

		return this;

	}

	equals( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	}

	fromArray( array, offset = 0 ) {

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.r = attribute.getX( index );
		this.g = attribute.getY( index );
		this.b = attribute.getZ( index );

		return this;

	}

	toJSON() {

		return this.getHex();

	}

	*[ Symbol.iterator ]() {

		yield this.r;
		yield this.g;
		yield this.b;

	}

}

const _color = /*@__PURE__*/ new Color();

Color.NAMES = _colorKeywords;

let _materialId = 0;

class Material extends EventDispatcher {

	constructor() {

		super();

		this.isMaterial = true;

		Object.defineProperty( this, 'id', { value: _materialId ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'Material';

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.vertexColors = false;

		this.opacity = 1;
		this.transparent = false;
		this.alphaHash = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;
		this.blendColor = new Color( 0, 0, 0 );
		this.blendAlpha = 0;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.stencilWriteMask = 0xff;
		this.stencilFunc = AlwaysStencilFunc;
		this.stencilRef = 0;
		this.stencilFuncMask = 0xff;
		this.stencilFail = KeepStencilOp;
		this.stencilZFail = KeepStencilOp;
		this.stencilZPass = KeepStencilOp;
		this.stencilWrite = false;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.shadowSide = null;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaToCoverage = false;
		this.premultipliedAlpha = false;
		this.forceSinglePass = false;

		this.visible = true;

		this.toneMapped = true;

		this.userData = {};

		this.version = 0;

		this._alphaTest = 0;

	}

	get alphaTest() {

		return this._alphaTest;

	}

	set alphaTest( value ) {

		if ( this._alphaTest > 0 !== value > 0 ) {

			this.version ++;

		}

		this._alphaTest = value;

	}

	onBuild( /* shaderobject, renderer */ ) {}

	onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

	onBeforeCompile( /* shaderobject, renderer */ ) {}

	customProgramCacheKey() {

		return this.onBeforeCompile.toString();

	}

	setValues( values ) {

		if ( values === undefined ) return;

		for ( const key in values ) {

			const newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( `THREE.Material: parameter '${ key }' has value of undefined.` );
				continue;

			}

			const currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( `THREE.Material: '${ key }' is not a property of THREE.${ this.type }.` );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( isRootObject ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		const data = {
			metadata: {
				version: 4.6,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.sheen !== undefined ) data.sheen = this.sheen;
		if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
		if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
		if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

		}

		if ( this.dispersion !== undefined ) data.dispersion = this.dispersion;

		if ( this.iridescence !== undefined ) data.iridescence = this.iridescence;
		if ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;
		if ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;

		if ( this.iridescenceMap && this.iridescenceMap.isTexture ) {

			data.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;

		}

		if ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {

			data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;

		}

		if ( this.anisotropy !== undefined ) data.anisotropy = this.anisotropy;
		if ( this.anisotropyRotation !== undefined ) data.anisotropyRotation = this.anisotropyRotation;

		if ( this.anisotropyMap && this.anisotropyMap.isTexture ) {

			data.anisotropyMap = this.anisotropyMap.toJSON( meta ).uuid;

		}

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

		if ( this.lightMap && this.lightMap.isTexture ) {

			data.lightMap = this.lightMap.toJSON( meta ).uuid;
			data.lightMapIntensity = this.lightMapIntensity;

		}

		if ( this.aoMap && this.aoMap.isTexture ) {

			data.aoMap = this.aoMap.toJSON( meta ).uuid;
			data.aoMapIntensity = this.aoMapIntensity;

		}

		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}

		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();

		}

		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}

		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
		if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
		if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;

			if ( this.combine !== undefined ) data.combine = this.combine;

		}

		if ( this.envMapRotation !== undefined ) data.envMapRotation = this.envMapRotation.toArray();
		if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
		if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
		if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.transmission !== undefined ) data.transmission = this.transmission;
		if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
		if ( this.thickness !== undefined ) data.thickness = this.thickness;
		if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
		if ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;
		if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors === true ) data.vertexColors = true;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = true;

		if ( this.blendSrc !== SrcAlphaFactor ) data.blendSrc = this.blendSrc;
		if ( this.blendDst !== OneMinusSrcAlphaFactor ) data.blendDst = this.blendDst;
		if ( this.blendEquation !== AddEquation ) data.blendEquation = this.blendEquation;
		if ( this.blendSrcAlpha !== null ) data.blendSrcAlpha = this.blendSrcAlpha;
		if ( this.blendDstAlpha !== null ) data.blendDstAlpha = this.blendDstAlpha;
		if ( this.blendEquationAlpha !== null ) data.blendEquationAlpha = this.blendEquationAlpha;
		if ( this.blendColor && this.blendColor.isColor ) data.blendColor = this.blendColor.getHex();
		if ( this.blendAlpha !== 0 ) data.blendAlpha = this.blendAlpha;

		if ( this.depthFunc !== LessEqualDepth ) data.depthFunc = this.depthFunc;
		if ( this.depthTest === false ) data.depthTest = this.depthTest;
		if ( this.depthWrite === false ) data.depthWrite = this.depthWrite;
		if ( this.colorWrite === false ) data.colorWrite = this.colorWrite;

		if ( this.stencilWriteMask !== 0xff ) data.stencilWriteMask = this.stencilWriteMask;
		if ( this.stencilFunc !== AlwaysStencilFunc ) data.stencilFunc = this.stencilFunc;
		if ( this.stencilRef !== 0 ) data.stencilRef = this.stencilRef;
		if ( this.stencilFuncMask !== 0xff ) data.stencilFuncMask = this.stencilFuncMask;
		if ( this.stencilFail !== KeepStencilOp ) data.stencilFail = this.stencilFail;
		if ( this.stencilZFail !== KeepStencilOp ) data.stencilZFail = this.stencilZFail;
		if ( this.stencilZPass !== KeepStencilOp ) data.stencilZPass = this.stencilZPass;
		if ( this.stencilWrite === true ) data.stencilWrite = this.stencilWrite;

		// rotation (SpriteMaterial)
		if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

		if ( this.polygonOffset === true ) data.polygonOffset = true;
		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

		if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		if ( this.scale !== undefined ) data.scale = this.scale;

		if ( this.dithering === true ) data.dithering = true;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.alphaHash === true ) data.alphaHash = true;
		if ( this.alphaToCoverage === true ) data.alphaToCoverage = true;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = true;
		if ( this.forceSinglePass === true ) data.forceSinglePass = true;

		if ( this.wireframe === true ) data.wireframe = true;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		if ( this.flatShading === true ) data.flatShading = true;

		if ( this.visible === false ) data.visible = false;

		if ( this.toneMapped === false ) data.toneMapped = false;

		if ( this.fog === false ) data.fog = false;

		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRootObject ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.blending = source.blending;
		this.side = source.side;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;
		this.blendColor.copy( source.blendColor );
		this.blendAlpha = source.blendAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;

		const srcPlanes = source.clippingPlanes;
		let dstPlanes = null;

		if ( srcPlanes !== null ) {

			const n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( let i = 0; i !== n; ++ i ) {

				dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

		}

		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;

		this.shadowSide = source.shadowSide;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;
		this.alphaHash = source.alphaHash;
		this.alphaToCoverage = source.alphaToCoverage;
		this.premultipliedAlpha = source.premultipliedAlpha;
		this.forceSinglePass = source.forceSinglePass;

		this.visible = source.visible;

		this.toneMapped = source.toneMapped;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

}

class MeshBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshBasicMaterial = true;

		this.type = 'MeshBasicMaterial';

		this.color = new Color( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapRotation = new Euler();
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapRotation.copy( source.envMapRotation );
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.fog = source.fog;

		return this;

	}

}

// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf

const _tables = /*@__PURE__*/ _generateTables();

function _generateTables() {

	// float32 to float16 helpers

	const buffer = new ArrayBuffer( 4 );
	const floatView = new Float32Array( buffer );
	const uint32View = new Uint32Array( buffer );

	const baseTable = new Uint32Array( 512 );
	const shiftTable = new Uint32Array( 512 );

	for ( let i = 0; i < 256; ++ i ) {

		const e = i - 127;

		// very small number (0, -0)

		if ( e < - 27 ) {

			baseTable[ i ] = 0x0000;
			baseTable[ i | 0x100 ] = 0x8000;
			shiftTable[ i ] = 24;
			shiftTable[ i | 0x100 ] = 24;

			// small number (denorm)

		} else if ( e < - 14 ) {

			baseTable[ i ] = 0x0400 >> ( - e - 14 );
			baseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;
			shiftTable[ i ] = - e - 1;
			shiftTable[ i | 0x100 ] = - e - 1;

			// normal number

		} else if ( e <= 15 ) {

			baseTable[ i ] = ( e + 15 ) << 10;
			baseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;
			shiftTable[ i ] = 13;
			shiftTable[ i | 0x100 ] = 13;

			// large number (Infinity, -Infinity)

		} else if ( e < 128 ) {

			baseTable[ i ] = 0x7c00;
			baseTable[ i | 0x100 ] = 0xfc00;
			shiftTable[ i ] = 24;
			shiftTable[ i | 0x100 ] = 24;

			// stay (NaN, Infinity, -Infinity)

		} else {

			baseTable[ i ] = 0x7c00;
			baseTable[ i | 0x100 ] = 0xfc00;
			shiftTable[ i ] = 13;
			shiftTable[ i | 0x100 ] = 13;

		}

	}

	// float16 to float32 helpers

	const mantissaTable = new Uint32Array( 2048 );
	const exponentTable = new Uint32Array( 64 );
	const offsetTable = new Uint32Array( 64 );

	for ( let i = 1; i < 1024; ++ i ) {

		let m = i << 13; // zero pad mantissa bits
		let e = 0; // zero exponent

		// normalized
		while ( ( m & 0x00800000 ) === 0 ) {

			m <<= 1;
			e -= 0x00800000; // decrement exponent

		}

		m &= ~ 0x00800000; // clear leading 1 bit
		e += 0x38800000; // adjust bias

		mantissaTable[ i ] = m | e;

	}

	for ( let i = 1024; i < 2048; ++ i ) {

		mantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );

	}

	for ( let i = 1; i < 31; ++ i ) {

		exponentTable[ i ] = i << 23;

	}

	exponentTable[ 31 ] = 0x47800000;
	exponentTable[ 32 ] = 0x80000000;

	for ( let i = 33; i < 63; ++ i ) {

		exponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );

	}

	exponentTable[ 63 ] = 0xc7800000;

	for ( let i = 1; i < 64; ++ i ) {

		if ( i !== 32 ) {

			offsetTable[ i ] = 1024;

		}

	}

	return {
		floatView: floatView,
		uint32View: uint32View,
		baseTable: baseTable,
		shiftTable: shiftTable,
		mantissaTable: mantissaTable,
		exponentTable: exponentTable,
		offsetTable: offsetTable
	};

}

// float32 to float16

function toHalfFloat( val ) {

	if ( Math.abs( val ) > 65504 ) console.warn( 'THREE.DataUtils.toHalfFloat(): Value out of range.' );

	val = clamp( val, - 65504, 65504 );

	_tables.floatView[ 0 ] = val;
	const f = _tables.uint32View[ 0 ];
	const e = ( f >> 23 ) & 0x1ff;
	return _tables.baseTable[ e ] + ( ( f & 0x007fffff ) >> _tables.shiftTable[ e ] );

}

// float16 to float32

function fromHalfFloat( val ) {

	const m = val >> 10;
	_tables.uint32View[ 0 ] = _tables.mantissaTable[ _tables.offsetTable[ m ] + ( val & 0x3ff ) ] + _tables.exponentTable[ m ];
	return _tables.floatView[ 0 ];

}

const DataUtils = {
	toHalfFloat: toHalfFloat,
	fromHalfFloat: fromHalfFloat,
};

const _vector$9 = /*@__PURE__*/ new Vector3();
const _vector2$1 = /*@__PURE__*/ new Vector2();

class BufferAttribute {

	constructor( array, itemSize, normalized = false ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.isBufferAttribute = true;

		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized;

		this.usage = StaticDrawUsage;
		this._updateRange = { offset: 0, count: - 1 };
		this.updateRanges = [];
		this.gpuType = FloatType;

		this.version = 0;

	}

	onUploadCallback() {}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	get updateRange() {

		warnOnce( 'THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.' ); // @deprecated, r159
		return this._updateRange;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	addUpdateRange( start, count ) {

		this.updateRanges.push( { start, count } );

	}

	clearUpdateRanges() {

		this.updateRanges.length = 0;

	}

	copy( source ) {

		this.name = source.name;
		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.usage = source.usage;
		this.gpuType = source.gpuType;

		return this;

	}

	copyAt( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	}

	copyArray( array ) {

		this.array.set( array );

		return this;

	}

	applyMatrix3( m ) {

		if ( this.itemSize === 2 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector2$1.fromBufferAttribute( this, i );
				_vector2$1.applyMatrix3( m );

				this.setXY( i, _vector2$1.x, _vector2$1.y );

			}

		} else if ( this.itemSize === 3 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$9.fromBufferAttribute( this, i );
				_vector$9.applyMatrix3( m );

				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

			}

		}

		return this;

	}

	applyMatrix4( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyMatrix4( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyNormalMatrix( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.transformDirection( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	set( value, offset = 0 ) {

		// Matching BufferAttribute constructor, do not normalize the array.
		this.array.set( value, offset );

		return this;

	}

	getComponent( index, component ) {

		let value = this.array[ index * this.itemSize + component ];

		if ( this.normalized ) value = denormalize( value, this.array );

		return value;

	}

	setComponent( index, component, value ) {

		if ( this.normalized ) value = normalize( value, this.array );

		this.array[ index * this.itemSize + component ] = value;

		return this;

	}

	getX( index ) {

		let x = this.array[ index * this.itemSize ];

		if ( this.normalized ) x = denormalize( x, this.array );

		return x;

	}

	setX( index, x ) {

		if ( this.normalized ) x = normalize( x, this.array );

		this.array[ index * this.itemSize ] = x;

		return this;

	}

	getY( index ) {

		let y = this.array[ index * this.itemSize + 1 ];

		if ( this.normalized ) y = denormalize( y, this.array );

		return y;

	}

	setY( index, y ) {

		if ( this.normalized ) y = normalize( y, this.array );

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	}

	getZ( index ) {

		let z = this.array[ index * this.itemSize + 2 ];

		if ( this.normalized ) z = denormalize( z, this.array );

		return z;

	}

	setZ( index, z ) {

		if ( this.normalized ) z = normalize( z, this.array );

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	}

	getW( index ) {

		let w = this.array[ index * this.itemSize + 3 ];

		if ( this.normalized ) w = denormalize( w, this.array );

		return w;

	}

	setW( index, w ) {

		if ( this.normalized ) w = normalize( w, this.array );

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	}

	setXY( index, x, y ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	}

	setXYZ( index, x, y, z ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );
			w = normalize( w, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	}

	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	clone() {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	}

	toJSON() {

		const data = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.from( this.array ),
			normalized: this.normalized
		};

		if ( this.name !== '' ) data.name = this.name;
		if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;

		return data;

	}

}

//

class Int8BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Int8Array( array ), itemSize, normalized );

	}

}

class Uint8BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint8Array( array ), itemSize, normalized );

	}

}

class Uint8ClampedBufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint8ClampedArray( array ), itemSize, normalized );

	}

}

class Int16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Int16Array( array ), itemSize, normalized );

	}

}

class Uint16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint16Array( array ), itemSize, normalized );

	}

}

class Int32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Int32Array( array ), itemSize, normalized );

	}

}

class Uint32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint32Array( array ), itemSize, normalized );

	}

}

class Float16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint16Array( array ), itemSize, normalized );

		this.isFloat16BufferAttribute = true;

	}

	getX( index ) {

		let x = fromHalfFloat( this.array[ index * this.itemSize ] );

		if ( this.normalized ) x = denormalize( x, this.array );

		return x;

	}

	setX( index, x ) {

		if ( this.normalized ) x = normalize( x, this.array );

		this.array[ index * this.itemSize ] = toHalfFloat( x );

		return this;

	}

	getY( index ) {

		let y = fromHalfFloat( this.array[ index * this.itemSize + 1 ] );

		if ( this.normalized ) y = denormalize( y, this.array );

		return y;

	}

	setY( index, y ) {

		if ( this.normalized ) y = normalize( y, this.array );

		this.array[ index * this.itemSize + 1 ] = toHalfFloat( y );

		return this;

	}

	getZ( index ) {

		let z = fromHalfFloat( this.array[ index * this.itemSize + 2 ] );

		if ( this.normalized ) z = denormalize( z, this.array );

		return z;

	}

	setZ( index, z ) {

		if ( this.normalized ) z = normalize( z, this.array );

		this.array[ index * this.itemSize + 2 ] = toHalfFloat( z );

		return this;

	}

	getW( index ) {

		let w = fromHalfFloat( this.array[ index * this.itemSize + 3 ] );

		if ( this.normalized ) w = denormalize( w, this.array );

		return w;

	}

	setW( index, w ) {

		if ( this.normalized ) w = normalize( w, this.array );

		this.array[ index * this.itemSize + 3 ] = toHalfFloat( w );

		return this;

	}

	setXY( index, x, y ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );

		}

		this.array[ index + 0 ] = toHalfFloat( x );
		this.array[ index + 1 ] = toHalfFloat( y );

		return this;

	}

	setXYZ( index, x, y, z ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );

		}

		this.array[ index + 0 ] = toHalfFloat( x );
		this.array[ index + 1 ] = toHalfFloat( y );
		this.array[ index + 2 ] = toHalfFloat( z );

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );
			w = normalize( w, this.array );

		}

		this.array[ index + 0 ] = toHalfFloat( x );
		this.array[ index + 1 ] = toHalfFloat( y );
		this.array[ index + 2 ] = toHalfFloat( z );
		this.array[ index + 3 ] = toHalfFloat( w );

		return this;

	}

}


class Float32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Float32Array( array ), itemSize, normalized );

	}

}

let _id$2 = 0;

const _m1$2 = /*@__PURE__*/ new Matrix4();
const _obj = /*@__PURE__*/ new Object3D();
const _offset = /*@__PURE__*/ new Vector3();
const _box$2 = /*@__PURE__*/ new Box3();
const _boxMorphTargets = /*@__PURE__*/ new Box3();
const _vector$8 = /*@__PURE__*/ new Vector3();

class BufferGeometry extends EventDispatcher {

	constructor() {

		super();

		this.isBufferGeometry = true;

		Object.defineProperty( this, 'id', { value: _id$2 ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};
		this.morphTargetsRelative = false;

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

		this.userData = {};

	}

	getIndex() {

		return this.index;

	}

	setIndex( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		} else {

			this.index = index;

		}

		return this;

	}

	getAttribute( name ) {

		return this.attributes[ name ];

	}

	setAttribute( name, attribute ) {

		this.attributes[ name ] = attribute;

		return this;

	}

	deleteAttribute( name ) {

		delete this.attributes[ name ];

		return this;

	}

	hasAttribute( name ) {

		return this.attributes[ name ] !== undefined;

	}

	addGroup( start, count, materialIndex = 0 ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex

		} );

	}

	clearGroups() {

		this.groups = [];

	}

	setDrawRange( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	}

	applyMatrix4( matrix ) {

		const position = this.attributes.position;

		if ( position !== undefined ) {

			position.applyMatrix4( matrix );

			position.needsUpdate = true;

		}

		const normal = this.attributes.normal;

		if ( normal !== undefined ) {

			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normal.applyNormalMatrix( normalMatrix );

			normal.needsUpdate = true;

		}

		const tangent = this.attributes.tangent;

		if ( tangent !== undefined ) {

			tangent.transformDirection( matrix );

			tangent.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	}

	applyQuaternion( q ) {

		_m1$2.makeRotationFromQuaternion( q );

		this.applyMatrix4( _m1$2 );

		return this;

	}

	rotateX( angle ) {

		// rotate geometry around world x-axis

		_m1$2.makeRotationX( angle );

		this.applyMatrix4( _m1$2 );

		return this;

	}

	rotateY( angle ) {

		// rotate geometry around world y-axis

		_m1$2.makeRotationY( angle );

		this.applyMatrix4( _m1$2 );

		return this;

	}

	rotateZ( angle ) {

		// rotate geometry around world z-axis

		_m1$2.makeRotationZ( angle );

		this.applyMatrix4( _m1$2 );

		return this;

	}

	translate( x, y, z ) {

		// translate geometry

		_m1$2.makeTranslation( x, y, z );

		this.applyMatrix4( _m1$2 );

		return this;

	}

	scale( x, y, z ) {

		// scale geometry

		_m1$2.makeScale( x, y, z );

		this.applyMatrix4( _m1$2 );

		return this;

	}

	lookAt( vector ) {

		_obj.lookAt( vector );

		_obj.updateMatrix();

		this.applyMatrix4( _obj.matrix );

		return this;

	}

	center() {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset ).negate();

		this.translate( _offset.x, _offset.y, _offset.z );

		return this;

	}

	setFromPoints( points ) {

		const position = [];

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const point = points[ i ];
			position.push( point.x, point.y, point.z || 0 );

		}

		this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

		return this;

	}

	computeBoundingBox() {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );

			this.boundingBox.set(
				new Vector3( - Infinity, - Infinity, - Infinity ),
				new Vector3( + Infinity, + Infinity, + Infinity )
			);

			return;

		}

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_box$2.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( this.boundingBox.min, _box$2.min );
						this.boundingBox.expandByPoint( _vector$8 );

						_vector$8.addVectors( this.boundingBox.max, _box$2.max );
						this.boundingBox.expandByPoint( _vector$8 );

					} else {

						this.boundingBox.expandByPoint( _box$2.min );
						this.boundingBox.expandByPoint( _box$2.max );

					}

				}

			}

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	}

	computeBoundingSphere() {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );

			this.boundingSphere.set( new Vector3(), Infinity );

			return;

		}

		if ( position ) {

			// first, find the center of the bounding sphere

			const center = this.boundingSphere.center;

			_box$2.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( _box$2.min, _boxMorphTargets.min );
						_box$2.expandByPoint( _vector$8 );

						_vector$8.addVectors( _box$2.max, _boxMorphTargets.max );
						_box$2.expandByPoint( _vector$8 );

					} else {

						_box$2.expandByPoint( _boxMorphTargets.min );
						_box$2.expandByPoint( _boxMorphTargets.max );

					}

				}

			}

			_box$2.getCenter( center );

			// second, try to find a boundingSphere with a radius smaller than the
			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			let maxRadiusSq = 0;

			for ( let i = 0, il = position.count; i < il; i ++ ) {

				_vector$8.fromBufferAttribute( position, i );

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

			}

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					const morphTargetsRelative = this.morphTargetsRelative;

					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

						_vector$8.fromBufferAttribute( morphAttribute, j );

						if ( morphTargetsRelative ) {

							_offset.fromBufferAttribute( position, j );
							_vector$8.add( _offset );

						}

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

					}

				}

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

			}

		}

	}

	computeTangents() {

		const index = this.index;
		const attributes = this.attributes;

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( index === null ||
			 attributes.position === undefined ||
			 attributes.normal === undefined ||
			 attributes.uv === undefined ) {

			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
			return;

		}

		const positionAttribute = attributes.position;
		const normalAttribute = attributes.normal;
		const uvAttribute = attributes.uv;

		if ( this.hasAttribute( 'tangent' ) === false ) {

			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );

		}

		const tangentAttribute = this.getAttribute( 'tangent' );

		const tan1 = [], tan2 = [];

		for ( let i = 0; i < positionAttribute.count; i ++ ) {

			tan1[ i ] = new Vector3();
			tan2[ i ] = new Vector3();

		}

		const vA = new Vector3(),
			vB = new Vector3(),
			vC = new Vector3(),

			uvA = new Vector2(),
			uvB = new Vector2(),
			uvC = new Vector2(),

			sdir = new Vector3(),
			tdir = new Vector3();

		function handleTriangle( a, b, c ) {

			vA.fromBufferAttribute( positionAttribute, a );
			vB.fromBufferAttribute( positionAttribute, b );
			vC.fromBufferAttribute( positionAttribute, c );

			uvA.fromBufferAttribute( uvAttribute, a );
			uvB.fromBufferAttribute( uvAttribute, b );
			uvC.fromBufferAttribute( uvAttribute, c );

			vB.sub( vA );
			vC.sub( vA );

			uvB.sub( uvA );
			uvC.sub( uvA );

			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

			// silently ignore degenerate uv triangles having coincident or colinear vertices

			if ( ! isFinite( r ) ) return;

			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		let groups = this.groups;

		if ( groups.length === 0 ) {

			groups = [ {
				start: 0,
				count: index.count
			} ];

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleTriangle(
					index.getX( j + 0 ),
					index.getX( j + 1 ),
					index.getX( j + 2 )
				);

			}

		}

		const tmp = new Vector3(), tmp2 = new Vector3();
		const n = new Vector3(), n2 = new Vector3();

		function handleVertex( v ) {

			n.fromBufferAttribute( normalAttribute, v );
			n2.copy( n );

			const t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			const test = tmp2.dot( tan2[ v ] );
			const w = ( test < 0.0 ) ? - 1.0 : 1.0;

			tangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleVertex( index.getX( j + 0 ) );
				handleVertex( index.getX( j + 1 ) );
				handleVertex( index.getX( j + 2 ) );

			}

		}

	}

	computeVertexNormals() {

		const index = this.index;
		const positionAttribute = this.getAttribute( 'position' );

		if ( positionAttribute !== undefined ) {

			let normalAttribute = this.getAttribute( 'normal' );

			if ( normalAttribute === undefined ) {

				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
				this.setAttribute( 'normal', normalAttribute );

			} else {

				// reset existing normals to zero

				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

					normalAttribute.setXYZ( i, 0, 0, 0 );

				}

			}

			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
			const cb = new Vector3(), ab = new Vector3();

			// indexed elements

			if ( index ) {

				for ( let i = 0, il = index.count; i < il; i += 3 ) {

					const vA = index.getX( i + 0 );
					const vB = index.getX( i + 1 );
					const vC = index.getX( i + 2 );

					pA.fromBufferAttribute( positionAttribute, vA );
					pB.fromBufferAttribute( positionAttribute, vB );
					pC.fromBufferAttribute( positionAttribute, vC );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					nA.fromBufferAttribute( normalAttribute, vA );
					nB.fromBufferAttribute( normalAttribute, vB );
					nC.fromBufferAttribute( normalAttribute, vC );

					nA.add( cb );
					nB.add( cb );
					nC.add( cb );

					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

					pA.fromBufferAttribute( positionAttribute, i + 0 );
					pB.fromBufferAttribute( positionAttribute, i + 1 );
					pC.fromBufferAttribute( positionAttribute, i + 2 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

				}

			}

			this.normalizeNormals();

			normalAttribute.needsUpdate = true;

		}

	}

	normalizeNormals() {

		const normals = this.attributes.normal;

		for ( let i = 0, il = normals.count; i < il; i ++ ) {

			_vector$8.fromBufferAttribute( normals, i );

			_vector$8.normalize();

			normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

		}

	}

	toNonIndexed() {

		function convertBufferAttribute( attribute, indices ) {

			const array = attribute.array;
			const itemSize = attribute.itemSize;
			const normalized = attribute.normalized;

			const array2 = new array.constructor( indices.length * itemSize );

			let index = 0, index2 = 0;

			for ( let i = 0, l = indices.length; i < l; i ++ ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					index = indices[ i ] * attribute.data.stride + attribute.offset;

				} else {

					index = indices[ i ] * itemSize;

				}

				for ( let j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			return new BufferAttribute( array2, itemSize, normalized );

		}

		//

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
			return this;

		}

		const geometry2 = new BufferGeometry();

		const indices = this.index.array;
		const attributes = this.attributes;

		// attributes

		for ( const name in attributes ) {

			const attribute = attributes[ name ];

			const newAttribute = convertBufferAttribute( attribute, indices );

			geometry2.setAttribute( name, newAttribute );

		}

		// morph attributes

		const morphAttributes = this.morphAttributes;

		for ( const name in morphAttributes ) {

			const morphArray = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				const attribute = morphAttribute[ i ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				morphArray.push( newAttribute );

			}

			geometry2.morphAttributes[ name ] = morphArray;

		}

		geometry2.morphTargetsRelative = this.morphTargetsRelative;

		// groups

		const groups = this.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			geometry2.addGroup( group.start, group.count, group.materialIndex );

		}

		return geometry2;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.6,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		if ( this.parameters !== undefined ) {

			const parameters = this.parameters;

			for ( const key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		// for simplicity the code assumes attributes are not shared across geometries, see #15811

		data.data = { attributes: {} };

		const index = this.index;

		if ( index !== null ) {

			data.data.index = {
				type: index.array.constructor.name,
				array: Array.prototype.slice.call( index.array )
			};

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			data.data.attributes[ key ] = attribute.toJSON( data.data );

		}

		const morphAttributes = {};
		let hasMorphAttributes = false;

		for ( const key in this.morphAttributes ) {

			const attributeArray = this.morphAttributes[ key ];

			const array = [];

			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

				const attribute = attributeArray[ i ];

				array.push( attribute.toJSON( data.data ) );

			}

			if ( array.length > 0 ) {

				morphAttributes[ key ] = array;

				hasMorphAttributes = true;

			}

		}

		if ( hasMorphAttributes ) {

			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;

		}

		const groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		const boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// used for storing cloned, shared data

		const data = {};

		// name

		this.name = source.name;

		// index

		const index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone( data ) );

		}

		// attributes

		const attributes = source.attributes;

		for ( const name in attributes ) {

			const attribute = attributes[ name ];
			this.setAttribute( name, attribute.clone( data ) );

		}

		// morph attributes

		const morphAttributes = source.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone( data ) );

			}

			this.morphAttributes[ name ] = array;

		}

		this.morphTargetsRelative = source.morphTargetsRelative;

		// groups

		const groups = source.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		const boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		const boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

const _inverseMatrix$3 = /*@__PURE__*/ new Matrix4();
const _ray$3 = /*@__PURE__*/ new Ray();
const _sphere$6 = /*@__PURE__*/ new Sphere();
const _sphereHitAt = /*@__PURE__*/ new Vector3();

const _vA$1 = /*@__PURE__*/ new Vector3();
const _vB$1 = /*@__PURE__*/ new Vector3();
const _vC$1 = /*@__PURE__*/ new Vector3();

const _tempA = /*@__PURE__*/ new Vector3();
const _morphA = /*@__PURE__*/ new Vector3();

const _uvA$1 = /*@__PURE__*/ new Vector2();
const _uvB$1 = /*@__PURE__*/ new Vector2();
const _uvC$1 = /*@__PURE__*/ new Vector2();

const _normalA = /*@__PURE__*/ new Vector3();
const _normalB = /*@__PURE__*/ new Vector3();
const _normalC = /*@__PURE__*/ new Vector3();

const _intersectionPoint = /*@__PURE__*/ new Vector3();
const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

class Mesh extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

		super();

		this.isMesh = true;

		this.type = 'Mesh';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.morphTargetInfluences !== undefined ) {

			this.morphTargetInfluences = source.morphTargetInfluences.slice();

		}

		if ( source.morphTargetDictionary !== undefined ) {

			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		}

		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
		this.geometry = source.geometry;

		return this;

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

	getVertexPosition( index, target ) {

		const geometry = this.geometry;
		const position = geometry.attributes.position;
		const morphPosition = geometry.morphAttributes.position;
		const morphTargetsRelative = geometry.morphTargetsRelative;

		target.fromBufferAttribute( position, index );

		const morphInfluences = this.morphTargetInfluences;

		if ( morphPosition && morphInfluences ) {

			_morphA.set( 0, 0, 0 );

			for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

				const influence = morphInfluences[ i ];
				const morphAttribute = morphPosition[ i ];

				if ( influence === 0 ) continue;

				_tempA.fromBufferAttribute( morphAttribute, index );

				if ( morphTargetsRelative ) {

					_morphA.addScaledVector( _tempA, influence );

				} else {

					_morphA.addScaledVector( _tempA.sub( target ), influence );

				}

			}

			target.add( _morphA );

		}

		return target;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const material = this.material;
		const matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// test with bounding sphere in world space

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$6.copy( geometry.boundingSphere );
		_sphere$6.applyMatrix4( matrixWorld );

		// check distance from ray origin to bounding sphere

		_ray$3.copy( raycaster.ray ).recast( raycaster.near );

		if ( _sphere$6.containsPoint( _ray$3.origin ) === false ) {

			if ( _ray$3.intersectSphere( _sphere$6, _sphereHitAt ) === null ) return;

			if ( _ray$3.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;

		}

		// convert ray to local space of mesh

		_inverseMatrix$3.copy( matrixWorld ).invert();
		_ray$3.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$3 );

		// test with bounding box in local space

		if ( geometry.boundingBox !== null ) {

			if ( _ray$3.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		// test for intersections with geometry

		this._computeIntersections( raycaster, intersects, _ray$3 );

	}

	_computeIntersections( raycaster, intersects, rayLocalSpace ) {

		let intersection;

		const geometry = this.geometry;
		const material = this.material;

		const index = geometry.index;
		const position = geometry.attributes.position;
		const uv = geometry.attributes.uv;
		const uv1 = geometry.attributes.uv1;
		const normal = geometry.attributes.normal;
		const groups = geometry.groups;
		const drawRange = geometry.drawRange;

		if ( index !== null ) {

			// indexed buffer geometry

			if ( Array.isArray( material ) ) {

				for ( let i = 0, il = groups.length; i < il; i ++ ) {

					const group = groups[ i ];
					const groupMaterial = material[ group.materialIndex ];

					const start = Math.max( group.start, drawRange.start );
					const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

					for ( let j = start, jl = end; j < jl; j += 3 ) {

						const a = index.getX( j );
						const b = index.getX( j + 1 );
						const c = index.getX( j + 2 );

						intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push( intersection );

						}

					}

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i += 3 ) {

					const a = index.getX( i );
					const b = index.getX( i + 1 );
					const c = index.getX( i + 2 );

					intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
						intersects.push( intersection );

					}

				}

			}

		} else if ( position !== undefined ) {

			// non-indexed buffer geometry

			if ( Array.isArray( material ) ) {

				for ( let i = 0, il = groups.length; i < il; i ++ ) {

					const group = groups[ i ];
					const groupMaterial = material[ group.materialIndex ];

					const start = Math.max( group.start, drawRange.start );
					const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

					for ( let j = start, jl = end; j < jl; j += 3 ) {

						const a = j;
						const b = j + 1;
						const c = j + 2;

						intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push( intersection );

						}

					}

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i += 3 ) {

					const a = i;
					const b = i + 1;
					const c = i + 2;

					intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
						intersects.push( intersection );

					}

				}

			}

		}

	}

}

function checkIntersection$1( object, material, raycaster, ray, pA, pB, pC, point ) {

	let intersect;

	if ( material.side === BackSide ) {

		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	} else {

		intersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );

	}

	if ( intersect === null ) return null;

	_intersectionPointWorld.copy( point );
	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

	if ( distance < raycaster.near || distance > raycaster.far ) return null;

	return {
		distance: distance,
		point: _intersectionPointWorld.clone(),
		object: object
	};

}

function checkGeometryIntersection( object, material, raycaster, ray, uv, uv1, normal, a, b, c ) {

	object.getVertexPosition( a, _vA$1 );
	object.getVertexPosition( b, _vB$1 );
	object.getVertexPosition( c, _vC$1 );

	const intersection = checkIntersection$1( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

	if ( intersection ) {

		if ( uv ) {

			_uvA$1.fromBufferAttribute( uv, a );
			_uvB$1.fromBufferAttribute( uv, b );
			_uvC$1.fromBufferAttribute( uv, c );

			intersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		}

		if ( uv1 ) {

			_uvA$1.fromBufferAttribute( uv1, a );
			_uvB$1.fromBufferAttribute( uv1, b );
			_uvC$1.fromBufferAttribute( uv1, c );

			intersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		}

		if ( normal ) {

			_normalA.fromBufferAttribute( normal, a );
			_normalB.fromBufferAttribute( normal, b );
			_normalC.fromBufferAttribute( normal, c );

			intersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector3() );

			if ( intersection.normal.dot( ray.direction ) > 0 ) {

				intersection.normal.multiplyScalar( - 1 );

			}

		}

		const face = {
			a: a,
			b: b,
			c: c,
			normal: new Vector3(),
			materialIndex: 0
		};

		Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

		intersection.face = face;

	}

	return intersection;

}

class BoxGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

		super();

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		const scope = this;

		// segments

		widthSegments = Math.floor( widthSegments );
		heightSegments = Math.floor( heightSegments );
		depthSegments = Math.floor( depthSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let numberOfVertices = 0;
		let groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			const segmentWidth = width / gridX;
			const segmentHeight = height / gridY;

			const widthHalf = width / 2;
			const heightHalf = height / 2;
			const depthHalf = depth / 2;

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			let vertexCounter = 0;
			let groupCount = 0;

			const vector = new Vector3();

			// generate vertices, normals and uvs

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segmentHeight - heightHalf;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = numberOfVertices + ix + gridX1 * iy;
					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

	}

}

/**
 * Uniform Utilities
 */

function cloneUniforms( src ) {

	const dst = {};

	for ( const u in src ) {

		dst[ u ] = {};

		for ( const p in src[ u ] ) {

			const property = src[ u ][ p ];

			if ( property && ( property.isColor ||
				property.isMatrix3 || property.isMatrix4 ||
				property.isVector2 || property.isVector3 || property.isVector4 ||
				property.isTexture || property.isQuaternion ) ) {

				if ( property.isRenderTargetTexture ) {

					console.warn( 'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().' );
					dst[ u ][ p ] = null;

				} else {

					dst[ u ][ p ] = property.clone();

				}

			} else if ( Array.isArray( property ) ) {

				dst[ u ][ p ] = property.slice();

			} else {

				dst[ u ][ p ] = property;

			}

		}

	}

	return dst;

}

function mergeUniforms( uniforms ) {

	const merged = {};

	for ( let u = 0; u < uniforms.length; u ++ ) {

		const tmp = cloneUniforms( uniforms[ u ] );

		for ( const p in tmp ) {

			merged[ p ] = tmp[ p ];

		}

	}

	return merged;

}

function cloneUniformsGroups( src ) {

	const dst = [];

	for ( let u = 0; u < src.length; u ++ ) {

		dst.push( src[ u ].clone() );

	}

	return dst;

}

function getUnlitUniformColorSpace( renderer ) {

	const currentRenderTarget = renderer.getRenderTarget();

	if ( currentRenderTarget === null ) {

		// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398
		return renderer.outputColorSpace;

	}

	// https://github.com/mrdoob/three.js/issues/27868
	if ( currentRenderTarget.isXRRenderTarget === true ) {

		return currentRenderTarget.texture.colorSpace;

	}

	return ColorManagement.workingColorSpace;

}

// Legacy

const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

class ShaderMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isShaderMaterial = true;

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};
		this.uniformsGroups = [];

		this.vertexShader = default_vertex;
		this.fragmentShader = default_fragment;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.forceSinglePass = true;

		this.extensions = {
			clipCullDistance: false, // set to use vertex shader clipping
			multiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv1': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;

		this.glslVersion = null;

		if ( parameters !== undefined ) {

			this.setValues( parameters );

		}

	}

	copy( source ) {

		super.copy( source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = cloneUniforms( source.uniforms );
		this.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );

		this.defines = Object.assign( {}, source.defines );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.fog = source.fog;
		this.lights = source.lights;
		this.clipping = source.clipping;

		this.extensions = Object.assign( {}, source.extensions );

		this.glslVersion = source.glslVersion;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.glslVersion = this.glslVersion;
		data.uniforms = {};

		for ( const name in this.uniforms ) {

			const uniform = this.uniforms[ name ];
			const value = uniform.value;

			if ( value && value.isTexture ) {

				data.uniforms[ name ] = {
					type: 't',
					value: value.toJSON( meta ).uuid
				};

			} else if ( value && value.isColor ) {

				data.uniforms[ name ] = {
					type: 'c',
					value: value.getHex()
				};

			} else if ( value && value.isVector2 ) {

				data.uniforms[ name ] = {
					type: 'v2',
					value: value.toArray()
				};

			} else if ( value && value.isVector3 ) {

				data.uniforms[ name ] = {
					type: 'v3',
					value: value.toArray()
				};

			} else if ( value && value.isVector4 ) {

				data.uniforms[ name ] = {
					type: 'v4',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix3 ) {

				data.uniforms[ name ] = {
					type: 'm3',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix4 ) {

				data.uniforms[ name ] = {
					type: 'm4',
					value: value.toArray()
				};

			} else {

				data.uniforms[ name ] = {
					value: value
				};

				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

			}

		}

		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		data.lights = this.lights;
		data.clipping = this.clipping;

		const extensions = {};

		for ( const key in this.extensions ) {

			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

		}

		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

		return data;

	}

}

class Camera extends Object3D {

	constructor() {

		super();

		this.isCamera = true;

		this.type = 'Camera';

		this.matrixWorldInverse = new Matrix4();

		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();

		this.coordinateSystem = WebGLCoordinateSystem;

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );

		this.projectionMatrix.copy( source.projectionMatrix );
		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

		this.coordinateSystem = source.coordinateSystem;

		return this;

	}

	getWorldDirection( target ) {

		return super.getWorldDirection( target ).negate();

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		super.updateWorldMatrix( updateParents, updateChildren );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _v3$1 = /*@__PURE__*/ new Vector3();
const _minTarget = /*@__PURE__*/ new Vector2();
const _maxTarget = /*@__PURE__*/ new Vector2();


class PerspectiveCamera extends Camera {

	constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

		super();

		this.isPerspectiveCamera = true;

		this.type = 'PerspectiveCamera';

		this.fov = fov;
		this.zoom = 1;

		this.near = near;
		this.far = far;
		this.focus = 10;

		this.aspect = aspect;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	}

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength( focalLength ) {

		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	}

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength() {

		const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	}

	getEffectiveFOV() {

		return RAD2DEG * 2 * Math.atan(
			Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

	}

	getFilmWidth() {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	}

	getFilmHeight() {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	}

	/**
	 * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
	 * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
	 */
	getViewBounds( distance, minTarget, maxTarget ) {

		_v3$1.set( - 1, - 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

		minTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );

		_v3$1.set( 1, 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

		maxTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );

	}

	/**
	 * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
	 * Copies the result into the target Vector2, where x is width and y is height.
	 */
	getViewSize( distance, target ) {

		this.getViewBounds( distance, _minTarget, _maxTarget );

		return target.subVectors( _maxTarget, _minTarget );

	}

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	updateProjectionMatrix() {

		const near = this.near;
		let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
		let height = 2 * top;
		let width = this.aspect * height;
		let left = - 0.5 * width;
		const view = this.view;

		if ( this.view !== null && this.view.enabled ) {

			const fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		const skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far, this.coordinateSystem );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

}

const fov = - 90; // negative fov is not an error
const aspect = 1;

class CubeCamera extends Object3D {

	constructor( near, far, renderTarget ) {

		super();

		this.type = 'CubeCamera';

		this.renderTarget = renderTarget;
		this.coordinateSystem = null;
		this.activeMipmapLevel = 0;

		const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.layers = this.layers;
		this.add( cameraPX );

		const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.layers = this.layers;
		this.add( cameraNX );

		const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.layers = this.layers;
		this.add( cameraPY );

		const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.layers = this.layers;
		this.add( cameraNY );

		const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.layers = this.layers;
		this.add( cameraPZ );

		const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.layers = this.layers;
		this.add( cameraNZ );

	}

	updateCoordinateSystem() {

		const coordinateSystem = this.coordinateSystem;

		const cameras = this.children.concat();

		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = cameras;

		for ( const camera of cameras ) this.remove( camera );

		if ( coordinateSystem === WebGLCoordinateSystem ) {

			cameraPX.up.set( 0, 1, 0 );
			cameraPX.lookAt( 1, 0, 0 );

			cameraNX.up.set( 0, 1, 0 );
			cameraNX.lookAt( - 1, 0, 0 );

			cameraPY.up.set( 0, 0, - 1 );
			cameraPY.lookAt( 0, 1, 0 );

			cameraNY.up.set( 0, 0, 1 );
			cameraNY.lookAt( 0, - 1, 0 );

			cameraPZ.up.set( 0, 1, 0 );
			cameraPZ.lookAt( 0, 0, 1 );

			cameraNZ.up.set( 0, 1, 0 );
			cameraNZ.lookAt( 0, 0, - 1 );

		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

			cameraPX.up.set( 0, - 1, 0 );
			cameraPX.lookAt( - 1, 0, 0 );

			cameraNX.up.set( 0, - 1, 0 );
			cameraNX.lookAt( 1, 0, 0 );

			cameraPY.up.set( 0, 0, 1 );
			cameraPY.lookAt( 0, 1, 0 );

			cameraNY.up.set( 0, 0, - 1 );
			cameraNY.lookAt( 0, - 1, 0 );

			cameraPZ.up.set( 0, - 1, 0 );
			cameraPZ.lookAt( 0, 0, 1 );

			cameraNZ.up.set( 0, - 1, 0 );
			cameraNZ.lookAt( 0, 0, - 1 );

		} else {

			throw new Error( 'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem );

		}

		for ( const camera of cameras ) {

			this.add( camera );

			camera.updateMatrixWorld();

		}

	}

	update( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		const { renderTarget, activeMipmapLevel } = this;

		if ( this.coordinateSystem !== renderer.coordinateSystem ) {

			this.coordinateSystem = renderer.coordinateSystem;

			this.updateCoordinateSystem();

		}

		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

		const currentRenderTarget = renderer.getRenderTarget();
		const currentActiveCubeFace = renderer.getActiveCubeFace();
		const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();

		const currentXrEnabled = renderer.xr.enabled;

		renderer.xr.enabled = false;

		const generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderer.setRenderTarget( renderTarget, 0, activeMipmapLevel );
		renderer.render( scene, cameraPX );

		renderer.setRenderTarget( renderTarget, 1, activeMipmapLevel );
		renderer.render( scene, cameraNX );

		renderer.setRenderTarget( renderTarget, 2, activeMipmapLevel );
		renderer.render( scene, cameraPY );

		renderer.setRenderTarget( renderTarget, 3, activeMipmapLevel );
		renderer.render( scene, cameraNY );

		renderer.setRenderTarget( renderTarget, 4, activeMipmapLevel );
		renderer.render( scene, cameraPZ );

		// mipmaps are generated during the last call of render()
		// at this point, all sides of the cube render target are defined

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderer.setRenderTarget( renderTarget, 5, activeMipmapLevel );
		renderer.render( scene, cameraNZ );

		renderer.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );

		renderer.xr.enabled = currentXrEnabled;

		renderTarget.texture.needsPMREMUpdate = true;

	}

}

class CubeTexture extends Texture {

	constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace ) {

		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

		super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

		this.isCubeTexture = true;

		this.flipY = false;

	}

	get images() {

		return this.image;

	}

	set images( value ) {

		this.image = value;

	}

}

class WebGLCubeRenderTarget extends WebGLRenderTarget {

	constructor( size = 1, options = {} ) {

		super( size, size, options );

		this.isWebGLCubeRenderTarget = true;

		const image = { width: size, height: size, depth: 1 };
		const images = [ image, image, image, image, image, image ];

		this.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );

		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
		// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
		// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

		this.texture.isRenderTargetTexture = true;

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

	}

	fromEquirectangularTexture( renderer, texture ) {

		this.texture.type = texture.type;
		this.texture.colorSpace = texture.colorSpace;

		this.texture.generateMipmaps = texture.generateMipmaps;
		this.texture.minFilter = texture.minFilter;
		this.texture.magFilter = texture.magFilter;

		const shader = {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
		};

		const geometry = new BoxGeometry( 5, 5, 5 );

		const material = new ShaderMaterial( {

			name: 'CubemapFromEquirect',

			uniforms: cloneUniforms( shader.uniforms ),
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			side: BackSide,
			blending: NoBlending

		} );

		material.uniforms.tEquirect.value = texture;

		const mesh = new Mesh( geometry, material );

		const currentMinFilter = texture.minFilter;

		// Avoid blurred poles
		if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

		const camera = new CubeCamera( 1, 10, this );
		camera.update( renderer, mesh );

		texture.minFilter = currentMinFilter;

		mesh.geometry.dispose();
		mesh.material.dispose();

		return this;

	}

	clear( renderer, color, depth, stencil ) {

		const currentRenderTarget = renderer.getRenderTarget();

		for ( let i = 0; i < 6; i ++ ) {

			renderer.setRenderTarget( this, i );

			renderer.clear( color, depth, stencil );

		}

		renderer.setRenderTarget( currentRenderTarget );

	}

}

const _vector1 = /*@__PURE__*/ new Vector3();
const _vector2 = /*@__PURE__*/ new Vector3();
const _normalMatrix = /*@__PURE__*/ new Matrix3();

class Plane {

	constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

		this.isPlane = true;

		// normal is assumed to be normalized

		this.normal = normal;
		this.constant = constant;

	}

	set( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	}

	setComponents( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	}

	setFromNormalAndCoplanarPoint( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );

		return this;

	}

	setFromCoplanarPoints( a, b, c ) {

		const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		this.setFromNormalAndCoplanarPoint( normal, a );

		return this;

	}

	copy( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	}

	normalize() {

		// Note: will lead to a divide by zero if the plane is invalid.

		const inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	}

	negate() {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	}

	distanceToPoint( point ) {

		return this.normal.dot( point ) + this.constant;

	}

	distanceToSphere( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	}

	projectPoint( point, target ) {

		return target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );

	}

	intersectLine( line, target ) {

		const direction = line.delta( _vector1 );

		const denominator = this.normal.dot( direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( this.distanceToPoint( line.start ) === 0 ) {

				return target.copy( line.start );

			}

			// Unsure if this is the correct method to handle this case.
			return null;

		}

		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

		if ( t < 0 || t > 1 ) {

			return null;

		}

		return target.copy( line.start ).addScaledVector( direction, t );

	}

	intersectsLine( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		const startSign = this.distanceToPoint( line.start );
		const endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	}

	intersectsBox( box ) {

		return box.intersectsPlane( this );

	}

	intersectsSphere( sphere ) {

		return sphere.intersectsPlane( this );

	}

	coplanarPoint( target ) {

		return target.copy( this.normal ).multiplyScalar( - this.constant );

	}

	applyMatrix4( matrix, optionalNormalMatrix ) {

		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

		this.constant = - referencePoint.dot( normal );

		return this;

	}

	translate( offset ) {

		this.constant -= offset.dot( this.normal );

		return this;

	}

	equals( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _sphere$5 = /*@__PURE__*/ new Sphere();
const _vector$7 = /*@__PURE__*/ new Vector3();

class Frustum {

	constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

		this.planes = [ p0, p1, p2, p3, p4, p5 ];

	}

	set( p0, p1, p2, p3, p4, p5 ) {

		const planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	}

	copy( frustum ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	}

	setFromProjectionMatrix( m, coordinateSystem = WebGLCoordinateSystem ) {

		const planes = this.planes;
		const me = m.elements;
		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();

		if ( coordinateSystem === WebGLCoordinateSystem ) {

			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

			planes[ 5 ].setComponents( me2, me6, me10, me14 ).normalize();

		} else {

			throw new Error( 'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem );

		}

		return this;

	}

	intersectsObject( object ) {

		if ( object.boundingSphere !== undefined ) {

			if ( object.boundingSphere === null ) object.computeBoundingSphere();

			_sphere$5.copy( object.boundingSphere ).applyMatrix4( object.matrixWorld );

		} else {

			const geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$5.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

		}

		return this.intersectsSphere( _sphere$5 );

	}

	intersectsSprite( sprite ) {

		_sphere$5.center.set( 0, 0, 0 );
		_sphere$5.radius = 0.7071067811865476;
		_sphere$5.applyMatrix4( sprite.matrixWorld );

		return this.intersectsSphere( _sphere$5 );

	}

	intersectsSphere( sphere ) {

		const planes = this.planes;
		const center = sphere.center;
		const negRadius = - sphere.radius;

		for ( let i = 0; i < 6; i ++ ) {

			const distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	}

	intersectsBox( box ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			const plane = planes[ i ];

			// corner at max distance

			_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

			if ( plane.distanceToPoint( _vector$7 ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	containsPoint( point ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

function WebGLAnimation() {

	let context = null;
	let isAnimating = false;
	let animationLoop = null;
	let requestId = null;

	function onAnimationFrame( time, frame ) {

		animationLoop( time, frame );

		requestId = context.requestAnimationFrame( onAnimationFrame );

	}

	return {

		start: function () {

			if ( isAnimating === true ) return;
			if ( animationLoop === null ) return;

			requestId = context.requestAnimationFrame( onAnimationFrame );

			isAnimating = true;

		},

		stop: function () {

			context.cancelAnimationFrame( requestId );

			isAnimating = false;

		},

		setAnimationLoop: function ( callback ) {

			animationLoop = callback;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

}

function WebGLAttributes( gl ) {

	const buffers = new WeakMap();

	function createBuffer( attribute, bufferType ) {

		const array = attribute.array;
		const usage = attribute.usage;
		const size = array.byteLength;

		const buffer = gl.createBuffer();

		gl.bindBuffer( bufferType, buffer );
		gl.bufferData( bufferType, array, usage );

		attribute.onUploadCallback();

		let type;

		if ( array instanceof Float32Array ) {

			type = gl.FLOAT;

		} else if ( array instanceof Uint16Array ) {

			if ( attribute.isFloat16BufferAttribute ) {

				type = gl.HALF_FLOAT;

			} else {

				type = gl.UNSIGNED_SHORT;

			}

		} else if ( array instanceof Int16Array ) {

			type = gl.SHORT;

		} else if ( array instanceof Uint32Array ) {

			type = gl.UNSIGNED_INT;

		} else if ( array instanceof Int32Array ) {

			type = gl.INT;

		} else if ( array instanceof Int8Array ) {

			type = gl.BYTE;

		} else if ( array instanceof Uint8Array ) {

			type = gl.UNSIGNED_BYTE;

		} else if ( array instanceof Uint8ClampedArray ) {

			type = gl.UNSIGNED_BYTE;

		} else {

			throw new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );

		}

		return {
			buffer: buffer,
			type: type,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version,
			size: size
		};

	}

	function updateBuffer( buffer, attribute, bufferType ) {

		const array = attribute.array;
		const updateRange = attribute._updateRange; // @deprecated, r159
		const updateRanges = attribute.updateRanges;

		gl.bindBuffer( bufferType, buffer );

		if ( updateRange.count === - 1 && updateRanges.length === 0 ) {

			// Not using update ranges
			gl.bufferSubData( bufferType, 0, array );

		}

		if ( updateRanges.length !== 0 ) {

			for ( let i = 0, l = updateRanges.length; i < l; i ++ ) {

				const range = updateRanges[ i ];

				gl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,
					array, range.start, range.count );

			}

			attribute.clearUpdateRanges();

		}

		// @deprecated, r159
		if ( updateRange.count !== - 1 ) {

			gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
				array, updateRange.offset, updateRange.count );

			updateRange.count = - 1; // reset range

		}

		attribute.onUploadCallback();

	}

	//

	function get( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return buffers.get( attribute );

	}

	function remove( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data ) {

			gl.deleteBuffer( data.buffer );

			buffers.delete( attribute );

		}

	}

	function update( attribute, bufferType ) {

		if ( attribute.isGLBufferAttribute ) {

			const cached = buffers.get( attribute );

			if ( ! cached || cached.version < attribute.version ) {

				buffers.set( attribute, {
					buffer: attribute.buffer,
					type: attribute.type,
					bytesPerElement: attribute.elementSize,
					version: attribute.version
				} );

			}

			return;

		}

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data === undefined ) {

			buffers.set( attribute, createBuffer( attribute, bufferType ) );

		} else if ( data.version < attribute.version ) {

			if ( data.size !== attribute.array.byteLength ) {

				throw new Error( 'THREE.WebGLAttributes: The size of the buffer attribute\'s array buffer does not match the original size. Resizing buffer attributes is not supported.' );

			}

			updateBuffer( data.buffer, attribute, bufferType );

			data.version = attribute.version;

		}

	}

	return {

		get: get,
		remove: remove,
		update: update

	};

}

class PlaneGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

		super();

		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		const width_half = width / 2;
		const height_half = height / 2;

		const gridX = Math.floor( widthSegments );
		const gridY = Math.floor( heightSegments );

		const gridX1 = gridX + 1;
		const gridY1 = gridY + 1;

		const segment_width = width / gridX;
		const segment_height = height / gridY;

		//

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		for ( let iy = 0; iy < gridY1; iy ++ ) {

			const y = iy * segment_height - height_half;

			for ( let ix = 0; ix < gridX1; ix ++ ) {

				const x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		for ( let iy = 0; iy < gridY; iy ++ ) {

			for ( let ix = 0; ix < gridX; ix ++ ) {

				const a = ix + gridX1 * iy;
				const b = ix + gridX1 * ( iy + 1 );
				const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				const d = ( ix + 1 ) + gridX1 * iy;

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

	}

}

var alphahash_fragment = "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";

var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif";

var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";

var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var alphatest_fragment = "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif";

var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";

var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";

var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

var batching_pars_vertex = "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif";

var batching_vertex = "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif";

var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif";

var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

var bsdfs = "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated";

var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";

var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif";

var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";

var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";

var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

var colorspace_pars_fragment = "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}";

var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";

var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";

var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}";

var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";

var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert";

var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";

var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif";

var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon";

var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong";

var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";

var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

var lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";

var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";

var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif";

var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";

var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

var morphinstance_vertex = "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[MORPHTARGETS_COUNT];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif";

var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";

var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";

var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t#endif\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\t#ifndef USE_INSTANCING_MORPH\n\t\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\t#endif\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";

var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";

var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;";

var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";

var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif";

var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif";

var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";

var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif";

var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";

var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";

var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}";

var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n#endif";

var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif";

var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif";

var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";

var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif";

var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";

var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";

var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";

var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

const vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

const fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

const vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

const fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

const fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

const vertex$e = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$a = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";

const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";

const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$2 = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";

const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";

const ShaderChunk = {
	alphahash_fragment: alphahash_fragment,
	alphahash_pars_fragment: alphahash_pars_fragment,
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	alphatest_pars_fragment: alphatest_pars_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	batching_pars_vertex: batching_pars_vertex,
	batching_vertex: batching_vertex,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	iridescence_fragment: iridescence_fragment,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	colorspace_fragment: colorspace_fragment,
	colorspace_pars_fragment: colorspace_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_common_pars_fragment: envmap_common_pars_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
	envmap_vertex: envmap_vertex,
	fog_vertex: fog_vertex,
	fog_pars_vertex: fog_pars_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_fragment: lights_lambert_fragment,
	lights_lambert_pars_fragment: lights_lambert_pars_fragment,
	lights_pars_begin: lights_pars_begin,
	lights_toon_fragment: lights_toon_fragment,
	lights_toon_pars_fragment: lights_toon_pars_fragment,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_fragment_begin: lights_fragment_begin,
	lights_fragment_maps: lights_fragment_maps,
	lights_fragment_end: lights_fragment_end,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphinstance_vertex: morphinstance_vertex,
	morphcolor_vertex: morphcolor_vertex,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_fragment_begin: normal_fragment_begin,
	normal_fragment_maps: normal_fragment_maps,
	normal_pars_fragment: normal_pars_fragment,
	normal_pars_vertex: normal_pars_vertex,
	normal_vertex: normal_vertex,
	normalmap_pars_fragment: normalmap_pars_fragment,
	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
	clearcoat_pars_fragment: clearcoat_pars_fragment,
	iridescence_pars_fragment: iridescence_pars_fragment,
	opaque_fragment: opaque_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	dithering_fragment: dithering_fragment,
	dithering_pars_fragment: dithering_pars_fragment,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	transmission_fragment: transmission_fragment,
	transmission_pars_fragment: transmission_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	worldpos_vertex: worldpos_vertex,

	background_vert: vertex$h,
	background_frag: fragment$h,
	backgroundCube_vert: vertex$g,
	backgroundCube_frag: fragment$g,
	cube_vert: vertex$f,
	cube_frag: fragment$f,
	depth_vert: vertex$e,
	depth_frag: fragment$e,
	distanceRGBA_vert: vertex$d,
	distanceRGBA_frag: fragment$d,
	equirect_vert: vertex$c,
	equirect_frag: fragment$c,
	linedashed_vert: vertex$b,
	linedashed_frag: fragment$b,
	meshbasic_vert: vertex$a,
	meshbasic_frag: fragment$a,
	meshlambert_vert: vertex$9,
	meshlambert_frag: fragment$9,
	meshmatcap_vert: vertex$8,
	meshmatcap_frag: fragment$8,
	meshnormal_vert: vertex$7,
	meshnormal_frag: fragment$7,
	meshphong_vert: vertex$6,
	meshphong_frag: fragment$6,
	meshphysical_vert: vertex$5,
	meshphysical_frag: fragment$5,
	meshtoon_vert: vertex$4,
	meshtoon_frag: fragment$4,
	points_vert: vertex$3,
	points_frag: fragment$3,
	shadow_vert: vertex$2,
	shadow_frag: fragment$2,
	sprite_vert: vertex$1,
	sprite_frag: fragment$1
};

/**
 * Uniforms library for shared webgl shaders
 */

const UniformsLib = {

	common: {

		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
		opacity: { value: 1.0 },

		map: { value: null },
		mapTransform: { value: /*@__PURE__*/ new Matrix3() },

		alphaMap: { value: null },
		alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },

		alphaTest: { value: 0 }

	},

	specularmap: {

		specularMap: { value: null },
		specularMapTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	envmap: {

		envMap: { value: null },
		envMapRotation: { value: /*@__PURE__*/ new Matrix3() },
		flipEnvMap: { value: - 1 },
		reflectivity: { value: 1.0 }, // basic, lambert, phong
		ior: { value: 1.5 }, // physical
		refractionRatio: { value: 0.98 }, // basic, lambert, phong

	},

	aomap: {

		aoMap: { value: null },
		aoMapIntensity: { value: 1 },
		aoMapTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	lightmap: {

		lightMap: { value: null },
		lightMapIntensity: { value: 1 },
		lightMapTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	bumpmap: {

		bumpMap: { value: null },
		bumpMapTransform: { value: /*@__PURE__*/ new Matrix3() },
		bumpScale: { value: 1 }

	},

	normalmap: {

		normalMap: { value: null },
		normalMapTransform: { value: /*@__PURE__*/ new Matrix3() },
		normalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) }

	},

	displacementmap: {

		displacementMap: { value: null },
		displacementMapTransform: { value: /*@__PURE__*/ new Matrix3() },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }

	},

	emissivemap: {

		emissiveMap: { value: null },
		emissiveMapTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	metalnessmap: {

		metalnessMap: { value: null },
		metalnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	roughnessmap: {

		roughnessMap: { value: null },
		roughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	gradientmap: {

		gradientMap: { value: null }

	},

	fog: {

		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: /*@__PURE__*/ new Color( 0xffffff ) }

	},

	lights: {

		ambientLightColor: { value: [] },

		lightProbe: { value: [] },

		directionalLights: { value: [], properties: {
			direction: {},
			color: {}
		} },

		directionalLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },

		spotLights: { value: [], properties: {
			color: {},
			position: {},
			direction: {},
			distance: {},
			coneCos: {},
			penumbraCos: {},
			decay: {}
		} },

		spotLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		spotLightMap: { value: [] },
		spotShadowMap: { value: [] },
		spotLightMatrix: { value: [] },

		pointLights: { value: [], properties: {
			color: {},
			position: {},
			decay: {},
			distance: {}
		} },

		pointLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {},
			shadowCameraNear: {},
			shadowCameraFar: {}
		} },

		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },

		hemisphereLights: { value: [], properties: {
			direction: {},
			skyColor: {},
			groundColor: {}
		} },

		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		rectAreaLights: { value: [], properties: {
			color: {},
			position: {},
			width: {},
			height: {}
		} },

		ltc_1: { value: null },
		ltc_2: { value: null }

	},

	points: {

		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		alphaMap: { value: null },
		alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },
		alphaTest: { value: 0 },
		uvTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	sprite: {

		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
		opacity: { value: 1.0 },
		center: { value: /*@__PURE__*/ new Vector2( 0.5, 0.5 ) },
		rotation: { value: 0.0 },
		map: { value: null },
		mapTransform: { value: /*@__PURE__*/ new Matrix3() },
		alphaMap: { value: null },
		alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },
		alphaTest: { value: 0 }

	}

};

const ShaderLib = {

	basic: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag

	},

	lambert: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag

	},

	phong: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
				specular: { value: /*@__PURE__*/ new Color( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag

	},

	standard: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.roughnessmap,
			UniformsLib.metalnessmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
				roughness: { value: 1.0 },
				metalness: { value: 0.0 },
				envMapIntensity: { value: 1 }
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	},

	toon: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.gradientmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshtoon_vert,
		fragmentShader: ShaderChunk.meshtoon_frag

	},

	matcap: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			{
				matcap: { value: null }
			}
		] ),

		vertexShader: ShaderChunk.meshmatcap_vert,
		fragmentShader: ShaderChunk.meshmatcap_frag

	},

	points: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.points,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag

	},

	dashed: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		] ),

		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag

	},

	depth: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap
		] ),

		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag

	},

	normal: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.meshnormal_vert,
		fragmentShader: ShaderChunk.meshnormal_frag

	},

	sprite: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.sprite,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.sprite_vert,
		fragmentShader: ShaderChunk.sprite_frag

	},

	background: {

		uniforms: {
			uvTransform: { value: /*@__PURE__*/ new Matrix3() },
			t2D: { value: null },
			backgroundIntensity: { value: 1 }
		},

		vertexShader: ShaderChunk.background_vert,
		fragmentShader: ShaderChunk.background_frag

	},

	backgroundCube: {

		uniforms: {
			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			backgroundBlurriness: { value: 0 },
			backgroundIntensity: { value: 1 },
			backgroundRotation: { value: /*@__PURE__*/ new Matrix3() }
		},

		vertexShader: ShaderChunk.backgroundCube_vert,
		fragmentShader: ShaderChunk.backgroundCube_frag

	},

	cube: {

		uniforms: {
			tCube: { value: null },
			tFlip: { value: - 1 },
			opacity: { value: 1.0 }
		},

		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag

	},

	equirect: {

		uniforms: {
			tEquirect: { value: null },
		},

		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag

	},

	distanceRGBA: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap,
			{
				referencePosition: { value: /*@__PURE__*/ new Vector3() },
				nearDistance: { value: 1 },
				farDistance: { value: 1000 }
			}
		] ),

		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag

	},

	shadow: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.lights,
			UniformsLib.fog,
			{
				color: { value: /*@__PURE__*/ new Color( 0x00000 ) },
				opacity: { value: 1.0 }
			},
		] ),

		vertexShader: ShaderChunk.shadow_vert,
		fragmentShader: ShaderChunk.shadow_frag

	}

};

ShaderLib.physical = {

	uniforms: /*@__PURE__*/ mergeUniforms( [
		ShaderLib.standard.uniforms,
		{
			clearcoat: { value: 0 },
			clearcoatMap: { value: null },
			clearcoatMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			clearcoatNormalMap: { value: null },
			clearcoatNormalMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			clearcoatNormalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) },
			clearcoatRoughness: { value: 0 },
			clearcoatRoughnessMap: { value: null },
			clearcoatRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			dispersion: { value: 0 },
			iridescence: { value: 0 },
			iridescenceMap: { value: null },
			iridescenceMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			iridescenceIOR: { value: 1.3 },
			iridescenceThicknessMinimum: { value: 100 },
			iridescenceThicknessMaximum: { value: 400 },
			iridescenceThicknessMap: { value: null },
			iridescenceThicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			sheen: { value: 0 },
			sheenColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
			sheenColorMap: { value: null },
			sheenColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			sheenRoughness: { value: 1 },
			sheenRoughnessMap: { value: null },
			sheenRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			transmission: { value: 0 },
			transmissionMap: { value: null },
			transmissionMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			transmissionSamplerSize: { value: /*@__PURE__*/ new Vector2() },
			transmissionSamplerMap: { value: null },
			thickness: { value: 0 },
			thicknessMap: { value: null },
			thicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			attenuationDistance: { value: 0 },
			attenuationColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
			specularColor: { value: /*@__PURE__*/ new Color( 1, 1, 1 ) },
			specularColorMap: { value: null },
			specularColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			specularIntensity: { value: 1 },
			specularIntensityMap: { value: null },
			specularIntensityMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			anisotropyVector: { value: /*@__PURE__*/ new Vector2() },
			anisotropyMap: { value: null },
			anisotropyMapTransform: { value: /*@__PURE__*/ new Matrix3() },
		}
	] ),

	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag

};

const _rgb = { r: 0, b: 0, g: 0 };
const _e1$1 = /*@__PURE__*/ new Euler();
const _m1$1 = /*@__PURE__*/ new Matrix4();

function WebGLBackground( renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha ) {

	const clearColor = new Color( 0x000000 );
	let clearAlpha = alpha === true ? 0 : 1;

	let planeMesh;
	let boxMesh;

	let currentBackground = null;
	let currentBackgroundVersion = 0;
	let currentTonemapping = null;

	function getBackground( scene ) {

		let background = scene.isScene === true ? scene.background : null;

		if ( background && background.isTexture ) {

			const usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background
			background = ( usePMREM ? cubeuvmaps : cubemaps ).get( background );

		}

		return background;

	}

	function render( scene ) {

		let forceClear = false;
		const background = getBackground( scene );

		if ( background === null ) {

			setClear( clearColor, clearAlpha );

		} else if ( background && background.isColor ) {

			setClear( background, 1 );
			forceClear = true;

		}

		const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();

		if ( environmentBlendMode === 'additive' ) {

			state.buffers.color.setClear( 0, 0, 0, 1, premultipliedAlpha );

		} else if ( environmentBlendMode === 'alpha-blend' ) {

			state.buffers.color.setClear( 0, 0, 0, 0, premultipliedAlpha );

		}

		if ( renderer.autoClear || forceClear ) {

			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

		}

	}

	function addToRenderList( renderList, scene ) {

		const background = getBackground( scene );

		if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {

			if ( boxMesh === undefined ) {

				boxMesh = new Mesh(
					new BoxGeometry( 1, 1, 1 ),
					new ShaderMaterial( {
						name: 'BackgroundCubeMaterial',
						uniforms: cloneUniforms( ShaderLib.backgroundCube.uniforms ),
						vertexShader: ShaderLib.backgroundCube.vertexShader,
						fragmentShader: ShaderLib.backgroundCube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				boxMesh.geometry.deleteAttribute( 'normal' );
				boxMesh.geometry.deleteAttribute( 'uv' );

				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

					this.matrixWorld.copyPosition( camera.matrixWorld );

				};

				// add "envMap" material property so the renderer can evaluate it like for built-in materials
				Object.defineProperty( boxMesh.material, 'envMap', {

					get: function () {

						return this.uniforms.envMap.value;

					}

				} );

				objects.update( boxMesh );

			}

			_e1$1.copy( scene.backgroundRotation );

			// accommodate left-handed frame
			_e1$1.x *= - 1; _e1$1.y *= - 1; _e1$1.z *= - 1;

			if ( background.isCubeTexture && background.isRenderTargetTexture === false ) {

				// environment maps which are not cube render targets or PMREMs follow a different convention
				_e1$1.y *= - 1;
				_e1$1.z *= - 1;

			}

			boxMesh.material.uniforms.envMap.value = background;
			boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? - 1 : 1;
			boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
			boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
			boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4( _m1$1.makeRotationFromEuler( _e1$1 ) );
			boxMesh.material.toneMapped = ColorManagement.getTransfer( background.colorSpace ) !== SRGBTransfer;

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				boxMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}

			boxMesh.layers.enableAll();

			// push to the pre-sorted opaque render list
			renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

		} else if ( background && background.isTexture ) {

			if ( planeMesh === undefined ) {

				planeMesh = new Mesh(
					new PlaneGeometry( 2, 2 ),
					new ShaderMaterial( {
						name: 'BackgroundMaterial',
						uniforms: cloneUniforms( ShaderLib.background.uniforms ),
						vertexShader: ShaderLib.background.vertexShader,
						fragmentShader: ShaderLib.background.fragmentShader,
						side: FrontSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				planeMesh.geometry.deleteAttribute( 'normal' );

				// add "map" material property so the renderer can evaluate it like for built-in materials
				Object.defineProperty( planeMesh.material, 'map', {

					get: function () {

						return this.uniforms.t2D.value;

					}

				} );

				objects.update( planeMesh );

			}

			planeMesh.material.uniforms.t2D.value = background;
			planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
			planeMesh.material.toneMapped = ColorManagement.getTransfer( background.colorSpace ) !== SRGBTransfer;

			if ( background.matrixAutoUpdate === true ) {

				background.updateMatrix();

			}

			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				planeMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}

			planeMesh.layers.enableAll();

			// push to the pre-sorted opaque render list
			renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

		}

	}

	function setClear( color, alpha ) {

		color.getRGB( _rgb, getUnlitUniformColorSpace( renderer ) );

		state.buffers.color.setClear( _rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha );

	}

	return {

		getClearColor: function () {

			return clearColor;

		},
		setClearColor: function ( color, alpha = 1 ) {

			clearColor.set( color );
			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		getClearAlpha: function () {

			return clearAlpha;

		},
		setClearAlpha: function ( alpha ) {

			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		render: render,
		addToRenderList: addToRenderList

	};

}

function WebGLBindingStates( gl, attributes ) {

	const maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );

	const bindingStates = {};

	const defaultState = createBindingState( null );
	let currentState = defaultState;
	let forceUpdate = false;

	function setup( object, material, program, geometry, index ) {

		let updateBuffers = false;

		const state = getBindingState( geometry, program, material );

		if ( currentState !== state ) {

			currentState = state;
			bindVertexArrayObject( currentState.object );

		}

		updateBuffers = needsUpdate( object, geometry, program, index );

		if ( updateBuffers ) saveCache( object, geometry, program, index );

		if ( index !== null ) {

			attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

		}

		if ( updateBuffers || forceUpdate ) {

			forceUpdate = false;

			setupVertexAttributes( object, material, program, geometry );

			if ( index !== null ) {

				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, attributes.get( index ).buffer );

			}

		}

	}

	function createVertexArrayObject() {

		return gl.createVertexArray();

	}

	function bindVertexArrayObject( vao ) {

		return gl.bindVertexArray( vao );

	}

	function deleteVertexArrayObject( vao ) {

		return gl.deleteVertexArray( vao );

	}

	function getBindingState( geometry, program, material ) {

		const wireframe = ( material.wireframe === true );

		let programMap = bindingStates[ geometry.id ];

		if ( programMap === undefined ) {

			programMap = {};
			bindingStates[ geometry.id ] = programMap;

		}

		let stateMap = programMap[ program.id ];

		if ( stateMap === undefined ) {

			stateMap = {};
			programMap[ program.id ] = stateMap;

		}

		let state = stateMap[ wireframe ];

		if ( state === undefined ) {

			state = createBindingState( createVertexArrayObject() );
			stateMap[ wireframe ] = state;

		}

		return state;

	}

	function createBindingState( vao ) {

		const newAttributes = [];
		const enabledAttributes = [];
		const attributeDivisors = [];

		for ( let i = 0; i < maxVertexAttributes; i ++ ) {

			newAttributes[ i ] = 0;
			enabledAttributes[ i ] = 0;
			attributeDivisors[ i ] = 0;

		}

		return {

			// for backward compatibility on non-VAO support browser
			geometry: null,
			program: null,
			wireframe: false,

			newAttributes: newAttributes,
			enabledAttributes: enabledAttributes,
			attributeDivisors: attributeDivisors,
			object: vao,
			attributes: {},
			index: null

		};

	}

	function needsUpdate( object, geometry, program, index ) {

		const cachedAttributes = currentState.attributes;
		const geometryAttributes = geometry.attributes;

		let attributesNum = 0;

		const programAttributes = program.getAttributes();

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute.location >= 0 ) {

				const cachedAttribute = cachedAttributes[ name ];
				let geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute === undefined ) {

					if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
					if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

				}

				if ( cachedAttribute === undefined ) return true;

				if ( cachedAttribute.attribute !== geometryAttribute ) return true;

				if ( geometryAttribute && cachedAttribute.data !== geometryAttribute.data ) return true;

				attributesNum ++;

			}

		}

		if ( currentState.attributesNum !== attributesNum ) return true;

		if ( currentState.index !== index ) return true;

		return false;

	}

	function saveCache( object, geometry, program, index ) {

		const cache = {};
		const attributes = geometry.attributes;
		let attributesNum = 0;

		const programAttributes = program.getAttributes();

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute.location >= 0 ) {

				let attribute = attributes[ name ];

				if ( attribute === undefined ) {

					if ( name === 'instanceMatrix' && object.instanceMatrix ) attribute = object.instanceMatrix;
					if ( name === 'instanceColor' && object.instanceColor ) attribute = object.instanceColor;

				}

				const data = {};
				data.attribute = attribute;

				if ( attribute && attribute.data ) {

					data.data = attribute.data;

				}

				cache[ name ] = data;

				attributesNum ++;

			}

		}

		currentState.attributes = cache;
		currentState.attributesNum = attributesNum;

		currentState.index = index;

	}

	function initAttributes() {

		const newAttributes = currentState.newAttributes;

		for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

			newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		enableAttributeAndDivisor( attribute, 0 );

	}

	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;
		const attributeDivisors = currentState.attributeDivisors;

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			gl.vertexAttribDivisor( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	}

	function disableUnusedAttributes() {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;

		for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	}

	function vertexAttribPointer( index, size, type, normalized, stride, offset, integer ) {

		if ( integer === true ) {

			gl.vertexAttribIPointer( index, size, type, stride, offset );

		} else {

			gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

		}

	}

	function setupVertexAttributes( object, material, program, geometry ) {

		initAttributes();

		const geometryAttributes = geometry.attributes;

		const programAttributes = program.getAttributes();

		const materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute.location >= 0 ) {

				let geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute === undefined ) {

					if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
					if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

				}

				if ( geometryAttribute !== undefined ) {

					const normalized = geometryAttribute.normalized;
					const size = geometryAttribute.itemSize;

					const attribute = attributes.get( geometryAttribute );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					const buffer = attribute.buffer;
					const type = attribute.type;
					const bytesPerElement = attribute.bytesPerElement;

					// check for integer attributes

					const integer = ( type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType );

					if ( geometryAttribute.isInterleavedBufferAttribute ) {

						const data = geometryAttribute.data;
						const stride = data.stride;
						const offset = geometryAttribute.offset;

						if ( data.isInstancedInterleavedBuffer ) {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );

							}

							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = data.meshPerAttribute * data.count;

							}

						} else {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttribute( programAttribute.location + i );

							}

						}

						gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

							vertexAttribPointer(
								programAttribute.location + i,
								size / programAttribute.locationSize,
								type,
								normalized,
								stride * bytesPerElement,
								( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement,
								integer
							);

						}

					} else {

						if ( geometryAttribute.isInstancedBufferAttribute ) {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );

							}

							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttribute( programAttribute.location + i );

							}

						}

						gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

							vertexAttribPointer(
								programAttribute.location + i,
								size / programAttribute.locationSize,
								type,
								normalized,
								size * bytesPerElement,
								( size / programAttribute.locationSize ) * i * bytesPerElement,
								integer
							);

						}

					}

				} else if ( materialDefaultAttributeValues !== undefined ) {

					const value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								gl.vertexAttrib2fv( programAttribute.location, value );
								break;

							case 3:
								gl.vertexAttrib3fv( programAttribute.location, value );
								break;

							case 4:
								gl.vertexAttrib4fv( programAttribute.location, value );
								break;

							default:
								gl.vertexAttrib1fv( programAttribute.location, value );

						}

					}

				}

			}

		}

		disableUnusedAttributes();

	}

	function dispose() {

		reset();

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			for ( const programId in programMap ) {

				const stateMap = programMap[ programId ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ programId ];

			}

			delete bindingStates[ geometryId ];

		}

	}

	function releaseStatesOfGeometry( geometry ) {

		if ( bindingStates[ geometry.id ] === undefined ) return;

		const programMap = bindingStates[ geometry.id ];

		for ( const programId in programMap ) {

			const stateMap = programMap[ programId ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ programId ];

		}

		delete bindingStates[ geometry.id ];

	}

	function releaseStatesOfProgram( program ) {

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			if ( programMap[ program.id ] === undefined ) continue;

			const stateMap = programMap[ program.id ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ program.id ];

		}

	}

	function reset() {

		resetDefaultState();
		forceUpdate = true;

		if ( currentState === defaultState ) return;

		currentState = defaultState;
		bindVertexArrayObject( currentState.object );

	}

	// for backward-compatibility

	function resetDefaultState() {

		defaultState.geometry = null;
		defaultState.program = null;
		defaultState.wireframe = false;

	}

	return {

		setup: setup,
		reset: reset,
		resetDefaultState: resetDefaultState,
		dispose: dispose,
		releaseStatesOfGeometry: releaseStatesOfGeometry,
		releaseStatesOfProgram: releaseStatesOfProgram,

		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		disableUnusedAttributes: disableUnusedAttributes

	};

}

function WebGLBufferRenderer( gl, extensions, info ) {

	let mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		gl.drawArrays( mode, start, count );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		gl.drawArraysInstanced( mode, start, count, primcount );

		info.update( count, mode, primcount );

	}

	function renderMultiDraw( starts, counts, drawCount ) {

		if ( drawCount === 0 ) return;

		const extension = extensions.get( 'WEBGL_multi_draw' );

		if ( extension === null ) {

			for ( let i = 0; i < drawCount; i ++ ) {

				this.render( starts[ i ], counts[ i ] );

			}

		} else {

			extension.multiDrawArraysWEBGL( mode, starts, 0, counts, 0, drawCount );

			let elementCount = 0;
			for ( let i = 0; i < drawCount; i ++ ) {

				elementCount += counts[ i ];

			}

			info.update( elementCount, mode, 1 );

		}

	}

	function renderMultiDrawInstances( starts, counts, drawCount, primcount ) {

		if ( drawCount === 0 ) return;

		const extension = extensions.get( 'WEBGL_multi_draw' );

		if ( extension === null ) {

			for ( let i = 0; i < starts.length; i ++ ) {

				renderInstances( starts[ i ], counts[ i ], primcount[ i ] );

			}

		} else {

			extension.multiDrawArraysInstancedWEBGL( mode, starts, 0, counts, 0, primcount, 0, drawCount );

			let elementCount = 0;
			for ( let i = 0; i < drawCount; i ++ ) {

				elementCount += counts[ i ];

			}

			for ( let i = 0; i < primcount.length; i ++ ) {

				info.update( elementCount, mode, primcount[ i ] );

			}

		}

	}

	//

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;
	this.renderMultiDraw = renderMultiDraw;
	this.renderMultiDrawInstances = renderMultiDrawInstances;

}

function WebGLCapabilities( gl, extensions, parameters, utils ) {

	let maxAnisotropy;

	function getMaxAnisotropy() {

		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			maxAnisotropy = 0;

		}

		return maxAnisotropy;

	}

	function textureFormatReadable( textureFormat ) {

		if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

			return false;

		}

		return true;

	}

	function textureTypeReadable( textureType ) {

		const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || extensions.has( 'EXT_color_buffer_float' ) );

		if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // Edge and Chrome Mac < 52 (#9513)
			textureType !== FloatType && ! halfFloatSupportedByExt ) {

			return false;

		}

		return true;

	}

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
				gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
				gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	const maxPrecision = getMaxPrecision( precision );

	if ( maxPrecision !== precision ) {

		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		precision = maxPrecision;

	}

	const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

	const maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	const maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	const maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
	const maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	const maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	const maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
	const maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
	const maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

	const vertexTextures = maxVertexTextures > 0;

	const maxSamples = gl.getParameter( gl.MAX_SAMPLES );

	return {

		isWebGL2: true, // keeping this for backwards compatibility

		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,

		textureFormatReadable: textureFormatReadable,
		textureTypeReadable: textureTypeReadable,

		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,

		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,

		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,

		vertexTextures: vertexTextures,

		maxSamples: maxSamples

	};

}

function WebGLClipping( properties ) {

	const scope = this;

	let globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false;

	const plane = new Plane(),
		viewNormalMatrix = new Matrix3(),

		uniform = { value: null, needsUpdate: false };

	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;

	this.init = function ( planes, enableLocalClipping ) {

		const enabled =
			planes.length !== 0 ||
			enableLocalClipping ||
			// enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 ||
			localClippingEnabled;

		localClippingEnabled = enableLocalClipping;

		numGlobalPlanes = planes.length;

		return enabled;

	};

	this.beginShadows = function () {

		renderingShadows = true;
		projectPlanes( null );

	};

	this.endShadows = function () {

		renderingShadows = false;

	};

	this.setGlobalState = function ( planes, camera ) {

		globalState = projectPlanes( planes, camera, 0 );

	};

	this.setState = function ( material, camera, useCache ) {

		const planes = material.clippingPlanes,
			clipIntersection = material.clipIntersection,
			clipShadows = material.clipShadows;

		const materialProperties = properties.get( material );

		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

			// there's no local clipping

			if ( renderingShadows ) {

				// there's no global clipping

				projectPlanes( null );

			} else {

				resetGlobalState();

			}

		} else {

			const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4;

			let dstArray = materialProperties.clippingState || null;

			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes( planes, camera, lGlobal, useCache );

			for ( let i = 0; i !== lGlobal; ++ i ) {

				dstArray[ i ] = globalState[ i ];

			}

			materialProperties.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;

		}


	};

	function resetGlobalState() {

		if ( uniform.value !== globalState ) {

			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;

		}

		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;

	}

	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		const nPlanes = planes !== null ? planes.length : 0;
		let dstArray = null;

		if ( nPlanes !== 0 ) {

			dstArray = uniform.value;

			if ( skipTransform !== true || dstArray === null ) {

				const flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;

				viewNormalMatrix.getNormalMatrix( viewMatrix );

				if ( dstArray === null || dstArray.length < flatSize ) {

					dstArray = new Float32Array( flatSize );

				}

				for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;

				}

			}

			uniform.value = dstArray;
			uniform.needsUpdate = true;

		}

		scope.numPlanes = nPlanes;
		scope.numIntersection = 0;

		return dstArray;

	}

}

function WebGLCubeMaps( renderer ) {

	let cubemaps = new WeakMap();

	function mapTextureMapping( texture, mapping ) {

		if ( mapping === EquirectangularReflectionMapping ) {

			texture.mapping = CubeReflectionMapping;

		} else if ( mapping === EquirectangularRefractionMapping ) {

			texture.mapping = CubeRefractionMapping;

		}

		return texture;

	}

	function get( texture ) {

		if ( texture && texture.isTexture ) {

			const mapping = texture.mapping;

			if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

				if ( cubemaps.has( texture ) ) {

					const cubemap = cubemaps.get( texture ).texture;
					return mapTextureMapping( cubemap, texture.mapping );

				} else {

					const image = texture.image;

					if ( image && image.height > 0 ) {

						const renderTarget = new WebGLCubeRenderTarget( image.height );
						renderTarget.fromEquirectangularTexture( renderer, texture );
						cubemaps.set( texture, renderTarget );

						texture.addEventListener( 'dispose', onTextureDispose );

						return mapTextureMapping( renderTarget.texture, texture.mapping );

					} else {

						// image not yet ready. try the conversion next frame

						return null;

					}

				}

			}

		}

		return texture;

	}

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		const cubemap = cubemaps.get( texture );

		if ( cubemap !== undefined ) {

			cubemaps.delete( texture );
			cubemap.dispose();

		}

	}

	function dispose() {

		cubemaps = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

class OrthographicCamera extends Camera {

	constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

		super();

		this.isOrthographicCamera = true;

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = near;
		this.far = far;

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	}

	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	updateProjectionMatrix() {

		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		const cx = ( this.right + this.left ) / 2;
		const cy = ( this.top + this.bottom ) / 2;

		let left = cx - dx;
		let right = cx + dx;
		let top = cy + dy;
		let bottom = cy - dy;

		if ( this.view !== null && this.view.enabled ) {

			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

			left += scaleW * this.view.offsetX;
			right = left + scaleW * this.view.width;
			top -= scaleH * this.view.offsetY;
			bottom = top - scaleH * this.view.height;

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far, this.coordinateSystem );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

}

const LOD_MIN = 4;

// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;

const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
const _clearColor = /*@__PURE__*/ new Color();
let _oldTarget = null;
let _oldActiveCubeFace = 0;
let _oldActiveMipmapLevel = 0;
let _oldXrEnabled = false;

// Golden Ratio
const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
const INV_PHI = 1 / PHI;

// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [
	/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ),
	/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
	/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
	/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
	/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( - 1, 1, 1 ),
	/*@__PURE__*/ new Vector3( 1, 1, 1 ) ];

/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/

class PMREMGenerator {

	constructor( renderer ) {

		this._renderer = renderer;
		this._pingPongRenderTarget = null;

		this._lodMax = 0;
		this._cubeSize = 0;
		this._lodPlanes = [];
		this._sizeLods = [];
		this._sigmas = [];

		this._blurMaterial = null;
		this._cubemapMaterial = null;
		this._equirectMaterial = null;

		this._compileMaterial( this._blurMaterial );

	}

	/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */
	fromScene( scene, sigma = 0, near = 0.1, far = 100 ) {

		_oldTarget = this._renderer.getRenderTarget();
		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
		_oldXrEnabled = this._renderer.xr.enabled;

		this._renderer.xr.enabled = false;

		this._setSize( 256 );

		const cubeUVRenderTarget = this._allocateTargets();
		cubeUVRenderTarget.depthBuffer = true;

		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );

		if ( sigma > 0 ) {

			this._blur( cubeUVRenderTarget, 0, 0, sigma );

		}

		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * or HDR. The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 * The smallest supported equirectangular image size is 64 x 32.
	 */
	fromEquirectangular( equirectangular, renderTarget = null ) {

		return this._fromTexture( equirectangular, renderTarget );

	}

	/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * or HDR. The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 * The smallest supported cube size is 16 x 16.
	 */
	fromCubemap( cubemap, renderTarget = null ) {

		return this._fromTexture( cubemap, renderTarget );

	}

	/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileCubemapShader() {

		if ( this._cubemapMaterial === null ) {

			this._cubemapMaterial = _getCubemapMaterial();
			this._compileMaterial( this._cubemapMaterial );

		}

	}

	/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileEquirectangularShader() {

		if ( this._equirectMaterial === null ) {

			this._equirectMaterial = _getEquirectMaterial();
			this._compileMaterial( this._equirectMaterial );

		}

	}

	/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */
	dispose() {

		this._dispose();

		if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();
		if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();

	}

	// private interface

	_setSize( cubeSize ) {

		this._lodMax = Math.floor( Math.log2( cubeSize ) );
		this._cubeSize = Math.pow( 2, this._lodMax );

	}

	_dispose() {

		if ( this._blurMaterial !== null ) this._blurMaterial.dispose();

		if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();

		for ( let i = 0; i < this._lodPlanes.length; i ++ ) {

			this._lodPlanes[ i ].dispose();

		}

	}

	_cleanup( outputTarget ) {

		this._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );
		this._renderer.xr.enabled = _oldXrEnabled;

		outputTarget.scissorTest = false;
		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

	}

	_fromTexture( texture, renderTarget ) {

		if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {

			this._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );

		} else { // Equirectangular

			this._setSize( texture.image.width / 4 );

		}

		_oldTarget = this._renderer.getRenderTarget();
		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
		_oldXrEnabled = this._renderer.xr.enabled;

		this._renderer.xr.enabled = false;

		const cubeUVRenderTarget = renderTarget || this._allocateTargets();
		this._textureToCubeUV( texture, cubeUVRenderTarget );
		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	_allocateTargets() {

		const width = 3 * Math.max( this._cubeSize, 16 * 7 );
		const height = 4 * this._cubeSize;

		const params = {
			magFilter: LinearFilter,
			minFilter: LinearFilter,
			generateMipmaps: false,
			type: HalfFloatType,
			format: RGBAFormat,
			colorSpace: LinearSRGBColorSpace,
			depthBuffer: false
		};

		const cubeUVRenderTarget = _createRenderTarget( width, height, params );

		if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {

			if ( this._pingPongRenderTarget !== null ) {

				this._dispose();

			}

			this._pingPongRenderTarget = _createRenderTarget( width, height, params );

			const { _lodMax } = this;
			( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );

			this._blurMaterial = _getBlurShader( _lodMax, width, height );

		}

		return cubeUVRenderTarget;

	}

	_compileMaterial( material ) {

		const tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );
		this._renderer.compile( tmpMesh, _flatCamera );

	}

	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

		const fov = 90;
		const aspect = 1;
		const cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
		const upSign = [ 1, - 1, 1, 1, 1, 1 ];
		const forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];
		const renderer = this._renderer;

		const originalAutoClear = renderer.autoClear;
		const toneMapping = renderer.toneMapping;
		renderer.getClearColor( _clearColor );

		renderer.toneMapping = NoToneMapping;
		renderer.autoClear = false;

		const backgroundMaterial = new MeshBasicMaterial( {
			name: 'PMREM.Background',
			side: BackSide,
			depthWrite: false,
			depthTest: false,
		} );

		const backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

		let useSolidColor = false;
		const background = scene.background;

		if ( background ) {

			if ( background.isColor ) {

				backgroundMaterial.color.copy( background );
				scene.background = null;
				useSolidColor = true;

			}

		} else {

			backgroundMaterial.color.copy( _clearColor );
			useSolidColor = true;

		}

		for ( let i = 0; i < 6; i ++ ) {

			const col = i % 3;

			if ( col === 0 ) {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

			} else if ( col === 1 ) {

				cubeCamera.up.set( 0, 0, upSign[ i ] );
				cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

			} else {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

			}

			const size = this._cubeSize;

			_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );

			renderer.setRenderTarget( cubeUVRenderTarget );

			if ( useSolidColor ) {

				renderer.render( backgroundBox, cubeCamera );

			}

			renderer.render( scene, cubeCamera );

		}

		backgroundBox.geometry.dispose();
		backgroundBox.material.dispose();

		renderer.toneMapping = toneMapping;
		renderer.autoClear = originalAutoClear;
		scene.background = background;

	}

	_textureToCubeUV( texture, cubeUVRenderTarget ) {

		const renderer = this._renderer;

		const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

		if ( isCubeTexture ) {

			if ( this._cubemapMaterial === null ) {

				this._cubemapMaterial = _getCubemapMaterial();

			}

			this._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? - 1 : 1;

		} else {

			if ( this._equirectMaterial === null ) {

				this._equirectMaterial = _getEquirectMaterial();

			}

		}

		const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
		const mesh = new Mesh( this._lodPlanes[ 0 ], material );

		const uniforms = material.uniforms;

		uniforms[ 'envMap' ].value = texture;

		const size = this._cubeSize;

		_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );

		renderer.setRenderTarget( cubeUVRenderTarget );
		renderer.render( mesh, _flatCamera );

	}

	_applyPMREM( cubeUVRenderTarget ) {

		const renderer = this._renderer;
		const autoClear = renderer.autoClear;
		renderer.autoClear = false;
		const n = this._lodPlanes.length;

		for ( let i = 1; i < n; i ++ ) {

			const sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );

			const poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];

			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

		}

		renderer.autoClear = autoClear;

	}

	/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */
	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

		const pingPongRenderTarget = this._pingPongRenderTarget;

		this._halfBlur(
			cubeUVRenderTarget,
			pingPongRenderTarget,
			lodIn,
			lodOut,
			sigma,
			'latitudinal',
			poleAxis );

		this._halfBlur(
			pingPongRenderTarget,
			cubeUVRenderTarget,
			lodOut,
			lodOut,
			sigma,
			'longitudinal',
			poleAxis );

	}

	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

		const renderer = this._renderer;
		const blurMaterial = this._blurMaterial;

		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

			console.error(
				'blur direction must be either latitudinal or longitudinal!' );

		}

		// Number of standard deviations at which to cut off the discrete approximation.
		const STANDARD_DEVIATIONS = 3;

		const blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );
		const blurUniforms = blurMaterial.uniforms;

		const pixels = this._sizeLods[ lodIn ] - 1;
		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
		const sigmaPixels = sigmaRadians / radiansPerPixel;
		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

		if ( samples > MAX_SAMPLES ) {

			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

		}

		const weights = [];
		let sum = 0;

		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

			const x = i / sigmaPixels;
			const weight = Math.exp( - x * x / 2 );
			weights.push( weight );

			if ( i === 0 ) {

				sum += weight;

			} else if ( i < samples ) {

				sum += 2 * weight;

			}

		}

		for ( let i = 0; i < weights.length; i ++ ) {

			weights[ i ] = weights[ i ] / sum;

		}

		blurUniforms[ 'envMap' ].value = targetIn.texture;
		blurUniforms[ 'samples' ].value = samples;
		blurUniforms[ 'weights' ].value = weights;
		blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

		if ( poleAxis ) {

			blurUniforms[ 'poleAxis' ].value = poleAxis;

		}

		const { _lodMax } = this;
		blurUniforms[ 'dTheta' ].value = radiansPerPixel;
		blurUniforms[ 'mipInt' ].value = _lodMax - lodIn;

		const outputSize = this._sizeLods[ lodOut ];
		const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
		const y = 4 * ( this._cubeSize - outputSize );

		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
		renderer.setRenderTarget( targetOut );
		renderer.render( blurMesh, _flatCamera );

	}

}



function _createPlanes( lodMax ) {

	const lodPlanes = [];
	const sizeLods = [];
	const sigmas = [];

	let lod = lodMax;

	const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

	for ( let i = 0; i < totalLods; i ++ ) {

		const sizeLod = Math.pow( 2, lod );
		sizeLods.push( sizeLod );
		let sigma = 1.0 / sizeLod;

		if ( i > lodMax - LOD_MIN ) {

			sigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];

		} else if ( i === 0 ) {

			sigma = 0;

		}

		sigmas.push( sigma );

		const texelSize = 1.0 / ( sizeLod - 2 );
		const min = - texelSize;
		const max = 1 + texelSize;
		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

		const cubeFaces = 6;
		const vertices = 6;
		const positionSize = 3;
		const uvSize = 2;
		const faceIndexSize = 1;

		const position = new Float32Array( positionSize * vertices * cubeFaces );
		const uv = new Float32Array( uvSize * vertices * cubeFaces );
		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

		for ( let face = 0; face < cubeFaces; face ++ ) {

			const x = ( face % 3 ) * 2 / 3 - 1;
			const y = face > 2 ? 0 : - 1;
			const coordinates = [
				x, y, 0,
				x + 2 / 3, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y + 1, 0
			];
			position.set( coordinates, positionSize * vertices * face );
			uv.set( uv1, uvSize * vertices * face );
			const fill = [ face, face, face, face, face, face ];
			faceIndex.set( fill, faceIndexSize * vertices * face );

		}

		const planes = new BufferGeometry();
		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
		lodPlanes.push( planes );

		if ( lod > LOD_MIN ) {

			lod --;

		}

	}

	return { lodPlanes, sizeLods, sigmas };

}

function _createRenderTarget( width, height, params ) {

	const cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );
	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;

}

function _setViewport( target, x, y, width, height ) {

	target.viewport.set( x, y, width, height );
	target.scissor.set( x, y, width, height );

}

function _getBlurShader( lodMax, width, height ) {

	const weights = new Float32Array( MAX_SAMPLES );
	const poleAxis = new Vector3( 0, 1, 0 );
	const shaderMaterial = new ShaderMaterial( {

		name: 'SphericalGaussianBlur',

		defines: {
			'n': MAX_SAMPLES,
			'CUBEUV_TEXEL_WIDTH': 1.0 / width,
			'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
			'CUBEUV_MAX_MIP': `${lodMax}.0`,
		},

		uniforms: {
			'envMap': { value: null },
			'samples': { value: 1 },
			'weights': { value: weights },
			'latitudinal': { value: false },
			'dTheta': { value: 0 },
			'mipInt': { value: 0 },
			'poleAxis': { value: poleAxis }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getEquirectMaterial() {

	return new ShaderMaterial( {

		name: 'EquirectangularToCubeUV',

		uniforms: {
			'envMap': { value: null }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

}

function _getCubemapMaterial() {

	return new ShaderMaterial( {

		name: 'CubemapToCubeUV',

		uniforms: {
			'envMap': { value: null },
			'flipEnvMap': { value: - 1 }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

}

function _getCommonVertexShader() {

	return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

}

function WebGLCubeUVMaps( renderer ) {

	let cubeUVmaps = new WeakMap();

	let pmremGenerator = null;

	function get( texture ) {

		if ( texture && texture.isTexture ) {

			const mapping = texture.mapping;

			const isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );
			const isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

			// equirect/cube map to cubeUV conversion

			if ( isEquirectMap || isCubeMap ) {

				let renderTarget = cubeUVmaps.get( texture );

				const currentPMREMVersion = renderTarget !== undefined ? renderTarget.texture.pmremVersion : 0;

				if ( texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion ) {

					if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

					renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );
					renderTarget.texture.pmremVersion = texture.pmremVersion;

					cubeUVmaps.set( texture, renderTarget );

					return renderTarget.texture;

				} else {

					if ( renderTarget !== undefined ) {

						return renderTarget.texture;

					} else {

						const image = texture.image;

						if ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {

							if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

							renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );
							renderTarget.texture.pmremVersion = texture.pmremVersion;

							cubeUVmaps.set( texture, renderTarget );

							texture.addEventListener( 'dispose', onTextureDispose );

							return renderTarget.texture;

						} else {

							// image not yet ready. try the conversion next frame

							return null;

						}

					}

				}

			}

		}

		return texture;

	}

	function isCubeTextureComplete( image ) {

		let count = 0;
		const length = 6;

		for ( let i = 0; i < length; i ++ ) {

			if ( image[ i ] !== undefined ) count ++;

		}

		return count === length;


	}

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		const cubemapUV = cubeUVmaps.get( texture );

		if ( cubemapUV !== undefined ) {

			cubeUVmaps.delete( texture );
			cubemapUV.dispose();

		}

	}

	function dispose() {

		cubeUVmaps = new WeakMap();

		if ( pmremGenerator !== null ) {

			pmremGenerator.dispose();
			pmremGenerator = null;

		}

	}

	return {
		get: get,
		dispose: dispose
	};

}

function WebGLExtensions( gl ) {

	const extensions = {};

	function getExtension( name ) {

		if ( extensions[ name ] !== undefined ) {

			return extensions[ name ];

		}

		let extension;

		switch ( name ) {

			case 'WEBGL_depth_texture':
				extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
				break;

			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				break;

			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				break;

			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				break;

			default:
				extension = gl.getExtension( name );

		}

		extensions[ name ] = extension;

		return extension;

	}

	return {

		has: function ( name ) {

			return getExtension( name ) !== null;

		},

		init: function () {

			getExtension( 'EXT_color_buffer_float' );
			getExtension( 'WEBGL_clip_cull_distance' );
			getExtension( 'OES_texture_float_linear' );
			getExtension( 'EXT_color_buffer_half_float' );
			getExtension( 'WEBGL_multisampled_render_to_texture' );
			getExtension( 'WEBGL_render_shared_exponent' );

		},

		get: function ( name ) {

			const extension = getExtension( name );

			if ( extension === null ) {

				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			return extension;

		}

	};

}

function WebGLGeometries( gl, attributes, info, bindingStates ) {

	const geometries = {};
	const wireframeAttributes = new WeakMap();

	function onGeometryDispose( event ) {

		const geometry = event.target;

		if ( geometry.index !== null ) {

			attributes.remove( geometry.index );

		}

		for ( const name in geometry.attributes ) {

			attributes.remove( geometry.attributes[ name ] );

		}

		for ( const name in geometry.morphAttributes ) {

			const array = geometry.morphAttributes[ name ];

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				attributes.remove( array[ i ] );

			}

		}

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		delete geometries[ geometry.id ];

		const attribute = wireframeAttributes.get( geometry );

		if ( attribute ) {

			attributes.remove( attribute );
			wireframeAttributes.delete( geometry );

		}

		bindingStates.releaseStatesOfGeometry( geometry );

		if ( geometry.isInstancedBufferGeometry === true ) {

			delete geometry._maxInstanceCount;

		}

		//

		info.memory.geometries --;

	}

	function get( object, geometry ) {

		if ( geometries[ geometry.id ] === true ) return geometry;

		geometry.addEventListener( 'dispose', onGeometryDispose );

		geometries[ geometry.id ] = true;

		info.memory.geometries ++;

		return geometry;

	}

	function update( geometry ) {

		const geometryAttributes = geometry.attributes;

		// Updating index buffer in VAO now. See WebGLBindingStates.

		for ( const name in geometryAttributes ) {

			attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

		}

		// morph targets

		const morphAttributes = geometry.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = morphAttributes[ name ];

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				attributes.update( array[ i ], gl.ARRAY_BUFFER );

			}

		}

	}

	function updateWireframeAttribute( geometry ) {

		const indices = [];

		const geometryIndex = geometry.index;
		const geometryPosition = geometry.attributes.position;
		let version = 0;

		if ( geometryIndex !== null ) {

			const array = geometryIndex.array;
			version = geometryIndex.version;

			for ( let i = 0, l = array.length; i < l; i += 3 ) {

				const a = array[ i + 0 ];
				const b = array[ i + 1 ];
				const c = array[ i + 2 ];

				indices.push( a, b, b, c, c, a );

			}

		} else if ( geometryPosition !== undefined ) {

			const array = geometryPosition.array;
			version = geometryPosition.version;

			for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				const a = i + 0;
				const b = i + 1;
				const c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		} else {

			return;

		}

		const attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
		attribute.version = version;

		// Updating index buffer in VAO now. See WebGLBindingStates

		//

		const previousAttribute = wireframeAttributes.get( geometry );

		if ( previousAttribute ) attributes.remove( previousAttribute );

		//

		wireframeAttributes.set( geometry, attribute );

	}

	function getWireframeAttribute( geometry ) {

		const currentAttribute = wireframeAttributes.get( geometry );

		if ( currentAttribute ) {

			const geometryIndex = geometry.index;

			if ( geometryIndex !== null ) {

				// if the attribute is obsolete, create a new one

				if ( currentAttribute.version < geometryIndex.version ) {

					updateWireframeAttribute( geometry );

				}

			}

		} else {

			updateWireframeAttribute( geometry );

		}

		return wireframeAttributes.get( geometry );

	}

	return {

		get: get,
		update: update,

		getWireframeAttribute: getWireframeAttribute

	};

}

function WebGLIndexedBufferRenderer( gl, extensions, info ) {

	let mode;

	function setMode( value ) {

		mode = value;

	}

	let type, bytesPerElement;

	function setIndex( value ) {

		type = value.type;
		bytesPerElement = value.bytesPerElement;

	}

	function render( start, count ) {

		gl.drawElements( mode, count, type, start * bytesPerElement );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		gl.drawElementsInstanced( mode, count, type, start * bytesPerElement, primcount );

		info.update( count, mode, primcount );

	}

	function renderMultiDraw( starts, counts, drawCount ) {

		if ( drawCount === 0 ) return;

		const extension = extensions.get( 'WEBGL_multi_draw' );

		if ( extension === null ) {

			for ( let i = 0; i < drawCount; i ++ ) {

				this.render( starts[ i ] / bytesPerElement, counts[ i ] );

			}

		} else {

			extension.multiDrawElementsWEBGL( mode, counts, 0, type, starts, 0, drawCount );

			let elementCount = 0;
			for ( let i = 0; i < drawCount; i ++ ) {

				elementCount += counts[ i ];

			}

			info.update( elementCount, mode, 1 );

		}

	}

	function renderMultiDrawInstances( starts, counts, drawCount, primcount ) {

		if ( drawCount === 0 ) return;

		const extension = extensions.get( 'WEBGL_multi_draw' );

		if ( extension === null ) {

			for ( let i = 0; i < starts.length; i ++ ) {

				renderInstances( starts[ i ] / bytesPerElement, counts[ i ], primcount[ i ] );

			}

		} else {

			extension.multiDrawElementsInstancedWEBGL( mode, counts, 0, type, starts, 0, primcount, 0, drawCount );

			let elementCount = 0;
			for ( let i = 0; i < drawCount; i ++ ) {

				elementCount += counts[ i ];

			}

			for ( let i = 0; i < primcount.length; i ++ ) {

				info.update( elementCount, mode, primcount[ i ] );

			}

		}

	}

	//

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;
	this.renderMultiDraw = renderMultiDraw;
	this.renderMultiDrawInstances = renderMultiDrawInstances;

}

function WebGLInfo( gl ) {

	const memory = {
		geometries: 0,
		textures: 0
	};

	const render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};

	function update( count, mode, instanceCount ) {

		render.calls ++;

		switch ( mode ) {

			case gl.TRIANGLES:
				render.triangles += instanceCount * ( count / 3 );
				break;

			case gl.LINES:
				render.lines += instanceCount * ( count / 2 );
				break;

			case gl.LINE_STRIP:
				render.lines += instanceCount * ( count - 1 );
				break;

			case gl.LINE_LOOP:
				render.lines += instanceCount * count;
				break;

			case gl.POINTS:
				render.points += instanceCount * count;
				break;

			default:
				console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
				break;

		}

	}

	function reset() {

		render.calls = 0;
		render.triangles = 0;
		render.points = 0;
		render.lines = 0;

	}

	return {
		memory: memory,
		render: render,
		programs: null,
		autoReset: true,
		reset: reset,
		update: update
	};

}

function WebGLMorphtargets( gl, capabilities, textures ) {

	const morphTextures = new WeakMap();
	const morph = new Vector4();

	function update( object, geometry, program ) {

		const objectInfluences = object.morphTargetInfluences;

		// instead of using attributes, the WebGL 2 code path encodes morph targets
		// into an array of data textures. Each layer represents a single morph target.

		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

		let entry = morphTextures.get( geometry );

		if ( entry === undefined || entry.count !== morphTargetsCount ) {

			if ( entry !== undefined ) entry.texture.dispose();

			const hasMorphPosition = geometry.morphAttributes.position !== undefined;
			const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
			const hasMorphColors = geometry.morphAttributes.color !== undefined;

			const morphTargets = geometry.morphAttributes.position || [];
			const morphNormals = geometry.morphAttributes.normal || [];
			const morphColors = geometry.morphAttributes.color || [];

			let vertexDataCount = 0;

			if ( hasMorphPosition === true ) vertexDataCount = 1;
			if ( hasMorphNormals === true ) vertexDataCount = 2;
			if ( hasMorphColors === true ) vertexDataCount = 3;

			let width = geometry.attributes.position.count * vertexDataCount;
			let height = 1;

			if ( width > capabilities.maxTextureSize ) {

				height = Math.ceil( width / capabilities.maxTextureSize );
				width = capabilities.maxTextureSize;

			}

			const buffer = new Float32Array( width * height * 4 * morphTargetsCount );

			const texture = new DataArrayTexture( buffer, width, height, morphTargetsCount );
			texture.type = FloatType;
			texture.needsUpdate = true;

			// fill buffer

			const vertexDataStride = vertexDataCount * 4;

			for ( let i = 0; i < morphTargetsCount; i ++ ) {

				const morphTarget = morphTargets[ i ];
				const morphNormal = morphNormals[ i ];
				const morphColor = morphColors[ i ];

				const offset = width * height * 4 * i;

				for ( let j = 0; j < morphTarget.count; j ++ ) {

					const stride = j * vertexDataStride;

					if ( hasMorphPosition === true ) {

						morph.fromBufferAttribute( morphTarget, j );

						buffer[ offset + stride + 0 ] = morph.x;
						buffer[ offset + stride + 1 ] = morph.y;
						buffer[ offset + stride + 2 ] = morph.z;
						buffer[ offset + stride + 3 ] = 0;

					}

					if ( hasMorphNormals === true ) {

						morph.fromBufferAttribute( morphNormal, j );

						buffer[ offset + stride + 4 ] = morph.x;
						buffer[ offset + stride + 5 ] = morph.y;
						buffer[ offset + stride + 6 ] = morph.z;
						buffer[ offset + stride + 7 ] = 0;

					}

					if ( hasMorphColors === true ) {

						morph.fromBufferAttribute( morphColor, j );

						buffer[ offset + stride + 8 ] = morph.x;
						buffer[ offset + stride + 9 ] = morph.y;
						buffer[ offset + stride + 10 ] = morph.z;
						buffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;

					}

				}

			}

			entry = {
				count: morphTargetsCount,
				texture: texture,
				size: new Vector2( width, height )
			};

			morphTextures.set( geometry, entry );

			function disposeTexture() {

				texture.dispose();

				morphTextures.delete( geometry );

				geometry.removeEventListener( 'dispose', disposeTexture );

			}

			geometry.addEventListener( 'dispose', disposeTexture );

		}

		//
		if ( object.isInstancedMesh === true && object.morphTexture !== null ) {

			program.getUniforms().setValue( gl, 'morphTexture', object.morphTexture, textures );

		} else {

			let morphInfluencesSum = 0;

			for ( let i = 0; i < objectInfluences.length; i ++ ) {

				morphInfluencesSum += objectInfluences[ i ];

			}

			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;


			program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
			program.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );

		}

		program.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );
		program.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );

	}

	return {

		update: update

	};

}

function WebGLObjects( gl, geometries, attributes, info ) {

	let updateMap = new WeakMap();

	function update( object ) {

		const frame = info.render.frame;

		const geometry = object.geometry;
		const buffergeometry = geometries.get( object, geometry );

		// Update once per frame

		if ( updateMap.get( buffergeometry ) !== frame ) {

			geometries.update( buffergeometry );

			updateMap.set( buffergeometry, frame );

		}

		if ( object.isInstancedMesh ) {

			if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

				object.addEventListener( 'dispose', onInstancedMeshDispose );

			}

			if ( updateMap.get( object ) !== frame ) {

				attributes.update( object.instanceMatrix, gl.ARRAY_BUFFER );

				if ( object.instanceColor !== null ) {

					attributes.update( object.instanceColor, gl.ARRAY_BUFFER );

				}

				updateMap.set( object, frame );

			}

		}

		if ( object.isSkinnedMesh ) {

			const skeleton = object.skeleton;

			if ( updateMap.get( skeleton ) !== frame ) {

				skeleton.update();

				updateMap.set( skeleton, frame );

			}

		}

		return buffergeometry;

	}

	function dispose() {

		updateMap = new WeakMap();

	}

	function onInstancedMeshDispose( event ) {

		const instancedMesh = event.target;

		instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

		attributes.remove( instancedMesh.instanceMatrix );

		if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

	}

	return {

		update: update,
		dispose: dispose

	};

}

class DepthTexture extends Texture {

	constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

		format = format !== undefined ? format : DepthFormat;

		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		}

		if ( type === undefined && format === DepthFormat ) type = UnsignedIntType;
		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.isDepthTexture = true;

		this.image = { width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.flipY = false;
		this.generateMipmaps = false;

		this.compareFunction = null;

	}


	copy( source ) {

		super.copy( source );

		this.compareFunction = source.compareFunction;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.compareFunction !== null ) data.compareFunction = this.compareFunction;

		return data;

	}

}

/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */


const emptyTexture = /*@__PURE__*/ new Texture();

const emptyShadowTexture = /*@__PURE__*/ new DepthTexture( 1, 1 );
emptyShadowTexture.compareFunction = LessEqualCompare;

const emptyArrayTexture = /*@__PURE__*/ new DataArrayTexture();
const empty3dTexture = /*@__PURE__*/ new Data3DTexture();
const emptyCubeTexture = /*@__PURE__*/ new CubeTexture();

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

const arrayCacheF32 = [];
const arrayCacheI32 = [];

// Float32Array caches used for uploading Matrix uniforms

const mat4array = new Float32Array( 16 );
const mat3array = new Float32Array( 9 );
const mat2array = new Float32Array( 4 );

// Flattening for arrays of vectors and matrices

function flatten( array, nBlocks, blockSize ) {

	const firstElem = array[ 0 ];

	if ( firstElem <= 0 || firstElem > 0 ) return array;
	// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983

	const n = nBlocks * blockSize;
	let r = arrayCacheF32[ n ];

	if ( r === undefined ) {

		r = new Float32Array( n );
		arrayCacheF32[ n ] = r;

	}

	if ( nBlocks !== 0 ) {

		firstElem.toArray( r, 0 );

		for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

			offset += blockSize;
			array[ i ].toArray( r, offset );

		}

	}

	return r;

}

function arraysEqual( a, b ) {

	if ( a.length !== b.length ) return false;

	for ( let i = 0, l = a.length; i < l; i ++ ) {

		if ( a[ i ] !== b[ i ] ) return false;

	}

	return true;

}

function copyArray( a, b ) {

	for ( let i = 0, l = b.length; i < l; i ++ ) {

		a[ i ] = b[ i ];

	}

}

// Texture unit allocation

function allocTexUnits( textures, n ) {

	let r = arrayCacheI32[ n ];

	if ( r === undefined ) {

		r = new Int32Array( n );
		arrayCacheI32[ n ] = r;

	}

	for ( let i = 0; i !== n; ++ i ) {

		r[ i ] = textures.allocateTextureUnit();

	}

	return r;

}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValueV1f( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1f( this.addr, v );

	cache[ 0 ] = v;

}

// Single float vector (from flat array or THREE.VectorN)

function setValueV2f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2f( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3f( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else if ( v.r !== undefined ) {

		if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

			gl.uniform3f( this.addr, v.r, v.g, v.b );

			cache[ 0 ] = v.r;
			cache[ 1 ] = v.g;
			cache[ 2 ] = v.b;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4fv( this.addr, v );

		copyArray( cache, v );

	}

}

// Single matrix (from flat array or THREE.MatrixN)

function setValueM2( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix2fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat2array.set( elements );

		gl.uniformMatrix2fv( this.addr, false, mat2array );

		copyArray( cache, elements );

	}

}

function setValueM3( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix3fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat3array.set( elements );

		gl.uniformMatrix3fv( this.addr, false, mat3array );

		copyArray( cache, elements );

	}

}

function setValueM4( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix4fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat4array.set( elements );

		gl.uniformMatrix4fv( this.addr, false, mat4array );

		copyArray( cache, elements );

	}

}

// Single integer / boolean

function setValueV1i( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1i( this.addr, v );

	cache[ 0 ] = v;

}

// Single integer / boolean vector (from flat array or THREE.VectorN)

function setValueV2i( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2i( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2iv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3i( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3i( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3iv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4i( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4i( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4iv( this.addr, v );

		copyArray( cache, v );

	}

}

// Single unsigned integer

function setValueV1ui( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1ui( this.addr, v );

	cache[ 0 ] = v;

}

// Single unsigned integer vector (from flat array or THREE.VectorN)

function setValueV2ui( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2ui( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2uiv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3ui( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3ui( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3uiv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4ui( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4ui( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4uiv( this.addr, v );

		copyArray( cache, v );

	}

}


// Single texture (2D / Cube)

function setValueT1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	const emptyTexture2D = ( this.type === gl.SAMPLER_2D_SHADOW ) ? emptyShadowTexture : emptyTexture;

	textures.setTexture2D( v || emptyTexture2D, unit );

}

function setValueT3D1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture3D( v || empty3dTexture, unit );

}

function setValueT6( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTextureCube( v || emptyCubeTexture, unit );

}

function setValueT2DArray1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture2DArray( v || emptyArrayTexture, unit );

}

// Helper to pick the right setter for the singular case

function getSingularSetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1f; // FLOAT
		case 0x8b50: return setValueV2f; // _VEC2
		case 0x8b51: return setValueV3f; // _VEC3
		case 0x8b52: return setValueV4f; // _VEC4

		case 0x8b5a: return setValueM2; // _MAT2
		case 0x8b5b: return setValueM3; // _MAT3
		case 0x8b5c: return setValueM4; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

		case 0x1405: return setValueV1ui; // UINT
		case 0x8dc6: return setValueV2ui; // _VEC2
		case 0x8dc7: return setValueV3ui; // _VEC3
		case 0x8dc8: return setValueV4ui; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1;

		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			return setValueT3D1;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6;

		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArray1;

	}

}


// Array of scalars

function setValueV1fArray( gl, v ) {

	gl.uniform1fv( this.addr, v );

}

// Array of vectors (from flat array or array of THREE.VectorN)

function setValueV2fArray( gl, v ) {

	const data = flatten( v, this.size, 2 );

	gl.uniform2fv( this.addr, data );

}

function setValueV3fArray( gl, v ) {

	const data = flatten( v, this.size, 3 );

	gl.uniform3fv( this.addr, data );

}

function setValueV4fArray( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniform4fv( this.addr, data );

}

// Array of matrices (from flat array or array of THREE.MatrixN)

function setValueM2Array( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniformMatrix2fv( this.addr, false, data );

}

function setValueM3Array( gl, v ) {

	const data = flatten( v, this.size, 9 );

	gl.uniformMatrix3fv( this.addr, false, data );

}

function setValueM4Array( gl, v ) {

	const data = flatten( v, this.size, 16 );

	gl.uniformMatrix4fv( this.addr, false, data );

}

// Array of integer / boolean

function setValueV1iArray( gl, v ) {

	gl.uniform1iv( this.addr, v );

}

// Array of integer / boolean vectors (from flat array)

function setValueV2iArray( gl, v ) {

	gl.uniform2iv( this.addr, v );

}

function setValueV3iArray( gl, v ) {

	gl.uniform3iv( this.addr, v );

}

function setValueV4iArray( gl, v ) {

	gl.uniform4iv( this.addr, v );

}

// Array of unsigned integer

function setValueV1uiArray( gl, v ) {

	gl.uniform1uiv( this.addr, v );

}

// Array of unsigned integer vectors (from flat array)

function setValueV2uiArray( gl, v ) {

	gl.uniform2uiv( this.addr, v );

}

function setValueV3uiArray( gl, v ) {

	gl.uniform3uiv( this.addr, v );

}

function setValueV4uiArray( gl, v ) {

	gl.uniform4uiv( this.addr, v );

}


// Array of textures (2D / 3D / Cube / 2DArray)

function setValueT1Array( gl, v, textures ) {

	const cache = this.cache;

	const n = v.length;

	const units = allocTexUnits( textures, n );

	if ( ! arraysEqual( cache, units ) ) {

		gl.uniform1iv( this.addr, units );

		copyArray( cache, units );

	}

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

	}

}

function setValueT3DArray( gl, v, textures ) {

	const cache = this.cache;

	const n = v.length;

	const units = allocTexUnits( textures, n );

	if ( ! arraysEqual( cache, units ) ) {

		gl.uniform1iv( this.addr, units );

		copyArray( cache, units );

	}

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTexture3D( v[ i ] || empty3dTexture, units[ i ] );

	}

}

function setValueT6Array( gl, v, textures ) {

	const cache = this.cache;

	const n = v.length;

	const units = allocTexUnits( textures, n );

	if ( ! arraysEqual( cache, units ) ) {

		gl.uniform1iv( this.addr, units );

		copyArray( cache, units );

	}

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

	}

}

function setValueT2DArrayArray( gl, v, textures ) {

	const cache = this.cache;

	const n = v.length;

	const units = allocTexUnits( textures, n );

	if ( ! arraysEqual( cache, units ) ) {

		gl.uniform1iv( this.addr, units );

		copyArray( cache, units );

	}

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTexture2DArray( v[ i ] || emptyArrayTexture, units[ i ] );

	}

}


// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1fArray; // FLOAT
		case 0x8b50: return setValueV2fArray; // _VEC2
		case 0x8b51: return setValueV3fArray; // _VEC3
		case 0x8b52: return setValueV4fArray; // _VEC4

		case 0x8b5a: return setValueM2Array; // _MAT2
		case 0x8b5b: return setValueM3Array; // _MAT3
		case 0x8b5c: return setValueM4Array; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

		case 0x1405: return setValueV1uiArray; // UINT
		case 0x8dc6: return setValueV2uiArray; // _VEC2
		case 0x8dc7: return setValueV3uiArray; // _VEC3
		case 0x8dc8: return setValueV4uiArray; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1Array;

		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			return setValueT3DArray;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6Array;

		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArrayArray;

	}

}

// --- Uniform Classes ---

class SingleUniform {

	constructor( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.type = activeInfo.type;
		this.setValue = getSingularSetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

}

class PureArrayUniform {

	constructor( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.type = activeInfo.type;
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

}

class StructuredUniform {

	constructor( id ) {

		this.id = id;

		this.seq = [];
		this.map = {};

	}

	setValue( gl, value, textures ) {

		const seq = this.seq;

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ];
			u.setValue( gl, value[ u.id ], textures );

		}

	}

}

// --- Top-level ---

// Parser - builds up the property tree from the path strings

const RePathPart = /(\w+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform( container, uniformObject ) {

	container.seq.push( uniformObject );
	container.map[ uniformObject.id ] = uniformObject;

}

function parseUniform( activeInfo, addr, container ) {

	const path = activeInfo.name,
		pathLength = path.length;

	// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex = 0;

	while ( true ) {

		const match = RePathPart.exec( path ),
			matchEnd = RePathPart.lastIndex;

		let id = match[ 1 ];
		const idIsIndex = match[ 2 ] === ']',
			subscript = match[ 3 ];

		if ( idIsIndex ) id = id | 0; // convert to integer

		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

			// bare name or "pure" bottom-level array "[0]" suffix

			addUniform( container, subscript === undefined ?
				new SingleUniform( id, activeInfo, addr ) :
				new PureArrayUniform( id, activeInfo, addr ) );

			break;

		} else {

			// step into inner node / create it in case it doesn't exist

			const map = container.map;
			let next = map[ id ];

			if ( next === undefined ) {

				next = new StructuredUniform( id );
				addUniform( container, next );

			}

			container = next;

		}

	}

}

// Root Container

class WebGLUniforms {

	constructor( gl, program ) {

		this.seq = [];
		this.map = {};

		const n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

		for ( let i = 0; i < n; ++ i ) {

			const info = gl.getActiveUniform( program, i ),
				addr = gl.getUniformLocation( program, info.name );

			parseUniform( info, addr, this );

		}

	}

	setValue( gl, name, value, textures ) {

		const u = this.map[ name ];

		if ( u !== undefined ) u.setValue( gl, value, textures );

	}

	setOptional( gl, object, name ) {

		const v = object[ name ];

		if ( v !== undefined ) this.setValue( gl, name, v );

	}

	static upload( gl, seq, values, textures ) {

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ],
				v = values[ u.id ];

			if ( v.needsUpdate !== false ) {

				// note: always updating when .needsUpdate is undefined
				u.setValue( gl, v.value, textures );

			}

		}

	}

	static seqWithValue( seq, values ) {

		const r = [];

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ];
			if ( u.id in values ) r.push( u );

		}

		return r;

	}

}

function WebGLShader( gl, type, string ) {

	const shader = gl.createShader( type );

	gl.shaderSource( shader, string );
	gl.compileShader( shader );

	return shader;

}

// From https://www.khronos.org/registry/webgl/extensions/KHR_parallel_shader_compile/
const COMPLETION_STATUS_KHR = 0x91B1;

let programIdCount = 0;

function handleSource( string, errorLine ) {

	const lines = string.split( '\n' );
	const lines2 = [];

	const from = Math.max( errorLine - 6, 0 );
	const to = Math.min( errorLine + 6, lines.length );

	for ( let i = from; i < to; i ++ ) {

		const line = i + 1;
		lines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );

	}

	return lines2.join( '\n' );

}

function getEncodingComponents( colorSpace ) {

	const workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );
	const encodingPrimaries = ColorManagement.getPrimaries( colorSpace );

	let gamutMapping;

	if ( workingPrimaries === encodingPrimaries ) {

		gamutMapping = '';

	} else if ( workingPrimaries === P3Primaries && encodingPrimaries === Rec709Primaries ) {

		gamutMapping = 'LinearDisplayP3ToLinearSRGB';

	} else if ( workingPrimaries === Rec709Primaries && encodingPrimaries === P3Primaries ) {

		gamutMapping = 'LinearSRGBToLinearDisplayP3';

	}

	switch ( colorSpace ) {

		case LinearSRGBColorSpace:
		case LinearDisplayP3ColorSpace:
			return [ gamutMapping, 'LinearTransferOETF' ];

		case SRGBColorSpace:
		case DisplayP3ColorSpace:
			return [ gamutMapping, 'sRGBTransferOETF' ];

		default:
			console.warn( 'THREE.WebGLProgram: Unsupported color space:', colorSpace );
			return [ gamutMapping, 'LinearTransferOETF' ];

	}

}

function getShaderErrors( gl, shader, type ) {

	const status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );
	const errors = gl.getShaderInfoLog( shader ).trim();

	if ( status && errors === '' ) return '';

	const errorMatches = /ERROR: 0:(\d+)/.exec( errors );
	if ( errorMatches ) {

		// --enable-privileged-webgl-extension
		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		const errorLine = parseInt( errorMatches[ 1 ] );
		return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource( gl.getShaderSource( shader ), errorLine );

	} else {

		return errors;

	}

}

function getTexelEncodingFunction( functionName, colorSpace ) {

	const components = getEncodingComponents( colorSpace );
	return `vec4 ${functionName}( vec4 value ) { return ${components[ 0 ]}( ${components[ 1 ]}( value ) ); }`;

}

function getToneMappingFunction( functionName, toneMapping ) {

	let toneMappingName;

	switch ( toneMapping ) {

		case LinearToneMapping:
			toneMappingName = 'Linear';
			break;

		case ReinhardToneMapping:
			toneMappingName = 'Reinhard';
			break;

		case CineonToneMapping:
			toneMappingName = 'OptimizedCineon';
			break;

		case ACESFilmicToneMapping:
			toneMappingName = 'ACESFilmic';
			break;

		case AgXToneMapping:
			toneMappingName = 'AgX';
			break;

		case NeutralToneMapping:
			toneMappingName = 'Neutral';
			break;

		case CustomToneMapping:
			toneMappingName = 'Custom';
			break;

		default:
			console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
			toneMappingName = 'Linear';

	}

	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

}

function generateVertexExtensions( parameters ) {

	const chunks = [
		parameters.extensionClipCullDistance ? '#extension GL_ANGLE_clip_cull_distance : require' : '',
		parameters.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : '',
	];

	return chunks.filter( filterEmptyLine ).join( '\n' );

}

function generateDefines( defines ) {

	const chunks = [];

	for ( const name in defines ) {

		const value = defines[ name ];

		if ( value === false ) continue;

		chunks.push( '#define ' + name + ' ' + value );

	}

	return chunks.join( '\n' );

}

function fetchAttributeLocations( gl, program ) {

	const attributes = {};

	const n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

	for ( let i = 0; i < n; i ++ ) {

		const info = gl.getActiveAttrib( program, i );
		const name = info.name;

		let locationSize = 1;
		if ( info.type === gl.FLOAT_MAT2 ) locationSize = 2;
		if ( info.type === gl.FLOAT_MAT3 ) locationSize = 3;
		if ( info.type === gl.FLOAT_MAT4 ) locationSize = 4;

		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

		attributes[ name ] = {
			type: info.type,
			location: gl.getAttribLocation( program, name ),
			locationSize: locationSize
		};

	}

	return attributes;

}

function filterEmptyLine( string ) {

	return string !== '';

}

function replaceLightNums( string, parameters ) {

	const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;

	return string
		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		.replace( /NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps )
		.replace( /NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords )
		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
		.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
		.replace( /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps )
		.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
		.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

}

function replaceClippingPlaneNums( string, parameters ) {

	return string
		.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
		.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

}

// Resolve Includes

const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes( string ) {

	return string.replace( includePattern, includeReplacer );

}

const shaderChunkMap = new Map();

function includeReplacer( match, include ) {

	let string = ShaderChunk[ include ];

	if ( string === undefined ) {

		const newInclude = shaderChunkMap.get( include );

		if ( newInclude !== undefined ) {

			string = ShaderChunk[ newInclude ];
			console.warn( 'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude );

		} else {

			throw new Error( 'Can not resolve #include <' + include + '>' );

		}

	}

	return resolveIncludes( string );

}

// Unroll Loops

const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function unrollLoops( string ) {

	return string.replace( unrollLoopPattern, loopReplacer );

}

function loopReplacer( match, start, end, snippet ) {

	let string = '';

	for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

		string += snippet
			.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
			.replace( /UNROLLED_LOOP_INDEX/g, i );

	}

	return string;

}

//

function generatePrecision( parameters ) {

	let precisionstring = `precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	precision ${parameters.precision} sampler3D;
	precision ${parameters.precision} sampler2DArray;
	precision ${parameters.precision} sampler2DShadow;
	precision ${parameters.precision} samplerCubeShadow;
	precision ${parameters.precision} sampler2DArrayShadow;
	precision ${parameters.precision} isampler2D;
	precision ${parameters.precision} isampler3D;
	precision ${parameters.precision} isamplerCube;
	precision ${parameters.precision} isampler2DArray;
	precision ${parameters.precision} usampler2D;
	precision ${parameters.precision} usampler3D;
	precision ${parameters.precision} usamplerCube;
	precision ${parameters.precision} usampler2DArray;
	`;

	if ( parameters.precision === 'highp' ) {

		precisionstring += '\n#define HIGH_PRECISION';

	} else if ( parameters.precision === 'mediump' ) {

		precisionstring += '\n#define MEDIUM_PRECISION';

	} else if ( parameters.precision === 'lowp' ) {

		precisionstring += '\n#define LOW_PRECISION';

	}

	return precisionstring;

}

function generateShadowMapTypeDefine( parameters ) {

	let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	if ( parameters.shadowMapType === PCFShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

	} else if ( parameters.shadowMapType === VSMShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

	}

	return shadowMapTypeDefine;

}

function generateEnvMapTypeDefine( parameters ) {

	let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;

			case CubeUVReflectionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;

		}

	}

	return envMapTypeDefine;

}

function generateEnvMapModeDefine( parameters ) {

	let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeRefractionMapping:

				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;

		}

	}

	return envMapModeDefine;

}

function generateEnvMapBlendingDefine( parameters ) {

	let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

	if ( parameters.envMap ) {

		switch ( parameters.combine ) {

			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;

			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;

			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;

		}

	}

	return envMapBlendingDefine;

}

function generateCubeUVSize( parameters ) {

	const imageHeight = parameters.envMapCubeUVHeight;

	if ( imageHeight === null ) return null;

	const maxMip = Math.log2( imageHeight ) - 2;

	const texelHeight = 1.0 / imageHeight;

	const texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );

	return { texelWidth, texelHeight, maxMip };

}

function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

	// TODO Send this event to Three.js DevTools
	// console.log( 'WebGLProgram', cacheKey );

	const gl = renderer.getContext();

	const defines = parameters.defines;

	let vertexShader = parameters.vertexShader;
	let fragmentShader = parameters.fragmentShader;

	const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
	const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
	const envMapModeDefine = generateEnvMapModeDefine( parameters );
	const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );
	const envMapCubeUVSize = generateCubeUVSize( parameters );

	const customVertexExtensions = generateVertexExtensions( parameters );

	const customDefines = generateDefines( defines );

	const program = gl.createProgram();

	let prefixVertex, prefixFragment;
	let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

	if ( parameters.isRawShaderMaterial ) {

		prefixVertex = [

			'#define SHADER_TYPE ' + parameters.shaderType,
			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixVertex.length > 0 ) {

			prefixVertex += '\n';

		}

		prefixFragment = [

			'#define SHADER_TYPE ' + parameters.shaderType,
			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixFragment.length > 0 ) {

			prefixFragment += '\n';

		}

	} else {

		prefixVertex = [

			generatePrecision( parameters ),

			'#define SHADER_TYPE ' + parameters.shaderType,
			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',
			parameters.batching ? '#define USE_BATCHING' : '',
			parameters.instancing ? '#define USE_INSTANCING' : '',
			parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
			parameters.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',

			parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
			parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
			parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
			parameters.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',

			parameters.anisotropy ? '#define USE_ANISOTROPY' : '',
			parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',

			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

			parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
			parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
			parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',

			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.alphaHash ? '#define USE_ALPHAHASH' : '',

			parameters.transmission ? '#define USE_TRANSMISSION' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

			parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
			parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',

			//

			parameters.mapUv ? '#define MAP_UV ' + parameters.mapUv : '',
			parameters.alphaMapUv ? '#define ALPHAMAP_UV ' + parameters.alphaMapUv : '',
			parameters.lightMapUv ? '#define LIGHTMAP_UV ' + parameters.lightMapUv : '',
			parameters.aoMapUv ? '#define AOMAP_UV ' + parameters.aoMapUv : '',
			parameters.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + parameters.emissiveMapUv : '',
			parameters.bumpMapUv ? '#define BUMPMAP_UV ' + parameters.bumpMapUv : '',
			parameters.normalMapUv ? '#define NORMALMAP_UV ' + parameters.normalMapUv : '',
			parameters.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + parameters.displacementMapUv : '',

			parameters.metalnessMapUv ? '#define METALNESSMAP_UV ' + parameters.metalnessMapUv : '',
			parameters.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + parameters.roughnessMapUv : '',

			parameters.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + parameters.anisotropyMapUv : '',

			parameters.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + parameters.clearcoatMapUv : '',
			parameters.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + parameters.clearcoatNormalMapUv : '',
			parameters.clearcoatRoughnessMapUv ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + parameters.clearcoatRoughnessMapUv : '',

			parameters.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + parameters.iridescenceMapUv : '',
			parameters.iridescenceThicknessMapUv ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + parameters.iridescenceThicknessMapUv : '',

			parameters.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + parameters.sheenColorMapUv : '',
			parameters.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + parameters.sheenRoughnessMapUv : '',

			parameters.specularMapUv ? '#define SPECULARMAP_UV ' + parameters.specularMapUv : '',
			parameters.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + parameters.specularColorMapUv : '',
			parameters.specularIntensityMapUv ? '#define SPECULAR_INTENSITYMAP_UV ' + parameters.specularIntensityMapUv : '',

			parameters.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + parameters.transmissionMapUv : '',
			parameters.thicknessMapUv ? '#define THICKNESSMAP_UV ' + parameters.thicknessMapUv : '',

			//

			parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',
			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			parameters.vertexUv1s ? '#define USE_UV1' : '',
			parameters.vertexUv2s ? '#define USE_UV2' : '',
			parameters.vertexUv3s ? '#define USE_UV3' : '',

			parameters.pointsUvs ? '#define USE_POINTS_UV' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.skinning ? '#define USE_SKINNING' : '',

			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			( parameters.morphColors ) ? '#define USE_MORPHCOLORS' : '',
			( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_TEXTURE' : '',
			( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',
			( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',
			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

			parameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',

			parameters.useLegacyLights ? '#define LEGACY_LIGHTS' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',

			'uniform mat4 modelMatrix;',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			'#ifdef USE_INSTANCING',

			'	attribute mat4 instanceMatrix;',

			'#endif',

			'#ifdef USE_INSTANCING_COLOR',

			'	attribute vec3 instanceColor;',

			'#endif',

			'#ifdef USE_INSTANCING_MORPH',

			'	uniform sampler2D morphTexture;',

			'#endif',

			'attribute vec3 position;',
			'attribute vec3 normal;',
			'attribute vec2 uv;',

			'#ifdef USE_UV1',

			'	attribute vec2 uv1;',

			'#endif',

			'#ifdef USE_UV2',

			'	attribute vec2 uv2;',

			'#endif',

			'#ifdef USE_UV3',

			'	attribute vec2 uv3;',

			'#endif',

			'#ifdef USE_TANGENT',

			'	attribute vec4 tangent;',

			'#endif',

			'#if defined( USE_COLOR_ALPHA )',

			'	attribute vec4 color;',

			'#elif defined( USE_COLOR )',

			'	attribute vec3 color;',

			'#endif',

			'#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',

			'	attribute vec3 morphTarget0;',
			'	attribute vec3 morphTarget1;',
			'	attribute vec3 morphTarget2;',
			'	attribute vec3 morphTarget3;',

			'	#ifdef USE_MORPHNORMALS',

			'		attribute vec3 morphNormal0;',
			'		attribute vec3 morphNormal1;',
			'		attribute vec3 morphNormal2;',
			'		attribute vec3 morphNormal3;',

			'	#else',

			'		attribute vec3 morphTarget4;',
			'		attribute vec3 morphTarget5;',
			'		attribute vec3 morphTarget6;',
			'		attribute vec3 morphTarget7;',

			'	#endif',

			'#endif',

			'#ifdef USE_SKINNING',

			'	attribute vec4 skinIndex;',
			'	attribute vec4 skinWeight;',

			'#endif',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			generatePrecision( parameters ),

			'#define SHADER_TYPE ' + parameters.shaderType,
			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
			parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

			parameters.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',
			parameters.map ? '#define USE_MAP' : '',
			parameters.matcap ? '#define USE_MATCAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapTypeDefine : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',
			envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',
			envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
			parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',

			parameters.anisotropy ? '#define USE_ANISOTROPY' : '',
			parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',

			parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

			parameters.dispersion ? '#define USE_DISPERSION' : '',

			parameters.iridescence ? '#define USE_IRIDESCENCE' : '',
			parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
			parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
			parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',

			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',

			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.alphaTest ? '#define USE_ALPHATEST' : '',
			parameters.alphaHash ? '#define USE_ALPHAHASH' : '',

			parameters.sheen ? '#define USE_SHEEN' : '',
			parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
			parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',

			parameters.transmission ? '#define USE_TRANSMISSION' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

			parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',
			parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			parameters.vertexUv1s ? '#define USE_UV1' : '',
			parameters.vertexUv2s ? '#define USE_UV2' : '',
			parameters.vertexUv3s ? '#define USE_UV3' : '',

			parameters.pointsUvs ? '#define USE_POINTS_UV' : '',

			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

			parameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',

			parameters.useLegacyLights ? '#define LEGACY_LIGHTS' : '',

			parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',

			'uniform mat4 viewMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

			parameters.dithering ? '#define DITHERING' : '',
			parameters.opaque ? '#define OPAQUE' : '',

			ShaderChunk[ 'colorspace_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
			getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputColorSpace ),

			parameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	}

	vertexShader = resolveIncludes( vertexShader );
	vertexShader = replaceLightNums( vertexShader, parameters );
	vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

	fragmentShader = resolveIncludes( fragmentShader );
	fragmentShader = replaceLightNums( fragmentShader, parameters );
	fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

	vertexShader = unrollLoops( vertexShader );
	fragmentShader = unrollLoops( fragmentShader );

	if ( parameters.isRawShaderMaterial !== true ) {

		// GLSL 3.0 conversion for built-in materials and ShaderMaterial

		versionString = '#version 300 es\n';

		prefixVertex = [
			customVertexExtensions,
			'#define attribute in',
			'#define varying out',
			'#define texture2D texture'
		].join( '\n' ) + '\n' + prefixVertex;

		prefixFragment = [
			'#define varying in',
			( parameters.glslVersion === GLSL3 ) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
			( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
			'#define gl_FragDepthEXT gl_FragDepth',
			'#define texture2D texture',
			'#define textureCube texture',
			'#define texture2DProj textureProj',
			'#define texture2DLodEXT textureLod',
			'#define texture2DProjLodEXT textureProjLod',
			'#define textureCubeLodEXT textureLod',
			'#define texture2DGradEXT textureGrad',
			'#define texture2DProjGradEXT textureProjGrad',
			'#define textureCubeGradEXT textureGrad'
		].join( '\n' ) + '\n' + prefixFragment;

	}

	const vertexGlsl = versionString + prefixVertex + vertexShader;
	const fragmentGlsl = versionString + prefixFragment + fragmentShader;

	// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );

	const glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
	const glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

	gl.attachShader( program, glVertexShader );
	gl.attachShader( program, glFragmentShader );

	// Force a particular attribute to index 0.

	if ( parameters.index0AttributeName !== undefined ) {

		gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

	} else if ( parameters.morphTargets === true ) {

		// programs with morphTargets displace position out of attribute 0
		gl.bindAttribLocation( program, 0, 'position' );

	}

	gl.linkProgram( program );

	function onFirstUse( self ) {

		// check for link errors
		if ( renderer.debug.checkShaderErrors ) {

			const programLog = gl.getProgramInfoLog( program ).trim();
			const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
			const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

			let runnable = true;
			let haveDiagnostics = true;

			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

				runnable = false;

				if ( typeof renderer.debug.onShaderError === 'function' ) {

					renderer.debug.onShaderError( gl, program, glVertexShader, glFragmentShader );

				} else {

					// default error reporting

					const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
					const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

					console.error(
						'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
						'VALIDATE_STATUS ' + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + '\n\n' +
						'Material Name: ' + self.name + '\n' +
						'Material Type: ' + self.type + '\n\n' +
						'Program Info Log: ' + programLog + '\n' +
						vertexErrors + '\n' +
						fragmentErrors
					);

				}

			} else if ( programLog !== '' ) {

				console.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );

			} else if ( vertexLog === '' || fragmentLog === '' ) {

				haveDiagnostics = false;

			}

			if ( haveDiagnostics ) {

				self.diagnostics = {

					runnable: runnable,

					programLog: programLog,

					vertexShader: {

						log: vertexLog,
						prefix: prefixVertex

					},

					fragmentShader: {

						log: fragmentLog,
						prefix: prefixFragment

					}

				};

			}

		}

		// Clean up

		// Crashes in iOS9 and iOS10. #18402
		// gl.detachShader( program, glVertexShader );
		// gl.detachShader( program, glFragmentShader );

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		cachedUniforms = new WebGLUniforms( gl, program );
		cachedAttributes = fetchAttributeLocations( gl, program );

	}

	// set up caching for uniform locations

	let cachedUniforms;

	this.getUniforms = function () {

		if ( cachedUniforms === undefined ) {

			// Populates cachedUniforms and cachedAttributes
			onFirstUse( this );

		}

		return cachedUniforms;

	};

	// set up caching for attribute locations

	let cachedAttributes;

	this.getAttributes = function () {

		if ( cachedAttributes === undefined ) {

			// Populates cachedAttributes and cachedUniforms
			onFirstUse( this );

		}

		return cachedAttributes;

	};

	// indicate when the program is ready to be used. if the KHR_parallel_shader_compile extension isn't supported,
	// flag the program as ready immediately. It may cause a stall when it's first used.

	let programReady = ( parameters.rendererExtensionParallelShaderCompile === false );

	this.isReady = function () {

		if ( programReady === false ) {

			programReady = gl.getProgramParameter( program, COMPLETION_STATUS_KHR );

		}

		return programReady;

	};

	// free resource

	this.destroy = function () {

		bindingStates.releaseStatesOfProgram( this );

		gl.deleteProgram( program );
		this.program = undefined;

	};

	//

	this.type = parameters.shaderType;
	this.name = parameters.shaderName;
	this.id = programIdCount ++;
	this.cacheKey = cacheKey;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;

	return this;

}

let _id$1 = 0;

class WebGLShaderCache {

	constructor() {

		this.shaderCache = new Map();
		this.materialCache = new Map();

	}

	update( material ) {

		const vertexShader = material.vertexShader;
		const fragmentShader = material.fragmentShader;

		const vertexShaderStage = this._getShaderStage( vertexShader );
		const fragmentShaderStage = this._getShaderStage( fragmentShader );

		const materialShaders = this._getShaderCacheForMaterial( material );

		if ( materialShaders.has( vertexShaderStage ) === false ) {

			materialShaders.add( vertexShaderStage );
			vertexShaderStage.usedTimes ++;

		}

		if ( materialShaders.has( fragmentShaderStage ) === false ) {

			materialShaders.add( fragmentShaderStage );
			fragmentShaderStage.usedTimes ++;

		}

		return this;

	}

	remove( material ) {

		const materialShaders = this.materialCache.get( material );

		for ( const shaderStage of materialShaders ) {

			shaderStage.usedTimes --;

			if ( shaderStage.usedTimes === 0 ) this.shaderCache.delete( shaderStage.code );

		}

		this.materialCache.delete( material );

		return this;

	}

	getVertexShaderID( material ) {

		return this._getShaderStage( material.vertexShader ).id;

	}

	getFragmentShaderID( material ) {

		return this._getShaderStage( material.fragmentShader ).id;

	}

	dispose() {

		this.shaderCache.clear();
		this.materialCache.clear();

	}

	_getShaderCacheForMaterial( material ) {

		const cache = this.materialCache;
		let set = cache.get( material );

		if ( set === undefined ) {

			set = new Set();
			cache.set( material, set );

		}

		return set;

	}

	_getShaderStage( code ) {

		const cache = this.shaderCache;
		let stage = cache.get( code );

		if ( stage === undefined ) {

			stage = new WebGLShaderStage( code );
			cache.set( code, stage );

		}

		return stage;

	}

}

class WebGLShaderStage {

	constructor( code ) {

		this.id = _id$1 ++;

		this.code = code;
		this.usedTimes = 0;

	}

}

function WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {

	const _programLayers = new Layers();
	const _customShaders = new WebGLShaderCache();
	const _activeChannels = new Set();
	const programs = [];

	const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
	const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;

	let precision = capabilities.precision;

	const shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'toon',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		MeshMatcapMaterial: 'matcap',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow',
		SpriteMaterial: 'sprite'
	};

	function getChannel( value ) {

		_activeChannels.add( value );

		if ( value === 0 ) return 'uv';

		return `uv${ value }`;

	}

	function getParameters( material, lights, shadows, scene, object ) {

		const fog = scene.fog;
		const geometry = object.geometry;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;

		const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
		const envMapCubeUVHeight = ( !! envMap ) && ( envMap.mapping === CubeUVReflectionMapping ) ? envMap.image.height : null;

		const shaderID = shaderIDs[ material.type ];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		//

		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

		let morphTextureStride = 0;

		if ( geometry.morphAttributes.position !== undefined ) morphTextureStride = 1;
		if ( geometry.morphAttributes.normal !== undefined ) morphTextureStride = 2;
		if ( geometry.morphAttributes.color !== undefined ) morphTextureStride = 3;

		//

		let vertexShader, fragmentShader;
		let customVertexShaderID, customFragmentShaderID;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];

			vertexShader = shader.vertexShader;
			fragmentShader = shader.fragmentShader;

		} else {

			vertexShader = material.vertexShader;
			fragmentShader = material.fragmentShader;

			_customShaders.update( material );

			customVertexShaderID = _customShaders.getVertexShaderID( material );
			customFragmentShaderID = _customShaders.getFragmentShaderID( material );

		}

		const currentRenderTarget = renderer.getRenderTarget();

		const IS_INSTANCEDMESH = object.isInstancedMesh === true;
		const IS_BATCHEDMESH = object.isBatchedMesh === true;

		const HAS_MAP = !! material.map;
		const HAS_MATCAP = !! material.matcap;
		const HAS_ENVMAP = !! envMap;
		const HAS_AOMAP = !! material.aoMap;
		const HAS_LIGHTMAP = !! material.lightMap;
		const HAS_BUMPMAP = !! material.bumpMap;
		const HAS_NORMALMAP = !! material.normalMap;
		const HAS_DISPLACEMENTMAP = !! material.displacementMap;
		const HAS_EMISSIVEMAP = !! material.emissiveMap;

		const HAS_METALNESSMAP = !! material.metalnessMap;
		const HAS_ROUGHNESSMAP = !! material.roughnessMap;

		const HAS_ANISOTROPY = material.anisotropy > 0;
		const HAS_CLEARCOAT = material.clearcoat > 0;
		const HAS_DISPERSION = material.dispersion > 0;
		const HAS_IRIDESCENCE = material.iridescence > 0;
		const HAS_SHEEN = material.sheen > 0;
		const HAS_TRANSMISSION = material.transmission > 0;

		const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !! material.anisotropyMap;

		const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !! material.clearcoatMap;
		const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !! material.clearcoatNormalMap;
		const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !! material.clearcoatRoughnessMap;

		const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !! material.iridescenceMap;
		const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !! material.iridescenceThicknessMap;

		const HAS_SHEEN_COLORMAP = HAS_SHEEN && !! material.sheenColorMap;
		const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !! material.sheenRoughnessMap;

		const HAS_SPECULARMAP = !! material.specularMap;
		const HAS_SPECULAR_COLORMAP = !! material.specularColorMap;
		const HAS_SPECULAR_INTENSITYMAP = !! material.specularIntensityMap;

		const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !! material.transmissionMap;
		const HAS_THICKNESSMAP = HAS_TRANSMISSION && !! material.thicknessMap;

		const HAS_GRADIENTMAP = !! material.gradientMap;

		const HAS_ALPHAMAP = !! material.alphaMap;

		const HAS_ALPHATEST = material.alphaTest > 0;

		const HAS_ALPHAHASH = !! material.alphaHash;

		const HAS_EXTENSIONS = !! material.extensions;

		let toneMapping = NoToneMapping;

		if ( material.toneMapped ) {

			if ( currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true ) {

				toneMapping = renderer.toneMapping;

			}

		}

		const parameters = {

			shaderID: shaderID,
			shaderType: material.type,
			shaderName: material.name,

			vertexShader: vertexShader,
			fragmentShader: fragmentShader,
			defines: material.defines,

			customVertexShaderID: customVertexShaderID,
			customFragmentShaderID: customFragmentShaderID,

			isRawShaderMaterial: material.isRawShaderMaterial === true,
			glslVersion: material.glslVersion,

			precision: precision,

			batching: IS_BATCHEDMESH,
			instancing: IS_INSTANCEDMESH,
			instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
			instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,

			supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
			outputColorSpace: ( currentRenderTarget === null ) ? renderer.outputColorSpace : ( currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace ),
			alphaToCoverage: !! material.alphaToCoverage,

			map: HAS_MAP,
			matcap: HAS_MATCAP,
			envMap: HAS_ENVMAP,
			envMapMode: HAS_ENVMAP && envMap.mapping,
			envMapCubeUVHeight: envMapCubeUVHeight,
			aoMap: HAS_AOMAP,
			lightMap: HAS_LIGHTMAP,
			bumpMap: HAS_BUMPMAP,
			normalMap: HAS_NORMALMAP,
			displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
			emissiveMap: HAS_EMISSIVEMAP,

			normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
			normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,

			metalnessMap: HAS_METALNESSMAP,
			roughnessMap: HAS_ROUGHNESSMAP,

			anisotropy: HAS_ANISOTROPY,
			anisotropyMap: HAS_ANISOTROPYMAP,

			clearcoat: HAS_CLEARCOAT,
			clearcoatMap: HAS_CLEARCOATMAP,
			clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
			clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,

			dispersion: HAS_DISPERSION,

			iridescence: HAS_IRIDESCENCE,
			iridescenceMap: HAS_IRIDESCENCEMAP,
			iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,

			sheen: HAS_SHEEN,
			sheenColorMap: HAS_SHEEN_COLORMAP,
			sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,

			specularMap: HAS_SPECULARMAP,
			specularColorMap: HAS_SPECULAR_COLORMAP,
			specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,

			transmission: HAS_TRANSMISSION,
			transmissionMap: HAS_TRANSMISSIONMAP,
			thicknessMap: HAS_THICKNESSMAP,

			gradientMap: HAS_GRADIENTMAP,

			opaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,

			alphaMap: HAS_ALPHAMAP,
			alphaTest: HAS_ALPHATEST,
			alphaHash: HAS_ALPHAHASH,

			combine: material.combine,

			//

			mapUv: HAS_MAP && getChannel( material.map.channel ),
			aoMapUv: HAS_AOMAP && getChannel( material.aoMap.channel ),
			lightMapUv: HAS_LIGHTMAP && getChannel( material.lightMap.channel ),
			bumpMapUv: HAS_BUMPMAP && getChannel( material.bumpMap.channel ),
			normalMapUv: HAS_NORMALMAP && getChannel( material.normalMap.channel ),
			displacementMapUv: HAS_DISPLACEMENTMAP && getChannel( material.displacementMap.channel ),
			emissiveMapUv: HAS_EMISSIVEMAP && getChannel( material.emissiveMap.channel ),

			metalnessMapUv: HAS_METALNESSMAP && getChannel( material.metalnessMap.channel ),
			roughnessMapUv: HAS_ROUGHNESSMAP && getChannel( material.roughnessMap.channel ),

			anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel( material.anisotropyMap.channel ),

			clearcoatMapUv: HAS_CLEARCOATMAP && getChannel( material.clearcoatMap.channel ),
			clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel( material.clearcoatNormalMap.channel ),
			clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel( material.clearcoatRoughnessMap.channel ),

			iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel( material.iridescenceMap.channel ),
			iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel( material.iridescenceThicknessMap.channel ),

			sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel( material.sheenColorMap.channel ),
			sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel( material.sheenRoughnessMap.channel ),

			specularMapUv: HAS_SPECULARMAP && getChannel( material.specularMap.channel ),
			specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel( material.specularColorMap.channel ),
			specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel( material.specularIntensityMap.channel ),

			transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel( material.transmissionMap.channel ),
			thicknessMapUv: HAS_THICKNESSMAP && getChannel( material.thicknessMap.channel ),

			alphaMapUv: HAS_ALPHAMAP && getChannel( material.alphaMap.channel ),

			//

			vertexTangents: !! geometry.attributes.tangent && ( HAS_NORMALMAP || HAS_ANISOTROPY ),
			vertexColors: material.vertexColors,
			vertexAlphas: material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4,

			pointsUvs: object.isPoints === true && !! geometry.attributes.uv && ( HAS_MAP || HAS_ALPHAMAP ),

			fog: !! fog,
			useFog: material.fog === true,
			fogExp2: ( !! fog && fog.isFogExp2 ),

			flatShading: material.flatShading === true,

			sizeAttenuation: material.sizeAttenuation === true,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			skinning: object.isSkinnedMesh === true,

			morphTargets: geometry.morphAttributes.position !== undefined,
			morphNormals: geometry.morphAttributes.normal !== undefined,
			morphColors: geometry.morphAttributes.color !== undefined,
			morphTargetsCount: morphTargetsCount,
			morphTextureStride: morphTextureStride,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numSpotLightMaps: lights.spotLightMap.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,

			numDirLightShadows: lights.directionalShadowMap.length,
			numPointLightShadows: lights.pointShadowMap.length,
			numSpotLightShadows: lights.spotShadowMap.length,
			numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,

			numLightProbes: lights.numLightProbes,

			numClippingPlanes: clipping.numPlanes,
			numClipIntersection: clipping.numIntersection,

			dithering: material.dithering,

			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: toneMapping,
			useLegacyLights: renderer._useLegacyLights,

			decodeVideoTexture: HAS_MAP && ( material.map.isVideoTexture === true ) && ( ColorManagement.getTransfer( material.map.colorSpace ) === SRGBTransfer ),

			premultipliedAlpha: material.premultipliedAlpha,

			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,

			useDepthPacking: material.depthPacking >= 0,
			depthPacking: material.depthPacking || 0,

			index0AttributeName: material.index0AttributeName,

			extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has( 'WEBGL_clip_cull_distance' ),
			extensionMultiDraw: HAS_EXTENSIONS && material.extensions.multiDraw === true && extensions.has( 'WEBGL_multi_draw' ),

			rendererExtensionParallelShaderCompile: extensions.has( 'KHR_parallel_shader_compile' ),

			customProgramCacheKey: material.customProgramCacheKey()

		};

		// the usage of getChannel() determines the active texture channels for this shader

		parameters.vertexUv1s = _activeChannels.has( 1 );
		parameters.vertexUv2s = _activeChannels.has( 2 );
		parameters.vertexUv3s = _activeChannels.has( 3 );

		_activeChannels.clear();

		return parameters;

	}

	function getProgramCacheKey( parameters ) {

		const array = [];

		if ( parameters.shaderID ) {

			array.push( parameters.shaderID );

		} else {

			array.push( parameters.customVertexShaderID );
			array.push( parameters.customFragmentShaderID );

		}

		if ( parameters.defines !== undefined ) {

			for ( const name in parameters.defines ) {

				array.push( name );
				array.push( parameters.defines[ name ] );

			}

		}

		if ( parameters.isRawShaderMaterial === false ) {

			getProgramCacheKeyParameters( array, parameters );
			getProgramCacheKeyBooleans( array, parameters );
			array.push( renderer.outputColorSpace );

		}

		array.push( parameters.customProgramCacheKey );

		return array.join();

	}

	function getProgramCacheKeyParameters( array, parameters ) {

		array.push( parameters.precision );
		array.push( parameters.outputColorSpace );
		array.push( parameters.envMapMode );
		array.push( parameters.envMapCubeUVHeight );
		array.push( parameters.mapUv );
		array.push( parameters.alphaMapUv );
		array.push( parameters.lightMapUv );
		array.push( parameters.aoMapUv );
		array.push( parameters.bumpMapUv );
		array.push( parameters.normalMapUv );
		array.push( parameters.displacementMapUv );
		array.push( parameters.emissiveMapUv );
		array.push( parameters.metalnessMapUv );
		array.push( parameters.roughnessMapUv );
		array.push( parameters.anisotropyMapUv );
		array.push( parameters.clearcoatMapUv );
		array.push( parameters.clearcoatNormalMapUv );
		array.push( parameters.clearcoatRoughnessMapUv );
		array.push( parameters.iridescenceMapUv );
		array.push( parameters.iridescenceThicknessMapUv );
		array.push( parameters.sheenColorMapUv );
		array.push( parameters.sheenRoughnessMapUv );
		array.push( parameters.specularMapUv );
		array.push( parameters.specularColorMapUv );
		array.push( parameters.specularIntensityMapUv );
		array.push( parameters.transmissionMapUv );
		array.push( parameters.thicknessMapUv );
		array.push( parameters.combine );
		array.push( parameters.fogExp2 );
		array.push( parameters.sizeAttenuation );
		array.push( parameters.morphTargetsCount );
		array.push( parameters.morphAttributeCount );
		array.push( parameters.numDirLights );
		array.push( parameters.numPointLights );
		array.push( parameters.numSpotLights );
		array.push( parameters.numSpotLightMaps );
		array.push( parameters.numHemiLights );
		array.push( parameters.numRectAreaLights );
		array.push( parameters.numDirLightShadows );
		array.push( parameters.numPointLightShadows );
		array.push( parameters.numSpotLightShadows );
		array.push( parameters.numSpotLightShadowsWithMaps );
		array.push( parameters.numLightProbes );
		array.push( parameters.shadowMapType );
		array.push( parameters.toneMapping );
		array.push( parameters.numClippingPlanes );
		array.push( parameters.numClipIntersection );
		array.push( parameters.depthPacking );

	}

	function getProgramCacheKeyBooleans( array, parameters ) {

		_programLayers.disableAll();

		if ( parameters.supportsVertexTextures )
			_programLayers.enable( 0 );
		if ( parameters.instancing )
			_programLayers.enable( 1 );
		if ( parameters.instancingColor )
			_programLayers.enable( 2 );
		if ( parameters.instancingMorph )
			_programLayers.enable( 3 );
		if ( parameters.matcap )
			_programLayers.enable( 4 );
		if ( parameters.envMap )
			_programLayers.enable( 5 );
		if ( parameters.normalMapObjectSpace )
			_programLayers.enable( 6 );
		if ( parameters.normalMapTangentSpace )
			_programLayers.enable( 7 );
		if ( parameters.clearcoat )
			_programLayers.enable( 8 );
		if ( parameters.iridescence )
			_programLayers.enable( 9 );
		if ( parameters.alphaTest )
			_programLayers.enable( 10 );
		if ( parameters.vertexColors )
			_programLayers.enable( 11 );
		if ( parameters.vertexAlphas )
			_programLayers.enable( 12 );
		if ( parameters.vertexUv1s )
			_programLayers.enable( 13 );
		if ( parameters.vertexUv2s )
			_programLayers.enable( 14 );
		if ( parameters.vertexUv3s )
			_programLayers.enable( 15 );
		if ( parameters.vertexTangents )
			_programLayers.enable( 16 );
		if ( parameters.anisotropy )
			_programLayers.enable( 17 );
		if ( parameters.alphaHash )
			_programLayers.enable( 18 );
		if ( parameters.batching )
			_programLayers.enable( 19 );
		if ( parameters.dispersion )
			_programLayers.enable( 20 );

		array.push( _programLayers.mask );
		_programLayers.disableAll();

		if ( parameters.fog )
			_programLayers.enable( 0 );
		if ( parameters.useFog )
			_programLayers.enable( 1 );
		if ( parameters.flatShading )
			_programLayers.enable( 2 );
		if ( parameters.logarithmicDepthBuffer )
			_programLayers.enable( 3 );
		if ( parameters.skinning )
			_programLayers.enable( 4 );
		if ( parameters.morphTargets )
			_programLayers.enable( 5 );
		if ( parameters.morphNormals )
			_programLayers.enable( 6 );
		if ( parameters.morphColors )
			_programLayers.enable( 7 );
		if ( parameters.premultipliedAlpha )
			_programLayers.enable( 8 );
		if ( parameters.shadowMapEnabled )
			_programLayers.enable( 9 );
		if ( parameters.useLegacyLights )
			_programLayers.enable( 10 );
		if ( parameters.doubleSided )
			_programLayers.enable( 11 );
		if ( parameters.flipSided )
			_programLayers.enable( 12 );
		if ( parameters.useDepthPacking )
			_programLayers.enable( 13 );
		if ( parameters.dithering )
			_programLayers.enable( 14 );
		if ( parameters.transmission )
			_programLayers.enable( 15 );
		if ( parameters.sheen )
			_programLayers.enable( 16 );
		if ( parameters.opaque )
			_programLayers.enable( 17 );
		if ( parameters.pointsUvs )
			_programLayers.enable( 18 );
		if ( parameters.decodeVideoTexture )
			_programLayers.enable( 19 );
		if ( parameters.alphaToCoverage )
			_programLayers.enable( 20 );

		array.push( _programLayers.mask );

	}

	function getUniforms( material ) {

		const shaderID = shaderIDs[ material.type ];
		let uniforms;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];
			uniforms = UniformsUtils.clone( shader.uniforms );

		} else {

			uniforms = material.uniforms;

		}

		return uniforms;

	}

	function acquireProgram( parameters, cacheKey ) {

		let program;

		// Check if code has been already compiled
		for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

			const preexistingProgram = programs[ p ];

			if ( preexistingProgram.cacheKey === cacheKey ) {

				program = preexistingProgram;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
			programs.push( program );

		}

		return program;

	}

	function releaseProgram( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			const i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	}

	function releaseShaderCache( material ) {

		_customShaders.remove( material );

	}

	function dispose() {

		_customShaders.dispose();

	}

	return {
		getParameters: getParameters,
		getProgramCacheKey: getProgramCacheKey,
		getUniforms: getUniforms,
		acquireProgram: acquireProgram,
		releaseProgram: releaseProgram,
		releaseShaderCache: releaseShaderCache,
		// Exposed for resource monitoring & error feedback via renderer.info:
		programs: programs,
		dispose: dispose
	};

}

function WebGLProperties() {

	let properties = new WeakMap();

	function get( object ) {

		let map = properties.get( object );

		if ( map === undefined ) {

			map = {};
			properties.set( object, map );

		}

		return map;

	}

	function remove( object ) {

		properties.delete( object );

	}

	function update( object, key, value ) {

		properties.get( object )[ key ] = value;

	}

	function dispose() {

		properties = new WeakMap();

	}

	return {
		get: get,
		remove: remove,
		update: update,
		dispose: dispose
	};

}

function painterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.material.id !== b.material.id ) {

		return a.material.id - b.material.id;

	} else if ( a.z !== b.z ) {

		return a.z - b.z;

	} else {

		return a.id - b.id;

	}

}

function reversePainterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.z !== b.z ) {

		return b.z - a.z;

	} else {

		return a.id - b.id;

	}

}


function WebGLRenderList() {

	const renderItems = [];
	let renderItemsIndex = 0;

	const opaque = [];
	const transmissive = [];
	const transparent = [];

	function init() {

		renderItemsIndex = 0;

		opaque.length = 0;
		transmissive.length = 0;
		transparent.length = 0;

	}

	function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

		let renderItem = renderItems[ renderItemsIndex ];

		if ( renderItem === undefined ) {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group
			};

			renderItems[ renderItemsIndex ] = renderItem;

		} else {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;

		}

		renderItemsIndex ++;

		return renderItem;

	}

	function push( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		if ( material.transmission > 0.0 ) {

			transmissive.push( renderItem );

		} else if ( material.transparent === true ) {

			transparent.push( renderItem );

		} else {

			opaque.push( renderItem );

		}

	}

	function unshift( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		if ( material.transmission > 0.0 ) {

			transmissive.unshift( renderItem );

		} else if ( material.transparent === true ) {

			transparent.unshift( renderItem );

		} else {

			opaque.unshift( renderItem );

		}

	}

	function sort( customOpaqueSort, customTransparentSort ) {

		if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
		if ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );
		if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

	}

	function finish() {

		// Clear references from inactive renderItems in the list

		for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

			const renderItem = renderItems[ i ];

			if ( renderItem.id === null ) break;

			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.group = null;

		}

	}

	return {

		opaque: opaque,
		transmissive: transmissive,
		transparent: transparent,

		init: init,
		push: push,
		unshift: unshift,
		finish: finish,

		sort: sort
	};

}

function WebGLRenderLists() {

	let lists = new WeakMap();

	function get( scene, renderCallDepth ) {

		const listArray = lists.get( scene );
		let list;

		if ( listArray === undefined ) {

			list = new WebGLRenderList();
			lists.set( scene, [ list ] );

		} else {

			if ( renderCallDepth >= listArray.length ) {

				list = new WebGLRenderList();
				listArray.push( list );

			} else {

				list = listArray[ renderCallDepth ];

			}

		}

		return list;

	}

	function dispose() {

		lists = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

function UniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3(),
						color: new Color()
					};
					break;

				case 'SpotLight':
					uniforms = {
						position: new Vector3(),
						direction: new Vector3(),
						color: new Color(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0
					};
					break;

				case 'PointLight':
					uniforms = {
						position: new Vector3(),
						color: new Color(),
						distance: 0,
						decay: 0
					};
					break;

				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3(),
						skyColor: new Color(),
						groundColor: new Color()
					};
					break;

				case 'RectAreaLight':
					uniforms = {
						color: new Color(),
						position: new Vector3(),
						halfWidth: new Vector3(),
						halfHeight: new Vector3()
					};
					break;

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}

function ShadowUniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'SpotLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'PointLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2(),
						shadowCameraNear: 1,
						shadowCameraFar: 1000
					};
					break;

				// TODO (abelnation): set RectAreaLight shadow uniforms

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}



let nextVersion = 0;

function shadowCastingAndTexturingLightsFirst( lightA, lightB ) {

	return ( lightB.castShadow ? 2 : 0 ) - ( lightA.castShadow ? 2 : 0 ) + ( lightB.map ? 1 : 0 ) - ( lightA.map ? 1 : 0 );

}

function WebGLLights( extensions ) {

	const cache = new UniformsCache();

	const shadowCache = ShadowUniformsCache();

	const state = {

		version: 0,

		hash: {
			directionalLength: - 1,
			pointLength: - 1,
			spotLength: - 1,
			rectAreaLength: - 1,
			hemiLength: - 1,

			numDirectionalShadows: - 1,
			numPointShadows: - 1,
			numSpotShadows: - 1,
			numSpotMaps: - 1,

			numLightProbes: - 1
		},

		ambient: [ 0, 0, 0 ],
		probe: [],
		directional: [],
		directionalShadow: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotLightMap: [],
		spotShadow: [],
		spotShadowMap: [],
		spotLightMatrix: [],
		rectArea: [],
		rectAreaLTC1: null,
		rectAreaLTC2: null,
		point: [],
		pointShadow: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: [],
		numSpotLightShadowsWithMaps: 0,
		numLightProbes: 0

	};

	for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

	const vector3 = new Vector3();
	const matrix4 = new Matrix4();
	const matrix42 = new Matrix4();

	function setup( lights, useLegacyLights ) {

		let r = 0, g = 0, b = 0;

		for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		let numDirectionalShadows = 0;
		let numPointShadows = 0;
		let numSpotShadows = 0;
		let numSpotMaps = 0;
		let numSpotShadowsWithMaps = 0;

		let numLightProbes = 0;

		// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]
		lights.sort( shadowCastingAndTexturingLightsFirst );

		// artist-friendly light intensity scaling factor
		const scaleFactor = ( useLegacyLights === true ) ? Math.PI : 1;

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			const color = light.color;
			const intensity = light.intensity;
			const distance = light.distance;

			const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			if ( light.isAmbientLight ) {

				r += color.r * intensity * scaleFactor;
				g += color.g * intensity * scaleFactor;
				b += color.b * intensity * scaleFactor;

			} else if ( light.isLightProbe ) {

				for ( let j = 0; j < 9; j ++ ) {

					state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

				}

				numLightProbes ++;

			} else if ( light.isDirectionalLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.directionalShadow[ directionalLength ] = shadowUniforms;
					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

					numDirectionalShadows ++;

				}

				state.directional[ directionalLength ] = uniforms;

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = cache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );

				uniforms.color.copy( color ).multiplyScalar( intensity * scaleFactor );
				uniforms.distance = distance;

				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = light.decay;

				state.spot[ spotLength ] = uniforms;

				const shadow = light.shadow;

				if ( light.map ) {

					state.spotLightMap[ numSpotMaps ] = light.map;
					numSpotMaps ++;

					// make sure the lightMatrix is up to date
					// TODO : do it if required only
					shadow.updateMatrices( light );

					if ( light.castShadow ) numSpotShadowsWithMaps ++;

				}

				state.spotLightMatrix[ spotLength ] = shadow.matrix;

				if ( light.castShadow ) {

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.spotShadow[ spotLength ] = shadowUniforms;
					state.spotShadowMap[ spotLength ] = shadowMap;

					numSpotShadows ++;

				}

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( color ).multiplyScalar( intensity );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				state.rectArea[ rectAreaLength ] = uniforms;

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );
				uniforms.distance = light.distance;
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;
					shadowUniforms.shadowCameraNear = shadow.camera.near;
					shadowUniforms.shadowCameraFar = shadow.camera.far;

					state.pointShadow[ pointLength ] = shadowUniforms;
					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

					numPointShadows ++;

				}

				state.point[ pointLength ] = uniforms;

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = cache.get( light );

				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity * scaleFactor );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity * scaleFactor );

				state.hemi[ hemiLength ] = uniforms;

				hemiLength ++;

			}

		}

		if ( rectAreaLength > 0 ) {

			if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

				state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
				state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

			} else {

				state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
				state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

			}

		}

		state.ambient[ 0 ] = r;
		state.ambient[ 1 ] = g;
		state.ambient[ 2 ] = b;

		const hash = state.hash;

		if ( hash.directionalLength !== directionalLength ||
			hash.pointLength !== pointLength ||
			hash.spotLength !== spotLength ||
			hash.rectAreaLength !== rectAreaLength ||
			hash.hemiLength !== hemiLength ||
			hash.numDirectionalShadows !== numDirectionalShadows ||
			hash.numPointShadows !== numPointShadows ||
			hash.numSpotShadows !== numSpotShadows ||
			hash.numSpotMaps !== numSpotMaps ||
			hash.numLightProbes !== numLightProbes ) {

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			state.directionalShadow.length = numDirectionalShadows;
			state.directionalShadowMap.length = numDirectionalShadows;
			state.pointShadow.length = numPointShadows;
			state.pointShadowMap.length = numPointShadows;
			state.spotShadow.length = numSpotShadows;
			state.spotShadowMap.length = numSpotShadows;
			state.directionalShadowMatrix.length = numDirectionalShadows;
			state.pointShadowMatrix.length = numPointShadows;
			state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
			state.spotLightMap.length = numSpotMaps;
			state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
			state.numLightProbes = numLightProbes;

			hash.directionalLength = directionalLength;
			hash.pointLength = pointLength;
			hash.spotLength = spotLength;
			hash.rectAreaLength = rectAreaLength;
			hash.hemiLength = hemiLength;

			hash.numDirectionalShadows = numDirectionalShadows;
			hash.numPointShadows = numPointShadows;
			hash.numSpotShadows = numSpotShadows;
			hash.numSpotMaps = numSpotMaps;

			hash.numLightProbes = numLightProbes;

			state.version = nextVersion ++;

		}

	}

	function setupView( lights, camera ) {

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		const viewMatrix = camera.matrixWorldInverse;

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			if ( light.isDirectionalLight ) {

				const uniforms = state.directional[ directionalLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = state.spot[ spotLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = state.rectArea[ rectAreaLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				// extract local rotation of light to derive width/height half vectors
				matrix42.identity();
				matrix4.copy( light.matrixWorld );
				matrix4.premultiply( viewMatrix );
				matrix42.extractRotation( matrix4 );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				uniforms.halfWidth.applyMatrix4( matrix42 );
				uniforms.halfHeight.applyMatrix4( matrix42 );

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = state.point[ pointLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = state.hemi[ hemiLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );

				hemiLength ++;

			}

		}

	}

	return {
		setup: setup,
		setupView: setupView,
		state: state
	};

}

function WebGLRenderState( extensions ) {

	const lights = new WebGLLights( extensions );

	const lightsArray = [];
	const shadowsArray = [];

	function init( camera ) {

		state.camera = camera;

		lightsArray.length = 0;
		shadowsArray.length = 0;

	}

	function pushLight( light ) {

		lightsArray.push( light );

	}

	function pushShadow( shadowLight ) {

		shadowsArray.push( shadowLight );

	}

	function setupLights( useLegacyLights ) {

		lights.setup( lightsArray, useLegacyLights );

	}

	function setupLightsView( camera ) {

		lights.setupView( lightsArray, camera );

	}

	const state = {
		lightsArray: lightsArray,
		shadowsArray: shadowsArray,

		camera: null,

		lights: lights,

		transmissionRenderTarget: {}
	};

	return {
		init: init,
		state: state,
		setupLights: setupLights,
		setupLightsView: setupLightsView,

		pushLight: pushLight,
		pushShadow: pushShadow
	};

}

function WebGLRenderStates( extensions ) {

	let renderStates = new WeakMap();

	function get( scene, renderCallDepth = 0 ) {

		const renderStateArray = renderStates.get( scene );
		let renderState;

		if ( renderStateArray === undefined ) {

			renderState = new WebGLRenderState( extensions );
			renderStates.set( scene, [ renderState ] );

		} else {

			if ( renderCallDepth >= renderStateArray.length ) {

				renderState = new WebGLRenderState( extensions );
				renderStateArray.push( renderState );

			} else {

				renderState = renderStateArray[ renderCallDepth ];

			}

		}

		return renderState;

	}

	function dispose() {

		renderStates = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

class MeshDepthMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshDepthMaterial = true;

		this.type = 'MeshDepthMaterial';

		this.depthPacking = BasicDepthPacking;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.depthPacking = source.depthPacking;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	}

}

class MeshDistanceMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshDistanceMaterial = true;

		this.type = 'MeshDistanceMaterial';

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		return this;

	}

}

const vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

function WebGLShadowMap( renderer, objects, capabilities ) {

	let _frustum = new Frustum();

	const _shadowMapSize = new Vector2(),
		_viewportSize = new Vector2(),

		_viewport = new Vector4(),

		_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),
		_distanceMaterial = new MeshDistanceMaterial(),

		_materialCache = {},

		_maxTextureSize = capabilities.maxTextureSize;

	const shadowSide = { [ FrontSide ]: BackSide, [ BackSide ]: FrontSide, [ DoubleSide ]: DoubleSide };

	const shadowMaterialVertical = new ShaderMaterial( {
		defines: {
			VSM_SAMPLES: 8
		},
		uniforms: {
			shadow_pass: { value: null },
			resolution: { value: new Vector2() },
			radius: { value: 4.0 }
		},

		vertexShader: vertex,
		fragmentShader: fragment

	} );

	const shadowMaterialHorizontal = shadowMaterialVertical.clone();
	shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

	const fullScreenTri = new BufferGeometry();
	fullScreenTri.setAttribute(
		'position',
		new BufferAttribute(
			new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
			3
		)
	);

	const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

	const scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = PCFShadowMap;
	let _previousType = this.type;

	this.render = function ( lights, scene, camera ) {

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		if ( lights.length === 0 ) return;

		const currentRenderTarget = renderer.getRenderTarget();
		const activeCubeFace = renderer.getActiveCubeFace();
		const activeMipmapLevel = renderer.getActiveMipmapLevel();

		const _state = renderer.state;

		// Set GL state for depth map.
		_state.setBlending( NoBlending );
		_state.buffers.color.setClear( 1, 1, 1, 1 );
		_state.buffers.depth.setTest( true );
		_state.setScissorTest( false );

		// check for shadow map type changes

		const toVSM = ( _previousType !== VSMShadowMap && this.type === VSMShadowMap );
		const fromVSM = ( _previousType === VSMShadowMap && this.type !== VSMShadowMap );

		// render depth map

		for ( let i = 0, il = lights.length; i < il; i ++ ) {

			const light = lights[ i ];
			const shadow = light.shadow;

			if ( shadow === undefined ) {

				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				continue;

			}

			if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

			_shadowMapSize.copy( shadow.mapSize );

			const shadowFrameExtents = shadow.getFrameExtents();

			_shadowMapSize.multiply( shadowFrameExtents );

			_viewportSize.copy( shadow.mapSize );

			if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

				if ( _shadowMapSize.x > _maxTextureSize ) {

					_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
					shadow.mapSize.x = _viewportSize.x;

				}

				if ( _shadowMapSize.y > _maxTextureSize ) {

					_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
					shadow.mapSize.y = _viewportSize.y;

				}

			}

			if ( shadow.map === null || toVSM === true || fromVSM === true ) {

				const pars = ( this.type !== VSMShadowMap ) ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};

				if ( shadow.map !== null ) {

					shadow.map.dispose();

				}

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + '.shadowMap';

				shadow.camera.updateProjectionMatrix();

			}

			renderer.setRenderTarget( shadow.map );
			renderer.clear();

			const viewportCount = shadow.getViewportCount();

			for ( let vp = 0; vp < viewportCount; vp ++ ) {

				const viewport = shadow.getViewport( vp );

				_viewport.set(
					_viewportSize.x * viewport.x,
					_viewportSize.y * viewport.y,
					_viewportSize.x * viewport.z,
					_viewportSize.y * viewport.w
				);

				_state.viewport( _viewport );

				shadow.updateMatrices( light, vp );

				_frustum = shadow.getFrustum();

				renderObject( scene, camera, shadow.camera, light, this.type );

			}

			// do blur pass for VSM

			if ( shadow.isPointLightShadow !== true && this.type === VSMShadowMap ) {

				VSMPass( shadow, camera );

			}

			shadow.needsUpdate = false;

		}

		_previousType = this.type;

		scope.needsUpdate = false;

		renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

	};

	function VSMPass( shadow, camera ) {

		const geometry = objects.update( fullScreenMesh );

		if ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {

			shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
			shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;

			shadowMaterialVertical.needsUpdate = true;
			shadowMaterialHorizontal.needsUpdate = true;

		}

		if ( shadow.mapPass === null ) {

			shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );

		}

		// vertical pass

		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialVertical.uniforms.radius.value = shadow.radius;
		renderer.setRenderTarget( shadow.mapPass );
		renderer.clear();
		renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

		// horizontal pass

		shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
		shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
		renderer.setRenderTarget( shadow.map );
		renderer.clear();
		renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

	}

	function getDepthMaterial( object, material, light, type ) {

		let result = null;

		const customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;

		if ( customMaterial !== undefined ) {

			result = customMaterial;

		} else {

			result = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;

			if ( ( renderer.localClippingEnabled && material.clipShadows === true && Array.isArray( material.clippingPlanes ) && material.clippingPlanes.length !== 0 ) ||
				( material.displacementMap && material.displacementScale !== 0 ) ||
				( material.alphaMap && material.alphaTest > 0 ) ||
				( material.map && material.alphaTest > 0 ) ) {

				// in this case we need a unique material instance reflecting the
				// appropriate state

				const keyA = result.uuid, keyB = material.uuid;

				let materialsForVariant = _materialCache[ keyA ];

				if ( materialsForVariant === undefined ) {

					materialsForVariant = {};
					_materialCache[ keyA ] = materialsForVariant;

				}

				let cachedMaterial = materialsForVariant[ keyB ];

				if ( cachedMaterial === undefined ) {

					cachedMaterial = result.clone();
					materialsForVariant[ keyB ] = cachedMaterial;
					material.addEventListener( 'dispose', onMaterialDispose );

				}

				result = cachedMaterial;

			}

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;

		if ( type === VSMShadowMap ) {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

		} else {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

		}

		result.alphaMap = material.alphaMap;
		result.alphaTest = material.alphaTest;
		result.map = material.map;

		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.clipIntersection = material.clipIntersection;

		result.displacementMap = material.displacementMap;
		result.displacementScale = material.displacementScale;
		result.displacementBias = material.displacementBias;

		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

			const materialProperties = renderer.properties.get( result );
			materialProperties.light = light;

		}

		return result;

	}

	function renderObject( object, camera, shadowCamera, light, type ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

			if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

				const geometry = objects.update( object );
				const material = object.material;

				if ( Array.isArray( material ) ) {

					const groups = geometry.groups;

					for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

						const group = groups[ k ];
						const groupMaterial = material[ group.materialIndex ];

						if ( groupMaterial && groupMaterial.visible ) {

							const depthMaterial = getDepthMaterial( object, groupMaterial, light, type );

							object.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );

							renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							object.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );

						}

					}

				} else if ( material.visible ) {

					const depthMaterial = getDepthMaterial( object, material, light, type );

					object.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );

					renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

					object.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );

				}

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			renderObject( children[ i ], camera, shadowCamera, light, type );

		}

	}

	function onMaterialDispose( event ) {

		const material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		// make sure to remove the unique distance/depth materials used for shadow map rendering

		for ( const id in _materialCache ) {

			const cache = _materialCache[ id ];

			const uuid = event.target.uuid;

			if ( uuid in cache ) {

				const shadowMaterial = cache[ uuid ];
				shadowMaterial.dispose();
				delete cache[ uuid ];

			}

		}

	}

}

function WebGLState( gl ) {

	function ColorBuffer() {

		let locked = false;

		const color = new Vector4();
		let currentColorMask = null;
		const currentColorClear = new Vector4( 0, 0, 0, 0 );

		return {

			setMask: function ( colorMask ) {

				if ( currentColorMask !== colorMask && ! locked ) {

					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					currentColorMask = colorMask;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( r, g, b, a, premultipliedAlpha ) {

				if ( premultipliedAlpha === true ) {

					r *= a; g *= a; b *= a;

				}

				color.set( r, g, b, a );

				if ( currentColorClear.equals( color ) === false ) {

					gl.clearColor( r, g, b, a );
					currentColorClear.copy( color );

				}

			},

			reset: function () {

				locked = false;

				currentColorMask = null;
				currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

			}

		};

	}

	function DepthBuffer() {

		let locked = false;

		let currentDepthMask = null;
		let currentDepthFunc = null;
		let currentDepthClear = null;

		return {

			setTest: function ( depthTest ) {

				if ( depthTest ) {

					enable( gl.DEPTH_TEST );

				} else {

					disable( gl.DEPTH_TEST );

				}

			},

			setMask: function ( depthMask ) {

				if ( currentDepthMask !== depthMask && ! locked ) {

					gl.depthMask( depthMask );
					currentDepthMask = depthMask;

				}

			},

			setFunc: function ( depthFunc ) {

				if ( currentDepthFunc !== depthFunc ) {

					switch ( depthFunc ) {

						case NeverDepth:

							gl.depthFunc( gl.NEVER );
							break;

						case AlwaysDepth:

							gl.depthFunc( gl.ALWAYS );
							break;

						case LessDepth:

							gl.depthFunc( gl.LESS );
							break;

						case LessEqualDepth:

							gl.depthFunc( gl.LEQUAL );
							break;

						case EqualDepth:

							gl.depthFunc( gl.EQUAL );
							break;

						case GreaterEqualDepth:

							gl.depthFunc( gl.GEQUAL );
							break;

						case GreaterDepth:

							gl.depthFunc( gl.GREATER );
							break;

						case NotEqualDepth:

							gl.depthFunc( gl.NOTEQUAL );
							break;

						default:

							gl.depthFunc( gl.LEQUAL );

					}

					currentDepthFunc = depthFunc;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( depth ) {

				if ( currentDepthClear !== depth ) {

					gl.clearDepth( depth );
					currentDepthClear = depth;

				}

			},

			reset: function () {

				locked = false;

				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;

			}

		};

	}

	function StencilBuffer() {

		let locked = false;

		let currentStencilMask = null;
		let currentStencilFunc = null;
		let currentStencilRef = null;
		let currentStencilFuncMask = null;
		let currentStencilFail = null;
		let currentStencilZFail = null;
		let currentStencilZPass = null;
		let currentStencilClear = null;

		return {

			setTest: function ( stencilTest ) {

				if ( ! locked ) {

					if ( stencilTest ) {

						enable( gl.STENCIL_TEST );

					} else {

						disable( gl.STENCIL_TEST );

					}

				}

			},

			setMask: function ( stencilMask ) {

				if ( currentStencilMask !== stencilMask && ! locked ) {

					gl.stencilMask( stencilMask );
					currentStencilMask = stencilMask;

				}

			},

			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

				if ( currentStencilFunc !== stencilFunc ||
				     currentStencilRef !== stencilRef ||
				     currentStencilFuncMask !== stencilMask ) {

					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;

				}

			},

			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

				if ( currentStencilFail !== stencilFail ||
				     currentStencilZFail !== stencilZFail ||
				     currentStencilZPass !== stencilZPass ) {

					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( stencil ) {

				if ( currentStencilClear !== stencil ) {

					gl.clearStencil( stencil );
					currentStencilClear = stencil;

				}

			},

			reset: function () {

				locked = false;

				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;

			}

		};

	}

	//

	const colorBuffer = new ColorBuffer();
	const depthBuffer = new DepthBuffer();
	const stencilBuffer = new StencilBuffer();

	const uboBindings = new WeakMap();
	const uboProgramMap = new WeakMap();

	let enabledCapabilities = {};

	let currentBoundFramebuffers = {};
	let currentDrawbuffers = new WeakMap();
	let defaultDrawbuffers = [];

	let currentProgram = null;

	let currentBlendingEnabled = false;
	let currentBlending = null;
	let currentBlendEquation = null;
	let currentBlendSrc = null;
	let currentBlendDst = null;
	let currentBlendEquationAlpha = null;
	let currentBlendSrcAlpha = null;
	let currentBlendDstAlpha = null;
	let currentBlendColor = new Color( 0, 0, 0 );
	let currentBlendAlpha = 0;
	let currentPremultipledAlpha = false;

	let currentFlipSided = null;
	let currentCullFace = null;

	let currentLineWidth = null;

	let currentPolygonOffsetFactor = null;
	let currentPolygonOffsetUnits = null;

	const maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

	let lineWidthAvailable = false;
	let version = 0;
	const glVersion = gl.getParameter( gl.VERSION );

	if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

		version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 1.0 );

	} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

		version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 2.0 );

	}

	let currentTextureSlot = null;
	let currentBoundTextures = {};

	const scissorParam = gl.getParameter( gl.SCISSOR_BOX );
	const viewportParam = gl.getParameter( gl.VIEWPORT );

	const currentScissor = new Vector4().fromArray( scissorParam );
	const currentViewport = new Vector4().fromArray( viewportParam );

	function createTexture( type, target, count, dimensions ) {

		const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		const texture = gl.createTexture();

		gl.bindTexture( type, texture );
		gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
		gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

		for ( let i = 0; i < count; i ++ ) {

			if ( type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY ) {

				gl.texImage3D( target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

			} else {

				gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

			}

		}

		return texture;

	}

	const emptyTextures = {};
	emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
	emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );
	emptyTextures[ gl.TEXTURE_2D_ARRAY ] = createTexture( gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1 );
	emptyTextures[ gl.TEXTURE_3D ] = createTexture( gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1 );

	// init

	colorBuffer.setClear( 0, 0, 0, 1 );
	depthBuffer.setClear( 1 );
	stencilBuffer.setClear( 0 );

	enable( gl.DEPTH_TEST );
	depthBuffer.setFunc( LessEqualDepth );

	setFlipSided( false );
	setCullFace( CullFaceBack );
	enable( gl.CULL_FACE );

	setBlending( NoBlending );

	//

	function enable( id ) {

		if ( enabledCapabilities[ id ] !== true ) {

			gl.enable( id );
			enabledCapabilities[ id ] = true;

		}

	}

	function disable( id ) {

		if ( enabledCapabilities[ id ] !== false ) {

			gl.disable( id );
			enabledCapabilities[ id ] = false;

		}

	}

	function bindFramebuffer( target, framebuffer ) {

		if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

			gl.bindFramebuffer( target, framebuffer );

			currentBoundFramebuffers[ target ] = framebuffer;

			// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

			if ( target === gl.DRAW_FRAMEBUFFER ) {

				currentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;

			}

			if ( target === gl.FRAMEBUFFER ) {

				currentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;

			}

			return true;

		}

		return false;

	}

	function drawBuffers( renderTarget, framebuffer ) {

		let drawBuffers = defaultDrawbuffers;

		let needsUpdate = false;

		if ( renderTarget ) {

			drawBuffers = currentDrawbuffers.get( framebuffer );

			if ( drawBuffers === undefined ) {

				drawBuffers = [];
				currentDrawbuffers.set( framebuffer, drawBuffers );

			}

			const textures = renderTarget.textures;

			if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {

				for ( let i = 0, il = textures.length; i < il; i ++ ) {

					drawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;

				}

				drawBuffers.length = textures.length;

				needsUpdate = true;

			}

		} else {

			if ( drawBuffers[ 0 ] !== gl.BACK ) {

				drawBuffers[ 0 ] = gl.BACK;

				needsUpdate = true;

			}

		}

		if ( needsUpdate ) {

			gl.drawBuffers( drawBuffers );

		}

	}

	function useProgram( program ) {

		if ( currentProgram !== program ) {

			gl.useProgram( program );

			currentProgram = program;

			return true;

		}

		return false;

	}

	const equationToGL = {
		[ AddEquation ]: gl.FUNC_ADD,
		[ SubtractEquation ]: gl.FUNC_SUBTRACT,
		[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT
	};

	equationToGL[ MinEquation ] = gl.MIN;
	equationToGL[ MaxEquation ] = gl.MAX;

	const factorToGL = {
		[ ZeroFactor ]: gl.ZERO,
		[ OneFactor ]: gl.ONE,
		[ SrcColorFactor ]: gl.SRC_COLOR,
		[ SrcAlphaFactor ]: gl.SRC_ALPHA,
		[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,
		[ DstColorFactor ]: gl.DST_COLOR,
		[ DstAlphaFactor ]: gl.DST_ALPHA,
		[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,
		[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,
		[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,
		[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA,
		[ ConstantColorFactor ]: gl.CONSTANT_COLOR,
		[ OneMinusConstantColorFactor ]: gl.ONE_MINUS_CONSTANT_COLOR,
		[ ConstantAlphaFactor ]: gl.CONSTANT_ALPHA,
		[ OneMinusConstantAlphaFactor ]: gl.ONE_MINUS_CONSTANT_ALPHA
	};

	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha ) {

		if ( blending === NoBlending ) {

			if ( currentBlendingEnabled === true ) {

				disable( gl.BLEND );
				currentBlendingEnabled = false;

			}

			return;

		}

		if ( currentBlendingEnabled === false ) {

			enable( gl.BLEND );
			currentBlendingEnabled = true;

		}

		if ( blending !== CustomBlending ) {

			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

				if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

					gl.blendEquation( gl.FUNC_ADD );

					currentBlendEquation = AddEquation;
					currentBlendEquationAlpha = AddEquation;

				}

				if ( premultipliedAlpha ) {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
							break;

						case AdditiveBlending:
							gl.blendFunc( gl.ONE, gl.ONE );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
							break;

						case MultiplyBlending:
							gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				} else {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
							break;

						case AdditiveBlending:
							gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
							break;

						case MultiplyBlending:
							gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				}

				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;
				currentBlendColor.set( 0, 0, 0 );
				currentBlendAlpha = 0;

				currentBlending = blending;
				currentPremultipledAlpha = premultipliedAlpha;

			}

			return;

		}

		// custom blending

		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;

		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

			currentBlendEquation = blendEquation;
			currentBlendEquationAlpha = blendEquationAlpha;

		}

		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

			currentBlendSrc = blendSrc;
			currentBlendDst = blendDst;
			currentBlendSrcAlpha = blendSrcAlpha;
			currentBlendDstAlpha = blendDstAlpha;

		}

		if ( blendColor.equals( currentBlendColor ) === false || blendAlpha !== currentBlendAlpha ) {

			gl.blendColor( blendColor.r, blendColor.g, blendColor.b, blendAlpha );

			currentBlendColor.copy( blendColor );
			currentBlendAlpha = blendAlpha;

		}

		currentBlending = blending;
		currentPremultipledAlpha = false;

	}

	function setMaterial( material, frontFaceCW ) {

		material.side === DoubleSide
			? disable( gl.CULL_FACE )
			: enable( gl.CULL_FACE );

		let flipSided = ( material.side === BackSide );
		if ( frontFaceCW ) flipSided = ! flipSided;

		setFlipSided( flipSided );

		( material.blending === NormalBlending && material.transparent === false )
			? setBlending( NoBlending )
			: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha );

		depthBuffer.setFunc( material.depthFunc );
		depthBuffer.setTest( material.depthTest );
		depthBuffer.setMask( material.depthWrite );
		colorBuffer.setMask( material.colorWrite );

		const stencilWrite = material.stencilWrite;
		stencilBuffer.setTest( stencilWrite );
		if ( stencilWrite ) {

			stencilBuffer.setMask( material.stencilWriteMask );
			stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
			stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

		}

		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		material.alphaToCoverage === true
			? enable( gl.SAMPLE_ALPHA_TO_COVERAGE )
			: disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

	}

	//

	function setFlipSided( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( gl.CW );

			} else {

				gl.frontFace( gl.CCW );

			}

			currentFlipSided = flipSided;

		}

	}

	function setCullFace( cullFace ) {

		if ( cullFace !== CullFaceNone ) {

			enable( gl.CULL_FACE );

			if ( cullFace !== currentCullFace ) {

				if ( cullFace === CullFaceBack ) {

					gl.cullFace( gl.BACK );

				} else if ( cullFace === CullFaceFront ) {

					gl.cullFace( gl.FRONT );

				} else {

					gl.cullFace( gl.FRONT_AND_BACK );

				}

			}

		} else {

			disable( gl.CULL_FACE );

		}

		currentCullFace = cullFace;

	}

	function setLineWidth( width ) {

		if ( width !== currentLineWidth ) {

			if ( lineWidthAvailable ) gl.lineWidth( width );

			currentLineWidth = width;

		}

	}

	function setPolygonOffset( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			enable( gl.POLYGON_OFFSET_FILL );

			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		} else {

			disable( gl.POLYGON_OFFSET_FILL );

		}

	}

	function setScissorTest( scissorTest ) {

		if ( scissorTest ) {

			enable( gl.SCISSOR_TEST );

		} else {

			disable( gl.SCISSOR_TEST );

		}

	}

	// texture

	function activeTexture( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	function bindTexture( webglType, webglTexture, webglSlot ) {

		if ( webglSlot === undefined ) {

			if ( currentTextureSlot === null ) {

				webglSlot = gl.TEXTURE0 + maxTextures - 1;

			} else {

				webglSlot = currentTextureSlot;

			}

		}

		let boundTexture = currentBoundTextures[ webglSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ webglSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	function unbindTexture() {

		const boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

			gl.bindTexture( boundTexture.type, null );

			boundTexture.type = undefined;
			boundTexture.texture = undefined;

		}

	}

	function compressedTexImage2D() {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function compressedTexImage3D() {

		try {

			gl.compressedTexImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texSubImage2D() {

		try {

			gl.texSubImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texSubImage3D() {

		try {

			gl.texSubImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function compressedTexSubImage2D() {

		try {

			gl.compressedTexSubImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function compressedTexSubImage3D() {

		try {

			gl.compressedTexSubImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texStorage2D() {

		try {

			gl.texStorage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texStorage3D() {

		try {

			gl.texStorage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage2D() {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage3D() {

		try {

			gl.texImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	//

	function scissor( scissor ) {

		if ( currentScissor.equals( scissor ) === false ) {

			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );

		}

	}

	function viewport( viewport ) {

		if ( currentViewport.equals( viewport ) === false ) {

			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );

		}

	}

	function updateUBOMapping( uniformsGroup, program ) {

		let mapping = uboProgramMap.get( program );

		if ( mapping === undefined ) {

			mapping = new WeakMap();

			uboProgramMap.set( program, mapping );

		}

		let blockIndex = mapping.get( uniformsGroup );

		if ( blockIndex === undefined ) {

			blockIndex = gl.getUniformBlockIndex( program, uniformsGroup.name );

			mapping.set( uniformsGroup, blockIndex );

		}

	}

	function uniformBlockBinding( uniformsGroup, program ) {

		const mapping = uboProgramMap.get( program );
		const blockIndex = mapping.get( uniformsGroup );

		if ( uboBindings.get( program ) !== blockIndex ) {

			// bind shader specific block index to global block point
			gl.uniformBlockBinding( program, blockIndex, uniformsGroup.__bindingPointIndex );

			uboBindings.set( program, blockIndex );

		}

	}

	//

	function reset() {

		// reset state

		gl.disable( gl.BLEND );
		gl.disable( gl.CULL_FACE );
		gl.disable( gl.DEPTH_TEST );
		gl.disable( gl.POLYGON_OFFSET_FILL );
		gl.disable( gl.SCISSOR_TEST );
		gl.disable( gl.STENCIL_TEST );
		gl.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

		gl.blendEquation( gl.FUNC_ADD );
		gl.blendFunc( gl.ONE, gl.ZERO );
		gl.blendFuncSeparate( gl.ONE, gl.ZERO, gl.ONE, gl.ZERO );
		gl.blendColor( 0, 0, 0, 0 );

		gl.colorMask( true, true, true, true );
		gl.clearColor( 0, 0, 0, 0 );

		gl.depthMask( true );
		gl.depthFunc( gl.LESS );
		gl.clearDepth( 1 );

		gl.stencilMask( 0xffffffff );
		gl.stencilFunc( gl.ALWAYS, 0, 0xffffffff );
		gl.stencilOp( gl.KEEP, gl.KEEP, gl.KEEP );
		gl.clearStencil( 0 );

		gl.cullFace( gl.BACK );
		gl.frontFace( gl.CCW );

		gl.polygonOffset( 0, 0 );

		gl.activeTexture( gl.TEXTURE0 );

		gl.bindFramebuffer( gl.FRAMEBUFFER, null );
		gl.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );
		gl.bindFramebuffer( gl.READ_FRAMEBUFFER, null );

		gl.useProgram( null );

		gl.lineWidth( 1 );

		gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
		gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

		// reset internals

		enabledCapabilities = {};

		currentTextureSlot = null;
		currentBoundTextures = {};

		currentBoundFramebuffers = {};
		currentDrawbuffers = new WeakMap();
		defaultDrawbuffers = [];

		currentProgram = null;

		currentBlendingEnabled = false;
		currentBlending = null;
		currentBlendEquation = null;
		currentBlendSrc = null;
		currentBlendDst = null;
		currentBlendEquationAlpha = null;
		currentBlendSrcAlpha = null;
		currentBlendDstAlpha = null;
		currentBlendColor = new Color( 0, 0, 0 );
		currentBlendAlpha = 0;
		currentPremultipledAlpha = false;

		currentFlipSided = null;
		currentCullFace = null;

		currentLineWidth = null;

		currentPolygonOffsetFactor = null;
		currentPolygonOffsetUnits = null;

		currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
		currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();

	}

	return {

		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},

		enable: enable,
		disable: disable,

		bindFramebuffer: bindFramebuffer,
		drawBuffers: drawBuffers,

		useProgram: useProgram,

		setBlending: setBlending,
		setMaterial: setMaterial,

		setFlipSided: setFlipSided,
		setCullFace: setCullFace,

		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,

		setScissorTest: setScissorTest,

		activeTexture: activeTexture,
		bindTexture: bindTexture,
		unbindTexture: unbindTexture,
		compressedTexImage2D: compressedTexImage2D,
		compressedTexImage3D: compressedTexImage3D,
		texImage2D: texImage2D,
		texImage3D: texImage3D,

		updateUBOMapping: updateUBOMapping,
		uniformBlockBinding: uniformBlockBinding,

		texStorage2D: texStorage2D,
		texStorage3D: texStorage3D,
		texSubImage2D: texSubImage2D,
		texSubImage3D: texSubImage3D,
		compressedTexSubImage2D: compressedTexSubImage2D,
		compressedTexSubImage3D: compressedTexSubImage3D,

		scissor: scissor,
		viewport: viewport,

		reset: reset

	};

}

function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

	const multisampledRTTExt = extensions.has( 'WEBGL_multisampled_render_to_texture' ) ? extensions.get( 'WEBGL_multisampled_render_to_texture' ) : null;
	const supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test( navigator.userAgent );

	const _imageDimensions = new Vector2();
	const _videoTextures = new WeakMap();
	let _canvas;

	const _sources = new WeakMap(); // maps WebglTexture objects to instances of Source

	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

	let useOffscreenCanvas = false;

	try {

		useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
			// eslint-disable-next-line compat/compat
			&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

	} catch ( err ) {

		// Ignore any errors

	}

	function createCanvas( width, height ) {

		// Use OffscreenCanvas when available. Specially needed in web workers

		return useOffscreenCanvas ?
			// eslint-disable-next-line compat/compat
			new OffscreenCanvas( width, height ) : createElementNS( 'canvas' );

	}

	function resizeImage( image, needsNewCanvas, maxSize ) {

		let scale = 1;

		const dimensions = getDimensions( image );

		// handle case if texture exceeds max size

		if ( dimensions.width > maxSize || dimensions.height > maxSize ) {

			scale = maxSize / Math.max( dimensions.width, dimensions.height );

		}

		// only perform resize if necessary

		if ( scale < 1 ) {

			// only perform resize for certain image types

			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ||
				( typeof VideoFrame !== 'undefined' && image instanceof VideoFrame ) ) {

				const width = Math.floor( scale * dimensions.width );
				const height = Math.floor( scale * dimensions.height );

				if ( _canvas === undefined ) _canvas = createCanvas( width, height );

				// cube textures can't reuse the same canvas

				const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

				canvas.width = width;
				canvas.height = height;

				const context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, width, height );

				console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + dimensions.width + 'x' + dimensions.height + ') to (' + width + 'x' + height + ').' );

				return canvas;

			} else {

				if ( 'data' in image ) {

					console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + dimensions.width + 'x' + dimensions.height + ').' );

				}

				return image;

			}

		}

		return image;

	}

	function textureNeedsGenerateMipmaps( texture ) {

		return texture.generateMipmaps && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

	}

	function generateMipmap( target ) {

		_gl.generateMipmap( target );

	}

	function getInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {

		if ( internalFormatName !== null ) {

			if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

		}

		let internalFormat = glFormat;

		if ( glFormat === _gl.RED ) {

			if ( glType === _gl.FLOAT ) internalFormat = _gl.R32F;
			if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.R16F;
			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8;

		}

		if ( glFormat === _gl.RED_INTEGER ) {

			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8UI;
			if ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.R16UI;
			if ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.R32UI;
			if ( glType === _gl.BYTE ) internalFormat = _gl.R8I;
			if ( glType === _gl.SHORT ) internalFormat = _gl.R16I;
			if ( glType === _gl.INT ) internalFormat = _gl.R32I;

		}

		if ( glFormat === _gl.RG ) {

			if ( glType === _gl.FLOAT ) internalFormat = _gl.RG32F;
			if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RG16F;
			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8;

		}

		if ( glFormat === _gl.RG_INTEGER ) {

			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8UI;
			if ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.RG16UI;
			if ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.RG32UI;
			if ( glType === _gl.BYTE ) internalFormat = _gl.RG8I;
			if ( glType === _gl.SHORT ) internalFormat = _gl.RG16I;
			if ( glType === _gl.INT ) internalFormat = _gl.RG32I;

		}

		if ( glFormat === _gl.RGB ) {

			if ( glType === _gl.UNSIGNED_INT_5_9_9_9_REV ) internalFormat = _gl.RGB9_E5;

		}

		if ( glFormat === _gl.RGBA ) {

			const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer( colorSpace );

			if ( glType === _gl.FLOAT ) internalFormat = _gl.RGBA32F;
			if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RGBA16F;
			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = ( transfer === SRGBTransfer ) ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
			if ( glType === _gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = _gl.RGBA4;
			if ( glType === _gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = _gl.RGB5_A1;

		}

		if ( internalFormat === _gl.R16F || internalFormat === _gl.R32F ||
			internalFormat === _gl.RG16F || internalFormat === _gl.RG32F ||
			internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F ) {

			extensions.get( 'EXT_color_buffer_float' );

		}

		return internalFormat;

	}

	function getMipLevels( texture, image ) {

		if ( textureNeedsGenerateMipmaps( texture ) === true || ( texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) ) {

			return Math.log2( Math.max( image.width, image.height ) ) + 1;

		} else if ( texture.mipmaps !== undefined && texture.mipmaps.length > 0 ) {

			// user-defined mipmaps

			return texture.mipmaps.length;

		} else if ( texture.isCompressedTexture && Array.isArray( texture.image ) ) {

			return image.mipmaps.length;

		} else {

			// texture without mipmaps (only base level)

			return 1;

		}

	}

	//

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		if ( texture.isVideoTexture ) {

			_videoTextures.delete( texture );

		}

	}

	function onRenderTargetDispose( event ) {

		const renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

	}

	//

	function deallocateTexture( texture ) {

		const textureProperties = properties.get( texture );

		if ( textureProperties.__webglInit === undefined ) return;

		// check if it's necessary to remove the WebGLTexture object

		const source = texture.source;
		const webglTextures = _sources.get( source );

		if ( webglTextures ) {

			const webglTexture = webglTextures[ textureProperties.__cacheKey ];
			webglTexture.usedTimes --;

			// the WebGLTexture object is not used anymore, remove it

			if ( webglTexture.usedTimes === 0 ) {

				deleteTexture( texture );

			}

			// remove the weak map entry if no WebGLTexture uses the source anymore

			if ( Object.keys( webglTextures ).length === 0 ) {

				_sources.delete( source );

			}

		}

		properties.remove( texture );

	}

	function deleteTexture( texture ) {

		const textureProperties = properties.get( texture );
		_gl.deleteTexture( textureProperties.__webglTexture );

		const source = texture.source;
		const webglTextures = _sources.get( source );
		delete webglTextures[ textureProperties.__cacheKey ];

		info.memory.textures --;

	}

	function deallocateRenderTarget( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );

		if ( renderTarget.depthTexture ) {

			renderTarget.depthTexture.dispose();

		}

		if ( renderTarget.isWebGLCubeRenderTarget ) {

			for ( let i = 0; i < 6; i ++ ) {

				if ( Array.isArray( renderTargetProperties.__webglFramebuffer[ i ] ) ) {

					for ( let level = 0; level < renderTargetProperties.__webglFramebuffer[ i ].length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ][ level ] );

				} else {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );

				}

				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			}

		} else {

			if ( Array.isArray( renderTargetProperties.__webglFramebuffer ) ) {

				for ( let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ level ] );

			} else {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );

			}

			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
			if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );

			if ( renderTargetProperties.__webglColorRenderbuffer ) {

				for ( let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i ++ ) {

					if ( renderTargetProperties.__webglColorRenderbuffer[ i ] ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer[ i ] );

				}

			}

			if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

		}

		const textures = renderTarget.textures;

		for ( let i = 0, il = textures.length; i < il; i ++ ) {

			const attachmentProperties = properties.get( textures[ i ] );

			if ( attachmentProperties.__webglTexture ) {

				_gl.deleteTexture( attachmentProperties.__webglTexture );

				info.memory.textures --;

			}

			properties.remove( textures[ i ] );

		}

		properties.remove( renderTarget );

	}

	//

	let textureUnits = 0;

	function resetTextureUnits() {

		textureUnits = 0;

	}

	function allocateTextureUnit() {

		const textureUnit = textureUnits;

		if ( textureUnit >= capabilities.maxTextures ) {

			console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

		}

		textureUnits += 1;

		return textureUnit;

	}

	function getTextureCacheKey( texture ) {

		const array = [];

		array.push( texture.wrapS );
		array.push( texture.wrapT );
		array.push( texture.wrapR || 0 );
		array.push( texture.magFilter );
		array.push( texture.minFilter );
		array.push( texture.anisotropy );
		array.push( texture.internalFormat );
		array.push( texture.format );
		array.push( texture.type );
		array.push( texture.generateMipmaps );
		array.push( texture.premultiplyAlpha );
		array.push( texture.flipY );
		array.push( texture.unpackAlignment );
		array.push( texture.colorSpace );

		return array.join();

	}

	//

	function setTexture2D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.isVideoTexture ) updateVideoTexture( texture );

		if ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {

			const image = texture.image;

			if ( image === null ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but no image data found.' );

			} else if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

			} else {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

		}

		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

	}

	function setTexture2DArray( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.bindTexture( _gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

	}

	function setTexture3D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.bindTexture( _gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

	}

	function setTextureCube( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadCubeTexture( textureProperties, texture, slot );
			return;

		}

		state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

	}

	const wrappingToGL = {
		[ RepeatWrapping ]: _gl.REPEAT,
		[ ClampToEdgeWrapping ]: _gl.CLAMP_TO_EDGE,
		[ MirroredRepeatWrapping ]: _gl.MIRRORED_REPEAT
	};

	const filterToGL = {
		[ NearestFilter ]: _gl.NEAREST,
		[ NearestMipmapNearestFilter ]: _gl.NEAREST_MIPMAP_NEAREST,
		[ NearestMipmapLinearFilter ]: _gl.NEAREST_MIPMAP_LINEAR,

		[ LinearFilter ]: _gl.LINEAR,
		[ LinearMipmapNearestFilter ]: _gl.LINEAR_MIPMAP_NEAREST,
		[ LinearMipmapLinearFilter ]: _gl.LINEAR_MIPMAP_LINEAR
	};

	const compareToGL = {
		[ NeverCompare ]: _gl.NEVER,
		[ AlwaysCompare ]: _gl.ALWAYS,
		[ LessCompare ]: _gl.LESS,
		[ LessEqualCompare ]: _gl.LEQUAL,
		[ EqualCompare ]: _gl.EQUAL,
		[ GreaterEqualCompare ]: _gl.GEQUAL,
		[ GreaterCompare ]: _gl.GREATER,
		[ NotEqualCompare ]: _gl.NOTEQUAL
	};

	function setTextureParameters( textureType, texture ) {

		if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false &&
			( texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||
			texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter ) ) {

			console.warn( 'THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.' );

		}

		_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );
		_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );

		if ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );

		}

		_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );
		_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[ texture.minFilter ] );

		if ( texture.compareFunction ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE );
			_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );

		}

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			if ( texture.magFilter === NearestFilter ) return;
			if ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;
			if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );
				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function initTexture( textureProperties, texture ) {

		let forceUpload = false;

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

		}

		// create Source <-> WebGLTextures mapping if necessary

		const source = texture.source;
		let webglTextures = _sources.get( source );

		if ( webglTextures === undefined ) {

			webglTextures = {};
			_sources.set( source, webglTextures );

		}

		// check if there is already a WebGLTexture object for the given texture parameters

		const textureCacheKey = getTextureCacheKey( texture );

		if ( textureCacheKey !== textureProperties.__cacheKey ) {

			// if not, create a new instance of WebGLTexture

			if ( webglTextures[ textureCacheKey ] === undefined ) {

				// create new entry

				webglTextures[ textureCacheKey ] = {
					texture: _gl.createTexture(),
					usedTimes: 0
				};

				info.memory.textures ++;

				// when a new instance of WebGLTexture was created, a texture upload is required
				// even if the image contents are identical

				forceUpload = true;

			}

			webglTextures[ textureCacheKey ].usedTimes ++;

			// every time the texture cache key changes, it's necessary to check if an instance of
			// WebGLTexture can be deleted in order to avoid a memory leak.

			const webglTexture = webglTextures[ textureProperties.__cacheKey ];

			if ( webglTexture !== undefined ) {

				webglTextures[ textureProperties.__cacheKey ].usedTimes --;

				if ( webglTexture.usedTimes === 0 ) {

					deleteTexture( texture );

				}

			}

			// store references to cache key and WebGLTexture object

			textureProperties.__cacheKey = textureCacheKey;
			textureProperties.__webglTexture = webglTextures[ textureCacheKey ].texture;

		}

		return forceUpload;

	}

	function uploadTexture( textureProperties, texture, slot ) {

		let textureType = _gl.TEXTURE_2D;

		if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) textureType = _gl.TEXTURE_2D_ARRAY;
		if ( texture.isData3DTexture ) textureType = _gl.TEXTURE_3D;

		const forceUpload = initTexture( textureProperties, texture );
		const source = texture.source;

		state.bindTexture( textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

		const sourceProperties = properties.get( source );

		if ( source.version !== sourceProperties.__version || forceUpload === true ) {

			state.activeTexture( _gl.TEXTURE0 + slot );

			const workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );
			const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries( texture.colorSpace );
			const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
			_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );

			let image = resizeImage( texture.image, false, capabilities.maxTextureSize );
			image = verifyColorSpace( texture, image );

			const glFormat = utils.convert( texture.format, texture.colorSpace );

			const glType = utils.convert( texture.type );
			let glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture );

			setTextureParameters( textureType, texture );

			let mipmap;
			const mipmaps = texture.mipmaps;

			const useTexStorage = ( texture.isVideoTexture !== true );
			const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
			const dataReady = source.dataReady;
			const levels = getMipLevels( texture, image );

			if ( texture.isDepthTexture ) {

				// populate depth texture with dummy data

				glInternalFormat = _gl.DEPTH_COMPONENT16;

				if ( texture.type === FloatType ) {

					glInternalFormat = _gl.DEPTH_COMPONENT32F;

				} else if ( texture.type === UnsignedIntType ) {

					glInternalFormat = _gl.DEPTH_COMPONENT24;

				} else if ( texture.type === UnsignedInt248Type ) {

					glInternalFormat = _gl.DEPTH24_STENCIL8;

				}

				//

				if ( allocateMemory ) {

					if ( useTexStorage ) {

						state.texStorage2D( _gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height );

					} else {

						state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

					}

				}

			} else if ( texture.isDataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( useTexStorage ) {

							if ( dataReady ) {

								state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

							}

						} else {

							state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

					}

					texture.generateMipmaps = false;

				} else {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );

						}

						if ( dataReady ) {

							state.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data );

						}

					} else {

						state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );

					}

				}

			} else if ( texture.isCompressedTexture ) {

				if ( texture.isCompressedArrayTexture ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height, image.depth );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( texture.format !== RGBAFormat ) {

							if ( glFormat !== null ) {

								if ( useTexStorage ) {

									if ( dataReady ) {

										state.compressedTexSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0 );

									}

								} else {

									state.compressedTexImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0 );

								}

							} else {

								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

							}

						} else {

							if ( useTexStorage ) {

								if ( dataReady ) {

									state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );

								}

							} else {

								state.texImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				} else {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( texture.format !== RGBAFormat ) {

							if ( glFormat !== null ) {

								if ( useTexStorage ) {

									if ( dataReady ) {

										state.compressedTexSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

									}

								} else {

									state.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								}

							} else {

								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

							}

						} else {

							if ( useTexStorage ) {

								if ( dataReady ) {

									state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

			} else if ( texture.isDataArrayTexture ) {

				if ( useTexStorage ) {

					if ( allocateMemory ) {

						state.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth );

					}

					if ( dataReady ) {

						state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

					}

				} else {

					state.texImage3D( _gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

				}

			} else if ( texture.isData3DTexture ) {

				if ( useTexStorage ) {

					if ( allocateMemory ) {

						state.texStorage3D( _gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth );

					}

					if ( dataReady ) {

						state.texSubImage3D( _gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

					}

				} else {

					state.texImage3D( _gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

				}

			} else if ( texture.isFramebufferTexture ) {

				if ( allocateMemory ) {

					if ( useTexStorage ) {

						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );

					} else {

						let width = image.width, height = image.height;

						for ( let i = 0; i < levels; i ++ ) {

							state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null );

							width >>= 1;
							height >>= 1;

						}

					}

				}

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 ) {

					if ( useTexStorage && allocateMemory ) {

						const dimensions = getDimensions( mipmaps[ 0 ] );

						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( useTexStorage ) {

							if ( dataReady ) {

								state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap );

							}

						} else {

							state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );

						}

					}

					texture.generateMipmaps = false;

				} else {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							const dimensions = getDimensions( image );

							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height );

						}

						if ( dataReady ) {

							state.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image );

						}

					} else {

						state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );

					}

				}

			}

			if ( textureNeedsGenerateMipmaps( texture ) ) {

				generateMipmap( textureType );

			}

			sourceProperties.__version = source.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		textureProperties.__version = texture.version;

	}

	function uploadCubeTexture( textureProperties, texture, slot ) {

		if ( texture.image.length !== 6 ) return;

		const forceUpload = initTexture( textureProperties, texture );
		const source = texture.source;

		state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

		const sourceProperties = properties.get( source );

		if ( source.version !== sourceProperties.__version || forceUpload === true ) {

			state.activeTexture( _gl.TEXTURE0 + slot );

			const workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );
			const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries( texture.colorSpace );
			const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
			_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );

			const isCompressed = ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture );
			const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

			const cubeImage = [];

			for ( let i = 0; i < 6; i ++ ) {

				if ( ! isCompressed && ! isDataTexture ) {

					cubeImage[ i ] = resizeImage( texture.image[ i ], true, capabilities.maxCubemapSize );

				} else {

					cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

				}

				cubeImage[ i ] = verifyColorSpace( texture, cubeImage[ i ] );

			}

			const image = cubeImage[ 0 ],
				glFormat = utils.convert( texture.format, texture.colorSpace ),
				glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );

			const useTexStorage = ( texture.isVideoTexture !== true );
			const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
			const dataReady = source.dataReady;
			let levels = getMipLevels( texture, image );

			setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture );

			let mipmaps;

			if ( isCompressed ) {

				if ( useTexStorage && allocateMemory ) {

					state.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height );

				}

				for ( let i = 0; i < 6; i ++ ) {

					mipmaps = cubeImage[ i ].mipmaps;

					for ( let j = 0; j < mipmaps.length; j ++ ) {

						const mipmap = mipmaps[ j ];

						if ( texture.format !== RGBAFormat ) {

							if ( glFormat !== null ) {

								if ( useTexStorage ) {

									if ( dataReady ) {

										state.compressedTexSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

									}

								} else {

									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								}

							} else {

								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

							}

						} else {

							if ( useTexStorage ) {

								if ( dataReady ) {

									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

			} else {

				mipmaps = texture.mipmaps;

				if ( useTexStorage && allocateMemory ) {

					// TODO: Uniformly handle mipmap definitions
					// Normal textures and compressed cube textures define base level + mips with their mipmap array
					// Uncompressed cube textures use their mipmap array only for mips (no base level)

					if ( mipmaps.length > 0 ) levels ++;

					const dimensions = getDimensions( cubeImage[ 0 ] );

					state.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height );

				}

				for ( let i = 0; i < 6; i ++ ) {

					if ( isDataTexture ) {

						if ( useTexStorage ) {

							if ( dataReady ) {

								state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[ i ].width, cubeImage[ i ].height, glFormat, glType, cubeImage[ i ].data );

							}

						} else {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						}

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];
							const mipmapImage = mipmap.image[ i ].image;

							if ( useTexStorage ) {

								if ( dataReady ) {

									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

							}

						}

					} else {

						if ( useTexStorage ) {

							if ( dataReady ) {

								state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[ i ] );

							}

						} else {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

						}

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];

							if ( useTexStorage ) {

								if ( dataReady ) {

									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[ i ] );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

							}

						}

					}

				}

			}

			if ( textureNeedsGenerateMipmaps( texture ) ) {

				// We assume images for cube map have the same size.
				generateMipmap( _gl.TEXTURE_CUBE_MAP );

			}

			sourceProperties.__version = source.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		textureProperties.__version = texture.version;

	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget, level ) {

		const glFormat = utils.convert( texture.format, texture.colorSpace );
		const glType = utils.convert( texture.type );
		const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );
		const renderTargetProperties = properties.get( renderTarget );

		if ( ! renderTargetProperties.__hasExternalTextures ) {

			const width = Math.max( 1, renderTarget.width >> level );
			const height = Math.max( 1, renderTarget.height >> level );

			if ( textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY ) {

				state.texImage3D( textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null );

			} else {

				state.texImage2D( textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null );

			}

		}

		state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

		if ( useMultisampledRTT( renderTarget ) ) {

			multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( texture ).__webglTexture, 0, getRenderTargetSamples( renderTarget ) );

		} else if ( textureTarget === _gl.TEXTURE_2D || ( textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z ) ) { // see #24753

			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( texture ).__webglTexture, level );

		}

		state.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}


	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			let glInternalFormat = _gl.DEPTH_COMPONENT24;

			if ( isMultisample || useMultisampledRTT( renderTarget ) ) {

				const depthTexture = renderTarget.depthTexture;

				if ( depthTexture && depthTexture.isDepthTexture ) {

					if ( depthTexture.type === FloatType ) {

						glInternalFormat = _gl.DEPTH_COMPONENT32F;

					} else if ( depthTexture.type === UnsignedIntType ) {

						glInternalFormat = _gl.DEPTH_COMPONENT24;

					}

				}

				const samples = getRenderTargetSamples( renderTarget );

				if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				}

			} else {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

			}

			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			const samples = getRenderTargetSamples( renderTarget );

			if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

				_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height );

			} else if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );

			}


			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			const textures = renderTarget.textures;

			for ( let i = 0; i < textures.length; i ++ ) {

				const texture = textures[ i ];

				const glFormat = utils.convert( texture.format, texture.colorSpace );
				const glType = utils.convert( texture.type );
				const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );
				const samples = getRenderTargetSamples( renderTarget );

				if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

				}

			}

		}

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture( framebuffer, renderTarget ) {

		const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
		if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

		state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

		}

		// upload an empty depth texture with framebuffer size
		if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {

			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;

		}

		setTexture2D( renderTarget.depthTexture, 0 );

		const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
		const samples = getRenderTargetSamples( renderTarget );

		if ( renderTarget.depthTexture.format === DepthFormat ) {

			if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );

			} else {

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

			}

		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

			if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );

			} else {

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

			}

		} else {

			throw new Error( 'Unknown depthTexture format' );

		}

	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );
		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

		if ( renderTarget.depthTexture && ! renderTargetProperties.__autoAllocateDepthBuffer ) {

			if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		} else {

			if ( isCube ) {

				renderTargetProperties.__webglDepthbuffer = [];

				for ( let i = 0; i < 6; i ++ ) {

					state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

				}

			} else {

				state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

			}

		}

		state.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}

	// rebind framebuffer with external textures
	function rebindTextures( renderTarget, colorTexture, depthTexture ) {

		const renderTargetProperties = properties.get( renderTarget );

		if ( colorTexture !== undefined ) {

			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0 );

		}

		if ( depthTexture !== undefined ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	// Set up GL resources for the render target
	function setupRenderTarget( renderTarget ) {

		const texture = renderTarget.texture;

		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( texture );

		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		const textures = renderTarget.textures;

		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
		const isMultipleRenderTargets = ( textures.length > 1 );

		if ( ! isMultipleRenderTargets ) {

			if ( textureProperties.__webglTexture === undefined ) {

				textureProperties.__webglTexture = _gl.createTexture();

			}

			textureProperties.__version = texture.version;
			info.memory.textures ++;

		}

		// Setup framebuffer

		if ( isCube ) {

			renderTargetProperties.__webglFramebuffer = [];

			for ( let i = 0; i < 6; i ++ ) {

				if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

					renderTargetProperties.__webglFramebuffer[ i ] = [];

					for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

						renderTargetProperties.__webglFramebuffer[ i ][ level ] = _gl.createFramebuffer();

					}

				} else {

					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

				}

			}

		} else {

			if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

				renderTargetProperties.__webglFramebuffer = [];

				for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

					renderTargetProperties.__webglFramebuffer[ level ] = _gl.createFramebuffer();

				}

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			}

			if ( isMultipleRenderTargets ) {

				for ( let i = 0, il = textures.length; i < il; i ++ ) {

					const attachmentProperties = properties.get( textures[ i ] );

					if ( attachmentProperties.__webglTexture === undefined ) {

						attachmentProperties.__webglTexture = _gl.createTexture();

						info.memory.textures ++;

					}

				}

			}

			if ( ( renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

				renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
				renderTargetProperties.__webglColorRenderbuffer = [];

				state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );

				for ( let i = 0; i < textures.length; i ++ ) {

					const texture = textures[ i ];
					renderTargetProperties.__webglColorRenderbuffer[ i ] = _gl.createRenderbuffer();

					_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

					const glFormat = utils.convert( texture.format, texture.colorSpace );
					const glType = utils.convert( texture.type );
					const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, renderTarget.isXRRenderTarget === true );
					const samples = getRenderTargetSamples( renderTarget );
					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

				}

				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

				if ( renderTarget.depthBuffer ) {

					renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

				}

				state.bindFramebuffer( _gl.FRAMEBUFFER, null );

			}

		}

		// Setup color buffer

		if ( isCube ) {

			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
			setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture );

			for ( let i = 0; i < 6; i ++ ) {

				if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

					for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

						setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ][ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level );

					}

				} else {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0 );

				}

			}

			if ( textureNeedsGenerateMipmaps( texture ) ) {

				generateMipmap( _gl.TEXTURE_CUBE_MAP );

			}

			state.unbindTexture();

		} else if ( isMultipleRenderTargets ) {

			for ( let i = 0, il = textures.length; i < il; i ++ ) {

				const attachment = textures[ i ];
				const attachmentProperties = properties.get( attachment );

				state.bindTexture( _gl.TEXTURE_2D, attachmentProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, attachment );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, 0 );

				if ( textureNeedsGenerateMipmaps( attachment ) ) {

					generateMipmap( _gl.TEXTURE_2D );

				}

			}

			state.unbindTexture();

		} else {

			let glTextureType = _gl.TEXTURE_2D;

			if ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {

				glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;

			}

			state.bindTexture( glTextureType, textureProperties.__webglTexture );
			setTextureParameters( glTextureType, texture );

			if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

				for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level );

				}

			} else {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0 );

			}

			if ( textureNeedsGenerateMipmaps( texture ) ) {

				generateMipmap( glTextureType );

			}

			state.unbindTexture();

		}

		// Setup depth and stencil buffers

		if ( renderTarget.depthBuffer ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	function updateRenderTargetMipmap( renderTarget ) {

		const textures = renderTarget.textures;

		for ( let i = 0, il = textures.length; i < il; i ++ ) {

			const texture = textures[ i ];

			if ( textureNeedsGenerateMipmaps( texture ) ) {

				const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
				const webglTexture = properties.get( texture ).__webglTexture;

				state.bindTexture( target, webglTexture );
				generateMipmap( target );
				state.unbindTexture();

			}

		}

	}

	const invalidationArrayRead = [];
	const invalidationArrayDraw = [];

	function updateMultisampleRenderTarget( renderTarget ) {

		if ( renderTarget.samples > 0 ) {

			if ( useMultisampledRTT( renderTarget ) === false ) {

				const textures = renderTarget.textures;
				const width = renderTarget.width;
				const height = renderTarget.height;
				let mask = _gl.COLOR_BUFFER_BIT;
				const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
				const renderTargetProperties = properties.get( renderTarget );
				const isMultipleRenderTargets = ( textures.length > 1 );

				// If MRT we need to remove FBO attachments
				if ( isMultipleRenderTargets ) {

					for ( let i = 0; i < textures.length; i ++ ) {

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null );

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0 );

					}

				}

				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );

				for ( let i = 0; i < textures.length; i ++ ) {

					if ( renderTarget.resolveDepthBuffer ) {

						if ( renderTarget.depthBuffer ) mask |= _gl.DEPTH_BUFFER_BIT;

						// resolving stencil is slow with a D3D backend. disable it for all transmission render targets (see #27799)

						if ( renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer ) mask |= _gl.STENCIL_BUFFER_BIT;

					}

					if ( isMultipleRenderTargets ) {

						_gl.framebufferRenderbuffer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

						const webglTexture = properties.get( textures[ i ] ).__webglTexture;
						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0 );

					}

					_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST );

					if ( supportsInvalidateFramebuffer === true ) {

						invalidationArrayRead.length = 0;
						invalidationArrayDraw.length = 0;

						invalidationArrayRead.push( _gl.COLOR_ATTACHMENT0 + i );

						if ( renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false ) {

							invalidationArrayRead.push( depthStyle );
							invalidationArrayDraw.push( depthStyle );

							_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, invalidationArrayDraw );

						}

						_gl.invalidateFramebuffer( _gl.READ_FRAMEBUFFER, invalidationArrayRead );

					}

				}

				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );
				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );

				// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
				if ( isMultipleRenderTargets ) {

					for ( let i = 0; i < textures.length; i ++ ) {

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

						const webglTexture = properties.get( textures[ i ] ).__webglTexture;

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0 );

					}

				}

				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );

			} else {

				if ( renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer ) {

					const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;

					_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, [ depthStyle ] );

				}

			}

		}

	}

	function getRenderTargetSamples( renderTarget ) {

		return Math.min( capabilities.maxSamples, renderTarget.samples );

	}

	function useMultisampledRTT( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );

		return renderTarget.samples > 0 && extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTargetProperties.__useRenderToTexture !== false;

	}

	function updateVideoTexture( texture ) {

		const frame = info.render.frame;

		// Check the last frame we updated the VideoTexture

		if ( _videoTextures.get( texture ) !== frame ) {

			_videoTextures.set( texture, frame );
			texture.update();

		}

	}

	function verifyColorSpace( texture, image ) {

		const colorSpace = texture.colorSpace;
		const format = texture.format;
		const type = texture.type;

		if ( texture.isCompressedTexture === true || texture.isVideoTexture === true ) return image;

		if ( colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace ) {

			// sRGB

			if ( ColorManagement.getTransfer( colorSpace ) === SRGBTransfer ) {

				// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format

				if ( format !== RGBAFormat || type !== UnsignedByteType ) {

					console.warn( 'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.' );

				}

			} else {

				console.error( 'THREE.WebGLTextures: Unsupported texture color space:', colorSpace );

			}

		}

		return image;

	}

	function getDimensions( image ) {

		if ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) {

			// if intrinsic data are not available, fallback to width/height

			_imageDimensions.width = image.naturalWidth || image.width;
			_imageDimensions.height = image.naturalHeight || image.height;

		} else if ( typeof VideoFrame !== 'undefined' && image instanceof VideoFrame ) {

			_imageDimensions.width = image.displayWidth;
			_imageDimensions.height = image.displayHeight;

		} else {

			_imageDimensions.width = image.width;
			_imageDimensions.height = image.height;

		}

		return _imageDimensions;

	}

	//

	this.allocateTextureUnit = allocateTextureUnit;
	this.resetTextureUnits = resetTextureUnits;

	this.setTexture2D = setTexture2D;
	this.setTexture2DArray = setTexture2DArray;
	this.setTexture3D = setTexture3D;
	this.setTextureCube = setTextureCube;
	this.rebindTextures = rebindTextures;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
	this.setupDepthRenderbuffer = setupDepthRenderbuffer;
	this.setupFrameBufferTexture = setupFrameBufferTexture;
	this.useMultisampledRTT = useMultisampledRTT;

}

function WebGLUtils( gl, extensions ) {

	function convert( p, colorSpace = NoColorSpace ) {

		let extension;

		const transfer = ColorManagement.getTransfer( colorSpace );

		if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
		if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === UnsignedInt5999Type ) return gl.UNSIGNED_INT_5_9_9_9_REV;

		if ( p === ByteType ) return gl.BYTE;
		if ( p === ShortType ) return gl.SHORT;
		if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
		if ( p === IntType ) return gl.INT;
		if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
		if ( p === FloatType ) return gl.FLOAT;
		if ( p === HalfFloatType ) return gl.HALF_FLOAT;

		if ( p === AlphaFormat ) return gl.ALPHA;
		if ( p === RGBFormat ) return gl.RGB;
		if ( p === RGBAFormat ) return gl.RGBA;
		if ( p === LuminanceFormat ) return gl.LUMINANCE;
		if ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;
		if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
		if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;

		// WebGL2 formats.

		if ( p === RedFormat ) return gl.RED;
		if ( p === RedIntegerFormat ) return gl.RED_INTEGER;
		if ( p === RGFormat ) return gl.RG;
		if ( p === RGIntegerFormat ) return gl.RG_INTEGER;
		if ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;

		// S3TC

		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			if ( transfer === SRGBTransfer ) {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			} else {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			}

		}

		// PVRTC

		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			} else {

				return null;

			}

		}

		// ETC

		if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

			if ( extension !== null ) {

				if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
				if ( p === RGBA_ETC2_EAC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;

			} else {

				return null;

			}

		}

		// ASTC

		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

			if ( extension !== null ) {

				if ( p === RGBA_ASTC_4x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
				if ( p === RGBA_ASTC_5x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
				if ( p === RGBA_ASTC_5x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
				if ( p === RGBA_ASTC_6x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
				if ( p === RGBA_ASTC_6x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
				if ( p === RGBA_ASTC_8x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
				if ( p === RGBA_ASTC_8x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
				if ( p === RGBA_ASTC_8x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
				if ( p === RGBA_ASTC_10x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
				if ( p === RGBA_ASTC_10x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
				if ( p === RGBA_ASTC_10x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
				if ( p === RGBA_ASTC_10x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
				if ( p === RGBA_ASTC_12x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
				if ( p === RGBA_ASTC_12x12_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;

			} else {

				return null;

			}

		}

		// BPTC

		if ( p === RGBA_BPTC_Format || p === RGB_BPTC_SIGNED_Format || p === RGB_BPTC_UNSIGNED_Format ) {

			extension = extensions.get( 'EXT_texture_compression_bptc' );

			if ( extension !== null ) {

				if ( p === RGBA_BPTC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
				if ( p === RGB_BPTC_SIGNED_Format ) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
				if ( p === RGB_BPTC_UNSIGNED_Format ) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;

			} else {

				return null;

			}

		}

		// RGTC

		if ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {

			extension = extensions.get( 'EXT_texture_compression_rgtc' );

			if ( extension !== null ) {

				if ( p === RGBA_BPTC_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;
				if ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
				if ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
				if ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;

			} else {

				return null;

			}

		}

		//

		if ( p === UnsignedInt248Type ) return gl.UNSIGNED_INT_24_8;

		// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

		return ( gl[ p ] !== undefined ) ? gl[ p ] : null;

	}

	return { convert: convert };

}

class ArrayCamera extends PerspectiveCamera {

	constructor( array = [] ) {

		super();

		this.isArrayCamera = true;

		this.cameras = array;

	}

}

class Group extends Object3D {

	constructor() {

		super();

		this.isGroup = true;

		this.type = 'Group';

	}

}

const _moveEvent = { type: 'move' };

class WebXRController {

	constructor() {

		this._targetRay = null;
		this._grip = null;
		this._hand = null;

	}

	getHandSpace() {

		if ( this._hand === null ) {

			this._hand = new Group();
			this._hand.matrixAutoUpdate = false;
			this._hand.visible = false;

			this._hand.joints = {};
			this._hand.inputState = { pinching: false };

		}

		return this._hand;

	}

	getTargetRaySpace() {

		if ( this._targetRay === null ) {

			this._targetRay = new Group();
			this._targetRay.matrixAutoUpdate = false;
			this._targetRay.visible = false;
			this._targetRay.hasLinearVelocity = false;
			this._targetRay.linearVelocity = new Vector3();
			this._targetRay.hasAngularVelocity = false;
			this._targetRay.angularVelocity = new Vector3();

		}

		return this._targetRay;

	}

	getGripSpace() {

		if ( this._grip === null ) {

			this._grip = new Group();
			this._grip.matrixAutoUpdate = false;
			this._grip.visible = false;
			this._grip.hasLinearVelocity = false;
			this._grip.linearVelocity = new Vector3();
			this._grip.hasAngularVelocity = false;
			this._grip.angularVelocity = new Vector3();

		}

		return this._grip;

	}

	dispatchEvent( event ) {

		if ( this._targetRay !== null ) {

			this._targetRay.dispatchEvent( event );

		}

		if ( this._grip !== null ) {

			this._grip.dispatchEvent( event );

		}

		if ( this._hand !== null ) {

			this._hand.dispatchEvent( event );

		}

		return this;

	}

	connect( inputSource ) {

		if ( inputSource && inputSource.hand ) {

			const hand = this._hand;

			if ( hand ) {

				for ( const inputjoint of inputSource.hand.values() ) {

					// Initialize hand with joints when connected
					this._getHandJoint( hand, inputjoint );

				}

			}

		}

		this.dispatchEvent( { type: 'connected', data: inputSource } );

		return this;

	}

	disconnect( inputSource ) {

		this.dispatchEvent( { type: 'disconnected', data: inputSource } );

		if ( this._targetRay !== null ) {

			this._targetRay.visible = false;

		}

		if ( this._grip !== null ) {

			this._grip.visible = false;

		}

		if ( this._hand !== null ) {

			this._hand.visible = false;

		}

		return this;

	}

	update( inputSource, frame, referenceSpace ) {

		let inputPose = null;
		let gripPose = null;
		let handPose = null;

		const targetRay = this._targetRay;
		const grip = this._grip;
		const hand = this._hand;

		if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

			if ( hand && inputSource.hand ) {

				handPose = true;

				for ( const inputjoint of inputSource.hand.values() ) {

					// Update the joints groups with the XRJoint poses
					const jointPose = frame.getJointPose( inputjoint, referenceSpace );

					// The transform of this joint will be updated with the joint pose on each frame
					const joint = this._getHandJoint( hand, inputjoint );

					if ( jointPose !== null ) {

						joint.matrix.fromArray( jointPose.transform.matrix );
						joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
						joint.matrixWorldNeedsUpdate = true;
						joint.jointRadius = jointPose.radius;

					}

					joint.visible = jointPose !== null;

				}

				// Custom events

				// Check pinchz
				const indexTip = hand.joints[ 'index-finger-tip' ];
				const thumbTip = hand.joints[ 'thumb-tip' ];
				const distance = indexTip.position.distanceTo( thumbTip.position );

				const distanceToPinch = 0.02;
				const threshold = 0.005;

				if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

					hand.inputState.pinching = false;
					this.dispatchEvent( {
						type: 'pinchend',
						handedness: inputSource.handedness,
						target: this
					} );

				} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

					hand.inputState.pinching = true;
					this.dispatchEvent( {
						type: 'pinchstart',
						handedness: inputSource.handedness,
						target: this
					} );

				}

			} else {

				if ( grip !== null && inputSource.gripSpace ) {

					gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

					if ( gripPose !== null ) {

						grip.matrix.fromArray( gripPose.transform.matrix );
						grip.matrix.decompose( grip.position, grip.rotation, grip.scale );
						grip.matrixWorldNeedsUpdate = true;

						if ( gripPose.linearVelocity ) {

							grip.hasLinearVelocity = true;
							grip.linearVelocity.copy( gripPose.linearVelocity );

						} else {

							grip.hasLinearVelocity = false;

						}

						if ( gripPose.angularVelocity ) {

							grip.hasAngularVelocity = true;
							grip.angularVelocity.copy( gripPose.angularVelocity );

						} else {

							grip.hasAngularVelocity = false;

						}

					}

				}

			}

			if ( targetRay !== null ) {

				inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

				// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
				if ( inputPose === null && gripPose !== null ) {

					inputPose = gripPose;

				}

				if ( inputPose !== null ) {

					targetRay.matrix.fromArray( inputPose.transform.matrix );
					targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );
					targetRay.matrixWorldNeedsUpdate = true;

					if ( inputPose.linearVelocity ) {

						targetRay.hasLinearVelocity = true;
						targetRay.linearVelocity.copy( inputPose.linearVelocity );

					} else {

						targetRay.hasLinearVelocity = false;

					}

					if ( inputPose.angularVelocity ) {

						targetRay.hasAngularVelocity = true;
						targetRay.angularVelocity.copy( inputPose.angularVelocity );

					} else {

						targetRay.hasAngularVelocity = false;

					}

					this.dispatchEvent( _moveEvent );

				}

			}


		}

		if ( targetRay !== null ) {

			targetRay.visible = ( inputPose !== null );

		}

		if ( grip !== null ) {

			grip.visible = ( gripPose !== null );

		}

		if ( hand !== null ) {

			hand.visible = ( handPose !== null );

		}

		return this;

	}

	// private method

	_getHandJoint( hand, inputjoint ) {

		if ( hand.joints[ inputjoint.jointName ] === undefined ) {

			const joint = new Group();
			joint.matrixAutoUpdate = false;
			joint.visible = false;
			hand.joints[ inputjoint.jointName ] = joint;

			hand.add( joint );

		}

		return hand.joints[ inputjoint.jointName ];

	}

}

const _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`;

const _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;

class WebXRDepthSensing {

	constructor() {

		this.texture = null;
		this.mesh = null;

		this.depthNear = 0;
		this.depthFar = 0;

	}

	init( renderer, depthData, renderState ) {

		if ( this.texture === null ) {

			const texture = new Texture();

			const texProps = renderer.properties.get( texture );
			texProps.__webglTexture = depthData.texture;

			if ( ( depthData.depthNear != renderState.depthNear ) || ( depthData.depthFar != renderState.depthFar ) ) {

				this.depthNear = depthData.depthNear;
				this.depthFar = depthData.depthFar;

			}

			this.texture = texture;

		}

	}

	render( renderer, cameraXR ) {

		if ( this.texture !== null ) {

			if ( this.mesh === null ) {

				const viewport = cameraXR.cameras[ 0 ].viewport;
				const material = new ShaderMaterial( {
					vertexShader: _occlusion_vertex,
					fragmentShader: _occlusion_fragment,
					uniforms: {
						depthColor: { value: this.texture },
						depthWidth: { value: viewport.z },
						depthHeight: { value: viewport.w }
					}
				} );

				this.mesh = new Mesh( new PlaneGeometry( 20, 20 ), material );

			}

			renderer.render( this.mesh, cameraXR );

		}

	}

	reset() {

		this.texture = null;
		this.mesh = null;

	}

}

class WebXRManager extends EventDispatcher {

	constructor( renderer, gl ) {

		super();

		const scope = this;

		let session = null;

		let framebufferScaleFactor = 1.0;

		let referenceSpace = null;
		let referenceSpaceType = 'local-floor';
		// Set default foveation to maximum.
		let foveation = 1.0;
		let customReferenceSpace = null;

		let pose = null;
		let glBinding = null;
		let glProjLayer = null;
		let glBaseLayer = null;
		let xrFrame = null;

		const depthSensing = new WebXRDepthSensing();
		const attributes = gl.getContextAttributes();

		let initialRenderTarget = null;
		let newRenderTarget = null;

		const controllers = [];
		const controllerInputSources = [];

		const currentSize = new Vector2();
		let currentPixelRatio = null;

		//

		const cameraL = new PerspectiveCamera();
		cameraL.layers.enable( 1 );
		cameraL.viewport = new Vector4();

		const cameraR = new PerspectiveCamera();
		cameraR.layers.enable( 2 );
		cameraR.viewport = new Vector4();

		const cameras = [ cameraL, cameraR ];

		const cameraXR = new ArrayCamera();
		cameraXR.layers.enable( 1 );
		cameraXR.layers.enable( 2 );

		let _currentDepthNear = null;
		let _currentDepthFar = null;

		//

		this.cameraAutoUpdate = true;
		this.enabled = false;

		this.isPresenting = false;

		this.getController = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getTargetRaySpace();

		};

		this.getControllerGrip = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getGripSpace();

		};

		this.getHand = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getHandSpace();

		};

		//

		function onSessionEvent( event ) {

			const controllerIndex = controllerInputSources.indexOf( event.inputSource );

			if ( controllerIndex === - 1 ) {

				return;

			}

			const controller = controllers[ controllerIndex ];

			if ( controller !== undefined ) {

				controller.update( event.inputSource, event.frame, customReferenceSpace || referenceSpace );
				controller.dispatchEvent( { type: event.type, data: event.inputSource } );

			}

		}

		function onSessionEnd() {

			session.removeEventListener( 'select', onSessionEvent );
			session.removeEventListener( 'selectstart', onSessionEvent );
			session.removeEventListener( 'selectend', onSessionEvent );
			session.removeEventListener( 'squeeze', onSessionEvent );
			session.removeEventListener( 'squeezestart', onSessionEvent );
			session.removeEventListener( 'squeezeend', onSessionEvent );
			session.removeEventListener( 'end', onSessionEnd );
			session.removeEventListener( 'inputsourceschange', onInputSourcesChange );

			for ( let i = 0; i < controllers.length; i ++ ) {

				const inputSource = controllerInputSources[ i ];

				if ( inputSource === null ) continue;

				controllerInputSources[ i ] = null;

				controllers[ i ].disconnect( inputSource );

			}

			_currentDepthNear = null;
			_currentDepthFar = null;

			depthSensing.reset();

			// restore framebuffer/rendering state

			renderer.setRenderTarget( initialRenderTarget );

			glBaseLayer = null;
			glProjLayer = null;
			glBinding = null;
			session = null;
			newRenderTarget = null;

			//

			animation.stop();

			scope.isPresenting = false;

			renderer.setPixelRatio( currentPixelRatio );
			renderer.setSize( currentSize.width, currentSize.height, false );

			scope.dispatchEvent( { type: 'sessionend' } );

		}

		this.setFramebufferScaleFactor = function ( value ) {

			framebufferScaleFactor = value;

			if ( scope.isPresenting === true ) {

				console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

			}

		};

		this.setReferenceSpaceType = function ( value ) {

			referenceSpaceType = value;

			if ( scope.isPresenting === true ) {

				console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

			}

		};

		this.getReferenceSpace = function () {

			return customReferenceSpace || referenceSpace;

		};

		this.setReferenceSpace = function ( space ) {

			customReferenceSpace = space;

		};

		this.getBaseLayer = function () {

			return glProjLayer !== null ? glProjLayer : glBaseLayer;

		};

		this.getBinding = function () {

			return glBinding;

		};

		this.getFrame = function () {

			return xrFrame;

		};

		this.getSession = function () {

			return session;

		};

		this.setSession = async function ( value ) {

			session = value;

			if ( session !== null ) {

				initialRenderTarget = renderer.getRenderTarget();

				session.addEventListener( 'select', onSessionEvent );
				session.addEventListener( 'selectstart', onSessionEvent );
				session.addEventListener( 'selectend', onSessionEvent );
				session.addEventListener( 'squeeze', onSessionEvent );
				session.addEventListener( 'squeezestart', onSessionEvent );
				session.addEventListener( 'squeezeend', onSessionEvent );
				session.addEventListener( 'end', onSessionEnd );
				session.addEventListener( 'inputsourceschange', onInputSourcesChange );

				if ( attributes.xrCompatible !== true ) {

					await gl.makeXRCompatible();

				}

				currentPixelRatio = renderer.getPixelRatio();
				renderer.getSize( currentSize );

				if ( session.renderState.layers === undefined ) {

					const layerInit = {
						antialias: attributes.antialias,
						alpha: true,
						depth: attributes.depth,
						stencil: attributes.stencil,
						framebufferScaleFactor: framebufferScaleFactor
					};

					glBaseLayer = new XRWebGLLayer( session, gl, layerInit );

					session.updateRenderState( { baseLayer: glBaseLayer } );

					renderer.setPixelRatio( 1 );
					renderer.setSize( glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false );

					newRenderTarget = new WebGLRenderTarget(
						glBaseLayer.framebufferWidth,
						glBaseLayer.framebufferHeight,
						{
							format: RGBAFormat,
							type: UnsignedByteType,
							colorSpace: renderer.outputColorSpace,
							stencilBuffer: attributes.stencil
						}
					);

				} else {

					let depthFormat = null;
					let depthType = null;
					let glDepthFormat = null;

					if ( attributes.depth ) {

						glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
						depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
						depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;

					}

					const projectionlayerInit = {
						colorFormat: gl.RGBA8,
						depthFormat: glDepthFormat,
						scaleFactor: framebufferScaleFactor
					};

					glBinding = new XRWebGLBinding( session, gl );

					glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );

					session.updateRenderState( { layers: [ glProjLayer ] } );

					renderer.setPixelRatio( 1 );
					renderer.setSize( glProjLayer.textureWidth, glProjLayer.textureHeight, false );

					newRenderTarget = new WebGLRenderTarget(
						glProjLayer.textureWidth,
						glProjLayer.textureHeight,
						{
							format: RGBAFormat,
							type: UnsignedByteType,
							depthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),
							stencilBuffer: attributes.stencil,
							colorSpace: renderer.outputColorSpace,
							samples: attributes.antialias ? 4 : 0,
							resolveDepthBuffer: ( glProjLayer.ignoreDepthValues === false )
						} );

				}

				newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278

				this.setFoveation( foveation );

				customReferenceSpace = null;
				referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

				animation.setContext( session );
				animation.start();

				scope.isPresenting = true;

				scope.dispatchEvent( { type: 'sessionstart' } );

			}

		};

		this.getEnvironmentBlendMode = function () {

			if ( session !== null ) {

				return session.environmentBlendMode;

			}

		};

		function onInputSourcesChange( event ) {

			// Notify disconnected

			for ( let i = 0; i < event.removed.length; i ++ ) {

				const inputSource = event.removed[ i ];
				const index = controllerInputSources.indexOf( inputSource );

				if ( index >= 0 ) {

					controllerInputSources[ index ] = null;
					controllers[ index ].disconnect( inputSource );

				}

			}

			// Notify connected

			for ( let i = 0; i < event.added.length; i ++ ) {

				const inputSource = event.added[ i ];

				let controllerIndex = controllerInputSources.indexOf( inputSource );

				if ( controllerIndex === - 1 ) {

					// Assign input source a controller that currently has no input source

					for ( let i = 0; i < controllers.length; i ++ ) {

						if ( i >= controllerInputSources.length ) {

							controllerInputSources.push( inputSource );
							controllerIndex = i;
							break;

						} else if ( controllerInputSources[ i ] === null ) {

							controllerInputSources[ i ] = inputSource;
							controllerIndex = i;
							break;

						}

					}

					// If all controllers do currently receive input we ignore new ones

					if ( controllerIndex === - 1 ) break;

				}

				const controller = controllers[ controllerIndex ];

				if ( controller ) {

					controller.connect( inputSource );

				}

			}

		}

		//

		const cameraLPos = new Vector3();
		const cameraRPos = new Vector3();

		/**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */
		function setProjectionFromUnion( camera, cameraL, cameraR ) {

			cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
			cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

			const ipd = cameraLPos.distanceTo( cameraRPos );

			const projL = cameraL.projectionMatrix.elements;
			const projR = cameraR.projectionMatrix.elements;

			// VR systems will have identical far and near planes, and
			// most likely identical top and bottom frustum extents.
			// Use the left camera for these values.
			const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
			const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
			const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
			const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

			const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
			const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
			const left = near * leftFov;
			const right = near * rightFov;

			// Calculate the new camera's position offset from the
			// left camera. xOffset should be roughly half `ipd`.
			const zOffset = ipd / ( - leftFov + rightFov );
			const xOffset = zOffset * - leftFov;

			// TODO: Better way to apply this offset?
			cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
			camera.translateX( xOffset );
			camera.translateZ( zOffset );
			camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

			// Find the union of the frustum values of the cameras and scale
			// the values so that the near plane's position does not change in world space,
			// although must now be relative to the new union camera.
			const near2 = near + zOffset;
			const far2 = far + zOffset;
			const left2 = left - xOffset;
			const right2 = right + ( ipd - xOffset );
			const top2 = topFov * far / far2 * near2;
			const bottom2 = bottomFov * far / far2 * near2;

			camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );
			camera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();

		}

		function updateCamera( camera, parent ) {

			if ( parent === null ) {

				camera.matrixWorld.copy( camera.matrix );

			} else {

				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

			}

			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

		}

		this.updateCamera = function ( camera ) {

			if ( session === null ) return;

			if ( depthSensing.texture !== null ) {

				camera.near = depthSensing.depthNear;
				camera.far = depthSensing.depthFar;

			}

			cameraXR.near = cameraR.near = cameraL.near = camera.near;
			cameraXR.far = cameraR.far = cameraL.far = camera.far;

			if ( _currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far ) {

				// Note that the new renderState won't apply until the next frame. See #18320

				session.updateRenderState( {
					depthNear: cameraXR.near,
					depthFar: cameraXR.far
				} );

				_currentDepthNear = cameraXR.near;
				_currentDepthFar = cameraXR.far;

				cameraL.near = _currentDepthNear;
				cameraL.far = _currentDepthFar;
				cameraR.near = _currentDepthNear;
				cameraR.far = _currentDepthFar;

				cameraL.updateProjectionMatrix();
				cameraR.updateProjectionMatrix();
				camera.updateProjectionMatrix();

			}

			const parent = camera.parent;
			const cameras = cameraXR.cameras;

			updateCamera( cameraXR, parent );

			for ( let i = 0; i < cameras.length; i ++ ) {

				updateCamera( cameras[ i ], parent );

			}

			// update projection matrix for proper view frustum culling

			if ( cameras.length === 2 ) {

				setProjectionFromUnion( cameraXR, cameraL, cameraR );

			} else {

				// assume single camera setup (AR)

				cameraXR.projectionMatrix.copy( cameraL.projectionMatrix );

			}

			// update user camera and its children

			updateUserCamera( camera, cameraXR, parent );

		};

		function updateUserCamera( camera, cameraXR, parent ) {

			if ( parent === null ) {

				camera.matrix.copy( cameraXR.matrixWorld );

			} else {

				camera.matrix.copy( parent.matrixWorld );
				camera.matrix.invert();
				camera.matrix.multiply( cameraXR.matrixWorld );

			}

			camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );
			camera.updateMatrixWorld( true );

			camera.projectionMatrix.copy( cameraXR.projectionMatrix );
			camera.projectionMatrixInverse.copy( cameraXR.projectionMatrixInverse );

			if ( camera.isPerspectiveCamera ) {

				camera.fov = RAD2DEG * 2 * Math.atan( 1 / camera.projectionMatrix.elements[ 5 ] );
				camera.zoom = 1;

			}

		}

		this.getCamera = function () {

			return cameraXR;

		};

		this.getFoveation = function () {

			if ( glProjLayer === null && glBaseLayer === null ) {

				return undefined;

			}

			return foveation;

		};

		this.setFoveation = function ( value ) {

			// 0 = no foveation = full resolution
			// 1 = maximum foveation = the edges render at lower resolution

			foveation = value;

			if ( glProjLayer !== null ) {

				glProjLayer.fixedFoveation = value;

			}

			if ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {

				glBaseLayer.fixedFoveation = value;

			}

		};

		this.hasDepthSensing = function () {

			return depthSensing.texture !== null;

		};

		// Animation Loop

		let onAnimationFrameCallback = null;

		function onAnimationFrame( time, frame ) {

			pose = frame.getViewerPose( customReferenceSpace || referenceSpace );
			xrFrame = frame;

			if ( pose !== null ) {

				const views = pose.views;

				if ( glBaseLayer !== null ) {

					renderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );
					renderer.setRenderTarget( newRenderTarget );

				}

				let cameraXRNeedsUpdate = false;

				// check if it's necessary to rebuild cameraXR's camera list

				if ( views.length !== cameraXR.cameras.length ) {

					cameraXR.cameras.length = 0;
					cameraXRNeedsUpdate = true;

				}

				for ( let i = 0; i < views.length; i ++ ) {

					const view = views[ i ];

					let viewport = null;

					if ( glBaseLayer !== null ) {

						viewport = glBaseLayer.getViewport( view );

					} else {

						const glSubImage = glBinding.getViewSubImage( glProjLayer, view );
						viewport = glSubImage.viewport;

						// For side-by-side projection, we only produce a single texture for both eyes.
						if ( i === 0 ) {

							renderer.setRenderTargetTextures(
								newRenderTarget,
								glSubImage.colorTexture,
								glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture );

							renderer.setRenderTarget( newRenderTarget );

						}

					}

					let camera = cameras[ i ];

					if ( camera === undefined ) {

						camera = new PerspectiveCamera();
						camera.layers.enable( i );
						camera.viewport = new Vector4();
						cameras[ i ] = camera;

					}

					camera.matrix.fromArray( view.transform.matrix );
					camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );
					camera.projectionMatrix.fromArray( view.projectionMatrix );
					camera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();
					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

					if ( i === 0 ) {

						cameraXR.matrix.copy( camera.matrix );
						cameraXR.matrix.decompose( cameraXR.position, cameraXR.quaternion, cameraXR.scale );

					}

					if ( cameraXRNeedsUpdate === true ) {

						cameraXR.cameras.push( camera );

					}

				}

				//

				const enabledFeatures = session.enabledFeatures;

				if ( enabledFeatures && enabledFeatures.includes( 'depth-sensing' ) ) {

					const depthData = glBinding.getDepthInformation( views[ 0 ] );

					if ( depthData && depthData.isValid && depthData.texture ) {

						depthSensing.init( renderer, depthData, session.renderState );

					}

				}

			}

			//

			for ( let i = 0; i < controllers.length; i ++ ) {

				const inputSource = controllerInputSources[ i ];
				const controller = controllers[ i ];

				if ( inputSource !== null && controller !== undefined ) {

					controller.update( inputSource, frame, customReferenceSpace || referenceSpace );

				}

			}

			depthSensing.render( renderer, cameraXR );

			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

			if ( frame.detectedPlanes ) {

				scope.dispatchEvent( { type: 'planesdetected', data: frame } );

			}

			xrFrame = null;

		}

		const animation = new WebGLAnimation();

		animation.setAnimationLoop( onAnimationFrame );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;

		};

		this.dispose = function () {};

	}

}

const _e1 = /*@__PURE__*/ new Euler();
const _m1 = /*@__PURE__*/ new Matrix4();

function WebGLMaterials( renderer, properties ) {

	function refreshTransformUniform( map, uniform ) {

		if ( map.matrixAutoUpdate === true ) {

			map.updateMatrix();

		}

		uniform.value.copy( map.matrix );

	}

	function refreshFogUniforms( uniforms, fog ) {

		fog.color.getRGB( uniforms.fogColor.value, getUnlitUniformColorSpace( renderer ) );

		if ( fog.isFog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog.isFogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {

		if ( material.isMeshBasicMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshLambertMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshToonMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsToon( uniforms, material );

		} else if ( material.isMeshPhongMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsPhong( uniforms, material );

		} else if ( material.isMeshStandardMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsStandard( uniforms, material );

			if ( material.isMeshPhysicalMaterial ) {

				refreshUniformsPhysical( uniforms, material, transmissionRenderTarget );

			}

		} else if ( material.isMeshMatcapMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsMatcap( uniforms, material );

		} else if ( material.isMeshDepthMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshDistanceMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsDistance( uniforms, material );

		} else if ( material.isMeshNormalMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isLineBasicMaterial ) {

			refreshUniformsLine( uniforms, material );

			if ( material.isLineDashedMaterial ) {

				refreshUniformsDash( uniforms, material );

			}

		} else if ( material.isPointsMaterial ) {

			refreshUniformsPoints( uniforms, material, pixelRatio, height );

		} else if ( material.isSpriteMaterial ) {

			refreshUniformsSprites( uniforms, material );

		} else if ( material.isShadowMaterial ) {

			uniforms.color.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

		} else if ( material.isShaderMaterial ) {

			material.uniformsNeedUpdate = false; // #15581

		}

	}

	function refreshUniformsCommon( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( material.color ) {

			uniforms.diffuse.value.copy( material.color );

		}

		if ( material.emissive ) {

			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		}

		if ( material.map ) {

			uniforms.map.value = material.map;

			refreshTransformUniform( material.map, uniforms.mapTransform );

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

			refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;

			refreshTransformUniform( material.bumpMap, uniforms.bumpMapTransform );

			uniforms.bumpScale.value = material.bumpScale;

			if ( material.side === BackSide ) {

				uniforms.bumpScale.value *= - 1;

			}

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;

			refreshTransformUniform( material.normalMap, uniforms.normalMapTransform );

			uniforms.normalScale.value.copy( material.normalScale );

			if ( material.side === BackSide ) {

				uniforms.normalScale.value.negate();

			}

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;

			refreshTransformUniform( material.displacementMap, uniforms.displacementMapTransform );

			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

			refreshTransformUniform( material.emissiveMap, uniforms.emissiveMapTransform );

		}

		if ( material.specularMap ) {

			uniforms.specularMap.value = material.specularMap;

			refreshTransformUniform( material.specularMap, uniforms.specularMapTransform );

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

		const materialProperties = properties.get( material );

		const envMap = materialProperties.envMap;
		const envMapRotation = materialProperties.envMapRotation;

		if ( envMap ) {

			uniforms.envMap.value = envMap;

			_e1.copy( envMapRotation );

			// accommodate left-handed frame
			_e1.x *= - 1; _e1.y *= - 1; _e1.z *= - 1;

			if ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) {

				// environment maps which are not cube render targets or PMREMs follow a different convention
				_e1.y *= - 1;
				_e1.z *= - 1;

			}

			uniforms.envMapRotation.value.setFromMatrix4( _m1.makeRotationFromEuler( _e1 ) );

			uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.ior.value = material.ior;
			uniforms.refractionRatio.value = material.refractionRatio;

		}

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;

			// artist-friendly light intensity scaling factor
			const scaleFactor = ( renderer._useLegacyLights === true ) ? Math.PI : 1;

			uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;

			refreshTransformUniform( material.lightMap, uniforms.lightMapTransform );

		}

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

			refreshTransformUniform( material.aoMap, uniforms.aoMapTransform );

		}

	}

	function refreshUniformsLine( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;

		if ( material.map ) {

			uniforms.map.value = material.map;

			refreshTransformUniform( material.map, uniforms.mapTransform );

		}

	}

	function refreshUniformsDash( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * pixelRatio;
		uniforms.scale.value = height * 0.5;

		if ( material.map ) {

			uniforms.map.value = material.map;

			refreshTransformUniform( material.map, uniforms.uvTransform );

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

			refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

	}

	function refreshUniformsSprites( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.rotation.value = material.rotation;

		if ( material.map ) {

			uniforms.map.value = material.map;

			refreshTransformUniform( material.map, uniforms.mapTransform );

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

			refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

	}

	function refreshUniformsPhong( uniforms, material ) {

		uniforms.specular.value.copy( material.specular );
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

	}

	function refreshUniformsToon( uniforms, material ) {

		if ( material.gradientMap ) {

			uniforms.gradientMap.value = material.gradientMap;

		}

	}

	function refreshUniformsStandard( uniforms, material ) {

		uniforms.metalness.value = material.metalness;

		if ( material.metalnessMap ) {

			uniforms.metalnessMap.value = material.metalnessMap;

			refreshTransformUniform( material.metalnessMap, uniforms.metalnessMapTransform );

		}

		uniforms.roughness.value = material.roughness;

		if ( material.roughnessMap ) {

			uniforms.roughnessMap.value = material.roughnessMap;

			refreshTransformUniform( material.roughnessMap, uniforms.roughnessMapTransform );

		}

		if ( material.envMap ) {

			//uniforms.envMap.value = material.envMap; // part of uniforms common

			uniforms.envMapIntensity.value = material.envMapIntensity;

		}

	}

	function refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {

		uniforms.ior.value = material.ior; // also part of uniforms common

		if ( material.sheen > 0 ) {

			uniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );

			uniforms.sheenRoughness.value = material.sheenRoughness;

			if ( material.sheenColorMap ) {

				uniforms.sheenColorMap.value = material.sheenColorMap;

				refreshTransformUniform( material.sheenColorMap, uniforms.sheenColorMapTransform );

			}

			if ( material.sheenRoughnessMap ) {

				uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;

				refreshTransformUniform( material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform );

			}

		}

		if ( material.clearcoat > 0 ) {

			uniforms.clearcoat.value = material.clearcoat;
			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

			if ( material.clearcoatMap ) {

				uniforms.clearcoatMap.value = material.clearcoatMap;

				refreshTransformUniform( material.clearcoatMap, uniforms.clearcoatMapTransform );

			}

			if ( material.clearcoatRoughnessMap ) {

				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

				refreshTransformUniform( material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform );

			}

			if ( material.clearcoatNormalMap ) {

				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

				refreshTransformUniform( material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform );

				uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );

				if ( material.side === BackSide ) {

					uniforms.clearcoatNormalScale.value.negate();

				}

			}

		}

		if ( material.dispersion > 0 ) {

			uniforms.dispersion.value = material.dispersion;

		}

		if ( material.iridescence > 0 ) {

			uniforms.iridescence.value = material.iridescence;
			uniforms.iridescenceIOR.value = material.iridescenceIOR;
			uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[ 0 ];
			uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[ 1 ];

			if ( material.iridescenceMap ) {

				uniforms.iridescenceMap.value = material.iridescenceMap;

				refreshTransformUniform( material.iridescenceMap, uniforms.iridescenceMapTransform );

			}

			if ( material.iridescenceThicknessMap ) {

				uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;

				refreshTransformUniform( material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform );

			}

		}

		if ( material.transmission > 0 ) {

			uniforms.transmission.value = material.transmission;
			uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
			uniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );

			if ( material.transmissionMap ) {

				uniforms.transmissionMap.value = material.transmissionMap;

				refreshTransformUniform( material.transmissionMap, uniforms.transmissionMapTransform );

			}

			uniforms.thickness.value = material.thickness;

			if ( material.thicknessMap ) {

				uniforms.thicknessMap.value = material.thicknessMap;

				refreshTransformUniform( material.thicknessMap, uniforms.thicknessMapTransform );

			}

			uniforms.attenuationDistance.value = material.attenuationDistance;
			uniforms.attenuationColor.value.copy( material.attenuationColor );

		}

		if ( material.anisotropy > 0 ) {

			uniforms.anisotropyVector.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );

			if ( material.anisotropyMap ) {

				uniforms.anisotropyMap.value = material.anisotropyMap;

				refreshTransformUniform( material.anisotropyMap, uniforms.anisotropyMapTransform );

			}

		}

		uniforms.specularIntensity.value = material.specularIntensity;
		uniforms.specularColor.value.copy( material.specularColor );

		if ( material.specularColorMap ) {

			uniforms.specularColorMap.value = material.specularColorMap;

			refreshTransformUniform( material.specularColorMap, uniforms.specularColorMapTransform );

		}

		if ( material.specularIntensityMap ) {

			uniforms.specularIntensityMap.value = material.specularIntensityMap;

			refreshTransformUniform( material.specularIntensityMap, uniforms.specularIntensityMapTransform );

		}

	}

	function refreshUniformsMatcap( uniforms, material ) {

		if ( material.matcap ) {

			uniforms.matcap.value = material.matcap;

		}

	}

	function refreshUniformsDistance( uniforms, material ) {

		const light = properties.get( material ).light;

		uniforms.referencePosition.value.setFromMatrixPosition( light.matrixWorld );
		uniforms.nearDistance.value = light.shadow.camera.near;
		uniforms.farDistance.value = light.shadow.camera.far;

	}

	return {
		refreshFogUniforms: refreshFogUniforms,
		refreshMaterialUniforms: refreshMaterialUniforms
	};

}

function WebGLUniformsGroups( gl, info, capabilities, state ) {

	let buffers = {};
	let updateList = {};
	let allocatedBindingPoints = [];

	const maxBindingPoints = gl.getParameter( gl.MAX_UNIFORM_BUFFER_BINDINGS ); // binding points are global whereas block indices are per shader program

	function bind( uniformsGroup, program ) {

		const webglProgram = program.program;
		state.uniformBlockBinding( uniformsGroup, webglProgram );

	}

	function update( uniformsGroup, program ) {

		let buffer = buffers[ uniformsGroup.id ];

		if ( buffer === undefined ) {

			prepareUniformsGroup( uniformsGroup );

			buffer = createBuffer( uniformsGroup );
			buffers[ uniformsGroup.id ] = buffer;

			uniformsGroup.addEventListener( 'dispose', onUniformsGroupsDispose );

		}

		// ensure to update the binding points/block indices mapping for this program

		const webglProgram = program.program;
		state.updateUBOMapping( uniformsGroup, webglProgram );

		// update UBO once per frame

		const frame = info.render.frame;

		if ( updateList[ uniformsGroup.id ] !== frame ) {

			updateBufferData( uniformsGroup );

			updateList[ uniformsGroup.id ] = frame;

		}

	}

	function createBuffer( uniformsGroup ) {

		// the setup of an UBO is independent of a particular shader program but global

		const bindingPointIndex = allocateBindingPointIndex();
		uniformsGroup.__bindingPointIndex = bindingPointIndex;

		const buffer = gl.createBuffer();
		const size = uniformsGroup.__size;
		const usage = uniformsGroup.usage;

		gl.bindBuffer( gl.UNIFORM_BUFFER, buffer );
		gl.bufferData( gl.UNIFORM_BUFFER, size, usage );
		gl.bindBuffer( gl.UNIFORM_BUFFER, null );
		gl.bindBufferBase( gl.UNIFORM_BUFFER, bindingPointIndex, buffer );

		return buffer;

	}

	function allocateBindingPointIndex() {

		for ( let i = 0; i < maxBindingPoints; i ++ ) {

			if ( allocatedBindingPoints.indexOf( i ) === - 1 ) {

				allocatedBindingPoints.push( i );
				return i;

			}

		}

		console.error( 'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.' );

		return 0;

	}

	function updateBufferData( uniformsGroup ) {

		const buffer = buffers[ uniformsGroup.id ];
		const uniforms = uniformsGroup.uniforms;
		const cache = uniformsGroup.__cache;

		gl.bindBuffer( gl.UNIFORM_BUFFER, buffer );

		for ( let i = 0, il = uniforms.length; i < il; i ++ ) {

			const uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];

			for ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {

				const uniform = uniformArray[ j ];

				if ( hasUniformChanged( uniform, i, j, cache ) === true ) {

					const offset = uniform.__offset;

					const values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];

					let arrayOffset = 0;

					for ( let k = 0; k < values.length; k ++ ) {

						const value = values[ k ];

						const info = getUniformSize( value );

						// TODO add integer and struct support
						if ( typeof value === 'number' || typeof value === 'boolean' ) {

							uniform.__data[ 0 ] = value;
							gl.bufferSubData( gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data );

						} else if ( value.isMatrix3 ) {

							// manually converting 3x3 to 3x4

							uniform.__data[ 0 ] = value.elements[ 0 ];
							uniform.__data[ 1 ] = value.elements[ 1 ];
							uniform.__data[ 2 ] = value.elements[ 2 ];
							uniform.__data[ 3 ] = 0;
							uniform.__data[ 4 ] = value.elements[ 3 ];
							uniform.__data[ 5 ] = value.elements[ 4 ];
							uniform.__data[ 6 ] = value.elements[ 5 ];
							uniform.__data[ 7 ] = 0;
							uniform.__data[ 8 ] = value.elements[ 6 ];
							uniform.__data[ 9 ] = value.elements[ 7 ];
							uniform.__data[ 10 ] = value.elements[ 8 ];
							uniform.__data[ 11 ] = 0;

						} else {

							value.toArray( uniform.__data, arrayOffset );

							arrayOffset += info.storage / Float32Array.BYTES_PER_ELEMENT;

						}

					}

					gl.bufferSubData( gl.UNIFORM_BUFFER, offset, uniform.__data );

				}

			}

		}

		gl.bindBuffer( gl.UNIFORM_BUFFER, null );

	}

	function hasUniformChanged( uniform, index, indexArray, cache ) {

		const value = uniform.value;
		const indexString = index + '_' + indexArray;

		if ( cache[ indexString ] === undefined ) {

			// cache entry does not exist so far

			if ( typeof value === 'number' || typeof value === 'boolean' ) {

				cache[ indexString ] = value;

			} else {

				cache[ indexString ] = value.clone();

			}

			return true;

		} else {

			const cachedObject = cache[ indexString ];

			// compare current value with cached entry

			if ( typeof value === 'number' || typeof value === 'boolean' ) {

				if ( cachedObject !== value ) {

					cache[ indexString ] = value;
					return true;

				}

			} else {

				if ( cachedObject.equals( value ) === false ) {

					cachedObject.copy( value );
					return true;

				}

			}

		}

		return false;

	}

	function prepareUniformsGroup( uniformsGroup ) {

		// determine total buffer size according to the STD140 layout
		// Hint: STD140 is the only supported layout in WebGL 2

		const uniforms = uniformsGroup.uniforms;

		let offset = 0; // global buffer offset in bytes
		const chunkSize = 16; // size of a chunk in bytes

		for ( let i = 0, l = uniforms.length; i < l; i ++ ) {

			const uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];

			for ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {

				const uniform = uniformArray[ j ];

				const values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];

				for ( let k = 0, kl = values.length; k < kl; k ++ ) {

					const value = values[ k ];

					const info = getUniformSize( value );

					// Calculate the chunk offset
					const chunkOffsetUniform = offset % chunkSize;

					// Check for chunk overflow
					if ( chunkOffsetUniform !== 0 && ( chunkSize - chunkOffsetUniform ) < info.boundary ) {

						// Add padding and adjust offset
						offset += ( chunkSize - chunkOffsetUniform );

					}

					// the following two properties will be used for partial buffer updates

					uniform.__data = new Float32Array( info.storage / Float32Array.BYTES_PER_ELEMENT );
					uniform.__offset = offset;


					// Update the global offset
					offset += info.storage;


				}

			}

		}

		// ensure correct final padding

		const chunkOffset = offset % chunkSize;

		if ( chunkOffset > 0 ) offset += ( chunkSize - chunkOffset );

		//

		uniformsGroup.__size = offset;
		uniformsGroup.__cache = {};

		return this;

	}

	function getUniformSize( value ) {

		const info = {
			boundary: 0, // bytes
			storage: 0 // bytes
		};

		// determine sizes according to STD140

		if ( typeof value === 'number' || typeof value === 'boolean' ) {

			// float/int/bool

			info.boundary = 4;
			info.storage = 4;

		} else if ( value.isVector2 ) {

			// vec2

			info.boundary = 8;
			info.storage = 8;

		} else if ( value.isVector3 || value.isColor ) {

			// vec3

			info.boundary = 16;
			info.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes

		} else if ( value.isVector4 ) {

			// vec4

			info.boundary = 16;
			info.storage = 16;

		} else if ( value.isMatrix3 ) {

			// mat3 (in STD140 a 3x3 matrix is represented as 3x4)

			info.boundary = 48;
			info.storage = 48;

		} else if ( value.isMatrix4 ) {

			// mat4

			info.boundary = 64;
			info.storage = 64;

		} else if ( value.isTexture ) {

			console.warn( 'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.' );

		} else {

			console.warn( 'THREE.WebGLRenderer: Unsupported uniform value type.', value );

		}

		return info;

	}

	function onUniformsGroupsDispose( event ) {

		const uniformsGroup = event.target;

		uniformsGroup.removeEventListener( 'dispose', onUniformsGroupsDispose );

		const index = allocatedBindingPoints.indexOf( uniformsGroup.__bindingPointIndex );
		allocatedBindingPoints.splice( index, 1 );

		gl.deleteBuffer( buffers[ uniformsGroup.id ] );

		delete buffers[ uniformsGroup.id ];
		delete updateList[ uniformsGroup.id ];

	}

	function dispose() {

		for ( const id in buffers ) {

			gl.deleteBuffer( buffers[ id ] );

		}

		allocatedBindingPoints = [];
		buffers = {};
		updateList = {};

	}

	return {

		bind: bind,
		update: update,

		dispose: dispose

	};

}

class WebGLRenderer {

	constructor( parameters = {} ) {

		const {
			canvas = createCanvasElement(),
			context = null,
			depth = true,
			stencil = false,
			alpha = false,
			antialias = false,
			premultipliedAlpha = true,
			preserveDrawingBuffer = false,
			powerPreference = 'default',
			failIfMajorPerformanceCaveat = false,
		} = parameters;

		this.isWebGLRenderer = true;

		let _alpha;

		if ( context !== null ) {

			if ( typeof WebGLRenderingContext !== 'undefined' && context instanceof WebGLRenderingContext ) {

				throw new Error( 'THREE.WebGLRenderer: WebGL 1 is not supported since r163.' );

			}

			_alpha = context.getContextAttributes().alpha;

		} else {

			_alpha = alpha;

		}

		const uintClearColor = new Uint32Array( 4 );
		const intClearColor = new Int32Array( 4 );

		let currentRenderList = null;
		let currentRenderState = null;

		// render() can be called from within a callback triggered by another render.
		// We track this so that the nested render call gets its list and state isolated from the parent render call.

		const renderListStack = [];
		const renderStateStack = [];

		// public properties

		this.domElement = canvas;

		// Debug configuration container
		this.debug = {

			/**
			 * Enables error checking and reporting when shader programs are being compiled
			 * @type {boolean}
			 */
			checkShaderErrors: true,
			/**
			 * Callback for custom error reporting.
			 * @type {?Function}
			 */
			onShaderError: null
		};

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false;

		// physically based shading

		this._outputColorSpace = SRGBColorSpace;

		// physical lights

		this._useLegacyLights = false;

		// tone mapping

		this.toneMapping = NoToneMapping;
		this.toneMappingExposure = 1.0;

		// internal properties

		const _this = this;

		let _isContextLost = false;

		// internal state cache

		let _currentActiveCubeFace = 0;
		let _currentActiveMipmapLevel = 0;
		let _currentRenderTarget = null;
		let _currentMaterialId = - 1;

		let _currentCamera = null;

		const _currentViewport = new Vector4();
		const _currentScissor = new Vector4();
		let _currentScissorTest = null;

		const _currentClearColor = new Color( 0x000000 );
		let _currentClearAlpha = 0;

		//

		let _width = canvas.width;
		let _height = canvas.height;

		let _pixelRatio = 1;
		let _opaqueSort = null;
		let _transparentSort = null;

		const _viewport = new Vector4( 0, 0, _width, _height );
		const _scissor = new Vector4( 0, 0, _width, _height );
		let _scissorTest = false;

		// frustum

		const _frustum = new Frustum();

		// clipping

		let _clippingEnabled = false;
		let _localClippingEnabled = false;

		// camera matrices cache

		const _projScreenMatrix = new Matrix4();

		const _vector3 = new Vector3();

		const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

		function getTargetPixelRatio() {

			return _currentRenderTarget === null ? _pixelRatio : 1;

		}

		// initialize

		let _gl = context;

		function getContext( contextName, contextAttributes ) {

			return canvas.getContext( contextName, contextAttributes );

		}

		try {

			const contextAttributes = {
				alpha: true,
				depth,
				stencil,
				antialias,
				premultipliedAlpha,
				preserveDrawingBuffer,
				powerPreference,
				failIfMajorPerformanceCaveat,
			};

			// OffscreenCanvas does not have setAttribute, see #22811
			if ( 'setAttribute' in canvas ) canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );

			// event listeners must be registered before WebGL context is created, see #12753
			canvas.addEventListener( 'webglcontextlost', onContextLost, false );
			canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );
			canvas.addEventListener( 'webglcontextcreationerror', onContextCreationError, false );

			if ( _gl === null ) {

				const contextName = 'webgl2';

				_gl = getContext( contextName, contextAttributes );

				if ( _gl === null ) {

					if ( getContext( contextName ) ) {

						throw new Error( 'Error creating WebGL context with your selected attributes.' );

					} else {

						throw new Error( 'Error creating WebGL context.' );

					}

				}

			}

		} catch ( error ) {

			console.error( 'THREE.WebGLRenderer: ' + error.message );
			throw error;

		}

		let extensions, capabilities, state, info;
		let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
		let programCache, materials, renderLists, renderStates, clipping, shadowMap;

		let background, morphtargets, bufferRenderer, indexedBufferRenderer;

		let utils, bindingStates, uniformsGroups;

		function initGLContext() {

			extensions = new WebGLExtensions( _gl );
			extensions.init();

			utils = new WebGLUtils( _gl, extensions );

			capabilities = new WebGLCapabilities( _gl, extensions, parameters, utils );

			state = new WebGLState( _gl );

			info = new WebGLInfo( _gl );
			properties = new WebGLProperties();
			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
			cubemaps = new WebGLCubeMaps( _this );
			cubeuvmaps = new WebGLCubeUVMaps( _this );
			attributes = new WebGLAttributes( _gl );
			bindingStates = new WebGLBindingStates( _gl, attributes );
			geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
			objects = new WebGLObjects( _gl, geometries, attributes, info );
			morphtargets = new WebGLMorphtargets( _gl, capabilities, textures );
			clipping = new WebGLClipping( properties );
			programCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );
			materials = new WebGLMaterials( _this, properties );
			renderLists = new WebGLRenderLists();
			renderStates = new WebGLRenderStates( extensions );
			background = new WebGLBackground( _this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha );
			shadowMap = new WebGLShadowMap( _this, objects, capabilities );
			uniformsGroups = new WebGLUniformsGroups( _gl, info, capabilities, state );

			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info );
			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info );

			info.programs = programCache.programs;

			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.shadowMap = shadowMap;
			_this.state = state;
			_this.info = info;

		}

		initGLContext();

		// xr

		const xr = new WebXRManager( _this, _gl );

		this.xr = xr;

		// API

		this.getContext = function () {

			return _gl;

		};

		this.getContextAttributes = function () {

			return _gl.getContextAttributes();

		};

		this.forceContextLoss = function () {

			const extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.loseContext();

		};

		this.forceContextRestore = function () {

			const extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.restoreContext();

		};

		this.getPixelRatio = function () {

			return _pixelRatio;

		};

		this.setPixelRatio = function ( value ) {

			if ( value === undefined ) return;

			_pixelRatio = value;

			this.setSize( _width, _height, false );

		};

		this.getSize = function ( target ) {

			return target.set( _width, _height );

		};

		this.setSize = function ( width, height, updateStyle = true ) {

			if ( xr.isPresenting ) {

				console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
				return;

			}

			_width = width;
			_height = height;

			canvas.width = Math.floor( width * _pixelRatio );
			canvas.height = Math.floor( height * _pixelRatio );

			if ( updateStyle === true ) {

				canvas.style.width = width + 'px';
				canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.getDrawingBufferSize = function ( target ) {

			return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

		};

		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

			_width = width;
			_height = height;

			_pixelRatio = pixelRatio;

			canvas.width = Math.floor( width * pixelRatio );
			canvas.height = Math.floor( height * pixelRatio );

			this.setViewport( 0, 0, width, height );

		};

		this.getCurrentViewport = function ( target ) {

			return target.copy( _currentViewport );

		};

		this.getViewport = function ( target ) {

			return target.copy( _viewport );

		};

		this.setViewport = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_viewport.set( x.x, x.y, x.z, x.w );

			} else {

				_viewport.set( x, y, width, height );

			}

			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).round() );

		};

		this.getScissor = function ( target ) {

			return target.copy( _scissor );

		};

		this.setScissor = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_scissor.set( x.x, x.y, x.z, x.w );

			} else {

				_scissor.set( x, y, width, height );

			}

			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).round() );

		};

		this.getScissorTest = function () {

			return _scissorTest;

		};

		this.setScissorTest = function ( boolean ) {

			state.setScissorTest( _scissorTest = boolean );

		};

		this.setOpaqueSort = function ( method ) {

			_opaqueSort = method;

		};

		this.setTransparentSort = function ( method ) {

			_transparentSort = method;

		};

		// Clearing

		this.getClearColor = function ( target ) {

			return target.copy( background.getClearColor() );

		};

		this.setClearColor = function () {

			background.setClearColor.apply( background, arguments );

		};

		this.getClearAlpha = function () {

			return background.getClearAlpha();

		};

		this.setClearAlpha = function () {

			background.setClearAlpha.apply( background, arguments );

		};

		this.clear = function ( color = true, depth = true, stencil = true ) {

			let bits = 0;

			if ( color ) {

				// check if we're trying to clear an integer target
				let isIntegerFormat = false;
				if ( _currentRenderTarget !== null ) {

					const targetFormat = _currentRenderTarget.texture.format;
					isIntegerFormat = targetFormat === RGBAIntegerFormat ||
						targetFormat === RGIntegerFormat ||
						targetFormat === RedIntegerFormat;

				}

				// use the appropriate clear functions to clear the target if it's a signed
				// or unsigned integer target
				if ( isIntegerFormat ) {

					const targetType = _currentRenderTarget.texture.type;
					const isUnsignedType = targetType === UnsignedByteType ||
						targetType === UnsignedIntType ||
						targetType === UnsignedShortType ||
						targetType === UnsignedInt248Type ||
						targetType === UnsignedShort4444Type ||
						targetType === UnsignedShort5551Type;

					const clearColor = background.getClearColor();
					const a = background.getClearAlpha();
					const r = clearColor.r;
					const g = clearColor.g;
					const b = clearColor.b;

					if ( isUnsignedType ) {

						uintClearColor[ 0 ] = r;
						uintClearColor[ 1 ] = g;
						uintClearColor[ 2 ] = b;
						uintClearColor[ 3 ] = a;
						_gl.clearBufferuiv( _gl.COLOR, 0, uintClearColor );

					} else {

						intClearColor[ 0 ] = r;
						intClearColor[ 1 ] = g;
						intClearColor[ 2 ] = b;
						intClearColor[ 3 ] = a;
						_gl.clearBufferiv( _gl.COLOR, 0, intClearColor );

					}

				} else {

					bits |= _gl.COLOR_BUFFER_BIT;

				}

			}

			if ( depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil ) {

				bits |= _gl.STENCIL_BUFFER_BIT;
				this.state.buffers.stencil.setMask( 0xffffffff );

			}

			_gl.clear( bits );

		};

		this.clearColor = function () {

			this.clear( true, false, false );

		};

		this.clearDepth = function () {

			this.clear( false, true, false );

		};

		this.clearStencil = function () {

			this.clear( false, false, true );

		};

		//

		this.dispose = function () {

			canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
			canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );
			canvas.removeEventListener( 'webglcontextcreationerror', onContextCreationError, false );

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			cubemaps.dispose();
			cubeuvmaps.dispose();
			objects.dispose();
			bindingStates.dispose();
			uniformsGroups.dispose();
			programCache.dispose();

			xr.dispose();

			xr.removeEventListener( 'sessionstart', onXRSessionStart );
			xr.removeEventListener( 'sessionend', onXRSessionEnd );

			animation.stop();

		};

		// Events

		function onContextLost( event ) {

			event.preventDefault();

			console.log( 'THREE.WebGLRenderer: Context Lost.' );

			_isContextLost = true;

		}

		function onContextRestore( /* event */ ) {

			console.log( 'THREE.WebGLRenderer: Context Restored.' );

			_isContextLost = false;

			const infoAutoReset = info.autoReset;
			const shadowMapEnabled = shadowMap.enabled;
			const shadowMapAutoUpdate = shadowMap.autoUpdate;
			const shadowMapNeedsUpdate = shadowMap.needsUpdate;
			const shadowMapType = shadowMap.type;

			initGLContext();

			info.autoReset = infoAutoReset;
			shadowMap.enabled = shadowMapEnabled;
			shadowMap.autoUpdate = shadowMapAutoUpdate;
			shadowMap.needsUpdate = shadowMapNeedsUpdate;
			shadowMap.type = shadowMapType;

		}

		function onContextCreationError( event ) {

			console.error( 'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage );

		}

		function onMaterialDispose( event ) {

			const material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		}

		// Buffer deallocation

		function deallocateMaterial( material ) {

			releaseMaterialProgramReferences( material );

			properties.remove( material );

		}


		function releaseMaterialProgramReferences( material ) {

			const programs = properties.get( material ).programs;

			if ( programs !== undefined ) {

				programs.forEach( function ( program ) {

					programCache.releaseProgram( program );

				} );

				if ( material.isShaderMaterial ) {

					programCache.releaseShaderCache( material );

				}

			}

		}

		// Buffer rendering

		this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

			if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

			const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

			const program = setProgram( camera, scene, geometry, material, object );

			state.setMaterial( material, frontFaceCW );

			//

			let index = geometry.index;
			let rangeFactor = 1;

			if ( material.wireframe === true ) {

				index = geometries.getWireframeAttribute( geometry );

				if ( index === undefined ) return;

				rangeFactor = 2;

			}

			//

			const drawRange = geometry.drawRange;
			const position = geometry.attributes.position;

			let drawStart = drawRange.start * rangeFactor;
			let drawEnd = ( drawRange.start + drawRange.count ) * rangeFactor;

			if ( group !== null ) {

				drawStart = Math.max( drawStart, group.start * rangeFactor );
				drawEnd = Math.min( drawEnd, ( group.start + group.count ) * rangeFactor );

			}

			if ( index !== null ) {

				drawStart = Math.max( drawStart, 0 );
				drawEnd = Math.min( drawEnd, index.count );

			} else if ( position !== undefined && position !== null ) {

				drawStart = Math.max( drawStart, 0 );
				drawEnd = Math.min( drawEnd, position.count );

			}

			const drawCount = drawEnd - drawStart;

			if ( drawCount < 0 || drawCount === Infinity ) return;

			//

			bindingStates.setup( object, material, program, geometry, index );

			let attribute;
			let renderer = bufferRenderer;

			if ( index !== null ) {

				attribute = attributes.get( index );

				renderer = indexedBufferRenderer;
				renderer.setIndex( attribute );

			}

			//

			if ( object.isMesh ) {

				if ( material.wireframe === true ) {

					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( _gl.LINES );

				} else {

					renderer.setMode( _gl.TRIANGLES );

				}

			} else if ( object.isLine ) {

				let lineWidth = material.linewidth;

				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

				state.setLineWidth( lineWidth * getTargetPixelRatio() );

				if ( object.isLineSegments ) {

					renderer.setMode( _gl.LINES );

				} else if ( object.isLineLoop ) {

					renderer.setMode( _gl.LINE_LOOP );

				} else {

					renderer.setMode( _gl.LINE_STRIP );

				}

			} else if ( object.isPoints ) {

				renderer.setMode( _gl.POINTS );

			} else if ( object.isSprite ) {

				renderer.setMode( _gl.TRIANGLES );

			}

			if ( object.isBatchedMesh ) {

				if ( object._multiDrawInstances !== null ) {

					renderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );

				} else {

					renderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );

				}

			} else if ( object.isInstancedMesh ) {

				renderer.renderInstances( drawStart, drawCount, object.count );

			} else if ( geometry.isInstancedBufferGeometry ) {

				const maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;
				const instanceCount = Math.min( geometry.instanceCount, maxInstanceCount );

				renderer.renderInstances( drawStart, drawCount, instanceCount );

			} else {

				renderer.render( drawStart, drawCount );

			}

		};

		// Compile

		function prepareMaterial( material, scene, object ) {

			if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

				material.side = BackSide;
				material.needsUpdate = true;
				getProgram( material, scene, object );

				material.side = FrontSide;
				material.needsUpdate = true;
				getProgram( material, scene, object );

				material.side = DoubleSide;

			} else {

				getProgram( material, scene, object );

			}

		}

		this.compile = function ( scene, camera, targetScene = null ) {

			if ( targetScene === null ) targetScene = scene;

			currentRenderState = renderStates.get( targetScene );
			currentRenderState.init( camera );

			renderStateStack.push( currentRenderState );

			// gather lights from both the target scene and the new object that will be added to the scene.

			targetScene.traverseVisible( function ( object ) {

				if ( object.isLight && object.layers.test( camera.layers ) ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				}

			} );

			if ( scene !== targetScene ) {

				scene.traverseVisible( function ( object ) {

					if ( object.isLight && object.layers.test( camera.layers ) ) {

						currentRenderState.pushLight( object );

						if ( object.castShadow ) {

							currentRenderState.pushShadow( object );

						}

					}

				} );

			}

			currentRenderState.setupLights( _this._useLegacyLights );

			// Only initialize materials in the new scene, not the targetScene.

			const materials = new Set();

			scene.traverse( function ( object ) {

				const material = object.material;

				if ( material ) {

					if ( Array.isArray( material ) ) {

						for ( let i = 0; i < material.length; i ++ ) {

							const material2 = material[ i ];

							prepareMaterial( material2, targetScene, object );
							materials.add( material2 );

						}

					} else {

						prepareMaterial( material, targetScene, object );
						materials.add( material );

					}

				}

			} );

			renderStateStack.pop();
			currentRenderState = null;

			return materials;

		};

		// compileAsync

		this.compileAsync = function ( scene, camera, targetScene = null ) {

			const materials = this.compile( scene, camera, targetScene );

			// Wait for all the materials in the new object to indicate that they're
			// ready to be used before resolving the promise.

			return new Promise( ( resolve ) => {

				function checkMaterialsReady() {

					materials.forEach( function ( material ) {

						const materialProperties = properties.get( material );
						const program = materialProperties.currentProgram;

						if ( program.isReady() ) {

							// remove any programs that report they're ready to use from the list
							materials.delete( material );

						}

					} );

					// once the list of compiling materials is empty, call the callback

					if ( materials.size === 0 ) {

						resolve( scene );
						return;

					}

					// if some materials are still not ready, wait a bit and check again

					setTimeout( checkMaterialsReady, 10 );

				}

				if ( extensions.get( 'KHR_parallel_shader_compile' ) !== null ) {

					// If we can check the compilation status of the materials without
					// blocking then do so right away.

					checkMaterialsReady();

				} else {

					// Otherwise start by waiting a bit to give the materials we just
					// initialized a chance to finish.

					setTimeout( checkMaterialsReady, 10 );

				}

			} );

		};

		// Animation Loop

		let onAnimationFrameCallback = null;

		function onAnimationFrame( time ) {

			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

		}

		function onXRSessionStart() {

			animation.stop();

		}

		function onXRSessionEnd() {

			animation.start();

		}

		const animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		if ( typeof self !== 'undefined' ) animation.setContext( self );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;
			xr.setAnimationLoop( callback );

			( callback === null ) ? animation.stop() : animation.start();

		};

		xr.addEventListener( 'sessionstart', onXRSessionStart );
		xr.addEventListener( 'sessionend', onXRSessionEnd );

		// Rendering

		this.render = function ( scene, camera ) {

			if ( camera !== undefined && camera.isCamera !== true ) {

				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			if ( _isContextLost === true ) return;

			// update scene graph

			if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();

			if ( xr.enabled === true && xr.isPresenting === true ) {

				if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );

				camera = xr.getCamera(); // use XR camera for rendering

			}

			//
			if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );

			currentRenderState = renderStates.get( scene, renderStateStack.length );
			currentRenderState.init( camera );

			renderStateStack.push( currentRenderState );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromProjectionMatrix( _projScreenMatrix );

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled );

			currentRenderList = renderLists.get( scene, renderListStack.length );
			currentRenderList.init();

			renderListStack.push( currentRenderList );

			projectObject( scene, camera, 0, _this.sortObjects );

			currentRenderList.finish();

			if ( _this.sortObjects === true ) {

				currentRenderList.sort( _opaqueSort, _transparentSort );

			}

			const renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;
			if ( renderBackground ) {

				background.addToRenderList( currentRenderList, scene );

			}

			//

			this.info.render.frame ++;

			if ( _clippingEnabled === true ) clipping.beginShadows();

			const shadowsArray = currentRenderState.state.shadowsArray;

			shadowMap.render( shadowsArray, scene, camera );

			if ( _clippingEnabled === true ) clipping.endShadows();

			//

			if ( this.info.autoReset === true ) this.info.reset();

			// render scene

			const opaqueObjects = currentRenderList.opaque;
			const transmissiveObjects = currentRenderList.transmissive;

			currentRenderState.setupLights( _this._useLegacyLights );

			if ( camera.isArrayCamera ) {

				const cameras = camera.cameras;

				if ( transmissiveObjects.length > 0 ) {

					for ( let i = 0, l = cameras.length; i < l; i ++ ) {

						const camera2 = cameras[ i ];

						renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera2 );

					}

				}

				if ( renderBackground ) background.render( scene );

				for ( let i = 0, l = cameras.length; i < l; i ++ ) {

					const camera2 = cameras[ i ];

					renderScene( currentRenderList, scene, camera2, camera2.viewport );

				}

			} else {

				if ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera );

				if ( renderBackground ) background.render( scene );

				renderScene( currentRenderList, scene, camera );

			}

			//

			if ( _currentRenderTarget !== null ) {

				// resolve multisample renderbuffers to a single-sample texture if necessary

				textures.updateMultisampleRenderTarget( _currentRenderTarget );

				// Generate mipmap if we're using any kind of mipmap filtering

				textures.updateRenderTargetMipmap( _currentRenderTarget );

			}

			//

			if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

			// _gl.finish();

			bindingStates.resetDefaultState();
			_currentMaterialId = - 1;
			_currentCamera = null;

			renderStateStack.pop();

			if ( renderStateStack.length > 0 ) {

				currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

				if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, currentRenderState.state.camera );

			} else {

				currentRenderState = null;

			}

			renderListStack.pop();

			if ( renderListStack.length > 0 ) {

				currentRenderList = renderListStack[ renderListStack.length - 1 ];

			} else {

				currentRenderList = null;

			}

		};

		function projectObject( object, camera, groupOrder, sortObjects ) {

			if ( object.visible === false ) return;

			const visible = object.layers.test( camera.layers );

			if ( visible ) {

				if ( object.isGroup ) {

					groupOrder = object.renderOrder;

				} else if ( object.isLOD ) {

					if ( object.autoUpdate === true ) object.update( camera );

				} else if ( object.isLight ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				} else if ( object.isSprite ) {

					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						const geometry = objects.update( object );
						const material = object.material;

						if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				} else if ( object.isMesh || object.isLine || object.isPoints ) {

					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

						const geometry = objects.update( object );
						const material = object.material;

						if ( sortObjects ) {

							if ( object.boundingSphere !== undefined ) {

								if ( object.boundingSphere === null ) object.computeBoundingSphere();
								_vector3.copy( object.boundingSphere.center );

							} else {

								if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
								_vector3.copy( geometry.boundingSphere.center );

							}

							_vector3
								.applyMatrix4( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						if ( Array.isArray( material ) ) {

							const groups = geometry.groups;

							for ( let i = 0, l = groups.length; i < l; i ++ ) {

								const group = groups[ i ];
								const groupMaterial = material[ group.materialIndex ];

								if ( groupMaterial && groupMaterial.visible ) {

									currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

								}

							}

						} else if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ], camera, groupOrder, sortObjects );

			}

		}

		function renderScene( currentRenderList, scene, camera, viewport ) {

			const opaqueObjects = currentRenderList.opaque;
			const transmissiveObjects = currentRenderList.transmissive;
			const transparentObjects = currentRenderList.transparent;

			currentRenderState.setupLightsView( camera );

			if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );

			if ( viewport ) state.viewport( _currentViewport.copy( viewport ) );

			if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
			if ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );
			if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest( true );
			state.buffers.depth.setMask( true );
			state.buffers.color.setMask( true );

			state.setPolygonOffset( false );

		}

		function renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera ) {

			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

			if ( overrideMaterial !== null ) {

				return;

			}

			if ( currentRenderState.state.transmissionRenderTarget[ camera.id ] === undefined ) {

				currentRenderState.state.transmissionRenderTarget[ camera.id ] = new WebGLRenderTarget( 1, 1, {
					generateMipmaps: true,
					type: ( extensions.has( 'EXT_color_buffer_half_float' ) || extensions.has( 'EXT_color_buffer_float' ) ) ? HalfFloatType : UnsignedByteType,
					minFilter: LinearMipmapLinearFilter,
					samples: 4,
					stencilBuffer: stencil,
					resolveDepthBuffer: false,
					resolveStencilBuffer: false
				} );

				// debug

				/*
				const geometry = new PlaneGeometry();
				const material = new MeshBasicMaterial( { map: _transmissionRenderTarget.texture } );

				const mesh = new Mesh( geometry, material );
				scene.add( mesh );
				*/

			}

			const transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[ camera.id ];

			const activeViewport = camera.viewport || _currentViewport;
			transmissionRenderTarget.setSize( activeViewport.z, activeViewport.w );

			//

			const currentRenderTarget = _this.getRenderTarget();
			_this.setRenderTarget( transmissionRenderTarget );

			_this.getClearColor( _currentClearColor );
			_currentClearAlpha = _this.getClearAlpha();
			if ( _currentClearAlpha < 1 ) _this.setClearColor( 0xffffff, 0.5 );

			_this.clear();

			// Turn off the features which can affect the frag color for opaque objects pass.
			// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
			const currentToneMapping = _this.toneMapping;
			_this.toneMapping = NoToneMapping;

			// Remove viewport from camera to avoid nested render calls resetting viewport to it (e.g Reflector).
			// Transmission render pass requires viewport to match the transmissionRenderTarget.
			const currentCameraViewport = camera.viewport;
			if ( camera.viewport !== undefined ) camera.viewport = undefined;

			currentRenderState.setupLightsView( camera );

			if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );

			renderObjects( opaqueObjects, scene, camera );

			textures.updateMultisampleRenderTarget( transmissionRenderTarget );
			textures.updateRenderTargetMipmap( transmissionRenderTarget );

			if ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === false ) { // see #28131

				let renderTargetNeedsUpdate = false;

				for ( let i = 0, l = transmissiveObjects.length; i < l; i ++ ) {

					const renderItem = transmissiveObjects[ i ];

					const object = renderItem.object;
					const geometry = renderItem.geometry;
					const material = renderItem.material;
					const group = renderItem.group;

					if ( material.side === DoubleSide && object.layers.test( camera.layers ) ) {

						const currentSide = material.side;

						material.side = BackSide;
						material.needsUpdate = true;

						renderObject( object, scene, camera, geometry, material, group );

						material.side = currentSide;
						material.needsUpdate = true;

						renderTargetNeedsUpdate = true;

					}

				}

				if ( renderTargetNeedsUpdate === true ) {

					textures.updateMultisampleRenderTarget( transmissionRenderTarget );
					textures.updateRenderTargetMipmap( transmissionRenderTarget );

				}

			}

			_this.setRenderTarget( currentRenderTarget );

			_this.setClearColor( _currentClearColor, _currentClearAlpha );

			if ( currentCameraViewport !== undefined ) camera.viewport = currentCameraViewport;

			_this.toneMapping = currentToneMapping;

		}

		function renderObjects( renderList, scene, camera ) {

			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

			for ( let i = 0, l = renderList.length; i < l; i ++ ) {

				const renderItem = renderList[ i ];

				const object = renderItem.object;
				const geometry = renderItem.geometry;
				const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
				const group = renderItem.group;

				if ( object.layers.test( camera.layers ) ) {

					renderObject( object, scene, camera, geometry, material, group );

				}

			}

		}

		function renderObject( object, scene, camera, geometry, material, group ) {

			object.onBeforeRender( _this, scene, camera, geometry, material, group );

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			material.onBeforeRender( _this, scene, camera, geometry, object, group );

			if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

				material.side = BackSide;
				material.needsUpdate = true;
				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

				material.side = FrontSide;
				material.needsUpdate = true;
				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

				material.side = DoubleSide;

			} else {

				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

			}

			object.onAfterRender( _this, scene, camera, geometry, material, group );

		}

		function getProgram( material, scene, object ) {

			if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			const materialProperties = properties.get( material );

			const lights = currentRenderState.state.lights;
			const shadowsArray = currentRenderState.state.shadowsArray;

			const lightsStateVersion = lights.state.version;

			const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
			const programCacheKey = programCache.getProgramCacheKey( parameters );

			let programs = materialProperties.programs;

			// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
			materialProperties.fog = scene.fog;
			materialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );
			materialProperties.envMapRotation = ( materialProperties.environment !== null && material.envMap === null ) ? scene.environmentRotation : material.envMapRotation;

			if ( programs === undefined ) {

				// new material

				material.addEventListener( 'dispose', onMaterialDispose );

				programs = new Map();
				materialProperties.programs = programs;

			}

			let program = programs.get( programCacheKey );

			if ( program !== undefined ) {

				// early out if program and light state is identical

				if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

					updateCommonMaterialProperties( material, parameters );

					return program;

				}

			} else {

				parameters.uniforms = programCache.getUniforms( material );

				material.onBuild( object, parameters, _this );

				material.onBeforeCompile( parameters, _this );

				program = programCache.acquireProgram( parameters, programCacheKey );
				programs.set( programCacheKey, program );

				materialProperties.uniforms = parameters.uniforms;

			}

			const uniforms = materialProperties.uniforms;

			if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

				uniforms.clippingPlanes = clipping.uniform;

			}

			updateCommonMaterialProperties( material, parameters );

			// store the light setup it was created for

			materialProperties.needsLights = materialNeedsLights( material );
			materialProperties.lightsStateVersion = lightsStateVersion;

			if ( materialProperties.needsLights ) {

				// wire up the material to this renderer's lighting state

				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.lightProbe.value = lights.state.probe;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.directionalLightShadows.value = lights.state.directionalShadow;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.spotLightShadows.value = lights.state.spotShadow;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.ltc_1.value = lights.state.rectAreaLTC1;
				uniforms.ltc_2.value = lights.state.rectAreaLTC2;
				uniforms.pointLights.value = lights.state.point;
				uniforms.pointLightShadows.value = lights.state.pointShadow;
				uniforms.hemisphereLights.value = lights.state.hemi;

				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
				uniforms.spotLightMap.value = lights.state.spotLightMap;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
				// TODO (abelnation): add area lights shadow info to uniforms

			}

			materialProperties.currentProgram = program;
			materialProperties.uniformsList = null;

			return program;

		}

		function getUniformList( materialProperties ) {

			if ( materialProperties.uniformsList === null ) {

				const progUniforms = materialProperties.currentProgram.getUniforms();
				materialProperties.uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, materialProperties.uniforms );

			}

			return materialProperties.uniformsList;

		}

		function updateCommonMaterialProperties( material, parameters ) {

			const materialProperties = properties.get( material );

			materialProperties.outputColorSpace = parameters.outputColorSpace;
			materialProperties.batching = parameters.batching;
			materialProperties.instancing = parameters.instancing;
			materialProperties.instancingColor = parameters.instancingColor;
			materialProperties.instancingMorph = parameters.instancingMorph;
			materialProperties.skinning = parameters.skinning;
			materialProperties.morphTargets = parameters.morphTargets;
			materialProperties.morphNormals = parameters.morphNormals;
			materialProperties.morphColors = parameters.morphColors;
			materialProperties.morphTargetsCount = parameters.morphTargetsCount;
			materialProperties.numClippingPlanes = parameters.numClippingPlanes;
			materialProperties.numIntersection = parameters.numClipIntersection;
			materialProperties.vertexAlphas = parameters.vertexAlphas;
			materialProperties.vertexTangents = parameters.vertexTangents;
			materialProperties.toneMapping = parameters.toneMapping;

		}

		function setProgram( camera, scene, geometry, material, object ) {

			if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			textures.resetTextureUnits();

			const fog = scene.fog;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;
			const colorSpace = ( _currentRenderTarget === null ) ? _this.outputColorSpace : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace );
			const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
			const vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;
			const vertexTangents = !! geometry.attributes.tangent && ( !! material.normalMap || material.anisotropy > 0 );
			const morphTargets = !! geometry.morphAttributes.position;
			const morphNormals = !! geometry.morphAttributes.normal;
			const morphColors = !! geometry.morphAttributes.color;

			let toneMapping = NoToneMapping;

			if ( material.toneMapped ) {

				if ( _currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true ) {

					toneMapping = _this.toneMapping;

				}

			}

			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
			const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

			const materialProperties = properties.get( material );
			const lights = currentRenderState.state.lights;

			if ( _clippingEnabled === true ) {

				if ( _localClippingEnabled === true || camera !== _currentCamera ) {

					const useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;

					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					clipping.setState( material, camera, useCache );

				}

			}

			//

			let needsProgramChange = false;

			if ( material.version === materialProperties.__version ) {

				if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

					needsProgramChange = true;

				} else if ( materialProperties.outputColorSpace !== colorSpace ) {

					needsProgramChange = true;

				} else if ( object.isBatchedMesh && materialProperties.batching === false ) {

					needsProgramChange = true;

				} else if ( ! object.isBatchedMesh && materialProperties.batching === true ) {

					needsProgramChange = true;

				} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

					needsProgramChange = true;

				} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

					needsProgramChange = true;

				} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {

					needsProgramChange = true;

				} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {

					needsProgramChange = true;

				} else if ( object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null ) {

					needsProgramChange = true;

				} else if ( object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null ) {

					needsProgramChange = true;

				} else if ( object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null ) {

					needsProgramChange = true;

				} else if ( object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null ) {

					needsProgramChange = true;

				} else if ( materialProperties.envMap !== envMap ) {

					needsProgramChange = true;

				} else if ( material.fog === true && materialProperties.fog !== fog ) {

					needsProgramChange = true;

				} else if ( materialProperties.numClippingPlanes !== undefined &&
					( materialProperties.numClippingPlanes !== clipping.numPlanes ||
					materialProperties.numIntersection !== clipping.numIntersection ) ) {

					needsProgramChange = true;

				} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

					needsProgramChange = true;

				} else if ( materialProperties.vertexTangents !== vertexTangents ) {

					needsProgramChange = true;

				} else if ( materialProperties.morphTargets !== morphTargets ) {

					needsProgramChange = true;

				} else if ( materialProperties.morphNormals !== morphNormals ) {

					needsProgramChange = true;

				} else if ( materialProperties.morphColors !== morphColors ) {

					needsProgramChange = true;

				} else if ( materialProperties.toneMapping !== toneMapping ) {

					needsProgramChange = true;

				} else if ( materialProperties.morphTargetsCount !== morphTargetsCount ) {

					needsProgramChange = true;

				}

			} else {

				needsProgramChange = true;
				materialProperties.__version = material.version;

			}

			//

			let program = materialProperties.currentProgram;

			if ( needsProgramChange === true ) {

				program = getProgram( material, scene, object );

			}

			let refreshProgram = false;
			let refreshMaterial = false;
			let refreshLights = false;

			const p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.uniforms;

			if ( state.useProgram( program.program ) ) {

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || _currentCamera !== camera ) {

				// common camera uniforms

				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );
				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

				const uCamPos = p_uniforms.map.cameraPosition;

				if ( uCamPos !== undefined ) {

					uCamPos.setValue( _gl, _vector3.setFromMatrixPosition( camera.matrixWorld ) );

				}

				if ( capabilities.logarithmicDepthBuffer ) {

					p_uniforms.setValue( _gl, 'logDepthBufFC',
						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}

				// consider moving isOrthographic to UniformLib and WebGLMaterials, see https://github.com/mrdoob/three.js/pull/26467#issuecomment-1645185067

				if ( material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ) {

					p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

				}

				if ( _currentCamera !== camera ) {

					_currentCamera = camera;

					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done

				}

			}

			// skinning and morph target uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone and morph texture must go before other textures
			// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

			if ( object.isSkinnedMesh ) {

				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

				const skeleton = object.skeleton;

				if ( skeleton ) {

					if ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();

					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );

				}

			}

			if ( object.isBatchedMesh ) {

				p_uniforms.setOptional( _gl, object, 'batchingTexture' );
				p_uniforms.setValue( _gl, 'batchingTexture', object._matricesTexture, textures );

			}

			const morphAttributes = geometry.morphAttributes;

			if ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined ) ) {

				morphtargets.update( object, geometry, program );

			}

			if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

				materialProperties.receiveShadow = object.receiveShadow;
				p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

			}

			// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512

			if ( material.isMeshGouraudMaterial && material.envMap !== null ) {

				m_uniforms.envMap.value = envMap;

				m_uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;

			}

			if ( material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null ) {

				m_uniforms.envMapIntensity.value = scene.environmentIntensity;

			}

			if ( refreshMaterial ) {

				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

				if ( materialProperties.needsLights ) {

					// the current material requires lighting info

					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required

					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

				}

				// refresh uniforms common to several materials

				if ( fog && material.fog === true ) {

					materials.refreshFogUniforms( m_uniforms, fog );

				}

				materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[ camera.id ] );

				WebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );

			}

			if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

				WebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );
				material.uniformsNeedUpdate = false;

			}

			if ( material.isSpriteMaterial ) {

				p_uniforms.setValue( _gl, 'center', object.center );

			}

			// common matrices

			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

			// UBOs

			if ( material.isShaderMaterial || material.isRawShaderMaterial ) {

				const groups = material.uniformsGroups;

				for ( let i = 0, l = groups.length; i < l; i ++ ) {

					const group = groups[ i ];

					uniformsGroups.update( group, program );
					uniformsGroups.bind( group, program );

				}

			}

			return program;

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;
			uniforms.lightProbe.needsUpdate = value;

			uniforms.directionalLights.needsUpdate = value;
			uniforms.directionalLightShadows.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.pointLightShadows.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.spotLightShadows.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;

		}

		function materialNeedsLights( material ) {

			return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
				material.isMeshStandardMaterial || material.isShadowMaterial ||
				( material.isShaderMaterial && material.lights === true );

		}

		this.getActiveCubeFace = function () {

			return _currentActiveCubeFace;

		};

		this.getActiveMipmapLevel = function () {

			return _currentActiveMipmapLevel;

		};

		this.getRenderTarget = function () {

			return _currentRenderTarget;

		};

		this.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {

			properties.get( renderTarget.texture ).__webglTexture = colorTexture;
			properties.get( renderTarget.depthTexture ).__webglTexture = depthTexture;

			const renderTargetProperties = properties.get( renderTarget );
			renderTargetProperties.__hasExternalTextures = true;

			renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;

			if ( ! renderTargetProperties.__autoAllocateDepthBuffer ) {

				// The multisample_render_to_texture extension doesn't work properly if there
				// are midframe flushes and an external depth buffer. Disable use of the extension.
				if ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) {

					console.warn( 'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided' );
					renderTargetProperties.__useRenderToTexture = false;

				}

			}

		};

		this.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {

			const renderTargetProperties = properties.get( renderTarget );
			renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
			renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;

		};

		this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

			_currentRenderTarget = renderTarget;
			_currentActiveCubeFace = activeCubeFace;
			_currentActiveMipmapLevel = activeMipmapLevel;

			let useDefaultFramebuffer = true;
			let framebuffer = null;
			let isCube = false;
			let isRenderTarget3D = false;

			if ( renderTarget ) {

				const renderTargetProperties = properties.get( renderTarget );

				if ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {

					// We need to make sure to rebind the framebuffer.
					state.bindFramebuffer( _gl.FRAMEBUFFER, null );
					useDefaultFramebuffer = false;

				} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {

					textures.setupRenderTarget( renderTarget );

				} else if ( renderTargetProperties.__hasExternalTextures ) {

					// Color and depth texture must be rebound in order for the swapchain to update.
					textures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );

				}

				const texture = renderTarget.texture;

				if ( texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

					isRenderTarget3D = true;

				}

				const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( renderTarget.isWebGLCubeRenderTarget ) {

					if ( Array.isArray( __webglFramebuffer[ activeCubeFace ] ) ) {

						framebuffer = __webglFramebuffer[ activeCubeFace ][ activeMipmapLevel ];

					} else {

						framebuffer = __webglFramebuffer[ activeCubeFace ];

					}

					isCube = true;

				} else if ( ( renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {

					framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

				} else {

					if ( Array.isArray( __webglFramebuffer ) ) {

						framebuffer = __webglFramebuffer[ activeMipmapLevel ];

					} else {

						framebuffer = __webglFramebuffer;

					}

				}

				_currentViewport.copy( renderTarget.viewport );
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;

			} else {

				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
				_currentScissorTest = _scissorTest;

			}

			const framebufferBound = state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

			if ( framebufferBound && useDefaultFramebuffer ) {

				state.drawBuffers( renderTarget, framebuffer );

			}

			state.viewport( _currentViewport );
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );

			if ( isCube ) {

				const textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

			} else if ( isRenderTarget3D ) {

				const textureProperties = properties.get( renderTarget.texture );
				const layer = activeCubeFace || 0;
				_gl.framebufferTextureLayer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );

			}

			_currentMaterialId = - 1; // reset current material to ensure correct uniform bindings

		};

		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

				framebuffer = framebuffer[ activeCubeFaceIndex ];

			}

			if ( framebuffer ) {

				state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				try {

					const texture = renderTarget.texture;
					const textureFormat = texture.format;
					const textureType = texture.type;

					if ( ! capabilities.textureFormatReadable( textureFormat ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;

					}

					if ( ! capabilities.textureTypeReadable( textureType ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;

					}

					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

					}

				} finally {

					// restore framebuffer of current render target if necessary

					const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
					state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				}

			}

		};

		this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

			const levelScale = Math.pow( 2, - level );
			const width = Math.floor( texture.image.width * levelScale );
			const height = Math.floor( texture.image.height * levelScale );

			textures.setTexture2D( texture, 0 );

			_gl.copyTexSubImage2D( _gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height );

			state.unbindTexture();

		};

		this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

			const width = srcTexture.image.width;
			const height = srcTexture.image.height;
			const glFormat = utils.convert( dstTexture.format );
			const glType = utils.convert( dstTexture.type );

			textures.setTexture2D( dstTexture, 0 );

			// As another texture upload may have changed pixelStorei
			// parameters, make sure they are correct for the dstTexture
			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

			if ( srcTexture.isDataTexture ) {

				_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

			} else {

				if ( srcTexture.isCompressedTexture ) {

					_gl.compressedTexSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

				} else {

					_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image );

				}

			}

			// Generate mipmaps only when copying level 0
			if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( _gl.TEXTURE_2D );

			state.unbindTexture();

		};

		this.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {

			const width = sourceBox.max.x - sourceBox.min.x;
			const height = sourceBox.max.y - sourceBox.min.y;
			const depth = sourceBox.max.z - sourceBox.min.z;
			const glFormat = utils.convert( dstTexture.format );
			const glType = utils.convert( dstTexture.type );
			let glTarget;

			if ( dstTexture.isData3DTexture ) {

				textures.setTexture3D( dstTexture, 0 );
				glTarget = _gl.TEXTURE_3D;

			} else if ( dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture ) {

				textures.setTexture2DArray( dstTexture, 0 );
				glTarget = _gl.TEXTURE_2D_ARRAY;

			} else {

				console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
				return;

			}

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

			const unpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );
			const unpackImageHeight = _gl.getParameter( _gl.UNPACK_IMAGE_HEIGHT );
			const unpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );
			const unpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );
			const unpackSkipImages = _gl.getParameter( _gl.UNPACK_SKIP_IMAGES );

			const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ level ] : srcTexture.image;

			_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );
			_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, image.height );
			_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, sourceBox.min.x );
			_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, sourceBox.min.y );
			_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, sourceBox.min.z );

			if ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {

				_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data );

			} else {

				if ( dstTexture.isCompressedArrayTexture ) {

					_gl.compressedTexSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data );

				} else {

					_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image );

				}

			}

			_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, unpackRowLen );
			_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight );
			_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, unpackSkipPixels );
			_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, unpackSkipRows );
			_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, unpackSkipImages );

			// Generate mipmaps only when copying level 0
			if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );

			state.unbindTexture();

		};

		this.initTexture = function ( texture ) {

			if ( texture.isCubeTexture ) {

				textures.setTextureCube( texture, 0 );

			} else if ( texture.isData3DTexture ) {

				textures.setTexture3D( texture, 0 );

			} else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

				textures.setTexture2DArray( texture, 0 );

			} else {

				textures.setTexture2D( texture, 0 );

			}

			state.unbindTexture();

		};

		this.resetState = function () {

			_currentActiveCubeFace = 0;
			_currentActiveMipmapLevel = 0;
			_currentRenderTarget = null;

			state.reset();
			bindingStates.reset();

		};

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

		}

	}

	get coordinateSystem() {

		return WebGLCoordinateSystem;

	}

	get outputColorSpace() {

		return this._outputColorSpace;

	}

	set outputColorSpace( colorSpace ) {

		this._outputColorSpace = colorSpace;

		const gl = this.getContext();
		gl.drawingBufferColorSpace = colorSpace === DisplayP3ColorSpace ? 'display-p3' : 'srgb';
		gl.unpackColorSpace = ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace ? 'display-p3' : 'srgb';

	}

	get useLegacyLights() { // @deprecated, r155

		console.warn( 'THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.' );
		return this._useLegacyLights;

	}

	set useLegacyLights( value ) { // @deprecated, r155

		console.warn( 'THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.' );
		this._useLegacyLights = value;

	}

}

class FogExp2 {

	constructor( color, density = 0.00025 ) {

		this.isFogExp2 = true;

		this.name = '';

		this.color = new Color( color );
		this.density = density;

	}

	clone() {

		return new FogExp2( this.color, this.density );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'FogExp2',
			name: this.name,
			color: this.color.getHex(),
			density: this.density
		};

	}

}

class Fog {

	constructor( color, near = 1, far = 1000 ) {

		this.isFog = true;

		this.name = '';

		this.color = new Color( color );

		this.near = near;
		this.far = far;

	}

	clone() {

		return new Fog( this.color, this.near, this.far );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'Fog',
			name: this.name,
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};

	}

}

class Scene extends Object3D {

	constructor() {

		super();

		this.isScene = true;

		this.type = 'Scene';

		this.background = null;
		this.environment = null;
		this.fog = null;

		this.backgroundBlurriness = 0;
		this.backgroundIntensity = 1;
		this.backgroundRotation = new Euler();

		this.environmentIntensity = 1;
		this.environmentRotation = new Euler();

		this.overrideMaterial = null;

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.background !== null ) this.background = source.background.clone();
		if ( source.environment !== null ) this.environment = source.environment.clone();
		if ( source.fog !== null ) this.fog = source.fog.clone();

		this.backgroundBlurriness = source.backgroundBlurriness;
		this.backgroundIntensity = source.backgroundIntensity;
		this.backgroundRotation.copy( source.backgroundRotation );

		this.environmentIntensity = source.environmentIntensity;
		this.environmentRotation.copy( source.environmentRotation );

		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

		if ( this.backgroundBlurriness > 0 ) data.object.backgroundBlurriness = this.backgroundBlurriness;
		if ( this.backgroundIntensity !== 1 ) data.object.backgroundIntensity = this.backgroundIntensity;
		data.object.backgroundRotation = this.backgroundRotation.toArray();

		if ( this.environmentIntensity !== 1 ) data.object.environmentIntensity = this.environmentIntensity;
		data.object.environmentRotation = this.environmentRotation.toArray();

		return data;

	}

}

class InterleavedBuffer {

	constructor( array, stride ) {

		this.isInterleavedBuffer = true;

		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;

		this.usage = StaticDrawUsage;
		this._updateRange = { offset: 0, count: - 1 };
		this.updateRanges = [];

		this.version = 0;

		this.uuid = generateUUID();

	}

	onUploadCallback() {}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	get updateRange() {

		warnOnce( 'THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.' ); // @deprecated, r159
		return this._updateRange;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	addUpdateRange( start, count ) {

		this.updateRanges.push( { start, count } );

	}

	clearUpdateRanges() {

		this.updateRanges.length = 0;

	}

	copy( source ) {

		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.usage = source.usage;

		return this;

	}

	copyAt( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( let i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	}

	set( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	}

	clone( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

		}

		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

		const ib = new this.constructor( array, this.stride );
		ib.setUsage( this.usage );

		return ib;

	}

	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	toJSON( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		// generate UUID for array buffer if necessary

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );

		}

		//

		return {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		};

	}

}

const _vector$6 = /*@__PURE__*/ new Vector3();

class InterleavedBufferAttribute {

	constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

		this.isInterleavedBufferAttribute = true;

		this.name = '';

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

		this.normalized = normalized;

	}

	get count() {

		return this.data.count;

	}

	get array() {

		return this.data.array;

	}

	set needsUpdate( value ) {

		this.data.needsUpdate = value;

	}

	applyMatrix4( m ) {

		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

			_vector$6.fromBufferAttribute( this, i );

			_vector$6.applyMatrix4( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$6.fromBufferAttribute( this, i );

			_vector$6.applyNormalMatrix( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$6.fromBufferAttribute( this, i );

			_vector$6.transformDirection( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	getComponent( index, component ) {

		let value = this.array[ index * this.data.stride + this.offset + component ];

		if ( this.normalized ) value = denormalize( value, this.array );

		return value;

	}

	setComponent( index, component, value ) {

		if ( this.normalized ) value = normalize( value, this.array );

		this.data.array[ index * this.data.stride + this.offset + component ] = value;

		return this;

	}

	setX( index, x ) {

		if ( this.normalized ) x = normalize( x, this.array );

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	}

	setY( index, y ) {

		if ( this.normalized ) y = normalize( y, this.array );

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	}

	setZ( index, z ) {

		if ( this.normalized ) z = normalize( z, this.array );

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	}

	setW( index, w ) {

		if ( this.normalized ) w = normalize( w, this.array );

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	}

	getX( index ) {

		let x = this.data.array[ index * this.data.stride + this.offset ];

		if ( this.normalized ) x = denormalize( x, this.array );

		return x;

	}

	getY( index ) {

		let y = this.data.array[ index * this.data.stride + this.offset + 1 ];

		if ( this.normalized ) y = denormalize( y, this.array );

		return y;

	}

	getZ( index ) {

		let z = this.data.array[ index * this.data.stride + this.offset + 2 ];

		if ( this.normalized ) z = denormalize( z, this.array );

		return z;

	}

	getW( index ) {

		let w = this.data.array[ index * this.data.stride + this.offset + 3 ];

		if ( this.normalized ) w = denormalize( w, this.array );

		return w;

	}

	setXY( index, x, y ) {

		index = index * this.data.stride + this.offset;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );

		}

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	}

	setXYZ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );

		}

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );
			w = normalize( w, this.array );

		}

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	}

	clone( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

		} else {

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

			}

			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

		}

	}

	toJSON( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			// de-interleave data and save it as an ordinary buffer attribute for now

			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: array,
				normalized: this.normalized
			};

		} else {

			// save as true interleaved attribute

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

			}

			return {
				isInterleavedBufferAttribute: true,
				itemSize: this.itemSize,
				data: this.data.uuid,
				offset: this.offset,
				normalized: this.normalized
			};

		}

	}

}

class SpriteMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isSpriteMaterial = true;

		this.type = 'SpriteMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.rotation = 0;

		this.sizeAttenuation = true;

		this.transparent = true;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.rotation = source.rotation;

		this.sizeAttenuation = source.sizeAttenuation;

		this.fog = source.fog;

		return this;

	}

}

let _geometry;

const _intersectPoint = /*@__PURE__*/ new Vector3();
const _worldScale = /*@__PURE__*/ new Vector3();
const _mvPosition = /*@__PURE__*/ new Vector3();

const _alignedPosition = /*@__PURE__*/ new Vector2();
const _rotatedPosition = /*@__PURE__*/ new Vector2();
const _viewWorldMatrix = /*@__PURE__*/ new Matrix4();

const _vA = /*@__PURE__*/ new Vector3();
const _vB = /*@__PURE__*/ new Vector3();
const _vC = /*@__PURE__*/ new Vector3();

const _uvA = /*@__PURE__*/ new Vector2();
const _uvB = /*@__PURE__*/ new Vector2();
const _uvC = /*@__PURE__*/ new Vector2();

class Sprite extends Object3D {

	constructor( material = new SpriteMaterial() ) {

		super();

		this.isSprite = true;

		this.type = 'Sprite';

		if ( _geometry === undefined ) {

			_geometry = new BufferGeometry();

			const float32Array = new Float32Array( [
				- 0.5, - 0.5, 0, 0, 0,
				0.5, - 0.5, 0, 1, 0,
				0.5, 0.5, 0, 1, 1,
				- 0.5, 0.5, 0, 0, 1
			] );

			const interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

			_geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
			_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
			_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

		}

		this.geometry = _geometry;
		this.material = material;

		this.center = new Vector2( 0.5, 0.5 );

	}

	raycast( raycaster, intersects ) {

		if ( raycaster.camera === null ) {

			console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

		}

		_worldScale.setFromMatrixScale( this.matrixWorld );

		_viewWorldMatrix.copy( raycaster.camera.matrixWorld );
		this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

		_mvPosition.setFromMatrixPosition( this.modelViewMatrix );

		if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

			_worldScale.multiplyScalar( - _mvPosition.z );

		}

		const rotation = this.material.rotation;
		let sin, cos;

		if ( rotation !== 0 ) {

			cos = Math.cos( rotation );
			sin = Math.sin( rotation );

		}

		const center = this.center;

		transformVertex( _vA.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vB.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );

		_uvA.set( 0, 0 );
		_uvB.set( 1, 0 );
		_uvC.set( 1, 1 );

		// check first triangle
		let intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );

		if ( intersect === null ) {

			// check second triangle
			transformVertex( _vB.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			_uvB.set( 0, 1 );

			intersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );
			if ( intersect === null ) {

				return;

			}

		}

		const distance = raycaster.ray.origin.distanceTo( _intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			point: _intersectPoint.clone(),
			uv: Triangle.getInterpolation( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ),
			face: null,
			object: this

		} );

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.center !== undefined ) this.center.copy( source.center );

		this.material = source.material;

		return this;

	}

}

function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

	// compute position in camera space
	_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

	// to check if rotation is not zero
	if ( sin !== undefined ) {

		_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
		_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );

	} else {

		_rotatedPosition.copy( _alignedPosition );

	}


	vertexPosition.copy( mvPosition );
	vertexPosition.x += _rotatedPosition.x;
	vertexPosition.y += _rotatedPosition.y;

	// transform to world space
	vertexPosition.applyMatrix4( _viewWorldMatrix );

}

const _v1$2 = /*@__PURE__*/ new Vector3();
const _v2$1 = /*@__PURE__*/ new Vector3();

class LOD extends Object3D {

	constructor() {

		super();

		this._currentLevel = 0;

		this.type = 'LOD';

		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			},
			isLOD: {
				value: true,
			}
		} );

		this.autoUpdate = true;

	}

	copy( source ) {

		super.copy( source, false );

		const levels = source.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			this.addLevel( level.object.clone(), level.distance, level.hysteresis );

		}

		this.autoUpdate = source.autoUpdate;

		return this;

	}

	addLevel( object, distance = 0, hysteresis = 0 ) {

		distance = Math.abs( distance );

		const levels = this.levels;

		let l;

		for ( l = 0; l < levels.length; l ++ ) {

			if ( distance < levels[ l ].distance ) {

				break;

			}

		}

		levels.splice( l, 0, { distance: distance, hysteresis: hysteresis, object: object } );

		this.add( object );

		return this;

	}

	getCurrentLevel() {

		return this._currentLevel;

	}



	getObjectForDistance( distance ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				let levelDistance = levels[ i ].distance;

				if ( levels[ i ].object.visible ) {

					levelDistance -= levelDistance * levels[ i ].hysteresis;

				}

				if ( distance < levelDistance ) {

					break;

				}

			}

			return levels[ i - 1 ].object;

		}

		return null;

	}

	raycast( raycaster, intersects ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			_v1$2.setFromMatrixPosition( this.matrixWorld );

			const distance = raycaster.ray.origin.distanceTo( _v1$2 );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		}

	}

	update( camera ) {

		const levels = this.levels;

		if ( levels.length > 1 ) {

			_v1$2.setFromMatrixPosition( camera.matrixWorld );
			_v2$1.setFromMatrixPosition( this.matrixWorld );

			const distance = _v1$2.distanceTo( _v2$1 ) / camera.zoom;

			levels[ 0 ].object.visible = true;

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				let levelDistance = levels[ i ].distance;

				if ( levels[ i ].object.visible ) {

					levelDistance -= levelDistance * levels[ i ].hysteresis;

				}

				if ( distance >= levelDistance ) {

					levels[ i - 1 ].object.visible = false;
					levels[ i ].object.visible = true;

				} else {

					break;

				}

			}

			this._currentLevel = i - 1;

			for ( ; i < l; i ++ ) {

				levels[ i ].object.visible = false;

			}

		}

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.autoUpdate === false ) data.object.autoUpdate = false;

		data.object.levels = [];

		const levels = this.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance,
				hysteresis: level.hysteresis
			} );

		}

		return data;

	}

}

const _basePosition = /*@__PURE__*/ new Vector3();

const _skinIndex = /*@__PURE__*/ new Vector4();
const _skinWeight = /*@__PURE__*/ new Vector4();

const _vector3 = /*@__PURE__*/ new Vector3();
const _matrix4 = /*@__PURE__*/ new Matrix4();
const _vertex = /*@__PURE__*/ new Vector3();

const _sphere$4 = /*@__PURE__*/ new Sphere();
const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
const _ray$2 = /*@__PURE__*/ new Ray();

class SkinnedMesh extends Mesh {

	constructor( geometry, material ) {

		super( geometry, material );

		this.isSkinnedMesh = true;

		this.type = 'SkinnedMesh';

		this.bindMode = AttachedBindMode;
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();

		this.boundingBox = null;
		this.boundingSphere = null;

	}

	computeBoundingBox() {

		const geometry = this.geometry;

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		this.boundingBox.makeEmpty();

		const positionAttribute = geometry.getAttribute( 'position' );

		for ( let i = 0; i < positionAttribute.count; i ++ ) {

			this.getVertexPosition( i, _vertex );
			this.boundingBox.expandByPoint( _vertex );

		}

	}

	computeBoundingSphere() {

		const geometry = this.geometry;

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		this.boundingSphere.makeEmpty();

		const positionAttribute = geometry.getAttribute( 'position' );

		for ( let i = 0; i < positionAttribute.count; i ++ ) {

			this.getVertexPosition( i, _vertex );
			this.boundingSphere.expandByPoint( _vertex );

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.bindMode = source.bindMode;
		this.bindMatrix.copy( source.bindMatrix );
		this.bindMatrixInverse.copy( source.bindMatrixInverse );

		this.skeleton = source.skeleton;

		if ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();
		if ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();

		return this;

	}

	raycast( raycaster, intersects ) {

		const material = this.material;
		const matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// test with bounding sphere in world space

		if ( this.boundingSphere === null ) this.computeBoundingSphere();

		_sphere$4.copy( this.boundingSphere );
		_sphere$4.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere$4 ) === false ) return;

		// convert ray to local space of skinned mesh

		_inverseMatrix$2.copy( matrixWorld ).invert();
		_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

		// test with bounding box in local space

		if ( this.boundingBox !== null ) {

			if ( _ray$2.intersectsBox( this.boundingBox ) === false ) return;

		}

		// test for intersections with geometry

		this._computeIntersections( raycaster, intersects, _ray$2 );

	}

	getVertexPosition( index, target ) {

		super.getVertexPosition( index, target );

		this.applyBoneTransform( index, target );

		return target;

	}

	bind( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.copy( bindMatrix ).invert();

	}

	pose() {

		this.skeleton.pose();

	}

	normalizeSkinWeights() {

		const vector = new Vector4();

		const skinWeight = this.geometry.attributes.skinWeight;

		for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

			vector.fromBufferAttribute( skinWeight, i );

			const scale = 1.0 / vector.manhattanLength();

			if ( scale !== Infinity ) {

				vector.multiplyScalar( scale );

			} else {

				vector.set( 1, 0, 0, 0 ); // do something reasonable

			}

			skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

		}

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		if ( this.bindMode === AttachedBindMode ) {

			this.bindMatrixInverse.copy( this.matrixWorld ).invert();

		} else if ( this.bindMode === DetachedBindMode ) {

			this.bindMatrixInverse.copy( this.bindMatrix ).invert();

		} else {

			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

		}

	}

	applyBoneTransform( index, vector ) {

		const skeleton = this.skeleton;
		const geometry = this.geometry;

		_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
		_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

		_basePosition.copy( vector ).applyMatrix4( this.bindMatrix );

		vector.set( 0, 0, 0 );

		for ( let i = 0; i < 4; i ++ ) {

			const weight = _skinWeight.getComponent( i );

			if ( weight !== 0 ) {

				const boneIndex = _skinIndex.getComponent( i );

				_matrix4.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

				vector.addScaledVector( _vector3.copy( _basePosition ).applyMatrix4( _matrix4 ), weight );

			}

		}

		return vector.applyMatrix4( this.bindMatrixInverse );

	}

}

class Bone extends Object3D {

	constructor() {

		super();

		this.isBone = true;

		this.type = 'Bone';

	}

}

class DataTexture extends Texture {

	constructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

		this.isDataTexture = true;

		this.image = { data: data, width: width, height: height };

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

}

const _offsetMatrix = /*@__PURE__*/ new Matrix4();
const _identityMatrix$1 = /*@__PURE__*/ new Matrix4();

class Skeleton {

	constructor( bones = [], boneInverses = [] ) {

		this.uuid = generateUUID();

		this.bones = bones.slice( 0 );
		this.boneInverses = boneInverses;
		this.boneMatrices = null;

		this.boneTexture = null;

		this.init();

	}

	init() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		this.boneMatrices = new Float32Array( bones.length * 16 );

		// calculate inverse bone matrices if necessary

		if ( boneInverses.length === 0 ) {

			this.calculateInverses();

		} else {

			// handle special case

			if ( bones.length !== boneInverses.length ) {

				console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

				this.boneInverses = [];

				for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

					this.boneInverses.push( new Matrix4() );

				}

			}

		}

	}

	calculateInverses() {

		this.boneInverses.length = 0;

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const inverse = new Matrix4();

			if ( this.bones[ i ] ) {

				inverse.copy( this.bones[ i ].matrixWorld ).invert();

			}

			this.boneInverses.push( inverse );

		}

	}

	pose() {

		// recover the bind-time world matrices

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				if ( bone.parent && bone.parent.isBone ) {

					bone.matrix.copy( bone.parent.matrixWorld ).invert();
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	}

	update() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;
		const boneMatrices = this.boneMatrices;
		const boneTexture = this.boneTexture;

		// flatten bone matrices to array

		for ( let i = 0, il = bones.length; i < il; i ++ ) {

			// compute the offset between the current and the original transform

			const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix$1;

			_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
			_offsetMatrix.toArray( boneMatrices, i * 16 );

		}

		if ( boneTexture !== null ) {

			boneTexture.needsUpdate = true;

		}

	}

	clone() {

		return new Skeleton( this.bones, this.boneInverses );

	}

	computeBoneTexture() {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

		let size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
		size = Math.ceil( size / 4 ) * 4;
		size = Math.max( size, 4 );

		const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
		boneMatrices.set( this.boneMatrices ); // copy current values

		const boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
		boneTexture.needsUpdate = true;

		this.boneMatrices = boneMatrices;
		this.boneTexture = boneTexture;

		return this;

	}

	getBoneByName( name ) {

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone.name === name ) {

				return bone;

			}

		}

		return undefined;

	}

	dispose( ) {

		if ( this.boneTexture !== null ) {

			this.boneTexture.dispose();

			this.boneTexture = null;

		}

	}

	fromJSON( json, bones ) {

		this.uuid = json.uuid;

		for ( let i = 0, l = json.bones.length; i < l; i ++ ) {

			const uuid = json.bones[ i ];
			let bone = bones[ uuid ];

			if ( bone === undefined ) {

				console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
				bone = new Bone();

			}

			this.bones.push( bone );
			this.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );

		}

		this.init();

		return this;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.6,
				type: 'Skeleton',
				generator: 'Skeleton.toJSON'
			},
			bones: [],
			boneInverses: []
		};

		data.uuid = this.uuid;

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		for ( let i = 0, l = bones.length; i < l; i ++ ) {

			const bone = bones[ i ];
			data.bones.push( bone.uuid );

			const boneInverse = boneInverses[ i ];
			data.boneInverses.push( boneInverse.toArray() );

		}

		return data;

	}

}

class InstancedBufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized, meshPerAttribute = 1 ) {

		super( array, itemSize, normalized );

		this.isInstancedBufferAttribute = true;

		this.meshPerAttribute = meshPerAttribute;

	}

	copy( source ) {

		super.copy( source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.meshPerAttribute = this.meshPerAttribute;

		data.isInstancedBufferAttribute = true;

		return data;

	}

}

const _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();
const _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();

const _instanceIntersects = [];

const _box3 = /*@__PURE__*/ new Box3();
const _identity = /*@__PURE__*/ new Matrix4();
const _mesh$1 = /*@__PURE__*/ new Mesh();
const _sphere$3 = /*@__PURE__*/ new Sphere();

class InstancedMesh extends Mesh {

	constructor( geometry, material, count ) {

		super( geometry, material );

		this.isInstancedMesh = true;

		this.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );
		this.instanceColor = null;
		this.morphTexture = null;

		this.count = count;

		this.boundingBox = null;
		this.boundingSphere = null;

		for ( let i = 0; i < count; i ++ ) {

			this.setMatrixAt( i, _identity );

		}

	}

	computeBoundingBox() {

		const geometry = this.geometry;
		const count = this.count;

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		if ( geometry.boundingBox === null ) {

			geometry.computeBoundingBox();

		}

		this.boundingBox.makeEmpty();

		for ( let i = 0; i < count; i ++ ) {

			this.getMatrixAt( i, _instanceLocalMatrix );

			_box3.copy( geometry.boundingBox ).applyMatrix4( _instanceLocalMatrix );

			this.boundingBox.union( _box3 );

		}

	}

	computeBoundingSphere() {

		const geometry = this.geometry;
		const count = this.count;

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		if ( geometry.boundingSphere === null ) {

			geometry.computeBoundingSphere();

		}

		this.boundingSphere.makeEmpty();

		for ( let i = 0; i < count; i ++ ) {

			this.getMatrixAt( i, _instanceLocalMatrix );

			_sphere$3.copy( geometry.boundingSphere ).applyMatrix4( _instanceLocalMatrix );

			this.boundingSphere.union( _sphere$3 );

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.instanceMatrix.copy( source.instanceMatrix );

		if ( source.morphTexture !== null ) this.morphTexture = source.morphTexture.clone();
		if ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();

		this.count = source.count;

		if ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();
		if ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();

		return this;

	}

	getColorAt( index, color ) {

		color.fromArray( this.instanceColor.array, index * 3 );

	}

	getMatrixAt( index, matrix ) {

		matrix.fromArray( this.instanceMatrix.array, index * 16 );

	}

	getMorphAt( index, object ) {

		const objectInfluences = object.morphTargetInfluences;

		const array = this.morphTexture.source.data.data;

		const len = objectInfluences.length + 1; // All influences + the baseInfluenceSum

		const dataIndex = index * len + 1; // Skip the baseInfluenceSum at the beginning

		for ( let i = 0; i < objectInfluences.length; i ++ ) {

			objectInfluences[ i ] = array[ dataIndex + i ];

		}

	}

	raycast( raycaster, intersects ) {

		const matrixWorld = this.matrixWorld;
		const raycastTimes = this.count;

		_mesh$1.geometry = this.geometry;
		_mesh$1.material = this.material;

		if ( _mesh$1.material === undefined ) return;

		// test with bounding sphere first

		if ( this.boundingSphere === null ) this.computeBoundingSphere();

		_sphere$3.copy( this.boundingSphere );
		_sphere$3.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;

		// now test each instance

		for ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

			// calculate the world matrix for each instance

			this.getMatrixAt( instanceId, _instanceLocalMatrix );

			_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

			// the mesh represents this single instance

			_mesh$1.matrixWorld = _instanceWorldMatrix;

			_mesh$1.raycast( raycaster, _instanceIntersects );

			// process the result of raycast

			for ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

				const intersect = _instanceIntersects[ i ];
				intersect.instanceId = instanceId;
				intersect.object = this;
				intersects.push( intersect );

			}

			_instanceIntersects.length = 0;

		}

	}

	setColorAt( index, color ) {

		if ( this.instanceColor === null ) {

			this.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ), 3 );

		}

		color.toArray( this.instanceColor.array, index * 3 );

	}

	setMatrixAt( index, matrix ) {

		matrix.toArray( this.instanceMatrix.array, index * 16 );

	}

	setMorphAt( index, object ) {

		const objectInfluences = object.morphTargetInfluences;

		const len = objectInfluences.length + 1; // morphBaseInfluence + all influences

		if ( this.morphTexture === null ) {

			this.morphTexture = new DataTexture( new Float32Array( len * this.count ), len, this.count, RedFormat, FloatType );

		}

		const array = this.morphTexture.source.data.data;

		let morphInfluencesSum = 0;

		for ( let i = 0; i < objectInfluences.length; i ++ ) {

			morphInfluencesSum += objectInfluences[ i ];

		}

		const morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

		const dataIndex = len * index;

		array[ dataIndex ] = morphBaseInfluence;

		array.set( objectInfluences, dataIndex + 1 );

	}

	updateMorphTargets() {

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

		if ( this.morphTexture !== null ) {

			this.morphTexture.dispose();
			this.morphTexture = null;

		}

		return this;

	}

}

function sortOpaque( a, b ) {

	return a.z - b.z;

}

function sortTransparent( a, b ) {

	return b.z - a.z;

}

class MultiDrawRenderList {

	constructor() {

		this.index = 0;
		this.pool = [];
		this.list = [];

	}

	push( drawRange, z ) {

		const pool = this.pool;
		const list = this.list;
		if ( this.index >= pool.length ) {

			pool.push( {

				start: - 1,
				count: - 1,
				z: - 1,

			} );

		}

		const item = pool[ this.index ];
		list.push( item );
		this.index ++;

		item.start = drawRange.start;
		item.count = drawRange.count;
		item.z = z;

	}

	reset() {

		this.list.length = 0;
		this.index = 0;

	}

}

const ID_ATTR_NAME = 'batchId';
const _matrix$1 = /*@__PURE__*/ new Matrix4();
const _invMatrixWorld = /*@__PURE__*/ new Matrix4();
const _identityMatrix = /*@__PURE__*/ new Matrix4();
const _projScreenMatrix$2 = /*@__PURE__*/ new Matrix4();
const _frustum = /*@__PURE__*/ new Frustum();
const _box$1 = /*@__PURE__*/ new Box3();
const _sphere$2 = /*@__PURE__*/ new Sphere();
const _vector$5 = /*@__PURE__*/ new Vector3();
const _renderList = /*@__PURE__*/ new MultiDrawRenderList();
const _mesh = /*@__PURE__*/ new Mesh();
const _batchIntersects = [];

// @TODO: SkinnedMesh support?
// @TODO: geometry.groups support?
// @TODO: geometry.drawRange support?
// @TODO: geometry.morphAttributes support?
// @TODO: Support uniform parameter per geometry
// @TODO: Add an "optimize" function to pack geometry and remove data gaps

// copies data from attribute "src" into "target" starting at "targetOffset"
function copyAttributeData( src, target, targetOffset = 0 ) {

	const itemSize = target.itemSize;
	if ( src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor ) {

		// use the component getters and setters if the array data cannot
		// be copied directly
		const vertexCount = src.count;
		for ( let i = 0; i < vertexCount; i ++ ) {

			for ( let c = 0; c < itemSize; c ++ ) {

				target.setComponent( i + targetOffset, c, src.getComponent( i, c ) );

			}

		}

	} else {

		// faster copy approach using typed array set function
		target.array.set( src.array, targetOffset * itemSize );

	}

	target.needsUpdate = true;

}

class BatchedMesh extends Mesh {

	get maxGeometryCount() {

		return this._maxGeometryCount;

	}

	constructor( maxGeometryCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material ) {

		super( new BufferGeometry(), material );

		this.isBatchedMesh = true;
		this.perObjectFrustumCulled = true;
		this.sortObjects = true;
		this.boundingBox = null;
		this.boundingSphere = null;
		this.customSort = null;

		this._drawRanges = [];
		this._reservedRanges = [];

		this._visibility = [];
		this._active = [];
		this._bounds = [];

		this._maxGeometryCount = maxGeometryCount;
		this._maxVertexCount = maxVertexCount;
		this._maxIndexCount = maxIndexCount;

		this._geometryInitialized = false;
		this._geometryCount = 0;
		this._multiDrawCounts = new Int32Array( maxGeometryCount );
		this._multiDrawStarts = new Int32Array( maxGeometryCount );
		this._multiDrawCount = 0;
		this._multiDrawInstances = null;
		this._visibilityChanged = true;

		// Local matrix per geometry by using data texture
		this._matricesTexture = null;

		this._initMatricesTexture();

	}

	_initMatricesTexture() {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 matrices * 4 pixels =  (8 * 8)
		//       16x16 pixel texture max   64 matrices * 4 pixels = (16 * 16)
		//       32x32 pixel texture max  256 matrices * 4 pixels = (32 * 32)
		//       64x64 pixel texture max 1024 matrices * 4 pixels = (64 * 64)

		let size = Math.sqrt( this._maxGeometryCount * 4 ); // 4 pixels needed for 1 matrix
		size = Math.ceil( size / 4 ) * 4;
		size = Math.max( size, 4 );

		const matricesArray = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
		const matricesTexture = new DataTexture( matricesArray, size, size, RGBAFormat, FloatType );

		this._matricesTexture = matricesTexture;

	}

	_initializeGeometry( reference ) {

		const geometry = this.geometry;
		const maxVertexCount = this._maxVertexCount;
		const maxGeometryCount = this._maxGeometryCount;
		const maxIndexCount = this._maxIndexCount;
		if ( this._geometryInitialized === false ) {

			for ( const attributeName in reference.attributes ) {

				const srcAttribute = reference.getAttribute( attributeName );
				const { array, itemSize, normalized } = srcAttribute;

				const dstArray = new array.constructor( maxVertexCount * itemSize );
				const dstAttribute = new BufferAttribute( dstArray, itemSize, normalized );

				geometry.setAttribute( attributeName, dstAttribute );

			}

			if ( reference.getIndex() !== null ) {

				const indexArray = maxVertexCount > 65536
					? new Uint32Array( maxIndexCount )
					: new Uint16Array( maxIndexCount );

				geometry.setIndex( new BufferAttribute( indexArray, 1 ) );

			}

			const idArray = maxGeometryCount > 65536
				? new Uint32Array( maxVertexCount )
				: new Uint16Array( maxVertexCount );
			geometry.setAttribute( ID_ATTR_NAME, new BufferAttribute( idArray, 1 ) );

			this._geometryInitialized = true;

		}

	}

	// Make sure the geometry is compatible with the existing combined geometry attributes
	_validateGeometry( geometry ) {

		// check that the geometry doesn't have a version of our reserved id attribute
		if ( geometry.getAttribute( ID_ATTR_NAME ) ) {

			throw new Error( `BatchedMesh: Geometry cannot use attribute "${ ID_ATTR_NAME }"` );

		}

		// check to ensure the geometries are using consistent attributes and indices
		const batchGeometry = this.geometry;
		if ( Boolean( geometry.getIndex() ) !== Boolean( batchGeometry.getIndex() ) ) {

			throw new Error( 'BatchedMesh: All geometries must consistently have "index".' );

		}

		for ( const attributeName in batchGeometry.attributes ) {

			if ( attributeName === ID_ATTR_NAME ) {

				continue;

			}

			if ( ! geometry.hasAttribute( attributeName ) ) {

				throw new Error( `BatchedMesh: Added geometry missing "${ attributeName }". All geometries must have consistent attributes.` );

			}

			const srcAttribute = geometry.getAttribute( attributeName );
			const dstAttribute = batchGeometry.getAttribute( attributeName );
			if ( srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized ) {

				throw new Error( 'BatchedMesh: All attributes must have a consistent itemSize and normalized value.' );

			}

		}

	}

	setCustomSort( func ) {

		this.customSort = func;
		return this;

	}

	computeBoundingBox() {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const geometryCount = this._geometryCount;
		const boundingBox = this.boundingBox;
		const active = this._active;

		boundingBox.makeEmpty();
		for ( let i = 0; i < geometryCount; i ++ ) {

			if ( active[ i ] === false ) continue;

			this.getMatrixAt( i, _matrix$1 );
			this.getBoundingBoxAt( i, _box$1 ).applyMatrix4( _matrix$1 );
			boundingBox.union( _box$1 );

		}

	}

	computeBoundingSphere() {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		const geometryCount = this._geometryCount;
		const boundingSphere = this.boundingSphere;
		const active = this._active;

		boundingSphere.makeEmpty();
		for ( let i = 0; i < geometryCount; i ++ ) {

			if ( active[ i ] === false ) continue;

			this.getMatrixAt( i, _matrix$1 );
			this.getBoundingSphereAt( i, _sphere$2 ).applyMatrix4( _matrix$1 );
			boundingSphere.union( _sphere$2 );

		}

	}

	addGeometry( geometry, vertexCount = - 1, indexCount = - 1 ) {

		this._initializeGeometry( geometry );

		this._validateGeometry( geometry );

		// ensure we're not over geometry
		if ( this._geometryCount >= this._maxGeometryCount ) {

			throw new Error( 'BatchedMesh: Maximum geometry count reached.' );

		}

		// get the necessary range fo the geometry
		const reservedRange = {
			vertexStart: - 1,
			vertexCount: - 1,
			indexStart: - 1,
			indexCount: - 1,
		};

		let lastRange = null;
		const reservedRanges = this._reservedRanges;
		const drawRanges = this._drawRanges;
		const bounds = this._bounds;
		if ( this._geometryCount !== 0 ) {

			lastRange = reservedRanges[ reservedRanges.length - 1 ];

		}

		if ( vertexCount === - 1 ) {

			reservedRange.vertexCount = geometry.getAttribute( 'position' ).count;

		} else {

			reservedRange.vertexCount = vertexCount;

		}

		if ( lastRange === null ) {

			reservedRange.vertexStart = 0;

		} else {

			reservedRange.vertexStart = lastRange.vertexStart + lastRange.vertexCount;

		}

		const index = geometry.getIndex();
		const hasIndex = index !== null;
		if ( hasIndex ) {

			if ( indexCount	=== - 1 ) {

				reservedRange.indexCount = index.count;

			} else {

				reservedRange.indexCount = indexCount;

			}

			if ( lastRange === null ) {

				reservedRange.indexStart = 0;

			} else {

				reservedRange.indexStart = lastRange.indexStart + lastRange.indexCount;

			}

		}

		if (
			reservedRange.indexStart !== - 1 &&
			reservedRange.indexStart + reservedRange.indexCount > this._maxIndexCount ||
			reservedRange.vertexStart + reservedRange.vertexCount > this._maxVertexCount
		) {

			throw new Error( 'BatchedMesh: Reserved space request exceeds the maximum buffer size.' );

		}

		const visibility = this._visibility;
		const active = this._active;
		const matricesTexture = this._matricesTexture;
		const matricesArray = this._matricesTexture.image.data;

		// push new visibility states
		visibility.push( true );
		active.push( true );

		// update id
		const geometryId = this._geometryCount;
		this._geometryCount ++;

		// initialize matrix information
		_identityMatrix.toArray( matricesArray, geometryId * 16 );
		matricesTexture.needsUpdate = true;

		// add the reserved range and draw range objects
		reservedRanges.push( reservedRange );
		drawRanges.push( {
			start: hasIndex ? reservedRange.indexStart : reservedRange.vertexStart,
			count: - 1
		} );
		bounds.push( {
			boxInitialized: false,
			box: new Box3(),

			sphereInitialized: false,
			sphere: new Sphere()
		} );

		// set the id for the geometry
		const idAttribute = this.geometry.getAttribute( ID_ATTR_NAME );
		for ( let i = 0; i < reservedRange.vertexCount; i ++ ) {

			idAttribute.setX( reservedRange.vertexStart + i, geometryId );

		}

		idAttribute.needsUpdate = true;

		// update the geometry
		this.setGeometryAt( geometryId, geometry );

		return geometryId;

	}

	setGeometryAt( id, geometry ) {

		if ( id >= this._geometryCount ) {

			throw new Error( 'BatchedMesh: Maximum geometry count reached.' );

		}

		this._validateGeometry( geometry );

		const batchGeometry = this.geometry;
		const hasIndex = batchGeometry.getIndex() !== null;
		const dstIndex = batchGeometry.getIndex();
		const srcIndex = geometry.getIndex();
		const reservedRange = this._reservedRanges[ id ];
		if (
			hasIndex &&
			srcIndex.count > reservedRange.indexCount ||
			geometry.attributes.position.count > reservedRange.vertexCount
		) {

			throw new Error( 'BatchedMesh: Reserved space not large enough for provided geometry.' );

		}

		// copy geometry over
		const vertexStart = reservedRange.vertexStart;
		const vertexCount = reservedRange.vertexCount;
		for ( const attributeName in batchGeometry.attributes ) {

			if ( attributeName === ID_ATTR_NAME ) {

				continue;

			}

			// copy attribute data
			const srcAttribute = geometry.getAttribute( attributeName );
			const dstAttribute = batchGeometry.getAttribute( attributeName );
			copyAttributeData( srcAttribute, dstAttribute, vertexStart );

			// fill the rest in with zeroes
			const itemSize = srcAttribute.itemSize;
			for ( let i = srcAttribute.count, l = vertexCount; i < l; i ++ ) {

				const index = vertexStart + i;
				for ( let c = 0; c < itemSize; c ++ ) {

					dstAttribute.setComponent( index, c, 0 );

				}

			}

			dstAttribute.needsUpdate = true;
			dstAttribute.addUpdateRange( vertexStart * itemSize, vertexCount * itemSize );

		}

		// copy index
		if ( hasIndex ) {

			const indexStart = reservedRange.indexStart;

			// copy index data over
			for ( let i = 0; i < srcIndex.count; i ++ ) {

				dstIndex.setX( indexStart + i, vertexStart + srcIndex.getX( i ) );

			}

			// fill the rest in with zeroes
			for ( let i = srcIndex.count, l = reservedRange.indexCount; i < l; i ++ ) {

				dstIndex.setX( indexStart + i, vertexStart );

			}

			dstIndex.needsUpdate = true;
			dstIndex.addUpdateRange( indexStart, reservedRange.indexCount );

		}

		// store the bounding boxes
		const bound = this._bounds[ id ];
		if ( geometry.boundingBox !== null ) {

			bound.box.copy( geometry.boundingBox );
			bound.boxInitialized = true;

		} else {

			bound.boxInitialized = false;

		}

		if ( geometry.boundingSphere !== null ) {

			bound.sphere.copy( geometry.boundingSphere );
			bound.sphereInitialized = true;

		} else {

			bound.sphereInitialized = false;

		}

		// set drawRange count
		const drawRange = this._drawRanges[ id ];
		const posAttr = geometry.getAttribute( 'position' );
		drawRange.count = hasIndex ? srcIndex.count : posAttr.count;
		this._visibilityChanged = true;

		return id;

	}

	deleteGeometry( geometryId ) {

		// Note: User needs to call optimize() afterward to pack the data.

		const active = this._active;
		if ( geometryId >= active.length || active[ geometryId ] === false ) {

			return this;

		}

		active[ geometryId ] = false;
		this._visibilityChanged = true;

		return this;

	}

	getInstanceCountAt( id ) {

		if ( this._multiDrawInstances === null ) return null;

		return this._multiDrawInstances[ id ];

	}

	setInstanceCountAt( id, instanceCount ) {

		if ( this._multiDrawInstances === null ) {

			this._multiDrawInstances = new Int32Array( this._maxGeometryCount ).fill( 1 );

		}

		this._multiDrawInstances[ id ] = instanceCount;

		return id;

	}

	// get bounding box and compute it if it doesn't exist
	getBoundingBoxAt( id, target ) {

		const active = this._active;
		if ( active[ id ] === false ) {

			return null;

		}

		// compute bounding box
		const bound = this._bounds[ id ];
		const box = bound.box;
		const geometry = this.geometry;
		if ( bound.boxInitialized === false ) {

			box.makeEmpty();

			const index = geometry.index;
			const position = geometry.attributes.position;
			const drawRange = this._drawRanges[ id ];
			for ( let i = drawRange.start, l = drawRange.start + drawRange.count; i < l; i ++ ) {

				let iv = i;
				if ( index ) {

					iv = index.getX( iv );

				}

				box.expandByPoint( _vector$5.fromBufferAttribute( position, iv ) );

			}

			bound.boxInitialized = true;

		}

		target.copy( box );
		return target;

	}

	// get bounding sphere and compute it if it doesn't exist
	getBoundingSphereAt( id, target ) {

		const active = this._active;
		if ( active[ id ] === false ) {

			return null;

		}

		// compute bounding sphere
		const bound = this._bounds[ id ];
		const sphere = bound.sphere;
		const geometry = this.geometry;
		if ( bound.sphereInitialized === false ) {

			sphere.makeEmpty();

			this.getBoundingBoxAt( id, _box$1 );
			_box$1.getCenter( sphere.center );

			const index = geometry.index;
			const position = geometry.attributes.position;
			const drawRange = this._drawRanges[ id ];

			let maxRadiusSq = 0;
			for ( let i = drawRange.start, l = drawRange.start + drawRange.count; i < l; i ++ ) {

				let iv = i;
				if ( index ) {

					iv = index.getX( iv );

				}

				_vector$5.fromBufferAttribute( position, iv );
				maxRadiusSq = Math.max( maxRadiusSq, sphere.center.distanceToSquared( _vector$5 ) );

			}

			sphere.radius = Math.sqrt( maxRadiusSq );
			bound.sphereInitialized = true;

		}

		target.copy( sphere );
		return target;

	}

	setMatrixAt( geometryId, matrix ) {

		// @TODO: Map geometryId to index of the arrays because
		//        optimize() can make geometryId mismatch the index

		const active = this._active;
		const matricesTexture = this._matricesTexture;
		const matricesArray = this._matricesTexture.image.data;
		const geometryCount = this._geometryCount;
		if ( geometryId >= geometryCount || active[ geometryId ] === false ) {

			return this;

		}

		matrix.toArray( matricesArray, geometryId * 16 );
		matricesTexture.needsUpdate = true;

		return this;

	}

	getMatrixAt( geometryId, matrix ) {

		const active = this._active;
		const matricesArray = this._matricesTexture.image.data;
		const geometryCount = this._geometryCount;
		if ( geometryId >= geometryCount || active[ geometryId ] === false ) {

			return null;

		}

		return matrix.fromArray( matricesArray, geometryId * 16 );

	}

	setVisibleAt( geometryId, value ) {

		const visibility = this._visibility;
		const active = this._active;
		const geometryCount = this._geometryCount;

		// if the geometry is out of range, not active, or visibility state
		// does not change then return early
		if (
			geometryId >= geometryCount ||
			active[ geometryId ] === false ||
			visibility[ geometryId ] === value
		) {

			return this;

		}

		visibility[ geometryId ] = value;
		this._visibilityChanged = true;

		return this;

	}

	getVisibleAt( geometryId ) {

		const visibility = this._visibility;
		const active = this._active;
		const geometryCount = this._geometryCount;

		// return early if the geometry is out of range or not active
		if ( geometryId >= geometryCount || active[ geometryId ] === false ) {

			return false;

		}

		return visibility[ geometryId ];

	}

	raycast( raycaster, intersects ) {

		const visibility = this._visibility;
		const active = this._active;
		const drawRanges = this._drawRanges;
		const geometryCount = this._geometryCount;
		const matrixWorld = this.matrixWorld;
		const batchGeometry = this.geometry;

		// iterate over each geometry
		_mesh.material = this.material;
		_mesh.geometry.index = batchGeometry.index;
		_mesh.geometry.attributes = batchGeometry.attributes;
		if ( _mesh.geometry.boundingBox === null ) {

			_mesh.geometry.boundingBox = new Box3();

		}

		if ( _mesh.geometry.boundingSphere === null ) {

			_mesh.geometry.boundingSphere = new Sphere();

		}

		for ( let i = 0; i < geometryCount; i ++ ) {

			if ( ! visibility[ i ] || ! active[ i ] ) {

				continue;

			}

			const drawRange = drawRanges[ i ];
			_mesh.geometry.setDrawRange( drawRange.start, drawRange.count );

			// ge the intersects
			this.getMatrixAt( i, _mesh.matrixWorld ).premultiply( matrixWorld );
			this.getBoundingBoxAt( i, _mesh.geometry.boundingBox );
			this.getBoundingSphereAt( i, _mesh.geometry.boundingSphere );
			_mesh.raycast( raycaster, _batchIntersects );

			// add batch id to the intersects
			for ( let j = 0, l = _batchIntersects.length; j < l; j ++ ) {

				const intersect = _batchIntersects[ j ];
				intersect.object = this;
				intersect.batchId = i;
				intersects.push( intersect );

			}

			_batchIntersects.length = 0;

		}

		_mesh.material = null;
		_mesh.geometry.index = null;
		_mesh.geometry.attributes = {};
		_mesh.geometry.setDrawRange( 0, Infinity );

	}

	copy( source ) {

		super.copy( source );

		this.geometry = source.geometry.clone();
		this.perObjectFrustumCulled = source.perObjectFrustumCulled;
		this.sortObjects = source.sortObjects;
		this.boundingBox = source.boundingBox !== null ? source.boundingBox.clone() : null;
		this.boundingSphere = source.boundingSphere !== null ? source.boundingSphere.clone() : null;

		this._drawRanges = source._drawRanges.map( range => ( { ...range } ) );
		this._reservedRanges = source._reservedRanges.map( range => ( { ...range } ) );

		this._visibility = source._visibility.slice();
		this._active = source._active.slice();
		this._bounds = source._bounds.map( bound => ( {
			boxInitialized: bound.boxInitialized,
			box: bound.box.clone(),

			sphereInitialized: bound.sphereInitialized,
			sphere: bound.sphere.clone()
		} ) );

		this._maxGeometryCount = source._maxGeometryCount;
		this._maxVertexCount = source._maxVertexCount;
		this._maxIndexCount = source._maxIndexCount;

		this._geometryInitialized = source._geometryInitialized;
		this._geometryCount = source._geometryCount;
		this._multiDrawCounts = source._multiDrawCounts.slice();
		this._multiDrawStarts = source._multiDrawStarts.slice();

		this._matricesTexture = source._matricesTexture.clone();
		this._matricesTexture.image.data = this._matricesTexture.image.slice();

		return this;

	}

	dispose() {

		// Assuming the geometry is not shared with other meshes
		this.geometry.dispose();

		this._matricesTexture.dispose();
		this._matricesTexture = null;
		return this;

	}

	onBeforeRender( renderer, scene, camera, geometry, material/*, _group*/ ) {

		// if visibility has not changed and frustum culling and object sorting is not required
		// then skip iterating over all items
		if ( ! this._visibilityChanged && ! this.perObjectFrustumCulled && ! this.sortObjects ) {

			return;

		}

		// the indexed version of the multi draw function requires specifying the start
		// offset in bytes.
		const index = geometry.getIndex();
		const bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT;

		const active = this._active;
		const visibility = this._visibility;
		const multiDrawStarts = this._multiDrawStarts;
		const multiDrawCounts = this._multiDrawCounts;
		const drawRanges = this._drawRanges;
		const perObjectFrustumCulled = this.perObjectFrustumCulled;

		// prepare the frustum in the local frame
		if ( perObjectFrustumCulled ) {

			_projScreenMatrix$2
				.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse )
				.multiply( this.matrixWorld );
			_frustum.setFromProjectionMatrix(
				_projScreenMatrix$2,
				renderer.coordinateSystem
			);

		}

		let count = 0;
		if ( this.sortObjects ) {

			// get the camera position in the local frame
			_invMatrixWorld.copy( this.matrixWorld ).invert();
			_vector$5.setFromMatrixPosition( camera.matrixWorld ).applyMatrix4( _invMatrixWorld );

			for ( let i = 0, l = visibility.length; i < l; i ++ ) {

				if ( visibility[ i ] && active[ i ] ) {

					// get the bounds in world space
					this.getMatrixAt( i, _matrix$1 );
					this.getBoundingSphereAt( i, _sphere$2 ).applyMatrix4( _matrix$1 );

					// determine whether the batched geometry is within the frustum
					let culled = false;
					if ( perObjectFrustumCulled ) {

						culled = ! _frustum.intersectsSphere( _sphere$2 );

					}

					if ( ! culled ) {

						// get the distance from camera used for sorting
						const z = _vector$5.distanceTo( _sphere$2.center );
						_renderList.push( drawRanges[ i ], z );

					}

				}

			}

			// Sort the draw ranges and prep for rendering
			const list = _renderList.list;
			const customSort = this.customSort;
			if ( customSort === null ) {

				list.sort( material.transparent ? sortTransparent : sortOpaque );

			} else {

				customSort.call( this, list, camera );

			}

			for ( let i = 0, l = list.length; i < l; i ++ ) {

				const item = list[ i ];
				multiDrawStarts[ count ] = item.start * bytesPerElement;
				multiDrawCounts[ count ] = item.count;
				count ++;

			}

			_renderList.reset();

		} else {

			for ( let i = 0, l = visibility.length; i < l; i ++ ) {

				if ( visibility[ i ] && active[ i ] ) {

					// determine whether the batched geometry is within the frustum
					let culled = false;
					if ( perObjectFrustumCulled ) {

						// get the bounds in world space
						this.getMatrixAt( i, _matrix$1 );
						this.getBoundingSphereAt( i, _sphere$2 ).applyMatrix4( _matrix$1 );
						culled = ! _frustum.intersectsSphere( _sphere$2 );

					}

					if ( ! culled ) {

						const range = drawRanges[ i ];
						multiDrawStarts[ count ] = range.start * bytesPerElement;
						multiDrawCounts[ count ] = range.count;
						count ++;

					}

				}

			}

		}

		this._multiDrawCount = count;
		this._visibilityChanged = false;

	}

	onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial/* , group */ ) {

		this.onBeforeRender( renderer, null, shadowCamera, geometry, depthMaterial );

	}

}

class LineBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isLineBasicMaterial = true;

		this.type = 'LineBasicMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		this.fog = source.fog;

		return this;

	}

}

const _vStart = /*@__PURE__*/ new Vector3();
const _vEnd = /*@__PURE__*/ new Vector3();

const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
const _ray$1 = /*@__PURE__*/ new Ray();
const _sphere$1 = /*@__PURE__*/ new Sphere();

const _intersectPointOnRay = /*@__PURE__*/ new Vector3();
const _intersectPointOnSegment = /*@__PURE__*/ new Vector3();

class Line extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

		super();

		this.isLine = true;

		this.type = 'Line';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
		this.geometry = source.geometry;

		return this;

	}

	computeLineDistances() {

		const geometry = this.geometry;

		// we assume non-indexed geometry

		if ( geometry.index === null ) {

			const positionAttribute = geometry.attributes.position;
			const lineDistances = [ 0 ];

			for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

				_vStart.fromBufferAttribute( positionAttribute, i - 1 );
				_vEnd.fromBufferAttribute( positionAttribute, i );

				lineDistances[ i ] = lineDistances[ i - 1 ];
				lineDistances[ i ] += _vStart.distanceTo( _vEnd );

			}

			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

		} else {

			console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

		}

		return this;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Line.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$1.copy( geometry.boundingSphere );
		_sphere$1.applyMatrix4( matrixWorld );
		_sphere$1.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

		//

		_inverseMatrix$1.copy( matrixWorld ).invert();
		_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const step = this.isLineSegments ? 2 : 1;

		const index = geometry.index;
		const attributes = geometry.attributes;
		const positionAttribute = attributes.position;

		if ( index !== null ) {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end - 1; i < l; i += step ) {

				const a = index.getX( i );
				const b = index.getX( i + 1 );

				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b );

				if ( intersect ) {

					intersects.push( intersect );

				}

			}

			if ( this.isLineLoop ) {

				const a = index.getX( end - 1 );
				const b = index.getX( start );

				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b );

				if ( intersect ) {

					intersects.push( intersect );

				}

			}

		} else {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end - 1; i < l; i += step ) {

				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, i, i + 1 );

				if ( intersect ) {

					intersects.push( intersect );

				}

			}

			if ( this.isLineLoop ) {

				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, end - 1, start );

				if ( intersect ) {

					intersects.push( intersect );

				}

			}

		}

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

}

function checkIntersection( object, raycaster, ray, thresholdSq, a, b ) {

	const positionAttribute = object.geometry.attributes.position;

	_vStart.fromBufferAttribute( positionAttribute, a );
	_vEnd.fromBufferAttribute( positionAttribute, b );

	const distSq = ray.distanceSqToSegment( _vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment );

	if ( distSq > thresholdSq ) return;

	_intersectPointOnRay.applyMatrix4( object.matrixWorld ); // Move back to world space for distance calculation

	const distance = raycaster.ray.origin.distanceTo( _intersectPointOnRay );

	if ( distance < raycaster.near || distance > raycaster.far ) return;

	return {

		distance: distance,
		// What do we want? intersection point on the ray or on the segment??
		// point: raycaster.ray.at( distance ),
		point: _intersectPointOnSegment.clone().applyMatrix4( object.matrixWorld ),
		index: a,
		face: null,
		faceIndex: null,
		object: object

	};

}

const _start = /*@__PURE__*/ new Vector3();
const _end = /*@__PURE__*/ new Vector3();

class LineSegments extends Line {

	constructor( geometry, material ) {

		super( geometry, material );

		this.isLineSegments = true;

		this.type = 'LineSegments';

	}

	computeLineDistances() {

		const geometry = this.geometry;

		// we assume non-indexed geometry

		if ( geometry.index === null ) {

			const positionAttribute = geometry.attributes.position;
			const lineDistances = [];

			for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

				_start.fromBufferAttribute( positionAttribute, i );
				_end.fromBufferAttribute( positionAttribute, i + 1 );

				lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
				lineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );

			}

			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

		} else {

			console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

		}

		return this;

	}

}

class LineLoop extends Line {

	constructor( geometry, material ) {

		super( geometry, material );

		this.isLineLoop = true;

		this.type = 'LineLoop';

	}

}

class PointsMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isPointsMaterial = true;

		this.type = 'PointsMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.fog = source.fog;

		return this;

	}

}

const _inverseMatrix = /*@__PURE__*/ new Matrix4();
const _ray = /*@__PURE__*/ new Ray();
const _sphere = /*@__PURE__*/ new Sphere();
const _position$2 = /*@__PURE__*/ new Vector3();

class Points extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

		super();

		this.isPoints = true;

		this.type = 'Points';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
		this.geometry = source.geometry;

		return this;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Points.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );
		_sphere.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.copy( matrixWorld ).invert();
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const index = geometry.index;
		const attributes = geometry.attributes;
		const positionAttribute = attributes.position;

		if ( index !== null ) {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, il = end; i < il; i ++ ) {

				const a = index.getX( i );

				_position$2.fromBufferAttribute( positionAttribute, a );

				testPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

			}

		} else {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end; i < l; i ++ ) {

				_position$2.fromBufferAttribute( positionAttribute, i );

				testPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

			}

		}

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

}

function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

	const rayPointDistanceSq = _ray.distanceSqToPoint( point );

	if ( rayPointDistanceSq < localThresholdSq ) {

		const intersectPoint = new Vector3();

		_ray.closestPointToPoint( point, intersectPoint );
		intersectPoint.applyMatrix4( matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			distanceToRay: Math.sqrt( rayPointDistanceSq ),
			point: intersectPoint,
			index: index,
			face: null,
			object: object

		} );

	}

}

class VideoTexture extends Texture {

	constructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		super( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.isVideoTexture = true;

		this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

		this.generateMipmaps = false;

		const scope = this;

		function updateVideo() {

			scope.needsUpdate = true;
			video.requestVideoFrameCallback( updateVideo );

		}

		if ( 'requestVideoFrameCallback' in video ) {

			video.requestVideoFrameCallback( updateVideo );

		}

	}

	clone() {

		return new this.constructor( this.image ).copy( this );

	}

	update() {

		const video = this.image;
		const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;

		if ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {

			this.needsUpdate = true;

		}

	}

}

class FramebufferTexture extends Texture {

	constructor( width, height ) {

		super( { width, height } );

		this.isFramebufferTexture = true;

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.generateMipmaps = false;

		this.needsUpdate = true;

	}

}

class CompressedTexture extends Texture {

	constructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

		this.isCompressedTexture = true;

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	}

}

class CompressedArrayTexture extends CompressedTexture {

	constructor( mipmaps, width, height, depth, format, type ) {

		super( mipmaps, width, height, format, type );

		this.isCompressedArrayTexture = true;
		this.image.depth = depth;
		this.wrapR = ClampToEdgeWrapping;

	}

}

class CompressedCubeTexture extends CompressedTexture {

	constructor( images, format, type ) {

		super( undefined, images[ 0 ].width, images[ 0 ].height, format, type, CubeReflectionMapping );

		this.isCompressedCubeTexture = true;
		this.isCubeTexture = true;

		this.image = images;

	}

}

class CanvasTexture extends Texture {

	constructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		super( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.isCanvasTexture = true;

		this.needsUpdate = true;

	}

}

/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

class Curve {

	constructor() {

		this.type = 'Curve';

		this.arcLengthDivisions = 200;

	}

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint( /* t, optionalTarget */ ) {

		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
		return null;

	}

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getPoint( t, optionalTarget );

	}

	// Get sequence of points using getPoint( t )

	getPoints( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPoint( d / divisions ) );

		}

		return points;

	}

	// Get sequence of points using getPointAt( u )

	getSpacedPoints( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPointAt( d / divisions ) );

		}

		return points;

	}

	// Get total curve arc length

	getLength() {

		const lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	}

	// Get list of cumulative segment lengths

	getLengths( divisions = this.arcLengthDivisions ) {

		if ( this.cacheArcLengths &&
			( this.cacheArcLengths.length === divisions + 1 ) &&
			! this.needsUpdate ) {

			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		const cache = [];
		let current, last = this.getPoint( 0 );
		let sum = 0;

		cache.push( 0 );

		for ( let p = 1; p <= divisions; p ++ ) {

			current = this.getPoint( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

	}

	updateArcLengths() {

		this.needsUpdate = true;
		this.getLengths();

	}

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping( u, distance ) {

		const arcLengths = this.getLengths();

		let i = 0;
		const il = arcLengths.length;

		let targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		// binary search for the index with largest value smaller than target u distance

		let low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		if ( arcLengths[ i ] === targetArcLength ) {

			return i / ( il - 1 );

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		const lengthBefore = arcLengths[ i ];
		const lengthAfter = arcLengths[ i + 1 ];

		const segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		const segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		const t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	}

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent( t, optionalTarget ) {

		const delta = 0.0001;
		let t1 = t - delta;
		let t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		const pt1 = this.getPoint( t1 );
		const pt2 = this.getPoint( t2 );

		const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );

		tangent.copy( pt2 ).sub( pt1 ).normalize();

		return tangent;

	}

	getTangentAt( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getTangent( t, optionalTarget );

	}

	computeFrenetFrames( segments, closed ) {

		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		const normal = new Vector3();

		const tangents = [];
		const normals = [];
		const binormals = [];

		const vec = new Vector3();
		const mat = new Matrix4();

		// compute the tangent vectors for each segment on the curve

		for ( let i = 0; i <= segments; i ++ ) {

			const u = i / segments;

			tangents[ i ] = this.getTangentAt( u, new Vector3() );

		}

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the minimum tangent xyz component

		normals[ 0 ] = new Vector3();
		binormals[ 0 ] = new Vector3();
		let min = Number.MAX_VALUE;
		const tx = Math.abs( tangents[ 0 ].x );
		const ty = Math.abs( tangents[ 0 ].y );
		const tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= min ) {

			min = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= min ) {

			min = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= min ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


		// compute the slowly-varying normal and binormal vectors for each segment on the curve

		for ( let i = 1; i <= segments; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > Number.EPSILON ) {

				vec.normalize();

				const theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed === true ) {

			let theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
			theta /= segments;

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( let i = 1; i <= segments; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}

		return {
			tangents: tangents,
			normals: normals,
			binormals: binormals
		};

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.arcLengthDivisions = source.arcLengthDivisions;

		return this;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.6,
				type: 'Curve',
				generator: 'Curve.toJSON'
			}
		};

		data.arcLengthDivisions = this.arcLengthDivisions;
		data.type = this.type;

		return data;

	}

	fromJSON( json ) {

		this.arcLengthDivisions = json.arcLengthDivisions;

		return this;

	}

}

class EllipseCurve extends Curve {

	constructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {

		super();

		this.isEllipseCurve = true;

		this.type = 'EllipseCurve';

		this.aX = aX;
		this.aY = aY;

		this.xRadius = xRadius;
		this.yRadius = yRadius;

		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;

		this.aClockwise = aClockwise;

		this.aRotation = aRotation;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const twoPi = Math.PI * 2;
		let deltaAngle = this.aEndAngle - this.aStartAngle;
		const samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle < 0 ) deltaAngle += twoPi;
		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

		if ( deltaAngle < Number.EPSILON ) {

			if ( samePoints ) {

				deltaAngle = 0;

			} else {

				deltaAngle = twoPi;

			}

		}

		if ( this.aClockwise === true && ! samePoints ) {

			if ( deltaAngle === twoPi ) {

				deltaAngle = - twoPi;

			} else {

				deltaAngle = deltaAngle - twoPi;

			}

		}

		const angle = this.aStartAngle + t * deltaAngle;
		let x = this.aX + this.xRadius * Math.cos( angle );
		let y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			const cos = Math.cos( this.aRotation );
			const sin = Math.sin( this.aRotation );

			const tx = x - this.aX;
			const ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;

		}

		return point.set( x, y );

	}

	copy( source ) {

		super.copy( source );

		this.aX = source.aX;
		this.aY = source.aY;

		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;

		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;

		this.aClockwise = source.aClockwise;

		this.aRotation = source.aRotation;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.aX = this.aX;
		data.aY = this.aY;

		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;

		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;

		data.aClockwise = this.aClockwise;

		data.aRotation = this.aRotation;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.aX = json.aX;
		this.aY = json.aY;

		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;

		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;

		this.aClockwise = json.aClockwise;

		this.aRotation = json.aRotation;

		return this;

	}

}

class ArcCurve extends EllipseCurve {

	constructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		super( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		this.isArcCurve = true;

		this.type = 'ArcCurve';

	}

}

/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */


/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {

	let c0 = 0, c1 = 0, c2 = 0, c3 = 0;

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	function init( x0, x1, t0, t1 ) {

		c0 = x0;
		c1 = t0;
		c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		c3 = 2 * x0 - 2 * x1 + t0 + t1;

	}

	return {

		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		},

		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			// compute tangents when parameterized in [t1,t2]
			let t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			let t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;

			init( x1, x2, t1, t2 );

		},

		calc: function ( t ) {

			const t2 = t * t;
			const t3 = t2 * t;
			return c0 + c1 * t + c2 * t2 + c3 * t3;

		}

	};

}

//

const tmp = /*@__PURE__*/ new Vector3();
const px = /*@__PURE__*/ new CubicPoly();
const py = /*@__PURE__*/ new CubicPoly();
const pz = /*@__PURE__*/ new CubicPoly();

class CatmullRomCurve3 extends Curve {

	constructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {

		super();

		this.isCatmullRomCurve3 = true;

		this.type = 'CatmullRomCurve3';

		this.points = points;
		this.closed = closed;
		this.curveType = curveType;
		this.tension = tension;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const points = this.points;
		const l = points.length;

		const p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		let intPoint = Math.floor( p );
		let weight = p - intPoint;

		if ( this.closed ) {

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

		} else if ( weight === 0 && intPoint === l - 1 ) {

			intPoint = l - 2;
			weight = 1;

		}

		let p0, p3; // 4 points (p1 & p2 defined below)

		if ( this.closed || intPoint > 0 ) {

			p0 = points[ ( intPoint - 1 ) % l ];

		} else {

			// extrapolate first point
			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			p0 = tmp;

		}

		const p1 = points[ intPoint % l ];
		const p2 = points[ ( intPoint + 1 ) % l ];

		if ( this.closed || intPoint + 2 < l ) {

			p3 = points[ ( intPoint + 2 ) % l ];

		} else {

			// extrapolate last point
			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			p3 = tmp;

		}

		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

			// init Centripetal / Chordal Catmull-Rom
			const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			let dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			let dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			let dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

			// safety check for repeated points
			if ( dt1 < 1e-4 ) dt1 = 1.0;
			if ( dt0 < 1e-4 ) dt0 = dt1;
			if ( dt2 < 1e-4 ) dt2 = dt1;

			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

		} else if ( this.curveType === 'catmullrom' ) {

			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

		}

		point.set(
			px.calc( weight ),
			py.calc( weight ),
			pz.calc( weight )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new Vector3().fromArray( point ) );

		}

		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;

		return this;

	}

}

/**
 * Bezier Curves formulas obtained from
 * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
 */

function CatmullRom( t, p0, p1, p2, p3 ) {

	const v0 = ( p2 - p0 ) * 0.5;
	const v1 = ( p3 - p1 ) * 0.5;
	const t2 = t * t;
	const t3 = t * t2;
	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

}

//

function QuadraticBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * p;

}

function QuadraticBezierP1( t, p ) {

	return 2 * ( 1 - t ) * t * p;

}

function QuadraticBezierP2( t, p ) {

	return t * t * p;

}

function QuadraticBezier( t, p0, p1, p2 ) {

	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
		QuadraticBezierP2( t, p2 );

}

//

function CubicBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * k * p;

}

function CubicBezierP1( t, p ) {

	const k = 1 - t;
	return 3 * k * k * t * p;

}

function CubicBezierP2( t, p ) {

	return 3 * ( 1 - t ) * t * t * p;

}

function CubicBezierP3( t, p ) {

	return t * t * t * p;

}

function CubicBezier( t, p0, p1, p2, p3 ) {

	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
		CubicBezierP3( t, p3 );

}

class CubicBezierCurve extends Curve {

	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {

		super();

		this.isCubicBezierCurve = true;

		this.type = 'CubicBezierCurve';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

class CubicBezierCurve3 extends Curve {

	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {

		super();

		this.isCubicBezierCurve3 = true;

		this.type = 'CubicBezierCurve3';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

class LineCurve extends Curve {

	constructor( v1 = new Vector2(), v2 = new Vector2() ) {

		super();

		this.isLineCurve = true;

		this.type = 'LineCurve';

		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}

	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}

	getTangent( t, optionalTarget = new Vector2() ) {

		return optionalTarget.subVectors( this.v2, this.v1 ).normalize();

	}

	getTangentAt( u, optionalTarget ) {

		return this.getTangent( u, optionalTarget );

	}

	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class LineCurve3 extends Curve {

	constructor( v1 = new Vector3(), v2 = new Vector3() ) {

		super();

		this.isLineCurve3 = true;

		this.type = 'LineCurve3';

		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}

	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}

	getTangent( t, optionalTarget = new Vector3() ) {

		return optionalTarget.subVectors( this.v2, this.v1 ).normalize();

	}

	getTangentAt( u, optionalTarget ) {

		return this.getTangent( u, optionalTarget );

	}

	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class QuadraticBezierCurve extends Curve {

	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {

		super();

		this.isQuadraticBezierCurve = true;

		this.type = 'QuadraticBezierCurve';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class QuadraticBezierCurve3 extends Curve {

	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {

		super();

		this.isQuadraticBezierCurve3 = true;

		this.type = 'QuadraticBezierCurve3';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y ),
			QuadraticBezier( t, v0.z, v1.z, v2.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class SplineCurve extends Curve {

	constructor( points = [] ) {

		super();

		this.isSplineCurve = true;

		this.type = 'SplineCurve';

		this.points = points;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const points = this.points;
		const p = ( points.length - 1 ) * t;

		const intPoint = Math.floor( p );
		const weight = p - intPoint;

		const p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		const p1 = points[ intPoint ];
		const p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		const p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		point.set(
			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new Vector2().fromArray( point ) );

		}

		return this;

	}

}

var Curves = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ArcCurve: ArcCurve,
	CatmullRomCurve3: CatmullRomCurve3,
	CubicBezierCurve: CubicBezierCurve,
	CubicBezierCurve3: CubicBezierCurve3,
	EllipseCurve: EllipseCurve,
	LineCurve: LineCurve,
	LineCurve3: LineCurve3,
	QuadraticBezierCurve: QuadraticBezierCurve,
	QuadraticBezierCurve3: QuadraticBezierCurve3,
	SplineCurve: SplineCurve
});

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

class CurvePath extends Curve {

	constructor() {

		super();

		this.type = 'CurvePath';

		this.curves = [];
		this.autoClose = false; // Automatically closes the path

	}

	add( curve ) {

		this.curves.push( curve );

	}

	closePath() {

		// Add a line curve if start and end of lines are not connected
		const startPoint = this.curves[ 0 ].getPoint( 0 );
		const endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			const lineType = ( startPoint.isVector2 === true ) ? 'LineCurve' : 'LineCurve3';
			this.curves.push( new Curves[ lineType ]( endPoint, startPoint ) );

		}

		return this;

	}

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	getPoint( t, optionalTarget ) {

		const d = t * this.getLength();
		const curveLengths = this.getCurveLengths();
		let i = 0;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				const diff = curveLengths[ i ] - d;
				const curve = this.curves[ i ];

				const segmentLength = curve.getLength();
				const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

				return curve.getPointAt( u, optionalTarget );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	}

	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	getLength() {

		const lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	}

	// cacheLengths must be recalculated.
	updateArcLengths() {

		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getCurveLengths();

	}

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	getCurveLengths() {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		const lengths = [];
		let sums = 0;

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	}

	getSpacedPoints( divisions = 40 ) {

		const points = [];

		for ( let i = 0; i <= divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

		}

		if ( this.autoClose ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	getPoints( divisions = 12 ) {

		const points = [];
		let last;

		for ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {

			const curve = curves[ i ];
			const resolution = curve.isEllipseCurve ? divisions * 2
				: ( curve.isLineCurve || curve.isLineCurve3 ) ? 1
					: curve.isSplineCurve ? divisions * curve.points.length
						: divisions;

			const pts = curve.getPoints( resolution );

			for ( let j = 0; j < pts.length; j ++ ) {

				const point = pts[ j ];

				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

				points.push( point );
				last = point;

			}

		}

		if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	copy( source ) {

		super.copy( source );

		this.curves = [];

		for ( let i = 0, l = source.curves.length; i < l; i ++ ) {

			const curve = source.curves[ i ];

			this.curves.push( curve.clone() );

		}

		this.autoClose = source.autoClose;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.autoClose = this.autoClose;
		data.curves = [];

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			const curve = this.curves[ i ];
			data.curves.push( curve.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.autoClose = json.autoClose;
		this.curves = [];

		for ( let i = 0, l = json.curves.length; i < l; i ++ ) {

			const curve = json.curves[ i ];
			this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

		}

		return this;

	}

}

class Path extends CurvePath {

	constructor( points ) {

		super();

		this.type = 'Path';

		this.currentPoint = new Vector2();

		if ( points ) {

			this.setFromPoints( points );

		}

	}

	setFromPoints( points ) {

		this.moveTo( points[ 0 ].x, points[ 0 ].y );

		for ( let i = 1, l = points.length; i < l; i ++ ) {

			this.lineTo( points[ i ].x, points[ i ].y );

		}

		return this;

	}

	moveTo( x, y ) {

		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		return this;

	}

	lineTo( x, y ) {

		const curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
		this.curves.push( curve );

		this.currentPoint.set( x, y );

		return this;

	}

	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		const curve = new QuadraticBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCPx, aCPy ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		const curve = new CubicBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCP1x, aCP1y ),
			new Vector2( aCP2x, aCP2y ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	splineThru( pts /*Array of Vector*/ ) {

		const npts = [ this.currentPoint.clone() ].concat( pts );

		const curve = new SplineCurve( npts );
		this.curves.push( curve );

		this.currentPoint.copy( pts[ pts.length - 1 ] );

		return this;

	}

	arc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	absarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	ellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		return this;

	}

	absellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		if ( this.curves.length > 0 ) {

			// if a previous curve is present, attempt to join
			const firstPoint = curve.getPoint( 0 );

			if ( ! firstPoint.equals( this.currentPoint ) ) {

				this.lineTo( firstPoint.x, firstPoint.y );

			}

		}

		this.curves.push( curve );

		const lastPoint = curve.getPoint( 1 );
		this.currentPoint.copy( lastPoint );

		return this;

	}

	copy( source ) {

		super.copy( source );

		this.currentPoint.copy( source.currentPoint );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.currentPoint = this.currentPoint.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.currentPoint.fromArray( json.currentPoint );

		return this;

	}

}

class LatheGeometry extends BufferGeometry {

	constructor( points = [ new Vector2( 0, - 0.5 ), new Vector2( 0.5, 0 ), new Vector2( 0, 0.5 ) ], segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {

		super();

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = Math.floor( segments );

		// clamp phiLength so it's in range of [ 0, 2PI ]

		phiLength = clamp( phiLength, 0, Math.PI * 2 );

		// buffers

		const indices = [];
		const vertices = [];
		const uvs = [];
		const initNormals = [];
		const normals = [];

		// helper variables

		const inverseSegments = 1.0 / segments;
		const vertex = new Vector3();
		const uv = new Vector2();
		const normal = new Vector3();
		const curNormal = new Vector3();
		const prevNormal = new Vector3();
		let dx = 0;
		let dy = 0;

		// pre-compute normals for initial "meridian"

		for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

			switch ( j ) {

				case 0:				// special handling for 1st vertex on path

					dx = points[ j + 1 ].x - points[ j ].x;
					dy = points[ j + 1 ].y - points[ j ].y;

					normal.x = dy * 1.0;
					normal.y = - dx;
					normal.z = dy * 0.0;

					prevNormal.copy( normal );

					normal.normalize();

					initNormals.push( normal.x, normal.y, normal.z );

					break;

				case ( points.length - 1 ):	// special handling for last Vertex on path

					initNormals.push( prevNormal.x, prevNormal.y, prevNormal.z );

					break;

				default:			// default handling for all vertices in between

					dx = points[ j + 1 ].x - points[ j ].x;
					dy = points[ j + 1 ].y - points[ j ].y;

					normal.x = dy * 1.0;
					normal.y = - dx;
					normal.z = dy * 0.0;

					curNormal.copy( normal );

					normal.x += prevNormal.x;
					normal.y += prevNormal.y;
					normal.z += prevNormal.z;

					normal.normalize();

					initNormals.push( normal.x, normal.y, normal.z );

					prevNormal.copy( curNormal );

			}

		}

		// generate vertices, uvs and normals

		for ( let i = 0; i <= segments; i ++ ) {

			const phi = phiStart + i * inverseSegments * phiLength;

			const sin = Math.sin( phi );
			const cos = Math.cos( phi );

			for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

				// vertex

				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;

				vertices.push( vertex.x, vertex.y, vertex.z );

				// uv

				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );

				uvs.push( uv.x, uv.y );

				// normal

				const x = initNormals[ 3 * j + 0 ] * sin;
				const y = initNormals[ 3 * j + 1 ];
				const z = initNormals[ 3 * j + 0 ] * cos;

				normals.push( x, y, z );

			}

		}

		// indices

		for ( let i = 0; i < segments; i ++ ) {

			for ( let j = 0; j < ( points.length - 1 ); j ++ ) {

				const base = j + i * points.length;

				const a = base;
				const b = base + points.length;
				const c = base + points.length + 1;
				const d = base + 1;

				// faces

				indices.push( a, b, d );
				indices.push( c, d, b );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new LatheGeometry( data.points, data.segments, data.phiStart, data.phiLength );

	}

}

class CapsuleGeometry extends LatheGeometry {

	constructor( radius = 1, length = 1, capSegments = 4, radialSegments = 8 ) {

		const path = new Path();
		path.absarc( 0, - length / 2, radius, Math.PI * 1.5, 0 );
		path.absarc( 0, length / 2, radius, 0, Math.PI * 0.5 );

		super( path.getPoints( capSegments ), radialSegments );

		this.type = 'CapsuleGeometry';

		this.parameters = {
			radius: radius,
			length: length,
			capSegments: capSegments,
			radialSegments: radialSegments,
		};

	}

	static fromJSON( data ) {

		return new CapsuleGeometry( data.radius, data.length, data.capSegments, data.radialSegments );

	}

}

class CircleGeometry extends BufferGeometry {

	constructor( radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		segments = Math.max( 3, segments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const uv = new Vector2();

		// center point

		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );

		for ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {

			const segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uvs

			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// indices

		for ( let i = 1; i <= segments; i ++ ) {

			indices.push( i, i + 1, 0 );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );

	}

}

class CylinderGeometry extends BufferGeometry {

	constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		const scope = this;

		radialSegments = Math.floor( radialSegments );
		heightSegments = Math.floor( heightSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let index = 0;
		const indexArray = [];
		const halfHeight = height / 2;
		let groupStart = 0;

		// generate geometry

		generateTorso();

		if ( openEnded === false ) {

			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function generateTorso() {

			const normal = new Vector3();
			const vertex = new Vector3();

			let groupCount = 0;

			// this will be used to calculate the normal
			const slope = ( radiusBottom - radiusTop ) / height;

			// generate vertices, normals and uvs

			for ( let y = 0; y <= heightSegments; y ++ ) {

				const indexRow = [];

				const v = y / heightSegments;

				// calculate the radius of the current row

				const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

				for ( let x = 0; x <= radialSegments; x ++ ) {

					const u = x / radialSegments;

					const theta = u * thetaLength + thetaStart;

					const sinTheta = Math.sin( theta );
					const cosTheta = Math.cos( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 1 - v );

					// save index of vertex in respective row

					indexRow.push( index ++ );

				}

				// now save vertices of the row in our index array

				indexArray.push( indexRow );

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				for ( let y = 0; y < heightSegments; y ++ ) {

					// we use the index array to access the correct indices

					const a = indexArray[ y ][ x ];
					const b = indexArray[ y + 1 ][ x ];
					const c = indexArray[ y + 1 ][ x + 1 ];
					const d = indexArray[ y ][ x + 1 ];

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// update group counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, 0 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

		function generateCap( top ) {

			// save the index of the first center vertex
			const centerIndexStart = index;

			const uv = new Vector2();
			const vertex = new Vector3();

			let groupCount = 0;

			const radius = ( top === true ) ? radiusTop : radiusBottom;
			const sign = ( top === true ) ? 1 : - 1;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for ( let x = 1; x <= radialSegments; x ++ ) {

				// vertex

				vertices.push( 0, halfHeight * sign, 0 );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uvs.push( 0.5, 0.5 );

				// increase index

				index ++;

			}

			// save the index of the last center vertex
			const centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for ( let x = 0; x <= radialSegments; x ++ ) {

				const u = x / radialSegments;
				const theta = u * thetaLength + thetaStart;

				const cosTheta = Math.cos( theta );
				const sinTheta = Math.sin( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );

				// increase index

				index ++;

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				const c = centerIndexStart + x;
				const i = centerIndexEnd + x;

				if ( top === true ) {

					// face top

					indices.push( i, i + 1, c );

				} else {

					// face bottom

					indices.push( i + 1, i, c );

				}

				groupCount += 3;

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

	}

}

class ConeGeometry extends CylinderGeometry {

	constructor( radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

	static fromJSON( data ) {

		return new ConeGeometry( data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

	}

}

class PolyhedronGeometry extends BufferGeometry {

	constructor( vertices = [], indices = [], radius = 1, detail = 0 ) {

		super();

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		// default buffer data

		const vertexBuffer = [];
		const uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide( detail );

		// all vertices should lie on a conceptual sphere with a given radius

		applyRadius( radius );

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

		if ( detail === 0 ) {

			this.computeVertexNormals(); // flat normals

		} else {

			this.normalizeNormals(); // smooth normals

		}

		// helper functions

		function subdivide( detail ) {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			// iterate over all faces and apply a subdivision with the given detail value

			for ( let i = 0; i < indices.length; i += 3 ) {

				// get the vertices of the face

				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );

				// perform subdivision

				subdivideFace( a, b, c, detail );

			}

		}

		function subdivideFace( a, b, c, detail ) {

			const cols = detail + 1;

			// we use this multidimensional array as a data structure for creating the subdivision

			const v = [];

			// construct all of the vertices for this subdivision

			for ( let i = 0; i <= cols; i ++ ) {

				v[ i ] = [];

				const aj = a.clone().lerp( c, i / cols );
				const bj = b.clone().lerp( c, i / cols );

				const rows = cols - i;

				for ( let j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

					}

				}

			}

			// construct all of the faces

			for ( let i = 0; i < cols; i ++ ) {

				for ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					const k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );

					} else {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );

					}

				}

			}

		}

		function applyRadius( radius ) {

			const vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				vertex.normalize().multiplyScalar( radius );

				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;

			}

		}

		function generateUVs() {

			const vertex = new Vector3();

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				const u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				const v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );

			}

			correctUVs();

			correctSeam();

		}

		function correctSeam() {

			// handle case when face straddles the seam, see #3269

			for ( let i = 0; i < uvBuffer.length; i += 6 ) {

				// uv data of a single face

				const x0 = uvBuffer[ i + 0 ];
				const x1 = uvBuffer[ i + 2 ];
				const x2 = uvBuffer[ i + 4 ];

				const max = Math.max( x0, x1, x2 );
				const min = Math.min( x0, x1, x2 );

				// 0.9 is somewhat arbitrary

				if ( max > 0.9 && min < 0.1 ) {

					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

				}

			}

		}

		function pushVertex( vertex ) {

			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

		}

		function getVertexByIndex( index, vertex ) {

			const stride = index * 3;

			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];

		}

		function correctUVs() {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			const centroid = new Vector3();

			const uvA = new Vector2();
			const uvB = new Vector2();
			const uvC = new Vector2();

			for ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

				const azi = azimuth( centroid );

				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );

			}

		}

		function correctUV( uv, stride, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

				uvBuffer[ stride ] = uv.x - 1;

			}

			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

			}

		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );

	}

}

class DodecahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;
		const r = 1 / t;

		const vertices = [

			// (±1, ±1, ±1)
			- 1, - 1, - 1,	- 1, - 1, 1,
			- 1, 1, - 1, - 1, 1, 1,
			1, - 1, - 1, 1, - 1, 1,
			1, 1, - 1, 1, 1, 1,

			// (0, ±1/φ, ±φ)
			0, - r, - t, 0, - r, t,
			0, r, - t, 0, r, t,

			// (±1/φ, ±φ, 0)
			- r, - t, 0, - r, t, 0,
			r, - t, 0, r, t, 0,

			// (±φ, 0, ±1/φ)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];

		const indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9
		];

		super( vertices, indices, radius, detail );

		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new DodecahedronGeometry( data.radius, data.detail );

	}

}

const _v0 = /*@__PURE__*/ new Vector3();
const _v1$1 = /*@__PURE__*/ new Vector3();
const _normal = /*@__PURE__*/ new Vector3();
const _triangle = /*@__PURE__*/ new Triangle();

class EdgesGeometry extends BufferGeometry {

	constructor( geometry = null, thresholdAngle = 1 ) {

		super();

		this.type = 'EdgesGeometry';

		this.parameters = {
			geometry: geometry,
			thresholdAngle: thresholdAngle
		};

		if ( geometry !== null ) {

			const precisionPoints = 4;
			const precision = Math.pow( 10, precisionPoints );
			const thresholdDot = Math.cos( DEG2RAD * thresholdAngle );

			const indexAttr = geometry.getIndex();
			const positionAttr = geometry.getAttribute( 'position' );
			const indexCount = indexAttr ? indexAttr.count : positionAttr.count;

			const indexArr = [ 0, 0, 0 ];
			const vertKeys = [ 'a', 'b', 'c' ];
			const hashes = new Array( 3 );

			const edgeData = {};
			const vertices = [];
			for ( let i = 0; i < indexCount; i += 3 ) {

				if ( indexAttr ) {

					indexArr[ 0 ] = indexAttr.getX( i );
					indexArr[ 1 ] = indexAttr.getX( i + 1 );
					indexArr[ 2 ] = indexAttr.getX( i + 2 );

				} else {

					indexArr[ 0 ] = i;
					indexArr[ 1 ] = i + 1;
					indexArr[ 2 ] = i + 2;

				}

				const { a, b, c } = _triangle;
				a.fromBufferAttribute( positionAttr, indexArr[ 0 ] );
				b.fromBufferAttribute( positionAttr, indexArr[ 1 ] );
				c.fromBufferAttribute( positionAttr, indexArr[ 2 ] );
				_triangle.getNormal( _normal );

				// create hashes for the edge from the vertices
				hashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;
				hashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;
				hashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;

				// skip degenerate triangles
				if ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {

					continue;

				}

				// iterate over every edge
				for ( let j = 0; j < 3; j ++ ) {

					// get the first and next vertex making up the edge
					const jNext = ( j + 1 ) % 3;
					const vecHash0 = hashes[ j ];
					const vecHash1 = hashes[ jNext ];
					const v0 = _triangle[ vertKeys[ j ] ];
					const v1 = _triangle[ vertKeys[ jNext ] ];

					const hash = `${ vecHash0 }_${ vecHash1 }`;
					const reverseHash = `${ vecHash1 }_${ vecHash0 }`;

					if ( reverseHash in edgeData && edgeData[ reverseHash ] ) {

						// if we found a sibling edge add it into the vertex array if
						// it meets the angle threshold and delete the edge from the map.
						if ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {

							vertices.push( v0.x, v0.y, v0.z );
							vertices.push( v1.x, v1.y, v1.z );

						}

						edgeData[ reverseHash ] = null;

					} else if ( ! ( hash in edgeData ) ) {

						// if we've already got an edge here then skip adding a new one
						edgeData[ hash ] = {

							index0: indexArr[ j ],
							index1: indexArr[ jNext ],
							normal: _normal.clone(),

						};

					}

				}

			}

			// iterate over all remaining, unmatched edges and add them to the vertex array
			for ( const key in edgeData ) {

				if ( edgeData[ key ] ) {

					const { index0, index1 } = edgeData[ key ];
					_v0.fromBufferAttribute( positionAttr, index0 );
					_v1$1.fromBufferAttribute( positionAttr, index1 );

					vertices.push( _v0.x, _v0.y, _v0.z );
					vertices.push( _v1$1.x, _v1$1.y, _v1$1.z );

				}

			}

			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

}

class Shape extends Path {

	constructor( points ) {

		super( points );

		this.uuid = generateUUID();

		this.type = 'Shape';

		this.holes = [];

	}

	getPointsHoles( divisions ) {

		const holesPts = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		}

		return holesPts;

	}

	// get points of shape and holes (keypoints based on segments parameter)

	extractPoints( divisions ) {

		return {

			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	}

	copy( source ) {

		super.copy( source );

		this.holes = [];

		for ( let i = 0, l = source.holes.length; i < l; i ++ ) {

			const hole = source.holes[ i ];

			this.holes.push( hole.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.uuid = this.uuid;
		data.holes = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			const hole = this.holes[ i ];
			data.holes.push( hole.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.uuid = json.uuid;
		this.holes = [];

		for ( let i = 0, l = json.holes.length; i < l; i ++ ) {

			const hole = json.holes[ i ];
			this.holes.push( new Path().fromJSON( hole ) );

		}

		return this;

	}

}

/**
 * Port from https://github.com/mapbox/earcut (v2.2.4)
 */

const Earcut = {

	triangulate: function ( data, holeIndices, dim = 2 ) {

		const hasHoles = holeIndices && holeIndices.length;
		const outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;
		let outerNode = linkedList( data, 0, outerLen, dim, true );
		const triangles = [];

		if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

		let minX, minY, maxX, maxY, x, y, invSize;

		if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

		// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
		if ( data.length > 80 * dim ) {

			minX = maxX = data[ 0 ];
			minY = maxY = data[ 1 ];

			for ( let i = dim; i < outerLen; i += dim ) {

				x = data[ i ];
				y = data[ i + 1 ];
				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;

			}

			// minX, minY and invSize are later used to transform coords into integers for z-order calculation
			invSize = Math.max( maxX - minX, maxY - minY );
			invSize = invSize !== 0 ? 32767 / invSize : 0;

		}

		earcutLinked( outerNode, triangles, dim, minX, minY, invSize, 0 );

		return triangles;

	}

};

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList( data, start, end, dim, clockwise ) {

	let i, last;

	if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

		for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	} else {

		for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	}

	if ( last && equals( last, last.next ) ) {

		removeNode( last );
		last = last.next;

	}

	return last;

}

// eliminate colinear or duplicate points
function filterPoints( start, end ) {

	if ( ! start ) return start;
	if ( ! end ) end = start;

	let p = start,
		again;
	do {

		again = false;

		if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

			removeNode( p );
			p = end = p.prev;
			if ( p === p.next ) break;
			again = true;

		} else {

			p = p.next;

		}

	} while ( again || p !== end );

	return end;

}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

	if ( ! ear ) return;

	// interlink polygon nodes in z-order
	if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

	let stop = ear,
		prev, next;

	// iterate through ears, slicing them one by one
	while ( ear.prev !== ear.next ) {

		prev = ear.prev;
		next = ear.next;

		if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

			// cut off the triangle
			triangles.push( prev.i / dim | 0 );
			triangles.push( ear.i / dim | 0 );
			triangles.push( next.i / dim | 0 );

			removeNode( ear );

			// skipping the next vertex leads to less sliver triangles
			ear = next.next;
			stop = next.next;

			continue;

		}

		ear = next;

		// if we looped through the whole remaining polygon and can't find any more ears
		if ( ear === stop ) {

			// try filtering points and slicing again
			if ( ! pass ) {

				earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

				// if this didn't work, try curing all small self-intersections locally

			} else if ( pass === 1 ) {

				ear = cureLocalIntersections( filterPoints( ear ), triangles, dim );
				earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

				// as a last resort, try splitting the remaining polygon into two

			} else if ( pass === 2 ) {

				splitEarcut( ear, triangles, dim, minX, minY, invSize );

			}

			break;

		}

	}

}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar( ear ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// now make sure we don't have other points inside the potential ear
	const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

	// triangle bbox; min & max are calculated like this for speed
	const x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),
		y0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),
		x1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),
		y1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );

	let p = c.next;
	while ( p !== a ) {

		if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
			pointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.next;

	}

	return true;

}

function isEarHashed( ear, minX, minY, invSize ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

	// triangle bbox; min & max are calculated like this for speed
	const x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),
		y0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),
		x1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),
		y1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );

	// z-order range for the current triangle bbox;
	const minZ = zOrder( x0, y0, minX, minY, invSize ),
		maxZ = zOrder( x1, y1, minX, minY, invSize );

	let p = ear.prevZ,
		n = ear.nextZ;

	// look for points inside the triangle in both directions
	while ( p && p.z >= minZ && n && n.z <= maxZ ) {

		if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
			pointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

		if ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
			pointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	// look for remaining points in decreasing z-order
	while ( p && p.z >= minZ ) {

		if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
			pointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

	}

	// look for remaining points in increasing z-order
	while ( n && n.z <= maxZ ) {

		if ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
			pointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	return true;

}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections( start, triangles, dim ) {

	let p = start;
	do {

		const a = p.prev,
			b = p.next.next;

		if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

			triangles.push( a.i / dim | 0 );
			triangles.push( p.i / dim | 0 );
			triangles.push( b.i / dim | 0 );

			// remove two nodes involved
			removeNode( p );
			removeNode( p.next );

			p = start = b;

		}

		p = p.next;

	} while ( p !== start );

	return filterPoints( p );

}

// try splitting polygon into two and triangulate them independently
function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

	// look for a valid diagonal that divides the polygon into two
	let a = start;
	do {

		let b = a.next.next;
		while ( b !== a.prev ) {

			if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

				// split the polygon in two by the diagonal
				let c = splitPolygon( a, b );

				// filter colinear points around the cuts
				a = filterPoints( a, a.next );
				c = filterPoints( c, c.next );

				// run earcut on each half
				earcutLinked( a, triangles, dim, minX, minY, invSize, 0 );
				earcutLinked( c, triangles, dim, minX, minY, invSize, 0 );
				return;

			}

			b = b.next;

		}

		a = a.next;

	} while ( a !== start );

}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles( data, holeIndices, outerNode, dim ) {

	const queue = [];
	let i, len, start, end, list;

	for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

		start = holeIndices[ i ] * dim;
		end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
		list = linkedList( data, start, end, dim, false );
		if ( list === list.next ) list.steiner = true;
		queue.push( getLeftmost( list ) );

	}

	queue.sort( compareX );

	// process holes from left to right
	for ( i = 0; i < queue.length; i ++ ) {

		outerNode = eliminateHole( queue[ i ], outerNode );

	}

	return outerNode;

}

function compareX( a, b ) {

	return a.x - b.x;

}

// find a bridge between vertices that connects hole with an outer ring and link it
function eliminateHole( hole, outerNode ) {

	const bridge = findHoleBridge( hole, outerNode );
	if ( ! bridge ) {

		return outerNode;

	}

	const bridgeReverse = splitPolygon( bridge, hole );

	// filter collinear points around the cuts
	filterPoints( bridgeReverse, bridgeReverse.next );
	return filterPoints( bridge, bridge.next );

}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge( hole, outerNode ) {

	let p = outerNode,
		qx = - Infinity,
		m;

	const hx = hole.x, hy = hole.y;

	// find a segment intersected by a ray from the hole's leftmost point to the left;
	// segment's endpoint with lesser x will be potential connection point
	do {

		if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

			const x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
			if ( x <= hx && x > qx ) {

				qx = x;
				m = p.x < p.next.x ? p : p.next;
				if ( x === hx ) return m; // hole touches outer segment; pick leftmost endpoint

			}

		}

		p = p.next;

	} while ( p !== outerNode );

	if ( ! m ) return null;

	// look for points inside the triangle of hole point, segment intersection and endpoint;
	// if there are no points found, we have a valid connection;
	// otherwise choose the point of the minimum angle with the ray as connection point

	const stop = m,
		mx = m.x,
		my = m.y;
	let tanMin = Infinity, tan;

	p = m;

	do {

		if ( hx >= p.x && p.x >= mx && hx !== p.x &&
				pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

			tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

			if ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {

				m = p;
				tanMin = tan;

			}

		}

		p = p.next;

	} while ( p !== stop );

	return m;

}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector( m, p ) {

	return area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;

}

// interlink polygon nodes in z-order
function indexCurve( start, minX, minY, invSize ) {

	let p = start;
	do {

		if ( p.z === 0 ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
		p.prevZ = p.prev;
		p.nextZ = p.next;
		p = p.next;

	} while ( p !== start );

	p.prevZ.nextZ = null;
	p.prevZ = null;

	sortLinked( p );

}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked( list ) {

	let i, p, q, e, tail, numMerges, pSize, qSize,
		inSize = 1;

	do {

		p = list;
		list = null;
		tail = null;
		numMerges = 0;

		while ( p ) {

			numMerges ++;
			q = p;
			pSize = 0;
			for ( i = 0; i < inSize; i ++ ) {

				pSize ++;
				q = q.nextZ;
				if ( ! q ) break;

			}

			qSize = inSize;

			while ( pSize > 0 || ( qSize > 0 && q ) ) {

				if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

					e = p;
					p = p.nextZ;
					pSize --;

				} else {

					e = q;
					q = q.nextZ;
					qSize --;

				}

				if ( tail ) tail.nextZ = e;
				else list = e;

				e.prevZ = tail;
				tail = e;

			}

			p = q;

		}

		tail.nextZ = null;
		inSize *= 2;

	} while ( numMerges > 1 );

	return list;

}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder( x, y, minX, minY, invSize ) {

	// coords are transformed into non-negative 15-bit integer range
	x = ( x - minX ) * invSize | 0;
	y = ( y - minY ) * invSize | 0;

	x = ( x | ( x << 8 ) ) & 0x00FF00FF;
	x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
	x = ( x | ( x << 2 ) ) & 0x33333333;
	x = ( x | ( x << 1 ) ) & 0x55555555;

	y = ( y | ( y << 8 ) ) & 0x00FF00FF;
	y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
	y = ( y | ( y << 2 ) ) & 0x33333333;
	y = ( y | ( y << 1 ) ) & 0x55555555;

	return x | ( y << 1 );

}

// find the leftmost node of a polygon ring
function getLeftmost( start ) {

	let p = start,
		leftmost = start;
	do {

		if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
		p = p.next;

	} while ( p !== start );

	return leftmost;

}

// check if a point lies within a convex triangle
function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

	return ( cx - px ) * ( ay - py ) >= ( ax - px ) * ( cy - py ) &&
           ( ax - px ) * ( by - py ) >= ( bx - px ) * ( ay - py ) &&
           ( bx - px ) * ( cy - py ) >= ( cx - px ) * ( by - py );

}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal( a, b ) {

	return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges
           ( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible
            ( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors
            equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case

}

// signed area of a triangle
function area( p, q, r ) {

	return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

}

// check if two points are equal
function equals( p1, p2 ) {

	return p1.x === p2.x && p1.y === p2.y;

}

// check if two segments intersect
function intersects( p1, q1, p2, q2 ) {

	const o1 = sign( area( p1, q1, p2 ) );
	const o2 = sign( area( p1, q1, q2 ) );
	const o3 = sign( area( p2, q2, p1 ) );
	const o4 = sign( area( p2, q2, q1 ) );

	if ( o1 !== o2 && o3 !== o4 ) return true; // general case

	if ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
	if ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
	if ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
	if ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

	return false;

}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment( p, q, r ) {

	return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

}

function sign( num ) {

	return num > 0 ? 1 : num < 0 ? - 1 : 0;

}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon( a, b ) {

	let p = a;
	do {

		if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
			intersects( p, p.next, a, b ) ) return true;
		p = p.next;

	} while ( p !== a );

	return false;

}

// check if a polygon diagonal is locally inside the polygon
function locallyInside( a, b ) {

	return area( a.prev, a, a.next ) < 0 ?
		area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
		area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside( a, b ) {

	let p = a,
		inside = false;
	const px = ( a.x + b.x ) / 2,
		py = ( a.y + b.y ) / 2;
	do {

		if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
			( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
			inside = ! inside;
		p = p.next;

	} while ( p !== a );

	return inside;

}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon( a, b ) {

	const a2 = new Node( a.i, a.x, a.y ),
		b2 = new Node( b.i, b.x, b.y ),
		an = a.next,
		bp = b.prev;

	a.next = b;
	b.prev = a;

	a2.next = an;
	an.prev = a2;

	b2.next = a2;
	a2.prev = b2;

	bp.next = b2;
	b2.prev = bp;

	return b2;

}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode( i, x, y, last ) {

	const p = new Node( i, x, y );

	if ( ! last ) {

		p.prev = p;
		p.next = p;

	} else {

		p.next = last.next;
		p.prev = last;
		last.next.prev = p;
		last.next = p;

	}

	return p;

}

function removeNode( p ) {

	p.next.prev = p.prev;
	p.prev.next = p.next;

	if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
	if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

}

function Node( i, x, y ) {

	// vertex index in coordinates array
	this.i = i;

	// vertex coordinates
	this.x = x;
	this.y = y;

	// previous and next vertex nodes in a polygon ring
	this.prev = null;
	this.next = null;

	// z-order curve value
	this.z = 0;

	// previous and next nodes in z-order
	this.prevZ = null;
	this.nextZ = null;

	// indicates whether this is a steiner point
	this.steiner = false;

}

function signedArea( data, start, end, dim ) {

	let sum = 0;
	for ( let i = start, j = end - dim; i < end; i += dim ) {

		sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
		j = i;

	}

	return sum;

}

class ShapeUtils {

	// calculate area of the contour polygon

	static area( contour ) {

		const n = contour.length;
		let a = 0.0;

		for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	}

	static isClockWise( pts ) {

		return ShapeUtils.area( pts ) < 0;

	}

	static triangulateShape( contour, holes ) {

		const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
		const holeIndices = []; // array of hole indices
		const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

		removeDupEndPts( contour );
		addContour( vertices, contour );

		//

		let holeIndex = contour.length;

		holes.forEach( removeDupEndPts );

		for ( let i = 0; i < holes.length; i ++ ) {

			holeIndices.push( holeIndex );
			holeIndex += holes[ i ].length;
			addContour( vertices, holes[ i ] );

		}

		//

		const triangles = Earcut.triangulate( vertices, holeIndices );

		//

		for ( let i = 0; i < triangles.length; i += 3 ) {

			faces.push( triangles.slice( i, i + 3 ) );

		}

		return faces;

	}

}

function removeDupEndPts( points ) {

	const l = points.length;

	if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

		points.pop();

	}

}

function addContour( vertices, contour ) {

	for ( let i = 0; i < contour.length; i ++ ) {

		vertices.push( contour[ i ].x );
		vertices.push( contour[ i ].y );

	}

}

/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */


class ExtrudeGeometry extends BufferGeometry {

	constructor( shapes = new Shape( [ new Vector2( 0.5, 0.5 ), new Vector2( - 0.5, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), options = {} ) {

		super();

		this.type = 'ExtrudeGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		const scope = this;

		const verticesArray = [];
		const uvArray = [];

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];
			addShape( shape );

		}

		// build geometry

		this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

		this.computeVertexNormals();

		// functions

		function addShape( shape ) {

			const placeholder = [];

			// options

			const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			const steps = options.steps !== undefined ? options.steps : 1;
			const depth = options.depth !== undefined ? options.depth : 1;

			let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
			let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
			let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
			let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			const extrudePath = options.extrudePath;

			const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

			//

			let extrudePts, extrudeByPath = false;
			let splineTube, binormal, normal, position2;

			if ( extrudePath ) {

				extrudePts = extrudePath.getSpacedPoints( steps );

				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = extrudePath.computeFrenetFrames( steps, false );

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();

			}

			// Safeguards if bevels are not enabled

			if ( ! bevelEnabled ) {

				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;
				bevelOffset = 0;

			}

			// Variables initialization

			const shapePoints = shape.extractPoints( curveSegments );

			let vertices = shapePoints.shape;
			const holes = shapePoints.holes;

			const reverse = ! ShapeUtils.isClockWise( vertices );

			if ( reverse ) {

				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];

					if ( ShapeUtils.isClockWise( ahole ) ) {

						holes[ h ] = ahole.reverse();

					}

				}

			}


			const faces = ShapeUtils.triangulateShape( vertices, holes );

			/* Vertices */

			const contour = vertices; // vertices has all points but contour has only points of circumference

			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				const ahole = holes[ h ];

				vertices = vertices.concat( ahole );

			}


			function scalePt2( pt, vec, size ) {

				if ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );

				return pt.clone().addScaledVector( vec, size );

			}

			const vlen = vertices.length, flen = faces.length;


			// Find directions for point movement


			function getBevelVec( inPt, inPrev, inNext ) {

				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.

				let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				const v_prev_x = inPt.x - inPrev.x,
					v_prev_y = inPt.y - inPrev.y;
				const v_next_x = inNext.x - inPt.x,
					v_next_y = inNext.y - inPt.y;

				const v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

				// check for collinear edges
				const collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

					// not collinear

					// length of vectors for normalizing

					const v_prev_len = Math.sqrt( v_prev_lensq );
					const v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

					// shift adjacent points by unit vectors to the left

					const ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					const ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

					const ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					const ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

					// scaling factor for v_prev to intersection point

					const sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
						( v_prev_x * v_next_y - v_prev_y * v_next_x );

					// vector from inPt to intersection point

					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					const v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {

						return new Vector2( v_trans_x, v_trans_y );

					} else {

						shrink_by = Math.sqrt( v_trans_lensq / 2 );

					}

				} else {

					// handle special case of collinear edges

					let direction_eq = false; // assumes: opposite

					if ( v_prev_x > Number.EPSILON ) {

						if ( v_next_x > Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( v_prev_x < - Number.EPSILON ) {

							if ( v_next_x < - Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

								direction_eq = true;

							}

						}

					}

					if ( direction_eq ) {

						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );

					} else {

						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );

					}

				}

				return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

			}


			const contourMovements = [];

			for ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

			}

			const holesMovements = [];
			let oneHoleMovements, verticesMovements = contourMovements.concat();

			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				const ahole = holes[ h ];

				oneHoleMovements = [];

				for ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

				}

				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );

			}


			// Loop bevelSegments, 1 for the front, 1 for the back

			for ( let b = 0; b < bevelSegments; b ++ ) {

				//for ( b = bevelSegments; b > 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				// contract shape

				for ( let i = 0, il = contour.length; i < il; i ++ ) {

					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

					v( vert.x, vert.y, - z );

				}

				// expand holes

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						v( vert.x, vert.y, - z );

					}

				}

			}

			const bs = bevelSize + bevelOffset;

			// Back facing vertices

			for ( let i = 0; i < vlen; i ++ ) {

				const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, 0 );

				} else {

					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

			// Add stepped vertices...
			// Including front facing vertices

			for ( let s = 1; s <= steps; s ++ ) {

				for ( let i = 0; i < vlen; i ++ ) {

					const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, depth / steps * s );

					} else {

						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

			}


			// Add bevel segments planes

			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( let b = bevelSegments - 1; b >= 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				// contract shape

				for ( let i = 0, il = contour.length; i < il; i ++ ) {

					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y, depth + z );

				}

				// expand holes

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y, depth + z );

						} else {

							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

						}

					}

				}

			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();


			/////  Internal functions

			function buildLidFaces() {

				const start = verticesArray.length / 3;

				if ( bevelEnabled ) {

					let layer = 0; // steps + 1
					let offset = vlen * layer;

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

					}

					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

					}

				} else {

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

					}

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

					}

				}

				scope.addGroup( start, verticesArray.length / 3 - start, 0 );

			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {

				const start = verticesArray.length / 3;
				let layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					sidewalls( ahole, layeroffset );

					//, true
					layeroffset += ahole.length;

				}


				scope.addGroup( start, verticesArray.length / 3 - start, 1 );


			}

			function sidewalls( contour, layeroffset ) {

				let i = contour.length;

				while ( -- i >= 0 ) {

					const j = i;
					let k = i - 1;
					if ( k < 0 ) k = contour.length - 1;

					//console.log('b', i,j, i-1, k,vertices.length);

					for ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {

						const slen1 = vlen * s;
						const slen2 = vlen * ( s + 1 );

						const a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;

						f4( a, b, c, d );

					}

				}

			}

			function v( x, y, z ) {

				placeholder.push( x );
				placeholder.push( y );
				placeholder.push( z );

			}


			function f3( a, b, c ) {

				addVertex( a );
				addVertex( b );
				addVertex( c );

				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );

			}

			function f4( a, b, c, d ) {

				addVertex( a );
				addVertex( b );
				addVertex( d );

				addVertex( b );
				addVertex( c );
				addVertex( d );


				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 3 ] );

				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
				addUV( uvs[ 3 ] );

			}

			function addVertex( index ) {

				verticesArray.push( placeholder[ index * 3 + 0 ] );
				verticesArray.push( placeholder[ index * 3 + 1 ] );
				verticesArray.push( placeholder[ index * 3 + 2 ] );

			}


			function addUV( vector2 ) {

				uvArray.push( vector2.x );
				uvArray.push( vector2.y );

			}

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		const shapes = this.parameters.shapes;
		const options = this.parameters.options;

		return toJSON$1( shapes, options, data );

	}

	static fromJSON( data, shapes ) {

		const geometryShapes = [];

		for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

			const shape = shapes[ data.shapes[ j ] ];

			geometryShapes.push( shape );

		}

		const extrudePath = data.options.extrudePath;

		if ( extrudePath !== undefined ) {

			data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

		}

		return new ExtrudeGeometry( geometryShapes, data.options );

	}

}

const WorldUVGenerator = {

	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];

		return [
			new Vector2( a_x, a_y ),
			new Vector2( b_x, b_y ),
			new Vector2( c_x, c_y )
		];

	},

	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const a_z = vertices[ indexA * 3 + 2 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const b_z = vertices[ indexB * 3 + 2 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];
		const c_z = vertices[ indexC * 3 + 2 ];
		const d_x = vertices[ indexD * 3 ];
		const d_y = vertices[ indexD * 3 + 1 ];
		const d_z = vertices[ indexD * 3 + 2 ];

		if ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {

			return [
				new Vector2( a_x, 1 - a_z ),
				new Vector2( b_x, 1 - b_z ),
				new Vector2( c_x, 1 - c_z ),
				new Vector2( d_x, 1 - d_z )
			];

		} else {

			return [
				new Vector2( a_y, 1 - a_z ),
				new Vector2( b_y, 1 - b_z ),
				new Vector2( c_y, 1 - c_z ),
				new Vector2( d_y, 1 - d_z )
			];

		}

	}

};

function toJSON$1( shapes, options, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	data.options = Object.assign( {}, options );

	if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

	return data;

}

class IcosahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;

		const vertices = [
			- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
			0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
			t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
		];

		const indices = [
			0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new IcosahedronGeometry( data.radius, data.detail );

	}

}

class OctahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
		];

		const indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];

		super( vertices, indices, radius, detail );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new OctahedronGeometry( data.radius, data.detail );

	}

}

class RingGeometry extends BufferGeometry {

	constructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		thetaSegments = Math.max( 3, thetaSegments );
		phiSegments = Math.max( 1, phiSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// some helper variables

		let radius = innerRadius;
		const radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		const vertex = new Vector3();
		const uv = new Vector2();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= phiSegments; j ++ ) {

			for ( let i = 0; i <= thetaSegments; i ++ ) {

				// values are generate from the inside of the ring to the outside

				const segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uv

				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// increase the radius for next row of vertices

			radius += radiusStep;

		}

		// indices

		for ( let j = 0; j < phiSegments; j ++ ) {

			const thetaSegmentLevel = j * ( thetaSegments + 1 );

			for ( let i = 0; i < thetaSegments; i ++ ) {

				const segment = i + thetaSegmentLevel;

				const a = segment;
				const b = segment + thetaSegments + 1;
				const c = segment + thetaSegments + 2;
				const d = segment + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new RingGeometry( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength );

	}

}

class ShapeGeometry extends BufferGeometry {

	constructor( shapes = new Shape( [ new Vector2( 0, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), curveSegments = 12 ) {

		super();

		this.type = 'ShapeGeometry';

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let groupStart = 0;
		let groupCount = 0;

		// allow single and array values for "shapes" parameter

		if ( Array.isArray( shapes ) === false ) {

			addShape( shapes );

		} else {

			for ( let i = 0; i < shapes.length; i ++ ) {

				addShape( shapes[ i ] );

				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

				groupStart += groupCount;
				groupCount = 0;

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


		// helper functions

		function addShape( shape ) {

			const indexOffset = vertices.length / 3;
			const points = shape.extractPoints( curveSegments );

			let shapeVertices = points.shape;
			const shapeHoles = points.holes;

			// check direction of vertices

			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

				shapeVertices = shapeVertices.reverse();

			}

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];

				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

					shapeHoles[ i ] = shapeHole.reverse();

				}

			}

			const faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

			// join vertices of inner and outer paths to a single array

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];
				shapeVertices = shapeVertices.concat( shapeHole );

			}

			// vertices, normals, uvs

			for ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {

				const vertex = shapeVertices[ i ];

				vertices.push( vertex.x, vertex.y, 0 );
				normals.push( 0, 0, 1 );
				uvs.push( vertex.x, vertex.y ); // world uvs

			}

			// indices

			for ( let i = 0, l = faces.length; i < l; i ++ ) {

				const face = faces[ i ];

				const a = face[ 0 ] + indexOffset;
				const b = face[ 1 ] + indexOffset;
				const c = face[ 2 ] + indexOffset;

				indices.push( a, b, c );
				groupCount += 3;

			}

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		const shapes = this.parameters.shapes;

		return toJSON( shapes, data );

	}

	static fromJSON( data, shapes ) {

		const geometryShapes = [];

		for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

			const shape = shapes[ data.shapes[ j ] ];

			geometryShapes.push( shape );

		}

		return new ShapeGeometry( geometryShapes, data.curveSegments );

	}

}

function toJSON( shapes, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	return data;

}

class SphereGeometry extends BufferGeometry {

	constructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

		super();

		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		widthSegments = Math.max( 3, Math.floor( widthSegments ) );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) );

		const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

		let index = 0;
		const grid = [];

		const vertex = new Vector3();
		const normal = new Vector3();

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// generate vertices, normals and uvs

		for ( let iy = 0; iy <= heightSegments; iy ++ ) {

			const verticesRow = [];

			const v = iy / heightSegments;

			// special case for the poles

			let uOffset = 0;

			if ( iy === 0 && thetaStart === 0 ) {

				uOffset = 0.5 / widthSegments;

			} else if ( iy === heightSegments && thetaEnd === Math.PI ) {

				uOffset = - 0.5 / widthSegments;

			}

			for ( let ix = 0; ix <= widthSegments; ix ++ ) {

				const u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.copy( vertex ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u + uOffset, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( let iy = 0; iy < heightSegments; iy ++ ) {

			for ( let ix = 0; ix < widthSegments; ix ++ ) {

				const a = grid[ iy ][ ix + 1 ];
				const b = grid[ iy ][ ix ];
				const c = grid[ iy + 1 ][ ix ];
				const d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );

	}

}

class TetrahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
		];

		const indices = [
			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new TetrahedronGeometry( data.radius, data.detail );

	}

}

class TorusGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2 ) {

		super();

		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radialSegments = Math.floor( radialSegments );
		tubularSegments = Math.floor( tubularSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const center = new Vector3();
		const vertex = new Vector3();
		const normal = new Vector3();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= radialSegments; j ++ ) {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				const u = i / tubularSegments * arc;
				const v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= radialSegments; j ++ ) {

			for ( let i = 1; i <= tubularSegments; i ++ ) {

				// indices

				const a = ( tubularSegments + 1 ) * j + i - 1;
				const b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				const c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				const d = ( tubularSegments + 1 ) * j + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new TorusGeometry( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc );

	}

}

class TorusKnotGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {

		super();

		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		tubularSegments = Math.floor( tubularSegments );
		radialSegments = Math.floor( radialSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();

		const P1 = new Vector3();
		const P2 = new Vector3();

		const B = new Vector3();
		const T = new Vector3();
		const N = new Vector3();

		// generate vertices, normals and uvs

		for ( let i = 0; i <= tubularSegments; ++ i ) {

			// the radian "u" is used to calculate the position on the torus curve of the current tubular segment

			const u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

			// calculate orthonormal basis

			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for ( let j = 0; j <= radialSegments; ++ j ) {

				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				const v = j / radialSegments * Math.PI * 2;
				const cx = - tube * Math.cos( v );
				const cy = tube * Math.sin( v );

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve

				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors( vertex, P1 ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= tubularSegments; j ++ ) {

			for ( let i = 1; i <= radialSegments; i ++ ) {

				// indices

				const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				const b = ( radialSegments + 1 ) * j + ( i - 1 );
				const c = ( radialSegments + 1 ) * j + i;
				const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve( u, p, q, radius, position ) {

			const cu = Math.cos( u );
			const su = Math.sin( u );
			const quOverP = q / p * u;
			const cs = Math.cos( quOverP );

			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	static fromJSON( data ) {

		return new TorusKnotGeometry( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q );

	}

}

class TubeGeometry extends BufferGeometry {

	constructor( path = new QuadraticBezierCurve3( new Vector3( - 1, - 1, 0 ), new Vector3( - 1, 1, 0 ), new Vector3( 1, 1, 0 ) ), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {

		super();

		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		const frames = path.computeFrenetFrames( tubularSegments, closed );

		// expose internals

		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();
		const uv = new Vector2();
		let P = new Vector3();

		// buffer

		const vertices = [];
		const normals = [];
		const uvs = [];
		const indices = [];

		// create buffer data

		generateBufferData();

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// functions

		function generateBufferData() {

			for ( let i = 0; i < tubularSegments; i ++ ) {

				generateSegment( i );

			}

			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

			generateSegment( ( closed === false ) ? tubularSegments : 0 );

			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries

			generateUVs();

			// finally create faces

			generateIndices();

		}

		function generateSegment( i ) {

			// we use getPointAt to sample evenly distributed points from the given path

			P = path.getPointAt( i / tubularSegments, P );

			// retrieve corresponding normal and binormal

			const N = frames.normals[ i ];
			const B = frames.binormals[ i ];

			// generate normals and vertices for the current segment

			for ( let j = 0; j <= radialSegments; j ++ ) {

				const v = j / radialSegments * Math.PI * 2;

				const sin = Math.sin( v );
				const cos = - Math.cos( v );

				// normal

				normal.x = ( cos * N.x + sin * B.x );
				normal.y = ( cos * N.y + sin * B.y );
				normal.z = ( cos * N.z + sin * B.z );
				normal.normalize();

				normals.push( normal.x, normal.y, normal.z );

				// vertex

				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;

				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		function generateIndices() {

			for ( let j = 1; j <= tubularSegments; j ++ ) {

				for ( let i = 1; i <= radialSegments; i ++ ) {

					const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					const b = ( radialSegments + 1 ) * j + ( i - 1 );
					const c = ( radialSegments + 1 ) * j + i;
					const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

		}

		function generateUVs() {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				for ( let j = 0; j <= radialSegments; j ++ ) {

					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;

					uvs.push( uv.x, uv.y );

				}

			}

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.path = this.parameters.path.toJSON();

		return data;

	}

	static fromJSON( data ) {

		// This only works for built-in curves (e.g. CatmullRomCurve3).
		// User defined curves or instances of CurvePath will not be deserialized.
		return new TubeGeometry(
			new Curves[ data.path.type ]().fromJSON( data.path ),
			data.tubularSegments,
			data.radius,
			data.radialSegments,
			data.closed
		);

	}

}

class WireframeGeometry extends BufferGeometry {

	constructor( geometry = null ) {

		super();

		this.type = 'WireframeGeometry';

		this.parameters = {
			geometry: geometry
		};

		if ( geometry !== null ) {

			// buffer

			const vertices = [];
			const edges = new Set();

			// helper variables

			const start = new Vector3();
			const end = new Vector3();

			if ( geometry.index !== null ) {

				// indexed BufferGeometry

				const position = geometry.attributes.position;
				const indices = geometry.index;
				let groups = geometry.groups;

				if ( groups.length === 0 ) {

					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

				}

				// create a data structure that contains all edges without duplicates

				for ( let o = 0, ol = groups.length; o < ol; ++ o ) {

					const group = groups[ o ];

					const groupStart = group.start;
					const groupCount = group.count;

					for ( let i = groupStart, l = ( groupStart + groupCount ); i < l; i += 3 ) {

						for ( let j = 0; j < 3; j ++ ) {

							const index1 = indices.getX( i + j );
							const index2 = indices.getX( i + ( j + 1 ) % 3 );

							start.fromBufferAttribute( position, index1 );
							end.fromBufferAttribute( position, index2 );

							if ( isUniqueEdge( start, end, edges ) === true ) {

								vertices.push( start.x, start.y, start.z );
								vertices.push( end.x, end.y, end.z );

							}

						}

					}

				}

			} else {

				// non-indexed BufferGeometry

				const position = geometry.attributes.position;

				for ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

					for ( let j = 0; j < 3; j ++ ) {

						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

						const index1 = 3 * i + j;
						const index2 = 3 * i + ( ( j + 1 ) % 3 );

						start.fromBufferAttribute( position, index1 );
						end.fromBufferAttribute( position, index2 );

						if ( isUniqueEdge( start, end, edges ) === true ) {

							vertices.push( start.x, start.y, start.z );
							vertices.push( end.x, end.y, end.z );

						}

					}

				}

			}

			// build geometry

			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

}

function isUniqueEdge( start, end, edges ) {

	const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
	const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge

	if ( edges.has( hash1 ) === true || edges.has( hash2 ) === true ) {

		return false;

	} else {

		edges.add( hash1 );
		edges.add( hash2 );
		return true;

	}

}

var Geometries = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BoxGeometry: BoxGeometry,
	CapsuleGeometry: CapsuleGeometry,
	CircleGeometry: CircleGeometry,
	ConeGeometry: ConeGeometry,
	CylinderGeometry: CylinderGeometry,
	DodecahedronGeometry: DodecahedronGeometry,
	EdgesGeometry: EdgesGeometry,
	ExtrudeGeometry: ExtrudeGeometry,
	IcosahedronGeometry: IcosahedronGeometry,
	LatheGeometry: LatheGeometry,
	OctahedronGeometry: OctahedronGeometry,
	PlaneGeometry: PlaneGeometry,
	PolyhedronGeometry: PolyhedronGeometry,
	RingGeometry: RingGeometry,
	ShapeGeometry: ShapeGeometry,
	SphereGeometry: SphereGeometry,
	TetrahedronGeometry: TetrahedronGeometry,
	TorusGeometry: TorusGeometry,
	TorusKnotGeometry: TorusKnotGeometry,
	TubeGeometry: TubeGeometry,
	WireframeGeometry: WireframeGeometry
});

class ShadowMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isShadowMaterial = true;

		this.type = 'ShadowMaterial';

		this.color = new Color( 0x000000 );
		this.transparent = true;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.fog = source.fog;

		return this;

	}

}

class RawShaderMaterial extends ShaderMaterial {

	constructor( parameters ) {

		super( parameters );

		this.isRawShaderMaterial = true;

		this.type = 'RawShaderMaterial';

	}

}

class MeshStandardMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshStandardMaterial = true;

		this.defines = { 'STANDARD': '' };

		this.type = 'MeshStandardMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.roughness = 1.0;
		this.metalness = 0.0;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.roughnessMap = null;

		this.metalnessMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapRotation = new Euler();
		this.envMapIntensity = 1.0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.defines = { 'STANDARD': '' };

		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapRotation.copy( source.envMapRotation );
		this.envMapIntensity = source.envMapIntensity;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class MeshPhysicalMaterial extends MeshStandardMaterial {

	constructor( parameters ) {

		super();

		this.isMeshPhysicalMaterial = true;

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.type = 'MeshPhysicalMaterial';

		this.anisotropyRotation = 0;
		this.anisotropyMap = null;

		this.clearcoatMap = null;
		this.clearcoatRoughness = 0.0;
		this.clearcoatRoughnessMap = null;
		this.clearcoatNormalScale = new Vector2( 1, 1 );
		this.clearcoatNormalMap = null;

		this.ior = 1.5;

		Object.defineProperty( this, 'reflectivity', {
			get: function () {

				return ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );

			},
			set: function ( reflectivity ) {

				this.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );

			}
		} );

		this.iridescenceMap = null;
		this.iridescenceIOR = 1.3;
		this.iridescenceThicknessRange = [ 100, 400 ];
		this.iridescenceThicknessMap = null;

		this.sheenColor = new Color( 0x000000 );
		this.sheenColorMap = null;
		this.sheenRoughness = 1.0;
		this.sheenRoughnessMap = null;

		this.transmissionMap = null;

		this.thickness = 0;
		this.thicknessMap = null;
		this.attenuationDistance = Infinity;
		this.attenuationColor = new Color( 1, 1, 1 );

		this.specularIntensity = 1.0;
		this.specularIntensityMap = null;
		this.specularColor = new Color( 1, 1, 1 );
		this.specularColorMap = null;

		this._anisotropy = 0;
		this._clearcoat = 0;
		this._dispersion = 0;
		this._iridescence = 0;
		this._sheen = 0.0;
		this._transmission = 0;

		this.setValues( parameters );

	}

	get anisotropy() {

		return this._anisotropy;

	}

	set anisotropy( value ) {

		if ( this._anisotropy > 0 !== value > 0 ) {

			this.version ++;

		}

		this._anisotropy = value;

	}

	get clearcoat() {

		return this._clearcoat;

	}

	set clearcoat( value ) {

		if ( this._clearcoat > 0 !== value > 0 ) {

			this.version ++;

		}

		this._clearcoat = value;

	}

	get iridescence() {

		return this._iridescence;

	}

	set iridescence( value ) {

		if ( this._iridescence > 0 !== value > 0 ) {

			this.version ++;

		}

		this._iridescence = value;

	}

	get dispersion() {

		return this._dispersion;

	}

	set dispersion( value ) {

		if ( this._dispersion > 0 !== value > 0 ) {

			this.version ++;

		}

		this._dispersion = value;

	}

	get sheen() {

		return this._sheen;

	}

	set sheen( value ) {

		if ( this._sheen > 0 !== value > 0 ) {

			this.version ++;

		}

		this._sheen = value;

	}

	get transmission() {

		return this._transmission;

	}

	set transmission( value ) {

		if ( this._transmission > 0 !== value > 0 ) {

			this.version ++;

		}

		this._transmission = value;

	}

	copy( source ) {

		super.copy( source );

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.anisotropy = source.anisotropy;
		this.anisotropyRotation = source.anisotropyRotation;
		this.anisotropyMap = source.anisotropyMap;

		this.clearcoat = source.clearcoat;
		this.clearcoatMap = source.clearcoatMap;
		this.clearcoatRoughness = source.clearcoatRoughness;
		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
		this.clearcoatNormalMap = source.clearcoatNormalMap;
		this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

		this.dispersion = source.dispersion;
		this.ior = source.ior;

		this.iridescence = source.iridescence;
		this.iridescenceMap = source.iridescenceMap;
		this.iridescenceIOR = source.iridescenceIOR;
		this.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];
		this.iridescenceThicknessMap = source.iridescenceThicknessMap;

		this.sheen = source.sheen;
		this.sheenColor.copy( source.sheenColor );
		this.sheenColorMap = source.sheenColorMap;
		this.sheenRoughness = source.sheenRoughness;
		this.sheenRoughnessMap = source.sheenRoughnessMap;

		this.transmission = source.transmission;
		this.transmissionMap = source.transmissionMap;

		this.thickness = source.thickness;
		this.thicknessMap = source.thicknessMap;
		this.attenuationDistance = source.attenuationDistance;
		this.attenuationColor.copy( source.attenuationColor );

		this.specularIntensity = source.specularIntensity;
		this.specularIntensityMap = source.specularIntensityMap;
		this.specularColor.copy( source.specularColor );
		this.specularColorMap = source.specularColorMap;

		return this;

	}

}

class MeshPhongMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshPhongMaterial = true;

		this.type = 'MeshPhongMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.specular = new Color( 0x111111 );
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapRotation = new Euler();
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapRotation.copy( source.envMapRotation );
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class MeshToonMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshToonMaterial = true;

		this.defines = { 'TOON': '' };

		this.type = 'MeshToonMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;
		this.gradientMap = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;
		this.gradientMap = source.gradientMap;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.fog = source.fog;

		return this;

	}

}

class MeshNormalMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshNormalMaterial = true;

		this.type = 'MeshNormalMaterial';

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.flatShading = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.flatShading = source.flatShading;

		return this;

	}

}

class MeshLambertMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshLambertMaterial = true;

		this.type = 'MeshLambertMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapRotation = new Euler();
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapRotation.copy( source.envMapRotation );
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class MeshMatcapMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshMatcapMaterial = true;

		this.defines = { 'MATCAP': '' };

		this.type = 'MeshMatcapMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.matcap = null;

		this.map = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.defines = { 'MATCAP': '' };

		this.color.copy( source.color );

		this.matcap = source.matcap;

		this.map = source.map;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class LineDashedMaterial extends LineBasicMaterial {

	constructor( parameters ) {

		super();

		this.isLineDashedMaterial = true;

		this.type = 'LineDashedMaterial';

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		return this;

	}

}

// converts an array to a specific type
function convertArray( array, type, forceClone ) {

	if ( ! array || // let 'undefined' and 'null' pass
		! forceClone && array.constructor === type ) return array;

	if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

		return new type( array ); // create typed array

	}

	return Array.prototype.slice.call( array ); // create Array

}

function isTypedArray( object ) {

	return ArrayBuffer.isView( object ) &&
		! ( object instanceof DataView );

}

// returns an array by which times and values can be sorted
function getKeyframeOrder( times ) {

	function compareTime( i, j ) {

		return times[ i ] - times[ j ];

	}

	const n = times.length;
	const result = new Array( n );
	for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

	result.sort( compareTime );

	return result;

}

// uses the array previously returned by 'getKeyframeOrder' to sort data
function sortedArray( values, stride, order ) {

	const nValues = values.length;
	const result = new values.constructor( nValues );

	for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

		const srcOffset = order[ i ] * stride;

		for ( let j = 0; j !== stride; ++ j ) {

			result[ dstOffset ++ ] = values[ srcOffset + j ];

		}

	}

	return result;

}

// function for parsing AOS keyframe formats
function flattenJSON( jsonKeys, times, values, valuePropertyName ) {

	let i = 1, key = jsonKeys[ 0 ];

	while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

		key = jsonKeys[ i ++ ];

	}

	if ( key === undefined ) return; // no data

	let value = key[ valuePropertyName ];
	if ( value === undefined ) return; // no data

	if ( Array.isArray( value ) ) {

		do {

			value = key[ valuePropertyName ];

			if ( value !== undefined ) {

				times.push( key.time );
				values.push.apply( values, value ); // push all elements

			}

			key = jsonKeys[ i ++ ];

		} while ( key !== undefined );

	} else if ( value.toArray !== undefined ) {

		// ...assume THREE.Math-ish

		do {

			value = key[ valuePropertyName ];

			if ( value !== undefined ) {

				times.push( key.time );
				value.toArray( values, values.length );

			}

			key = jsonKeys[ i ++ ];

		} while ( key !== undefined );

	} else {

		// otherwise push as-is

		do {

			value = key[ valuePropertyName ];

			if ( value !== undefined ) {

				times.push( key.time );
				values.push( value );

			}

			key = jsonKeys[ i ++ ];

		} while ( key !== undefined );

	}

}

function subclip( sourceClip, name, startFrame, endFrame, fps = 30 ) {

	const clip = sourceClip.clone();

	clip.name = name;

	const tracks = [];

	for ( let i = 0; i < clip.tracks.length; ++ i ) {

		const track = clip.tracks[ i ];
		const valueSize = track.getValueSize();

		const times = [];
		const values = [];

		for ( let j = 0; j < track.times.length; ++ j ) {

			const frame = track.times[ j ] * fps;

			if ( frame < startFrame || frame >= endFrame ) continue;

			times.push( track.times[ j ] );

			for ( let k = 0; k < valueSize; ++ k ) {

				values.push( track.values[ j * valueSize + k ] );

			}

		}

		if ( times.length === 0 ) continue;

		track.times = convertArray( times, track.times.constructor );
		track.values = convertArray( values, track.values.constructor );

		tracks.push( track );

	}

	clip.tracks = tracks;

	// find minimum .times value across all tracks in the trimmed clip

	let minStartTime = Infinity;

	for ( let i = 0; i < clip.tracks.length; ++ i ) {

		if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

			minStartTime = clip.tracks[ i ].times[ 0 ];

		}

	}

	// shift all tracks such that clip begins at t=0

	for ( let i = 0; i < clip.tracks.length; ++ i ) {

		clip.tracks[ i ].shift( - 1 * minStartTime );

	}

	clip.resetDuration();

	return clip;

}

function makeClipAdditive( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {

	if ( fps <= 0 ) fps = 30;

	const numTracks = referenceClip.tracks.length;
	const referenceTime = referenceFrame / fps;

	// Make each track's values relative to the values at the reference frame
	for ( let i = 0; i < numTracks; ++ i ) {

		const referenceTrack = referenceClip.tracks[ i ];
		const referenceTrackType = referenceTrack.ValueTypeName;

		// Skip this track if it's non-numeric
		if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;

		// Find the track in the target clip whose name and type matches the reference track
		const targetTrack = targetClip.tracks.find( function ( track ) {

			return track.name === referenceTrack.name
				&& track.ValueTypeName === referenceTrackType;

		} );

		if ( targetTrack === undefined ) continue;

		let referenceOffset = 0;
		const referenceValueSize = referenceTrack.getValueSize();

		if ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

			referenceOffset = referenceValueSize / 3;

		}

		let targetOffset = 0;
		const targetValueSize = targetTrack.getValueSize();

		if ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

			targetOffset = targetValueSize / 3;

		}

		const lastIndex = referenceTrack.times.length - 1;
		let referenceValue;

		// Find the value to subtract out of the track
		if ( referenceTime <= referenceTrack.times[ 0 ] ) {

			// Reference frame is earlier than the first keyframe, so just use the first keyframe
			const startIndex = referenceOffset;
			const endIndex = referenceValueSize - referenceOffset;
			referenceValue = referenceTrack.values.slice( startIndex, endIndex );

		} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

			// Reference frame is after the last keyframe, so just use the last keyframe
			const startIndex = lastIndex * referenceValueSize + referenceOffset;
			const endIndex = startIndex + referenceValueSize - referenceOffset;
			referenceValue = referenceTrack.values.slice( startIndex, endIndex );

		} else {

			// Interpolate to the reference value
			const interpolant = referenceTrack.createInterpolant();
			const startIndex = referenceOffset;
			const endIndex = referenceValueSize - referenceOffset;
			interpolant.evaluate( referenceTime );
			referenceValue = interpolant.resultBuffer.slice( startIndex, endIndex );

		}

		// Conjugate the quaternion
		if ( referenceTrackType === 'quaternion' ) {

			const referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();
			referenceQuat.toArray( referenceValue );

		}

		// Subtract the reference value from all of the track values

		const numTimes = targetTrack.times.length;
		for ( let j = 0; j < numTimes; ++ j ) {

			const valueStart = j * targetValueSize + targetOffset;

			if ( referenceTrackType === 'quaternion' ) {

				// Multiply the conjugate for quaternion track types
				Quaternion.multiplyQuaternionsFlat(
					targetTrack.values,
					valueStart,
					referenceValue,
					0,
					targetTrack.values,
					valueStart
				);

			} else {

				const valueEnd = targetValueSize - targetOffset * 2;

				// Subtract each value for all other numeric track types
				for ( let k = 0; k < valueEnd; ++ k ) {

					targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

				}

			}

		}

	}

	targetClip.blendMode = AdditiveAnimationBlendMode;

	return targetClip;

}

const AnimationUtils = {
	convertArray: convertArray,
	isTypedArray: isTypedArray,
	getKeyframeOrder: getKeyframeOrder,
	sortedArray: sortedArray,
	flattenJSON: flattenJSON,
	subclip: subclip,
	makeClipAdditive: makeClipAdditive
};

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */

class Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;

		this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;

		this.settings = null;
		this.DefaultSettings_ = {};

	}

	evaluate( t ) {

		const pp = this.parameterPositions;
		let i1 = this._cachedIndex,
			t1 = pp[ i1 ],
			t0 = pp[ i1 - 1 ];

		validate_interval: {

			seek: {

				let right;

				linear_scan: {

					//- See http://jsperf.com/comparison-to-undefined/3
					//- slower code:
					//-
					//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if ( ! ( t < t1 ) ) {

						for ( let giveUpAt = i1 + 2; ; ) {

							if ( t1 === undefined ) {

								if ( t < t0 ) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.copySampleValue_( i1 - 1 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t0 = t1;
							t1 = pp[ ++ i1 ];

							if ( t < t1 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;

					}

					//- slower code:
					//-					if ( t < t0 || t0 === undefined ) {
					if ( ! ( t >= t0 ) ) {

						// looping?

						const t1global = pp[ 1 ];

						if ( t < t1global ) {

							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;

						}

						// linear reverse scan

						for ( let giveUpAt = i1 - 2; ; ) {

							if ( t0 === undefined ) {

								// before start

								this._cachedIndex = 0;
								return this.copySampleValue_( 0 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t1 = t0;
							t0 = pp[ -- i1 - 1 ];

							if ( t >= t0 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;

					}

					// the interval is valid

					break validate_interval;

				} // linear scan

				// binary search

				while ( i1 < right ) {

					const mid = ( i1 + right ) >>> 1;

					if ( t < pp[ mid ] ) {

						right = mid;

					} else {

						i1 = mid + 1;

					}

				}

				t1 = pp[ i1 ];
				t0 = pp[ i1 - 1 ];

				// check boundary cases, again

				if ( t0 === undefined ) {

					this._cachedIndex = 0;
					return this.copySampleValue_( 0 );

				}

				if ( t1 === undefined ) {

					i1 = pp.length;
					this._cachedIndex = i1;
					return this.copySampleValue_( i1 - 1 );

				}

			} // seek

			this._cachedIndex = i1;

			this.intervalChanged_( i1, t0, t1 );

		} // validate_interval

		return this.interpolate_( i1, t0, t, t1 );

	}

	getSettings_() {

		return this.settings || this.DefaultSettings_;

	}

	copySampleValue_( index ) {

		// copies a sample value to the result buffer

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

	// Template methods for derived classes:

	interpolate_( /* i1, t0, t, t1 */ ) {

		throw new Error( 'call to abstract method' );
		// implementations shall return this.resultBuffer

	}

	intervalChanged_( /* i1, t0, t1 */ ) {

		// empty

	}

}

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */

class CubicInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

		this._weightPrev = - 0;
		this._offsetPrev = - 0;
		this._weightNext = - 0;
		this._offsetNext = - 0;

		this.DefaultSettings_ = {

			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding

		};

	}

	intervalChanged_( i1, t0, t1 ) {

		const pp = this.parameterPositions;
		let iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		const halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		const sP = - wP * ppp + 2 * wP * pp - wP * p;
		const s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
		const s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
		const sN = wN * ppp - wN * pp;

		// combine data linearly

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

}

class LinearInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

}

/**
 *
 * Interpolant that evaluates to the sample value at the position preceding
 * the parameter.
 */

class DiscreteInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1 /*, t0, t, t1 */ ) {

		return this.copySampleValue_( i1 - 1 );

	}

}

class KeyframeTrack {

	constructor( name, times, values, interpolation ) {

		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

		this.name = name;

		this.times = convertArray( times, this.TimeBufferType );
		this.values = convertArray( values, this.ValueBufferType );

		this.setInterpolation( interpolation || this.DefaultInterpolation );

	}

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	static toJSON( track ) {

		const trackType = track.constructor;

		let json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== this.toJSON ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': convertArray( track.times, Array ),
				'values': convertArray( track.values, Array )

			};

			const interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	}

	InterpolantFactoryMethodDiscrete( result ) {

		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodLinear( result ) {

		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodSmooth( result ) {

		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	setInterpolation( interpolation ) {

		let factoryMethod;

		switch ( interpolation ) {

			case InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			const message = 'unsupported interpolation for ' +
				this.ValueTypeName + ' keyframe track named ' + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( 'THREE.KeyframeTrack:', message );
			return this;

		}

		this.createInterpolant = factoryMethod;

		return this;

	}

	getInterpolation() {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return InterpolateSmooth;

		}

	}

	getValueSize() {

		return this.values.length / this.times.length;

	}

	// move all keyframes either forwards or backwards in time
	shift( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	}

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale( timeScale ) {

		if ( timeScale !== 1.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	}

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim( startTime, endTime ) {

		const times = this.times,
			nKeys = times.length;

		let from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) {

			++ from;

		}

		while ( to !== - 1 && times[ to ] > endTime ) {

			-- to;

		}

		++ to; // inclusive -> exclusive bound

		if ( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) {

				to = Math.max( to, 1 );
				from = to - 1;

			}

			const stride = this.getValueSize();
			this.times = times.slice( from, to );
			this.values = this.values.slice( from * stride, to * stride );

		}

		return this;

	}

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate() {

		let valid = true;

		const valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
			valid = false;

		}

		const times = this.times,
			values = this.values,

			nKeys = times.length;

		if ( nKeys === 0 ) {

			console.error( 'THREE.KeyframeTrack: Track is empty.', this );
			valid = false;

		}

		let prevTime = null;

		for ( let i = 0; i !== nKeys; i ++ ) {

			const currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
				valid = false;
				break;

			}

			if ( prevTime !== null && prevTime > currTime ) {

				console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( isTypedArray( values ) ) {

				for ( let i = 0, n = values.length; i !== n; ++ i ) {

					const value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	}

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize() {

		// times or values may be shared with other tracks, so overwriting is unsafe
		const times = this.times.slice(),
			values = this.values.slice(),
			stride = this.getValueSize(),

			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

			lastIndex = times.length - 1;

		let writeIndex = 1;

		for ( let i = 1; i < lastIndex; ++ i ) {

			let keep = false;

			const time = times[ i ];
			const timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

				if ( ! smoothInterpolation ) {

					// remove unnecessary keyframes same as their neighbors

					const offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for ( let j = 0; j !== stride; ++ j ) {

						const value = values[ offset + j ];

						if ( value !== values[ offsetP + j ] ||
							value !== values[ offsetN + j ] ) {

							keep = true;
							break;

						}

					}

				} else {

					keep = true;

				}

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					const readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( let j = 0; j !== stride; ++ j ) {

						values[ writeOffset + j ] = values[ readOffset + j ];

					}

				}

				++ writeIndex;

			}

		}

		// flush last keyframe (compaction looks ahead)

		if ( lastIndex > 0 ) {

			times[ writeIndex ] = times[ lastIndex ];

			for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

				values[ writeOffset + j ] = values[ readOffset + j ];

			}

			++ writeIndex;

		}

		if ( writeIndex !== times.length ) {

			this.times = times.slice( 0, writeIndex );
			this.values = values.slice( 0, writeIndex * stride );

		} else {

			this.times = times;
			this.values = values;

		}

		return this;

	}

	clone() {

		const times = this.times.slice();
		const values = this.values.slice();

		const TypedKeyframeTrack = this.constructor;
		const track = new TypedKeyframeTrack( this.name, times, values );

		// Interpolant argument to constructor is not saved, so copy the factory method directly.
		track.createInterpolant = this.createInterpolant;

		return track;

	}

}

KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

/**
 * A Track of Boolean keyframe values.
 */
class BooleanKeyframeTrack extends KeyframeTrack {}

BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of keyframe values that represent color.
 */
class ColorKeyframeTrack extends KeyframeTrack {}

ColorKeyframeTrack.prototype.ValueTypeName = 'color';

/**
 * A Track of numeric keyframe values.
 */
class NumberKeyframeTrack extends KeyframeTrack {}

NumberKeyframeTrack.prototype.ValueTypeName = 'number';

/**
 * Spherical linear unit quaternion interpolant.
 */

class QuaternionLinearInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			alpha = ( t - t0 ) / ( t1 - t0 );

		let offset = i1 * stride;

		for ( let end = offset + stride; offset !== end; offset += 4 ) {

			Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

		}

		return result;

	}

}

/**
 * A Track of quaternion keyframe values.
 */
class QuaternionKeyframeTrack extends KeyframeTrack {

	InterpolantFactoryMethodLinear( result ) {

		return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

}

QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
// ValueBufferType is inherited
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track that interpolates Strings
 */
class StringKeyframeTrack extends KeyframeTrack {}

StringKeyframeTrack.prototype.ValueTypeName = 'string';
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of vectored keyframe values.
 */
class VectorKeyframeTrack extends KeyframeTrack {}

VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

class AnimationClip {

	constructor( name = '', duration = - 1, tracks = [], blendMode = NormalAnimationBlendMode ) {

		this.name = name;
		this.tracks = tracks;
		this.duration = duration;
		this.blendMode = blendMode;

		this.uuid = generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {

			this.resetDuration();

		}

	}


	static parse( json ) {

		const tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

		}

		const clip = new this( json.name, json.duration, tracks, json.blendMode );
		clip.uuid = json.uuid;

		return clip;

	}

	static toJSON( clip ) {

		const tracks = [],
			clipTracks = clip.tracks;

		const json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks,
			'uuid': clip.uuid,
			'blendMode': clip.blendMode

		};

		for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	}

	static CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {

		const numMorphTargets = morphTargetSequence.length;
		const tracks = [];

		for ( let i = 0; i < numMorphTargets; i ++ ) {

			let times = [];
			let values = [];

			times.push(
				( i + numMorphTargets - 1 ) % numMorphTargets,
				i,
				( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			const order = getKeyframeOrder( times );
			times = sortedArray( times, 1, order );
			values = sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
				new NumberKeyframeTrack(
					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
					times, values
				).scale( 1.0 / fps ) );

		}

		return new this( name, - 1, tracks );

	}

	static findByName( objectOrClipArray, name ) {

		let clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			const o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( let i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}

		}

		return null;

	}

	static CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {

		const animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		const pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

			const morphTarget = morphTargets[ i ];
			const parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				const name = parts[ 1 ];

				let animationMorphTargets = animationToMorphTargets[ name ];

				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		const clips = [];

		for ( const name in animationToMorphTargets ) {

			clips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	}

	// parse the animation.hierarchy format
	static parseAnimation( animation, bones ) {

		if ( ! animation ) {

			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			return null;

		}

		const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				const times = [];
				const values = [];

				flattenJSON( animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		const tracks = [];

		const clipName = animation.name || 'default';
		const fps = animation.fps || 30;
		const blendMode = animation.blendMode;

		// automatic length determination in AnimationClip.
		let duration = animation.length || - 1;

		const hierarchyTracks = animation.hierarchy || [];

		for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

			const animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) continue;

			// process morph targets
			if ( animationKeys[ 0 ].morphTargets ) {

				// figure out all morph targets used in this track
				const morphTargetNames = {};

				let k;

				for ( k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[ k ].morphTargets ) {

						for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( const morphTargetName in morphTargetNames ) {

					const times = [];
					const values = [];

					for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

						const animationKey = animationKeys[ k ];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * fps;

			} else {

				// ...assume skeletal animation

				const boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.position',
					animationKeys, 'pos', tracks );

				addNonemptyTrack(
					QuaternionKeyframeTrack, boneName + '.quaternion',
					animationKeys, 'rot', tracks );

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.scale',
					animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		const clip = new this( clipName, duration, tracks, blendMode );

		return clip;

	}

	resetDuration() {

		const tracks = this.tracks;
		let duration = 0;

		for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

			const track = this.tracks[ i ];

			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

		return this;

	}

	trim() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	}

	validate() {

		let valid = true;

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			valid = valid && this.tracks[ i ].validate();

		}

		return valid;

	}

	optimize() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	}

	clone() {

		const tracks = [];

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			tracks.push( this.tracks[ i ].clone() );

		}

		return new this.constructor( this.name, this.duration, tracks, this.blendMode );

	}

	toJSON() {

		return this.constructor.toJSON( this );

	}

}

function getTrackTypeForValueTypeName( typeName ) {

	switch ( typeName.toLowerCase() ) {

		case 'scalar':
		case 'double':
		case 'float':
		case 'number':
		case 'integer':

			return NumberKeyframeTrack;

		case 'vector':
		case 'vector2':
		case 'vector3':
		case 'vector4':

			return VectorKeyframeTrack;

		case 'color':

			return ColorKeyframeTrack;

		case 'quaternion':

			return QuaternionKeyframeTrack;

		case 'bool':
		case 'boolean':

			return BooleanKeyframeTrack;

		case 'string':

			return StringKeyframeTrack;

	}

	throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

}

function parseKeyframeTrack( json ) {

	if ( json.type === undefined ) {

		throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

	}

	const trackType = getTrackTypeForValueTypeName( json.type );

	if ( json.times === undefined ) {

		const times = [], values = [];

		flattenJSON( json.keys, times, values, 'value' );

		json.times = times;
		json.values = values;

	}

	// derived classes can define a static parse method
	if ( trackType.parse !== undefined ) {

		return trackType.parse( json );

	} else {

		// by default, we assume a constructor compatible with the base
		return new trackType( json.name, json.times, json.values, json.interpolation );

	}

}

const Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

class LoadingManager {

	constructor( onLoad, onProgress, onError ) {

		const scope = this;

		let isLoading = false;
		let itemsLoaded = 0;
		let itemsTotal = 0;
		let urlModifier = undefined;
		const handlers = [];

		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

		this.resolveURL = function ( url ) {

			if ( urlModifier ) {

				return urlModifier( url );

			}

			return url;

		};

		this.setURLModifier = function ( transform ) {

			urlModifier = transform;

			return this;

		};

		this.addHandler = function ( regex, loader ) {

			handlers.push( regex, loader );

			return this;

		};

		this.removeHandler = function ( regex ) {

			const index = handlers.indexOf( regex );

			if ( index !== - 1 ) {

				handlers.splice( index, 2 );

			}

			return this;

		};

		this.getHandler = function ( file ) {

			for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

				const regex = handlers[ i ];
				const loader = handlers[ i + 1 ];

				if ( regex.global ) regex.lastIndex = 0; // see #17920

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		};

	}

}

const DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();

class Loader {

	constructor( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		this.crossOrigin = 'anonymous';
		this.withCredentials = false;
		this.path = '';
		this.resourcePath = '';
		this.requestHeader = {};

	}

	load( /* url, onLoad, onProgress, onError */ ) {}

	loadAsync( url, onProgress ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.load( url, resolve, onProgress, reject );

		} );

	}

	parse( /* data */ ) {}

	setCrossOrigin( crossOrigin ) {

		this.crossOrigin = crossOrigin;
		return this;

	}

	setWithCredentials( value ) {

		this.withCredentials = value;
		return this;

	}

	setPath( path ) {

		this.path = path;
		return this;

	}

	setResourcePath( resourcePath ) {

		this.resourcePath = resourcePath;
		return this;

	}

	setRequestHeader( requestHeader ) {

		this.requestHeader = requestHeader;
		return this;

	}

}

Loader.DEFAULT_MATERIAL_NAME = '__DEFAULT';

const loading = {};

class HttpError extends Error {

	constructor( message, response ) {

		super( message );
		this.response = response;

	}

}

class FileLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			this.manager.itemStart( url );

			setTimeout( () => {

				if ( onLoad ) onLoad( cached );

				this.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		// Check if request is duplicate

		if ( loading[ url ] !== undefined ) {

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			return;

		}

		// Initialise array for duplicate requests
		loading[ url ] = [];

		loading[ url ].push( {
			onLoad: onLoad,
			onProgress: onProgress,
			onError: onError,
		} );

		// create request
		const req = new Request( url, {
			headers: new Headers( this.requestHeader ),
			credentials: this.withCredentials ? 'include' : 'same-origin',
			// An abort controller could be added within a future PR
		} );

		// record states ( avoid data race )
		const mimeType = this.mimeType;
		const responseType = this.responseType;

		// start the fetch
		fetch( req )
			.then( response => {

				if ( response.status === 200 || response.status === 0 ) {

					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.

					if ( response.status === 0 ) {

						console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

					}

					// Workaround: Checking if response.body === undefined for Alipay browser #23548

					if ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {

						return response;

					}

					const callbacks = loading[ url ];
					const reader = response.body.getReader();

					// Nginx needs X-File-Size check
					// https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content
					const contentLength = response.headers.get( 'X-File-Size' ) || response.headers.get( 'Content-Length' );
					const total = contentLength ? parseInt( contentLength ) : 0;
					const lengthComputable = total !== 0;
					let loaded = 0;

					// periodically read data into the new stream tracking while download progress
					const stream = new ReadableStream( {
						start( controller ) {

							readData();

							function readData() {

								reader.read().then( ( { done, value } ) => {

									if ( done ) {

										controller.close();

									} else {

										loaded += value.byteLength;

										const event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );
										for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

											const callback = callbacks[ i ];
											if ( callback.onProgress ) callback.onProgress( event );

										}

										controller.enqueue( value );
										readData();

									}

								} );

							}

						}

					} );

					return new Response( stream );

				} else {

					throw new HttpError( `fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response );

				}

			} )
			.then( response => {

				switch ( responseType ) {

					case 'arraybuffer':

						return response.arrayBuffer();

					case 'blob':

						return response.blob();

					case 'document':

						return response.text()
							.then( text => {

								const parser = new DOMParser();
								return parser.parseFromString( text, mimeType );

							} );

					case 'json':

						return response.json();

					default:

						if ( mimeType === undefined ) {

							return response.text();

						} else {

							// sniff encoding
							const re = /charset="?([^;"\s]*)"?/i;
							const exec = re.exec( mimeType );
							const label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;
							const decoder = new TextDecoder( label );
							return response.arrayBuffer().then( ab => decoder.decode( ab ) );

						}

				}

			} )
			.then( data => {

				// Add to cache only on HTTP success, so that we do not cache
				// error response bodies as proper responses to requests.
				Cache.add( url, data );

				const callbacks = loading[ url ];
				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onLoad ) callback.onLoad( data );

				}

			} )
			.catch( err => {

				// Abort errors and other errors are handled the same

				const callbacks = loading[ url ];

				if ( callbacks === undefined ) {

					// When onLoad was called and url was deleted in `loading`
					this.manager.itemError( url );
					throw err;

				}

				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( err );

				}

				this.manager.itemError( url );

			} )
			.finally( () => {

				this.manager.itemEnd( url );

			} );

		this.manager.itemStart( url );

	}

	setResponseType( value ) {

		this.responseType = value;
		return this;

	}

	setMimeType( value ) {

		this.mimeType = value;
		return this;

	}

}

class AnimationLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const animations = [];

		for ( let i = 0; i < json.length; i ++ ) {

			const clip = AnimationClip.parse( json[ i ] );

			animations.push( clip );

		}

		return animations;

	}

}

/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

class CompressedTextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const images = [];

		const texture = new CompressedTexture();

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( scope.withCredentials );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( url[ i ], function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				images[ i ] = {
					width: texDatas.width,
					height: texDatas.height,
					format: texDatas.format,
					mipmaps: texDatas.mipmaps
				};

				loaded += 1;

				if ( loaded === 6 ) {

					if ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;

					texture.image = images;
					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, onProgress, onError );

		}

		if ( Array.isArray( url ) ) {

			for ( let i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				if ( texDatas.isCubemap ) {

					const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( let f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps: [] };

						for ( let i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

					texture.image = images;

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	}

}

class ImageLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const image = createElementNS( 'img' );

		function onImageLoad() {

			removeEventListeners();

			Cache.add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}

		function onImageError( event ) {

			removeEventListeners();

			if ( onError ) onError( event );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		}

		function removeEventListeners() {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

		}

		image.addEventListener( 'load', onImageLoad, false );
		image.addEventListener( 'error', onImageError, false );

		if ( url.slice( 0, 5 ) !== 'data:' ) {

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		}

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	}

}

class CubeTextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( urls, onLoad, onProgress, onError ) {

		const texture = new CubeTexture();
		texture.colorSpace = SRGBColorSpace;

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( let i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	}

}

/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

class DataTextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const texture = new DataTexture();

		const loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setPath( this.path );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( buffer ) {

			let texData;

			try {

				texData = scope.parse( buffer );

			} catch ( error ) {

				if ( onError !== undefined ) {

					onError( error );

				} else {

					console.error( error );
					return;

				}

			}

			if ( texData.image !== undefined ) {

				texture.image = texData.image;

			} else if ( texData.data !== undefined ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
			texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

			texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
			texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;

			texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

			if ( texData.colorSpace !== undefined ) {

				texture.colorSpace = texData.colorSpace;

			}

			if ( texData.flipY !== undefined ) {

				texture.flipY = texData.flipY;

			}

			if ( texData.format !== undefined ) {

				texture.format = texData.format;

			}

			if ( texData.type !== undefined ) {

				texture.type = texData.type;

			}

			if ( texData.mipmaps !== undefined ) {

				texture.mipmaps = texData.mipmaps;
				texture.minFilter = LinearMipmapLinearFilter; // presumably...

			}

			if ( texData.mipmapCount === 1 ) {

				texture.minFilter = LinearFilter;

			}

			if ( texData.generateMipmaps !== undefined ) {

				texture.generateMipmaps = texData.generateMipmaps;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	}

}

class TextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const texture = new Texture();

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		loader.load( url, function ( image ) {

			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	}

}

class Light extends Object3D {

	constructor( color, intensity = 1 ) {

		super();

		this.isLight = true;

		this.type = 'Light';

		this.color = new Color( color );
		this.intensity = intensity;

	}

	dispose() {

		// Empty here in base class; some subclasses override.

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

		return data;

	}

}

class HemisphereLight extends Light {

	constructor( skyColor, groundColor, intensity ) {

		super( skyColor, intensity );

		this.isHemisphereLight = true;

		this.type = 'HemisphereLight';

		this.position.copy( Object3D.DEFAULT_UP );
		this.updateMatrix();

		this.groundColor = new Color( groundColor );

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.groundColor.copy( source.groundColor );

		return this;

	}

}

const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
const _lookTarget$1 = /*@__PURE__*/ new Vector3();

class LightShadow {

	constructor( camera ) {

		this.camera = camera;

		this.bias = 0;
		this.normalBias = 0;
		this.radius = 1;
		this.blurSamples = 8;

		this.mapSize = new Vector2( 512, 512 );

		this.map = null;
		this.mapPass = null;
		this.matrix = new Matrix4();

		this.autoUpdate = true;
		this.needsUpdate = false;

		this._frustum = new Frustum();
		this._frameExtents = new Vector2( 1, 1 );

		this._viewportCount = 1;

		this._viewports = [

			new Vector4( 0, 0, 1, 1 )

		];

	}

	getViewportCount() {

		return this._viewportCount;

	}

	getFrustum() {

		return this._frustum;

	}

	updateMatrices( light ) {

		const shadowCamera = this.camera;
		const shadowMatrix = this.matrix;

		_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
		shadowCamera.position.copy( _lightPositionWorld$1 );

		_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
		shadowCamera.lookAt( _lookTarget$1 );
		shadowCamera.updateMatrixWorld();

		_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

		shadowMatrix.set(
			0.5, 0.0, 0.0, 0.5,
			0.0, 0.5, 0.0, 0.5,
			0.0, 0.0, 0.5, 0.5,
			0.0, 0.0, 0.0, 1.0
		);

		shadowMatrix.multiply( _projScreenMatrix$1 );

	}

	getViewport( viewportIndex ) {

		return this._viewports[ viewportIndex ];

	}

	getFrameExtents() {

		return this._frameExtents;

	}

	dispose() {

		if ( this.map ) {

			this.map.dispose();

		}

		if ( this.mapPass ) {

			this.mapPass.dispose();

		}

	}

	copy( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	toJSON() {

		const object = {};

		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	}

}

class SpotLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

		this.isSpotLightShadow = true;

		this.focus = 1;

	}

	updateMatrices( light ) {

		const camera = this.camera;

		const fov = RAD2DEG * 2 * light.angle * this.focus;
		const aspect = this.mapSize.width / this.mapSize.height;
		const far = light.distance || camera.far;

		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();

		}

		super.updateMatrices( light );

	}

	copy( source ) {

		super.copy( source );

		this.focus = source.focus;

		return this;

	}

}

class SpotLight extends Light {

	constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2 ) {

		super( color, intensity );

		this.isSpotLight = true;

		this.type = 'SpotLight';

		this.position.copy( Object3D.DEFAULT_UP );
		this.updateMatrix();

		this.target = new Object3D();

		this.distance = distance;
		this.angle = angle;
		this.penumbra = penumbra;
		this.decay = decay;

		this.map = null;

		this.shadow = new SpotLightShadow();

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)
		return this.intensity * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / Math.PI;

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

}

const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld = /*@__PURE__*/ new Vector3();
const _lookTarget = /*@__PURE__*/ new Vector3();

class PointLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

		this.isPointLightShadow = true;

		this._frameExtents = new Vector2( 4, 2 );

		this._viewportCount = 6;

		this._viewports = [
			// These viewports map a cube-map onto a 2D texture with the
			// following orientation:
			//
			//  xzXZ
			//   y Y
			//
			// X - Positive x direction
			// x - Negative x direction
			// Y - Positive y direction
			// y - Negative y direction
			// Z - Positive z direction
			// z - Negative z direction

			// positive X
			new Vector4( 2, 1, 1, 1 ),
			// negative X
			new Vector4( 0, 1, 1, 1 ),
			// positive Z
			new Vector4( 3, 1, 1, 1 ),
			// negative Z
			new Vector4( 1, 1, 1, 1 ),
			// positive Y
			new Vector4( 3, 0, 1, 1 ),
			// negative Y
			new Vector4( 1, 0, 1, 1 )
		];

		this._cubeDirections = [
			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
		];

		this._cubeUps = [
			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
		];

	}

	updateMatrices( light, viewportIndex = 0 ) {

		const camera = this.camera;
		const shadowMatrix = this.matrix;

		const far = light.distance || camera.far;

		if ( far !== camera.far ) {

			camera.far = far;
			camera.updateProjectionMatrix();

		}

		_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		camera.position.copy( _lightPositionWorld );

		_lookTarget.copy( camera.position );
		_lookTarget.add( this._cubeDirections[ viewportIndex ] );
		camera.up.copy( this._cubeUps[ viewportIndex ] );
		camera.lookAt( _lookTarget );
		camera.updateMatrixWorld();

		shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix );

	}

}

class PointLight extends Light {

	constructor( color, intensity, distance = 0, decay = 2 ) {

		super( color, intensity );

		this.isPointLight = true;

		this.type = 'PointLight';

		this.distance = distance;
		this.decay = decay;

		this.shadow = new PointLightShadow();

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)
		return this.intensity * 4 * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / ( 4 * Math.PI );

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

}

class DirectionalLightShadow extends LightShadow {

	constructor() {

		super( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

		this.isDirectionalLightShadow = true;

	}

}

class DirectionalLight extends Light {

	constructor( color, intensity ) {

		super( color, intensity );

		this.isDirectionalLight = true;

		this.type = 'DirectionalLight';

		this.position.copy( Object3D.DEFAULT_UP );
		this.updateMatrix();

		this.target = new Object3D();

		this.shadow = new DirectionalLightShadow();

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source ) {

		super.copy( source );

		this.target = source.target.clone();
		this.shadow = source.shadow.clone();

		return this;

	}

}

class AmbientLight extends Light {

	constructor( color, intensity ) {

		super( color, intensity );

		this.isAmbientLight = true;

		this.type = 'AmbientLight';

	}

}

class RectAreaLight extends Light {

	constructor( color, intensity, width = 10, height = 10 ) {

		super( color, intensity );

		this.isRectAreaLight = true;

		this.type = 'RectAreaLight';

		this.width = width;
		this.height = height;

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in nits)
		return this.intensity * this.width * this.height * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in nits) from the desired luminous power (in lumens)
		this.intensity = power / ( this.width * this.height * Math.PI );

	}

	copy( source ) {

		super.copy( source );

		this.width = source.width;
		this.height = source.height;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.width = this.width;
		data.object.height = this.height;

		return data;

	}

}

/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */

// 3-band SH defined by 9 coefficients

class SphericalHarmonics3 {

	constructor() {

		this.isSphericalHarmonics3 = true;

		this.coefficients = [];

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients.push( new Vector3() );

		}

	}

	set( coefficients ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].copy( coefficients[ i ] );

		}

		return this;

	}

	zero() {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].set( 0, 0, 0 );

		}

		return this;

	}

	// get the radiance in the direction of the normal
	// target is a Vector3
	getAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

		// band 1
		target.addScaledVector( coeff[ 1 ], 0.488603 * y );
		target.addScaledVector( coeff[ 2 ], 0.488603 * z );
		target.addScaledVector( coeff[ 3 ], 0.488603 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
		target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
		target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
		target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
		target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

		return target;

	}

	// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
	// target is a Vector3
	// https://graphics.stanford.edu/papers/envmap/envmap.pdf
	getIrradianceAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095

		// band 1
		target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603
		target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
		target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548
		target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
		target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3
		target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
		target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274

		return target;

	}

	add( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].add( sh.coefficients[ i ] );

		}

		return this;

	}

	addScaledSH( sh, s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

		}

		return this;

	}

	scale( s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].multiplyScalar( s );

		}

		return this;

	}

	lerp( sh, alpha ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

		}

		return this;

	}

	equals( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

				return false;

			}

		}

		return true;

	}

	copy( sh ) {

		return this.set( sh.coefficients );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	fromArray( array, offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].toArray( array, offset + ( i * 3 ) );

		}

		return array;

	}

	// evaluate the basis functions
	// shBasis is an Array[ 9 ]
	static getBasisAt( normal, shBasis ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		// band 0
		shBasis[ 0 ] = 0.282095;

		// band 1
		shBasis[ 1 ] = 0.488603 * y;
		shBasis[ 2 ] = 0.488603 * z;
		shBasis[ 3 ] = 0.488603 * x;

		// band 2
		shBasis[ 4 ] = 1.092548 * x * y;
		shBasis[ 5 ] = 1.092548 * y * z;
		shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
		shBasis[ 7 ] = 1.092548 * x * z;
		shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

	}

}

class LightProbe extends Light {

	constructor( sh = new SphericalHarmonics3(), intensity = 1 ) {

		super( undefined, intensity );

		this.isLightProbe = true;

		this.sh = sh;

	}

	copy( source ) {

		super.copy( source );

		this.sh.copy( source.sh );

		return this;

	}

	fromJSON( json ) {

		this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
		this.sh.fromArray( json.sh );

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.sh = this.sh.toArray();

		return data;

	}

}

class MaterialLoader extends Loader {

	constructor( manager ) {

		super( manager );
		this.textures = {};

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const textures = this.textures;

		function getTexture( name ) {

			if ( textures[ name ] === undefined ) {

				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		}

		const material = MaterialLoader.createMaterialFromType( json.type );

		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.sheen !== undefined ) material.sheen = json.sheen;
		if ( json.sheenColor !== undefined ) material.sheenColor = new Color().setHex( json.sheenColor );
		if ( json.sheenRoughness !== undefined ) material.sheenRoughness = json.sheenRoughness;
		if ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.specularIntensity !== undefined ) material.specularIntensity = json.specularIntensity;
		if ( json.specularColor !== undefined && material.specularColor !== undefined ) material.specularColor.setHex( json.specularColor );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;
		if ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;
		if ( json.dispersion !== undefined ) material.dispersion = json.dispersion;
		if ( json.iridescence !== undefined ) material.iridescence = json.iridescence;
		if ( json.iridescenceIOR !== undefined ) material.iridescenceIOR = json.iridescenceIOR;
		if ( json.iridescenceThicknessRange !== undefined ) material.iridescenceThicknessRange = json.iridescenceThicknessRange;
		if ( json.transmission !== undefined ) material.transmission = json.transmission;
		if ( json.thickness !== undefined ) material.thickness = json.thickness;
		if ( json.attenuationDistance !== undefined ) material.attenuationDistance = json.attenuationDistance;
		if ( json.attenuationColor !== undefined && material.attenuationColor !== undefined ) material.attenuationColor.setHex( json.attenuationColor );
		if ( json.anisotropy !== undefined ) material.anisotropy = json.anisotropy;
		if ( json.anisotropyRotation !== undefined ) material.anisotropyRotation = json.anisotropyRotation;
		if ( json.fog !== undefined ) material.fog = json.fog;
		if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.combine !== undefined ) material.combine = json.combine;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.shadowSide !== undefined ) material.shadowSide = json.shadowSide;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.alphaHash !== undefined ) material.alphaHash = json.alphaHash;
		if ( json.depthFunc !== undefined ) material.depthFunc = json.depthFunc;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
		if ( json.blendSrc !== undefined ) material.blendSrc = json.blendSrc;
		if ( json.blendDst !== undefined ) material.blendDst = json.blendDst;
		if ( json.blendEquation !== undefined ) material.blendEquation = json.blendEquation;
		if ( json.blendSrcAlpha !== undefined ) material.blendSrcAlpha = json.blendSrcAlpha;
		if ( json.blendDstAlpha !== undefined ) material.blendDstAlpha = json.blendDstAlpha;
		if ( json.blendEquationAlpha !== undefined ) material.blendEquationAlpha = json.blendEquationAlpha;
		if ( json.blendColor !== undefined && material.blendColor !== undefined ) material.blendColor.setHex( json.blendColor );
		if ( json.blendAlpha !== undefined ) material.blendAlpha = json.blendAlpha;
		if ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;
		if ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;
		if ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;
		if ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;
		if ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;
		if ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;
		if ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;
		if ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;

		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

		if ( json.rotation !== undefined ) material.rotation = json.rotation;

		if ( json.linewidth !== undefined ) material.linewidth = json.linewidth;
		if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
		if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
		if ( json.scale !== undefined ) material.scale = json.scale;

		if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
		if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
		if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

		if ( json.dithering !== undefined ) material.dithering = json.dithering;

		if ( json.alphaToCoverage !== undefined ) material.alphaToCoverage = json.alphaToCoverage;
		if ( json.premultipliedAlpha !== undefined ) material.premultipliedAlpha = json.premultipliedAlpha;
		if ( json.forceSinglePass !== undefined ) material.forceSinglePass = json.forceSinglePass;

		if ( json.visible !== undefined ) material.visible = json.visible;

		if ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;

		if ( json.userData !== undefined ) material.userData = json.userData;

		if ( json.vertexColors !== undefined ) {

			if ( typeof json.vertexColors === 'number' ) {

				material.vertexColors = ( json.vertexColors > 0 ) ? true : false;

			} else {

				material.vertexColors = json.vertexColors;

			}

		}

		// Shader Material

		if ( json.uniforms !== undefined ) {

			for ( const name in json.uniforms ) {

				const uniform = json.uniforms[ name ];

				material.uniforms[ name ] = {};

				switch ( uniform.type ) {

					case 't':
						material.uniforms[ name ].value = getTexture( uniform.value );
						break;

					case 'c':
						material.uniforms[ name ].value = new Color().setHex( uniform.value );
						break;

					case 'v2':
						material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
						break;

					case 'v3':
						material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
						break;

					case 'v4':
						material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
						break;

					case 'm3':
						material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );
						break;

					case 'm4':
						material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
						break;

					default:
						material.uniforms[ name ].value = uniform.value;

				}

			}

		}

		if ( json.defines !== undefined ) material.defines = json.defines;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
		if ( json.glslVersion !== undefined ) material.glslVersion = json.glslVersion;

		if ( json.extensions !== undefined ) {

			for ( const key in json.extensions ) {

				material.extensions[ key ] = json.extensions[ key ];

			}

		}

		if ( json.lights !== undefined ) material.lights = json.lights;
		if ( json.clipping !== undefined ) material.clipping = json.clipping;

		// for PointsMaterial

		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = getTexture( json.map );
		if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );

		if ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );

		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
		if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
		if ( json.normalScale !== undefined ) {

			let normalScale = json.normalScale;

			if ( Array.isArray( normalScale ) === false ) {

				// Blender exporter used to export a scalar. See #7459

				normalScale = [ normalScale, normalScale ];

			}

			material.normalScale = new Vector2().fromArray( normalScale );

		}

		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );
		if ( json.specularIntensityMap !== undefined ) material.specularIntensityMap = getTexture( json.specularIntensityMap );
		if ( json.specularColorMap !== undefined ) material.specularColorMap = getTexture( json.specularColorMap );

		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
		if ( json.envMapRotation !== undefined ) material.envMapRotation.fromArray( json.envMapRotation );
		if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
		if ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;

		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

		if ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );
		if ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );
		if ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );
		if ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );

		if ( json.iridescenceMap !== undefined ) material.iridescenceMap = getTexture( json.iridescenceMap );
		if ( json.iridescenceThicknessMap !== undefined ) material.iridescenceThicknessMap = getTexture( json.iridescenceThicknessMap );

		if ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );
		if ( json.thicknessMap !== undefined ) material.thicknessMap = getTexture( json.thicknessMap );

		if ( json.anisotropyMap !== undefined ) material.anisotropyMap = getTexture( json.anisotropyMap );

		if ( json.sheenColorMap !== undefined ) material.sheenColorMap = getTexture( json.sheenColorMap );
		if ( json.sheenRoughnessMap !== undefined ) material.sheenRoughnessMap = getTexture( json.sheenRoughnessMap );

		return material;

	}

	setTextures( value ) {

		this.textures = value;
		return this;

	}

	static createMaterialFromType( type ) {

		const materialLib = {
			ShadowMaterial,
			SpriteMaterial,
			RawShaderMaterial,
			ShaderMaterial,
			PointsMaterial,
			MeshPhysicalMaterial,
			MeshStandardMaterial,
			MeshPhongMaterial,
			MeshToonMaterial,
			MeshNormalMaterial,
			MeshLambertMaterial,
			MeshDepthMaterial,
			MeshDistanceMaterial,
			MeshBasicMaterial,
			MeshMatcapMaterial,
			LineDashedMaterial,
			LineBasicMaterial,
			Material
		};

		return new materialLib[ type ]();

	}

}

class LoaderUtils {

	static decodeText( array ) {

		if ( typeof TextDecoder !== 'undefined' ) {

			return new TextDecoder().decode( array );

		}

		// Avoid the String.fromCharCode.apply(null, array) shortcut, which
		// throws a "maximum call stack size exceeded" error for large arrays.

		let s = '';

		for ( let i = 0, il = array.length; i < il; i ++ ) {

			// Implicitly assumes little-endian.
			s += String.fromCharCode( array[ i ] );

		}

		try {

			// merges multi-byte utf-8 characters.

			return decodeURIComponent( escape( s ) );

		} catch ( e ) { // see #16358

			return s;

		}

	}

	static extractUrlBase( url ) {

		const index = url.lastIndexOf( '/' );

		if ( index === - 1 ) return './';

		return url.slice( 0, index + 1 );

	}

	static resolveURL( url, path ) {

		// Invalid URL
		if ( typeof url !== 'string' || url === '' ) return '';

		// Host Relative URL
		if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {

			path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );

		}

		// Absolute URL http://,https://,//
		if ( /^(https?:)?\/\//i.test( url ) ) return url;

		// Data URI
		if ( /^data:.*,.*$/i.test( url ) ) return url;

		// Blob URL
		if ( /^blob:.*$/i.test( url ) ) return url;

		// Relative URL
		return path + url;

	}

}

class InstancedBufferGeometry extends BufferGeometry {

	constructor() {

		super();

		this.isInstancedBufferGeometry = true;

		this.type = 'InstancedBufferGeometry';
		this.instanceCount = Infinity;

	}

	copy( source ) {

		super.copy( source );

		this.instanceCount = source.instanceCount;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.instanceCount = this.instanceCount;

		data.isInstancedBufferGeometry = true;

		return data;

	}

}

class BufferGeometryLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const interleavedBufferMap = {};
		const arrayBufferMap = {};

		function getInterleavedBuffer( json, uuid ) {

			if ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];

			const interleavedBuffers = json.interleavedBuffers;
			const interleavedBuffer = interleavedBuffers[ uuid ];

			const buffer = getArrayBuffer( json, interleavedBuffer.buffer );

			const array = getTypedArray( interleavedBuffer.type, buffer );
			const ib = new InterleavedBuffer( array, interleavedBuffer.stride );
			ib.uuid = interleavedBuffer.uuid;

			interleavedBufferMap[ uuid ] = ib;

			return ib;

		}

		function getArrayBuffer( json, uuid ) {

			if ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];

			const arrayBuffers = json.arrayBuffers;
			const arrayBuffer = arrayBuffers[ uuid ];

			const ab = new Uint32Array( arrayBuffer ).buffer;

			arrayBufferMap[ uuid ] = ab;

			return ab;

		}

		const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();

		const index = json.data.index;

		if ( index !== undefined ) {

			const typedArray = getTypedArray( index.type, index.array );
			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

		}

		const attributes = json.data.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];
			let bufferAttribute;

			if ( attribute.isInterleavedBufferAttribute ) {

				const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
				bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

			} else {

				const typedArray = getTypedArray( attribute.type, attribute.array );
				const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
				bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );

			}

			if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
			if ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );

			geometry.setAttribute( key, bufferAttribute );

		}

		const morphAttributes = json.data.morphAttributes;

		if ( morphAttributes ) {

			for ( const key in morphAttributes ) {

				const attributeArray = morphAttributes[ key ];

				const array = [];

				for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

					const attribute = attributeArray[ i ];
					let bufferAttribute;

					if ( attribute.isInterleavedBufferAttribute ) {

						const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
						bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

					} else {

						const typedArray = getTypedArray( attribute.type, attribute.array );
						bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );

					}

					if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
					array.push( bufferAttribute );

				}

				geometry.morphAttributes[ key ] = array;

			}

		}

		const morphTargetsRelative = json.data.morphTargetsRelative;

		if ( morphTargetsRelative ) {

			geometry.morphTargetsRelative = true;

		}

		const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( let i = 0, n = groups.length; i !== n; ++ i ) {

				const group = groups[ i ];

				geometry.addGroup( group.start, group.count, group.materialIndex );

			}

		}

		const boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			const center = new Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

		}

		if ( json.name ) geometry.name = json.name;
		if ( json.userData ) geometry.userData = json.userData;

		return geometry;

	}

}

class ObjectLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			let json = null;

			try {

				json = JSON.parse( text );

			} catch ( error ) {

				if ( onError !== undefined ) onError( error );

				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

				return;

			}

			const metadata = json.metadata;

			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

				if ( onError !== undefined ) onError( new Error( 'THREE.ObjectLoader: Can\'t load ' + url ) );

				console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
				return;

			}

			scope.parse( json, onLoad );

		}, onProgress, onError );

	}

	async loadAsync( url, onProgress ) {

		const scope = this;

		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		const text = await loader.loadAsync( url, onProgress );

		const json = JSON.parse( text );

		const metadata = json.metadata;

		if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

			throw new Error( 'THREE.ObjectLoader: Can\'t load ' + url );

		}

		return await scope.parseAsync( json );

	}

	parse( json, onLoad ) {

		const animations = this.parseAnimations( json.animations );
		const shapes = this.parseShapes( json.shapes );
		const geometries = this.parseGeometries( json.geometries, shapes );

		const images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		const textures = this.parseTextures( json.textures, images );
		const materials = this.parseMaterials( json.materials, textures );

		const object = this.parseObject( json.object, geometries, materials, textures, animations );
		const skeletons = this.parseSkeletons( json.skeletons, object );

		this.bindSkeletons( object, skeletons );

		//

		if ( onLoad !== undefined ) {

			let hasImages = false;

			for ( const uuid in images ) {

				if ( images[ uuid ].data instanceof HTMLImageElement ) {

					hasImages = true;
					break;

				}

			}

			if ( hasImages === false ) onLoad( object );

		}

		return object;

	}

	async parseAsync( json ) {

		const animations = this.parseAnimations( json.animations );
		const shapes = this.parseShapes( json.shapes );
		const geometries = this.parseGeometries( json.geometries, shapes );

		const images = await this.parseImagesAsync( json.images );

		const textures = this.parseTextures( json.textures, images );
		const materials = this.parseMaterials( json.materials, textures );

		const object = this.parseObject( json.object, geometries, materials, textures, animations );
		const skeletons = this.parseSkeletons( json.skeletons, object );

		this.bindSkeletons( object, skeletons );

		return object;

	}

	parseShapes( json ) {

		const shapes = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const shape = new Shape().fromJSON( json[ i ] );

				shapes[ shape.uuid ] = shape;

			}

		}

		return shapes;

	}

	parseSkeletons( json, object ) {

		const skeletons = {};
		const bones = {};

		// generate bone lookup table

		object.traverse( function ( child ) {

			if ( child.isBone ) bones[ child.uuid ] = child;

		} );

		// create skeletons

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const skeleton = new Skeleton().fromJSON( json[ i ], bones );

				skeletons[ skeleton.uuid ] = skeleton;

			}

		}

		return skeletons;

	}

	parseGeometries( json, shapes ) {

		const geometries = {};

		if ( json !== undefined ) {

			const bufferGeometryLoader = new BufferGeometryLoader();

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				let geometry;
				const data = json[ i ];

				switch ( data.type ) {

					case 'BufferGeometry':
					case 'InstancedBufferGeometry':

						geometry = bufferGeometryLoader.parse( data );
						break;

					default:

						if ( data.type in Geometries ) {

							geometry = Geometries[ data.type ].fromJSON( data, shapes );

						} else {

							console.warn( `THREE.ObjectLoader: Unsupported geometry type "${ data.type }"` );

						}

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;
				if ( data.userData !== undefined ) geometry.userData = data.userData;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	}

	parseMaterials( json, textures ) {

		const cache = {}; // MultiMaterial
		const materials = {};

		if ( json !== undefined ) {

			const loader = new MaterialLoader();
			loader.setTextures( textures );

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( cache[ data.uuid ] === undefined ) {

					cache[ data.uuid ] = loader.parse( data );

				}

				materials[ data.uuid ] = cache[ data.uuid ];

			}

		}

		return materials;

	}

	parseAnimations( json ) {

		const animations = {};

		if ( json !== undefined ) {

			for ( let i = 0; i < json.length; i ++ ) {

				const data = json[ i ];

				const clip = AnimationClip.parse( data );

				animations[ clip.uuid ] = clip;

			}

		}

		return animations;

	}

	parseImages( json, onLoad ) {

		const scope = this;
		const images = {};

		let loader;

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			}, undefined, function () {

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			} );

		}

		function deserializeImage( image ) {

			if ( typeof image === 'string' ) {

				const url = image;

				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

				return loadImage( path );

			} else {

				if ( image.data ) {

					return {
						data: getTypedArray( image.type, image.data ),
						width: image.width,
						height: image.height
					};

				} else {

					return null;

				}

			}

		}

		if ( json !== undefined && json.length > 0 ) {

			const manager = new LoadingManager( onLoad );

			loader = new ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( let i = 0, il = json.length; i < il; i ++ ) {

				const image = json[ i ];
				const url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					const imageArray = [];

					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

						const currentUrl = url[ j ];

						const deserializedImage = deserializeImage( currentUrl );

						if ( deserializedImage !== null ) {

							if ( deserializedImage instanceof HTMLImageElement ) {

								imageArray.push( deserializedImage );

							} else {

								// special case: handle array of data textures for cube textures

								imageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

							}

						}

					}

					images[ image.uuid ] = new Source( imageArray );

				} else {

					// load single image

					const deserializedImage = deserializeImage( image.url );
					images[ image.uuid ] = new Source( deserializedImage );


				}

			}

		}

		return images;

	}

	async parseImagesAsync( json ) {

		const scope = this;
		const images = {};

		let loader;

		async function deserializeImage( image ) {

			if ( typeof image === 'string' ) {

				const url = image;

				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

				return await loader.loadAsync( path );

			} else {

				if ( image.data ) {

					return {
						data: getTypedArray( image.type, image.data ),
						width: image.width,
						height: image.height
					};

				} else {

					return null;

				}

			}

		}

		if ( json !== undefined && json.length > 0 ) {

			loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( let i = 0, il = json.length; i < il; i ++ ) {

				const image = json[ i ];
				const url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					const imageArray = [];

					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

						const currentUrl = url[ j ];

						const deserializedImage = await deserializeImage( currentUrl );

						if ( deserializedImage !== null ) {

							if ( deserializedImage instanceof HTMLImageElement ) {

								imageArray.push( deserializedImage );

							} else {

								// special case: handle array of data textures for cube textures

								imageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

							}

						}

					}

					images[ image.uuid ] = new Source( imageArray );

				} else {

					// load single image

					const deserializedImage = await deserializeImage( image.url );
					images[ image.uuid ] = new Source( deserializedImage );

				}

			}

		}

		return images;

	}

	parseTextures( json, images ) {

		function parseConstant( value, type ) {

			if ( typeof value === 'number' ) return value;

			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return type[ value ];

		}

		const textures = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

				}

				const source = images[ data.image ];
				const image = source.data;

				let texture;

				if ( Array.isArray( image ) ) {

					texture = new CubeTexture();

					if ( image.length === 6 ) texture.needsUpdate = true;

				} else {

					if ( image && image.data ) {

						texture = new DataTexture();

					} else {

						texture = new Texture();

					}

					if ( image ) texture.needsUpdate = true; // textures can have undefined image data

				}

				texture.source = source;

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;

				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );
				if ( data.channel !== undefined ) texture.channel = data.channel;

				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
				if ( data.center !== undefined ) texture.center.fromArray( data.center );
				if ( data.rotation !== undefined ) texture.rotation = data.rotation;

				if ( data.wrap !== undefined ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
					texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

				}

				if ( data.format !== undefined ) texture.format = data.format;
				if ( data.internalFormat !== undefined ) texture.internalFormat = data.internalFormat;
				if ( data.type !== undefined ) texture.type = data.type;
				if ( data.colorSpace !== undefined ) texture.colorSpace = data.colorSpace;

				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

				if ( data.generateMipmaps !== undefined ) texture.generateMipmaps = data.generateMipmaps;
				if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
				if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;
				if ( data.compareFunction !== undefined ) texture.compareFunction = data.compareFunction;

				if ( data.userData !== undefined ) texture.userData = data.userData;

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	}

	parseObject( data, geometries, materials, textures, animations ) {

		let object;

		function getGeometry( name ) {

			if ( geometries[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

			}

			return geometries[ name ];

		}

		function getMaterial( name ) {

			if ( name === undefined ) return undefined;

			if ( Array.isArray( name ) ) {

				const array = [];

				for ( let i = 0, l = name.length; i < l; i ++ ) {

					const uuid = name[ i ];

					if ( materials[ uuid ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

					}

					array.push( materials[ uuid ] );

				}

				return array;

			}

			if ( materials[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined material', name );

			}

			return materials[ name ];

		}

		function getTexture( uuid ) {

			if ( textures[ uuid ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined texture', uuid );

			}

			return textures[ uuid ];

		}

		let geometry, material;

		switch ( data.type ) {

			case 'Scene':

				object = new Scene();

				if ( data.background !== undefined ) {

					if ( Number.isInteger( data.background ) ) {

						object.background = new Color( data.background );

					} else {

						object.background = getTexture( data.background );

					}

				}

				if ( data.environment !== undefined ) {

					object.environment = getTexture( data.environment );

				}

				if ( data.fog !== undefined ) {

					if ( data.fog.type === 'Fog' ) {

						object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

					} else if ( data.fog.type === 'FogExp2' ) {

						object.fog = new FogExp2( data.fog.color, data.fog.density );

					}

					if ( data.fog.name !== '' ) {

						object.fog.name = data.fog.name;

					}

				}

				if ( data.backgroundBlurriness !== undefined ) object.backgroundBlurriness = data.backgroundBlurriness;
				if ( data.backgroundIntensity !== undefined ) object.backgroundIntensity = data.backgroundIntensity;
				if ( data.backgroundRotation !== undefined ) object.backgroundRotation.fromArray( data.backgroundRotation );

				if ( data.environmentIntensity !== undefined ) object.environmentIntensity = data.environmentIntensity;
				if ( data.environmentRotation !== undefined ) object.environmentRotation.fromArray( data.environmentRotation );

				break;

			case 'PerspectiveCamera':

				object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

				if ( data.focus !== undefined ) object.focus = data.focus;
				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
				if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'OrthographicCamera':

				object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'AmbientLight':

				object = new AmbientLight( data.color, data.intensity );

				break;

			case 'DirectionalLight':

				object = new DirectionalLight( data.color, data.intensity );

				break;

			case 'PointLight':

				object = new PointLight( data.color, data.intensity, data.distance, data.decay );

				break;

			case 'RectAreaLight':

				object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

				break;

			case 'SpotLight':

				object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

				break;

			case 'HemisphereLight':

				object = new HemisphereLight( data.color, data.groundColor, data.intensity );

				break;

			case 'LightProbe':

				object = new LightProbe().fromJSON( data );

				break;

			case 'SkinnedMesh':

				geometry = getGeometry( data.geometry );
			 	material = getMaterial( data.material );

				object = new SkinnedMesh( geometry, material );

				if ( data.bindMode !== undefined ) object.bindMode = data.bindMode;
				if ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );
				if ( data.skeleton !== undefined ) object.skeleton = data.skeleton;

				break;

			case 'Mesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );

				object = new Mesh( geometry, material );

				break;

			case 'InstancedMesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );
				const count = data.count;
				const instanceMatrix = data.instanceMatrix;
				const instanceColor = data.instanceColor;

				object = new InstancedMesh( geometry, material, count );
				object.instanceMatrix = new InstancedBufferAttribute( new Float32Array( instanceMatrix.array ), 16 );
				if ( instanceColor !== undefined ) object.instanceColor = new InstancedBufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );

				break;

			case 'BatchedMesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );

				object = new BatchedMesh( data.maxGeometryCount, data.maxVertexCount, data.maxIndexCount, material );
				object.geometry = geometry;
				object.perObjectFrustumCulled = data.perObjectFrustumCulled;
				object.sortObjects = data.sortObjects;

				object._drawRanges = data.drawRanges;
				object._reservedRanges = data.reservedRanges;

				object._visibility = data.visibility;
				object._active = data.active;
				object._bounds = data.bounds.map( bound => {

					const box = new Box3();
					box.min.fromArray( bound.boxMin );
					box.max.fromArray( bound.boxMax );

					const sphere = new Sphere();
					sphere.radius = bound.sphereRadius;
					sphere.center.fromArray( bound.sphereCenter );

					return {
						boxInitialized: bound.boxInitialized,
						box: box,

						sphereInitialized: bound.sphereInitialized,
						sphere: sphere
					};

				} );

				object._maxGeometryCount = data.maxGeometryCount;
				object._maxVertexCount = data.maxVertexCount;
				object._maxIndexCount = data.maxIndexCount;

				object._geometryInitialized = data.geometryInitialized;
				object._geometryCount = data.geometryCount;

				object._matricesTexture = getTexture( data.matricesTexture.uuid );

				break;

			case 'LOD':

				object = new LOD();

				break;

			case 'Line':

				object = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineLoop':

				object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineSegments':

				object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'PointCloud':
			case 'Points':

				object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'Sprite':

				object = new Sprite( getMaterial( data.material ) );

				break;

			case 'Group':

				object = new Group();

				break;

			case 'Bone':

				object = new Bone();

				break;

			default:

				object = new Object3D();

		}

		object.uuid = data.uuid;

		if ( data.name !== undefined ) object.name = data.name;

		if ( data.matrix !== undefined ) {

			object.matrix.fromArray( data.matrix );

			if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
			if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

		} else {

			if ( data.position !== undefined ) object.position.fromArray( data.position );
			if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
			if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
			if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

		}

		if ( data.up !== undefined ) object.up.fromArray( data.up );

		if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
		if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

		if ( data.shadow ) {

			if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
			if ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;
			if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
			if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
			if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

		}

		if ( data.visible !== undefined ) object.visible = data.visible;
		if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
		if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
		if ( data.userData !== undefined ) object.userData = data.userData;
		if ( data.layers !== undefined ) object.layers.mask = data.layers;

		if ( data.children !== undefined ) {

			const children = data.children;

			for ( let i = 0; i < children.length; i ++ ) {

				object.add( this.parseObject( children[ i ], geometries, materials, textures, animations ) );

			}

		}

		if ( data.animations !== undefined ) {

			const objectAnimations = data.animations;

			for ( let i = 0; i < objectAnimations.length; i ++ ) {

				const uuid = objectAnimations[ i ];

				object.animations.push( animations[ uuid ] );

			}

		}

		if ( data.type === 'LOD' ) {

			if ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;

			const levels = data.levels;

			for ( let l = 0; l < levels.length; l ++ ) {

				const level = levels[ l ];
				const child = object.getObjectByProperty( 'uuid', level.object );

				if ( child !== undefined ) {

					object.addLevel( child, level.distance, level.hysteresis );

				}

			}

		}

		return object;

	}

	bindSkeletons( object, skeletons ) {

		if ( Object.keys( skeletons ).length === 0 ) return;

		object.traverse( function ( child ) {

			if ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {

				const skeleton = skeletons[ child.skeleton ];

				if ( skeleton === undefined ) {

					console.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );

				} else {

					child.bind( skeleton, child.bindMatrix );

				}

			}

		} );

	}

}

const TEXTURE_MAPPING = {
	UVMapping: UVMapping,
	CubeReflectionMapping: CubeReflectionMapping,
	CubeRefractionMapping: CubeRefractionMapping,
	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
	CubeUVReflectionMapping: CubeUVReflectionMapping
};

const TEXTURE_WRAPPING = {
	RepeatWrapping: RepeatWrapping,
	ClampToEdgeWrapping: ClampToEdgeWrapping,
	MirroredRepeatWrapping: MirroredRepeatWrapping
};

const TEXTURE_FILTER = {
	NearestFilter: NearestFilter,
	NearestMipmapNearestFilter: NearestMipmapNearestFilter,
	NearestMipmapLinearFilter: NearestMipmapLinearFilter,
	LinearFilter: LinearFilter,
	LinearMipmapNearestFilter: LinearMipmapNearestFilter,
	LinearMipmapLinearFilter: LinearMipmapLinearFilter
};

class ImageBitmapLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.isImageBitmapLoader = true;

		if ( typeof createImageBitmap === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

		}

		if ( typeof fetch === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

		}

		this.options = { premultiplyAlpha: 'none' };

	}

	setOptions( options ) {

		this.options = options;

		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			// If cached is a promise, wait for it to resolve
			if ( cached.then ) {

				cached.then( imageBitmap => {

					if ( onLoad ) onLoad( imageBitmap );

					scope.manager.itemEnd( url );

				} ).catch( e => {

					if ( onError ) onError( e );

				} );
				return;

			}

			// If cached is not a promise (i.e., it's already an imageBitmap)
			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const fetchOptions = {};
		fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';
		fetchOptions.headers = this.requestHeader;

		const promise = fetch( url, fetchOptions ).then( function ( res ) {

			return res.blob();

		} ).then( function ( blob ) {

			return createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );

		} ).then( function ( imageBitmap ) {

			Cache.add( url, imageBitmap );

			if ( onLoad ) onLoad( imageBitmap );

			scope.manager.itemEnd( url );

			return imageBitmap;

		} ).catch( function ( e ) {

			if ( onError ) onError( e );

			Cache.remove( url );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		} );

		Cache.add( url, promise );
		scope.manager.itemStart( url );

	}

}

let _context;

class AudioContext {

	static getContext() {

		if ( _context === undefined ) {

			_context = new ( window.AudioContext || window.webkitAudioContext )();

		}

		return _context;

	}

	static setContext( value ) {

		_context = value;

	}

}

class AudioLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( buffer ) {

			try {

				// Create a copy of the buffer. The `decodeAudioData` method
				// detaches the buffer when complete, preventing reuse.
				const bufferCopy = buffer.slice( 0 );

				const context = AudioContext.getContext();
				context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

					onLoad( audioBuffer );

				} ).catch( handleError );

			} catch ( e ) {

				handleError( e );

			}

		}, onProgress, onError );

		function handleError( e ) {

			if ( onError ) {

				onError( e );

			} else {

				console.error( e );

			}

			scope.manager.itemError( url );

		}

	}

}

const _eyeRight = /*@__PURE__*/ new Matrix4();
const _eyeLeft = /*@__PURE__*/ new Matrix4();
const _projectionMatrix = /*@__PURE__*/ new Matrix4();

class StereoCamera {

	constructor() {

		this.type = 'StereoCamera';

		this.aspect = 1;

		this.eyeSep = 0.064;

		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;

		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;

		this._cache = {
			focus: null,
			fov: null,
			aspect: null,
			near: null,
			far: null,
			zoom: null,
			eyeSep: null
		};

	}

	update( camera ) {

		const cache = this._cache;

		const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
			cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
			cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

		if ( needsUpdate ) {

			cache.focus = camera.focus;
			cache.fov = camera.fov;
			cache.aspect = camera.aspect * this.aspect;
			cache.near = camera.near;
			cache.far = camera.far;
			cache.zoom = camera.zoom;
			cache.eyeSep = this.eyeSep;

			// Off-axis stereoscopic effect based on
			// http://paulbourke.net/stereographics/stereorender/

			_projectionMatrix.copy( camera.projectionMatrix );
			const eyeSepHalf = cache.eyeSep / 2;
			const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
			const ymax = ( cache.near * Math.tan( DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;
			let xmin, xmax;

			// translate xOffset

			_eyeLeft.elements[ 12 ] = - eyeSepHalf;
			_eyeRight.elements[ 12 ] = eyeSepHalf;

			// for left eye

			xmin = - ymax * cache.aspect + eyeSepOnProjection;
			xmax = ymax * cache.aspect + eyeSepOnProjection;

			_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraL.projectionMatrix.copy( _projectionMatrix );

			// for right eye

			xmin = - ymax * cache.aspect - eyeSepOnProjection;
			xmax = ymax * cache.aspect - eyeSepOnProjection;

			_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraR.projectionMatrix.copy( _projectionMatrix );

		}

		this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );
		this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );

	}

}

class Clock {

	constructor( autoStart = true ) {

		this.autoStart = autoStart;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	}

	start() {

		this.startTime = now();

		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;

	}

	stop() {

		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;

	}

	getElapsedTime() {

		this.getDelta();
		return this.elapsedTime;

	}

	getDelta() {

		let diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();
			return 0;

		}

		if ( this.running ) {

			const newTime = now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

}

function now() {

	return ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

}

const _position$1 = /*@__PURE__*/ new Vector3();
const _quaternion$1 = /*@__PURE__*/ new Quaternion();
const _scale$1 = /*@__PURE__*/ new Vector3();
const _orientation$1 = /*@__PURE__*/ new Vector3();

class AudioListener extends Object3D {

	constructor() {

		super();

		this.type = 'AudioListener';

		this.context = AudioContext.getContext();

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.filter = null;

		this.timeDelta = 0;

		// private

		this._clock = new Clock();

	}

	getInput() {

		return this.gain;

	}

	removeFilter() {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
			this.gain.connect( this.context.destination );
			this.filter = null;

		}

		return this;

	}

	getFilter() {

		return this.filter;

	}

	setFilter( value ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );

		} else {

			this.gain.disconnect( this.context.destination );

		}

		this.filter = value;
		this.gain.connect( this.filter );
		this.filter.connect( this.context.destination );

		return this;

	}

	getMasterVolume() {

		return this.gain.gain.value;

	}

	setMasterVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		const listener = this.context.listener;
		const up = this.up;

		this.timeDelta = this._clock.getDelta();

		this.matrixWorld.decompose( _position$1, _quaternion$1, _scale$1 );

		_orientation$1.set( 0, 0, - 1 ).applyQuaternion( _quaternion$1 );

		if ( listener.positionX ) {

			// code path for Chrome (see #14393)

			const endTime = this.context.currentTime + this.timeDelta;

			listener.positionX.linearRampToValueAtTime( _position$1.x, endTime );
			listener.positionY.linearRampToValueAtTime( _position$1.y, endTime );
			listener.positionZ.linearRampToValueAtTime( _position$1.z, endTime );
			listener.forwardX.linearRampToValueAtTime( _orientation$1.x, endTime );
			listener.forwardY.linearRampToValueAtTime( _orientation$1.y, endTime );
			listener.forwardZ.linearRampToValueAtTime( _orientation$1.z, endTime );
			listener.upX.linearRampToValueAtTime( up.x, endTime );
			listener.upY.linearRampToValueAtTime( up.y, endTime );
			listener.upZ.linearRampToValueAtTime( up.z, endTime );

		} else {

			listener.setPosition( _position$1.x, _position$1.y, _position$1.z );
			listener.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z );

		}

	}

}

class Audio extends Object3D {

	constructor( listener ) {

		super();

		this.type = 'Audio';

		this.listener = listener;
		this.context = listener.context;

		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );

		this.autoplay = false;

		this.buffer = null;
		this.detune = 0;
		this.loop = false;
		this.loopStart = 0;
		this.loopEnd = 0;
		this.offset = 0;
		this.duration = undefined;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.source = null;
		this.sourceType = 'empty';

		this._startedAt = 0;
		this._progress = 0;
		this._connected = false;

		this.filters = [];

	}

	getOutput() {

		return this.gain;

	}

	setNodeSource( audioNode ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();

		return this;

	}

	setMediaElementSource( mediaElement ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaNode';
		this.source = this.context.createMediaElementSource( mediaElement );
		this.connect();

		return this;

	}

	setMediaStreamSource( mediaStream ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaStreamNode';
		this.source = this.context.createMediaStreamSource( mediaStream );
		this.connect();

		return this;

	}

	setBuffer( audioBuffer ) {

		this.buffer = audioBuffer;
		this.sourceType = 'buffer';

		if ( this.autoplay ) this.play();

		return this;

	}

	play( delay = 0 ) {

		if ( this.isPlaying === true ) {

			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._startedAt = this.context.currentTime + delay;

		const source = this.context.createBufferSource();
		source.buffer = this.buffer;
		source.loop = this.loop;
		source.loopStart = this.loopStart;
		source.loopEnd = this.loopEnd;
		source.onended = this.onEnded.bind( this );
		source.start( this._startedAt, this._progress + this.offset, this.duration );

		this.isPlaying = true;

		this.source = source;

		this.setDetune( this.detune );
		this.setPlaybackRate( this.playbackRate );

		return this.connect();

	}

	pause() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		if ( this.isPlaying === true ) {

			// update current progress

			this._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

			if ( this.loop === true ) {

				// ensure _progress does not exceed duration with looped audios

				this._progress = this._progress % ( this.duration || this.buffer.duration );

			}

			this.source.stop();
			this.source.onended = null;

			this.isPlaying = false;

		}

		return this;

	}

	stop() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._progress = 0;

		if ( this.source !== null ) {

			this.source.stop();
			this.source.onended = null;

		}

		this.isPlaying = false;

		return this;

	}

	connect() {

		if ( this.filters.length > 0 ) {

			this.source.connect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].connect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

		} else {

			this.source.connect( this.getOutput() );

		}

		this._connected = true;

		return this;

	}

	disconnect() {

		if ( this._connected === false ) {

			return;

		}

		if ( this.filters.length > 0 ) {

			this.source.disconnect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

		} else {

			this.source.disconnect( this.getOutput() );

		}

		this._connected = false;

		return this;

	}

	getFilters() {

		return this.filters;

	}

	setFilters( value ) {

		if ( ! value ) value = [];

		if ( this._connected === true ) {

			this.disconnect();
			this.filters = value.slice();
			this.connect();

		} else {

			this.filters = value.slice();

		}

		return this;

	}

	setDetune( value ) {

		this.detune = value;

		if ( this.isPlaying === true && this.source.detune !== undefined ) {

			this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

		}

		return this;

	}

	getDetune() {

		return this.detune;

	}

	getFilter() {

		return this.getFilters()[ 0 ];

	}

	setFilter( filter ) {

		return this.setFilters( filter ? [ filter ] : [] );

	}

	setPlaybackRate( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.playbackRate = value;

		if ( this.isPlaying === true ) {

			this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

		}

		return this;

	}

	getPlaybackRate() {

		return this.playbackRate;

	}

	onEnded() {

		this.isPlaying = false;

	}

	getLoop() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return false;

		}

		return this.loop;

	}

	setLoop( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.loop = value;

		if ( this.isPlaying === true ) {

			this.source.loop = this.loop;

		}

		return this;

	}

	setLoopStart( value ) {

		this.loopStart = value;

		return this;

	}

	setLoopEnd( value ) {

		this.loopEnd = value;

		return this;

	}

	getVolume() {

		return this.gain.gain.value;

	}

	setVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

}

const _position = /*@__PURE__*/ new Vector3();
const _quaternion = /*@__PURE__*/ new Quaternion();
const _scale = /*@__PURE__*/ new Vector3();
const _orientation = /*@__PURE__*/ new Vector3();

class PositionalAudio extends Audio {

	constructor( listener ) {

		super( listener );

		this.panner = this.context.createPanner();
		this.panner.panningModel = 'HRTF';
		this.panner.connect( this.gain );

	}

	connect() {

		super.connect();

		this.panner.connect( this.gain );

	}

	disconnect() {

		super.disconnect();

		this.panner.disconnect( this.gain );

	}

	getOutput() {

		return this.panner;

	}

	getRefDistance() {

		return this.panner.refDistance;

	}

	setRefDistance( value ) {

		this.panner.refDistance = value;

		return this;

	}

	getRolloffFactor() {

		return this.panner.rolloffFactor;

	}

	setRolloffFactor( value ) {

		this.panner.rolloffFactor = value;

		return this;

	}

	getDistanceModel() {

		return this.panner.distanceModel;

	}

	setDistanceModel( value ) {

		this.panner.distanceModel = value;

		return this;

	}

	getMaxDistance() {

		return this.panner.maxDistance;

	}

	setMaxDistance( value ) {

		this.panner.maxDistance = value;

		return this;

	}

	setDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

		this.panner.coneInnerAngle = coneInnerAngle;
		this.panner.coneOuterAngle = coneOuterAngle;
		this.panner.coneOuterGain = coneOuterGain;

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		if ( this.hasPlaybackControl === true && this.isPlaying === false ) return;

		this.matrixWorld.decompose( _position, _quaternion, _scale );

		_orientation.set( 0, 0, 1 ).applyQuaternion( _quaternion );

		const panner = this.panner;

		if ( panner.positionX ) {

			// code path for Chrome and Firefox (see #14393)

			const endTime = this.context.currentTime + this.listener.timeDelta;

			panner.positionX.linearRampToValueAtTime( _position.x, endTime );
			panner.positionY.linearRampToValueAtTime( _position.y, endTime );
			panner.positionZ.linearRampToValueAtTime( _position.z, endTime );
			panner.orientationX.linearRampToValueAtTime( _orientation.x, endTime );
			panner.orientationY.linearRampToValueAtTime( _orientation.y, endTime );
			panner.orientationZ.linearRampToValueAtTime( _orientation.z, endTime );

		} else {

			panner.setPosition( _position.x, _position.y, _position.z );
			panner.setOrientation( _orientation.x, _orientation.y, _orientation.z );

		}

	}

}

class AudioAnalyser {

	constructor( audio, fftSize = 2048 ) {

		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize;

		this.data = new Uint8Array( this.analyser.frequencyBinCount );

		audio.getOutput().connect( this.analyser );

	}


	getFrequencyData() {

		this.analyser.getByteFrequencyData( this.data );

		return this.data;

	}

	getAverageFrequency() {

		let value = 0;
		const data = this.getFrequencyData();

		for ( let i = 0; i < data.length; i ++ ) {

			value += data[ i ];

		}

		return value / data.length;

	}

}

class PropertyMixer {

	constructor( binding, typeName, valueSize ) {

		this.binding = binding;
		this.valueSize = valueSize;

		let mixFunction,
			mixFunctionAdditive,
			setIdentity;

		// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property
		//
		// 'add' is used for additive cumulative results
		//
		// 'work' is optional and is only present for quaternion types. It is used
		// to store intermediate quaternion multiplication results

		switch ( typeName ) {

			case 'quaternion':
				mixFunction = this._slerp;
				mixFunctionAdditive = this._slerpAdditive;
				setIdentity = this._setAdditiveIdentityQuaternion;

				this.buffer = new Float64Array( valueSize * 6 );
				this._workIndex = 5;
				break;

			case 'string':
			case 'bool':
				mixFunction = this._select;

				// Use the regular mix function and for additive on these types,
				// additive is not relevant for non-numeric types
				mixFunctionAdditive = this._select;

				setIdentity = this._setAdditiveIdentityOther;

				this.buffer = new Array( valueSize * 5 );
				break;

			default:
				mixFunction = this._lerp;
				mixFunctionAdditive = this._lerpAdditive;
				setIdentity = this._setAdditiveIdentityNumeric;

				this.buffer = new Float64Array( valueSize * 5 );

		}

		this._mixBufferRegion = mixFunction;
		this._mixBufferRegionAdditive = mixFunctionAdditive;
		this._setIdentity = setIdentity;
		this._origIndex = 3;
		this._addIndex = 4;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		this.useCount = 0;
		this.referenceCount = 0;

	}

	// accumulate data in the 'incoming' region into 'accu<i>'
	accumulate( accuIndex, weight ) {

		// note: happily accumulating nothing when weight = 0, the caller knows
		// the weight and shouldn't have made the call in the first place

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride;

		let currentWeight = this.cumulativeWeight;

		if ( currentWeight === 0 ) {

			// accuN := incoming * weight

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ offset + i ] = buffer[ i ];

			}

			currentWeight = weight;

		} else {

			// accuN := accuN + incoming * weight

			currentWeight += weight;
			const mix = weight / currentWeight;
			this._mixBufferRegion( buffer, offset, 0, mix, stride );

		}

		this.cumulativeWeight = currentWeight;

	}

	// accumulate data in the 'incoming' region into 'add'
	accumulateAdditive( weight ) {

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = stride * this._addIndex;

		if ( this.cumulativeWeightAdditive === 0 ) {

			// add = identity

			this._setIdentity();

		}

		// add := add + incoming * weight

		this._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );
		this.cumulativeWeightAdditive += weight;

	}

	// apply the state of 'accu<i>' to the binding when accus differ
	apply( accuIndex ) {

		const stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,

			weight = this.cumulativeWeight,
			weightAdditive = this.cumulativeWeightAdditive,

			binding = this.binding;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		if ( weight < 1 ) {

			// accuN := accuN + original * ( 1 - cumulativeWeight )

			const originalValueOffset = stride * this._origIndex;

			this._mixBufferRegion(
				buffer, offset, originalValueOffset, 1 - weight, stride );

		}

		if ( weightAdditive > 0 ) {

			// accuN := accuN + additive accuN

			this._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );

		}

		for ( let i = stride, e = stride + stride; i !== e; ++ i ) {

			if ( buffer[ i ] !== buffer[ i + stride ] ) {

				// value has changed -> update scene graph

				binding.setValue( buffer, offset );
				break;

			}

		}

	}

	// remember the state of the bound property and copy it to both accus
	saveOriginalState() {

		const binding = this.binding;

		const buffer = this.buffer,
			stride = this.valueSize,

			originalValueOffset = stride * this._origIndex;

		binding.getValue( buffer, originalValueOffset );

		// accu[0..1] := orig -- initially detect changes against the original
		for ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {

			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		}

		// Add to identity for additive
		this._setIdentity();

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

	}

	// apply the state previously taken via 'saveOriginalState' to the binding
	restoreOriginalState() {

		const originalValueOffset = this.valueSize * 3;
		this.binding.setValue( this.buffer, originalValueOffset );

	}

	_setAdditiveIdentityNumeric() {

		const startIndex = this._addIndex * this.valueSize;
		const endIndex = startIndex + this.valueSize;

		for ( let i = startIndex; i < endIndex; i ++ ) {

			this.buffer[ i ] = 0;

		}

	}

	_setAdditiveIdentityQuaternion() {

		this._setAdditiveIdentityNumeric();
		this.buffer[ this._addIndex * this.valueSize + 3 ] = 1;

	}

	_setAdditiveIdentityOther() {

		const startIndex = this._origIndex * this.valueSize;
		const targetIndex = this._addIndex * this.valueSize;

		for ( let i = 0; i < this.valueSize; i ++ ) {

			this.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];

		}

	}


	// mix functions

	_select( buffer, dstOffset, srcOffset, t, stride ) {

		if ( t >= 0.5 ) {

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			}

		}

	}

	_slerp( buffer, dstOffset, srcOffset, t ) {

		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

	}

	_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		const workOffset = this._workIndex * stride;

		// Store result in intermediate buffer offset
		Quaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );

		// Slerp to the intermediate result
		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );

	}

	_lerp( buffer, dstOffset, srcOffset, t, stride ) {

		const s = 1 - t;

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		}

	}

	_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;

		}

	}

}

// Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe = /*@__PURE__*/ /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe = /*@__PURE__*/ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe = /*@__PURE__*/ /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

const _trackRe = new RegExp( ''
	+ '^'
	+ _directoryRe
	+ _nodeRe
	+ _objectRe
	+ _propertyRe
	+ '$'
);

const _supportedObjectNames = [ 'material', 'materials', 'bones', 'map' ];

class Composite {

	constructor( targetGroup, path, optionalParsedPath ) {

		const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );

	}

	getValue( array, offset ) {

		this.bind(); // bind all binding

		const firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	}

	setValue( array, offset ) {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	}

	bind() {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	}

	unbind() {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

}

// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
class PropertyBinding {

	constructor( rootNode, path, parsedPath ) {

		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName );

		this.rootNode = rootNode;

		// initial state of these methods that calls 'bind'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}


	static create( root, path, parsedPath ) {

		if ( ! ( root && root.isAnimationObjectGroup ) ) {

			return new PropertyBinding( root, path, parsedPath );

		} else {

			return new PropertyBinding.Composite( root, path, parsedPath );

		}

	}

	/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */
	static sanitizeNodeName( name ) {

		return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

	}

	static parseTrackName( trackName ) {

		const matches = _trackRe.exec( trackName );

		if ( matches === null ) {

			throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

		}

		const results = {
			// directoryName: matches[ 1 ], // (tschw) currently unused
			nodeName: matches[ 2 ],
			objectName: matches[ 3 ],
			objectIndex: matches[ 4 ],
			propertyName: matches[ 5 ], // required
			propertyIndex: matches[ 6 ]
		};

		const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

		if ( lastDot !== undefined && lastDot !== - 1 ) {

			const objectName = results.nodeName.substring( lastDot + 1 );

			// Object names must be checked against an allowlist. Otherwise, there
			// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
			// 'bar' could be the objectName, or part of a nodeName (which can
			// include '.' characters).
			if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

				results.nodeName = results.nodeName.substring( 0, lastDot );
				results.objectName = objectName;

			}

		}

		if ( results.propertyName === null || results.propertyName.length === 0 ) {

			throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

		}

		return results;

	}

	static findNode( root, nodeName ) {

		if ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

			return root;

		}

		// search into skeleton bones.
		if ( root.skeleton ) {

			const bone = root.skeleton.getBoneByName( nodeName );

			if ( bone !== undefined ) {

				return bone;

			}

		}

		// search into node subtree.
		if ( root.children ) {

			const searchNodeSubtree = function ( children ) {

				for ( let i = 0; i < children.length; i ++ ) {

					const childNode = children[ i ];

					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

						return childNode;

					}

					const result = searchNodeSubtree( childNode.children );

					if ( result ) return result;

				}

				return null;

			};

			const subTreeNode = searchNodeSubtree( root.children );

			if ( subTreeNode ) {

				return subTreeNode;

			}

		}

		return null;

	}

	// these are used to "bind" a nonexistent property
	_getValue_unavailable() {}
	_setValue_unavailable() {}

	// Getters

	_getValue_direct( buffer, offset ) {

		buffer[ offset ] = this.targetObject[ this.propertyName ];

	}

	_getValue_array( buffer, offset ) {

		const source = this.resolvedProperty;

		for ( let i = 0, n = source.length; i !== n; ++ i ) {

			buffer[ offset ++ ] = source[ i ];

		}

	}

	_getValue_arrayElement( buffer, offset ) {

		buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

	}

	_getValue_toArray( buffer, offset ) {

		this.resolvedProperty.toArray( buffer, offset );

	}

	// Direct

	_setValue_direct( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];

	}

	_setValue_direct_setNeedsUpdate( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];
		this.targetObject.needsUpdate = true;

	}

	_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// EntireArray

	_setValue_array( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

	}

	_setValue_array_setNeedsUpdate( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

		this.targetObject.needsUpdate = true;

	}

	_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// ArrayElement

	_setValue_arrayElement( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

	}

	_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		this.targetObject.needsUpdate = true;

	}

	_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// HasToFromArray

	_setValue_fromArray( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );

	}

	_setValue_fromArray_setNeedsUpdate( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );
		this.targetObject.needsUpdate = true;

	}

	_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	_getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

	}

	_setValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	}

	// create getter / setter pair for a property in the scene graph
	bind() {

		let targetObject = this.node;
		const parsedPath = this.parsedPath;

		const objectName = parsedPath.objectName;
		const propertyName = parsedPath.propertyName;
		let propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName );

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

		// ensure there is a value node
		if ( ! targetObject ) {

			console.warn( 'THREE.PropertyBinding: No target node found for track: ' + this.path + '.' );
			return;

		}

		if ( objectName ) {

			let objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.materials ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if ( ! targetObject.skeleton ) {

						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( let i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[ i ].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				case 'map':

					if ( 'map' in targetObject ) {

						targetObject = targetObject.map;
						break;

					}

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.map ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this );
						return;

					}

					targetObject = targetObject.material.map;
					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {

				if ( targetObject[ objectIndex ] === undefined ) {

					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		const nodeProperty = targetObject[ propertyName ];

		if ( nodeProperty === undefined ) {

			const nodeName = parsedPath.nodeName;

			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
				'.' + propertyName + ' but it wasn\'t found.', targetObject );
			return;

		}

		// determine versioning scheme
		let versioning = this.Versioning.None;

		this.targetObject = targetObject;

		if ( targetObject.needsUpdate !== undefined ) { // material

			versioning = this.Versioning.NeedsUpdate;

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;

		}

		// determine how the property gets bound
		let bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {

			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === 'morphTargetInfluences' ) {

				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
					return;

				}

				if ( ! targetObject.geometry.morphAttributes ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
					return;

				}

				if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

					propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( Array.isArray( nodeProperty ) ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	}

	unbind() {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

}

PropertyBinding.Composite = Composite;

PropertyBinding.prototype.BindingType = {
	Direct: 0,
	EntireArray: 1,
	ArrayElement: 2,
	HasFromToArray: 3
};

PropertyBinding.prototype.Versioning = {
	None: 0,
	NeedsUpdate: 1,
	MatrixWorldNeedsUpdate: 2
};

PropertyBinding.prototype.GetterByBindingType = [

	PropertyBinding.prototype._getValue_direct,
	PropertyBinding.prototype._getValue_array,
	PropertyBinding.prototype._getValue_arrayElement,
	PropertyBinding.prototype._getValue_toArray,

];

PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [

	[
		// Direct
		PropertyBinding.prototype._setValue_direct,
		PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
		PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,

	], [

		// EntireArray

		PropertyBinding.prototype._setValue_array,
		PropertyBinding.prototype._setValue_array_setNeedsUpdate,
		PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,

	], [

		// ArrayElement
		PropertyBinding.prototype._setValue_arrayElement,
		PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
		PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,

	], [

		// HasToFromArray
		PropertyBinding.prototype._setValue_fromArray,
		PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
		PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,

	]

];

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */

class AnimationObjectGroup {

	constructor() {

		this.isAnimationObjectGroup = true;

		this.uuid = generateUUID();

		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );

		this.nCachedObjects_ = 0; // threshold
		// note: read by PropertyBinding.Composite

		const indices = {};
		this._indicesByUUID = indices; // for bookkeeping

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			indices[ arguments[ i ].uuid ] = i;

		}

		this._paths = []; // inside: string
		this._parsedPaths = []; // inside: { we don't care, here }
		this._bindings = []; // inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; // inside: indices in these arrays

		const scope = this;

		this.stats = {

			objects: {
				get total() {

					return scope._objects.length;

				},
				get inUse() {

					return this.total - scope.nCachedObjects_;

				}
			},
			get bindingsPerObject() {

				return scope._bindings.length;

			}

		};

	}

	add() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			paths = this._paths,
			parsedPaths = this._parsedPaths,
			bindings = this._bindings,
			nBindings = bindings.length;

		let knownObject = undefined,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid;
			let index = indicesByUUID[ uuid ];

			if ( index === undefined ) {

				// unknown object -> add it to the ACTIVE region

				index = nObjects ++;
				indicesByUUID[ uuid ] = index;
				objects.push( object );

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

				}

			} else if ( index < nCachedObjects ) {

				knownObject = objects[ index ];

				// move existing object to the ACTIVE region

				const firstActiveIndex = -- nCachedObjects,
					lastCachedObject = objects[ firstActiveIndex ];

				indicesByUUID[ lastCachedObject.uuid ] = index;
				objects[ index ] = lastCachedObject;

				indicesByUUID[ uuid ] = firstActiveIndex;
				objects[ firstActiveIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						lastCached = bindingsForPath[ firstActiveIndex ];

					let binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = lastCached;

					if ( binding === undefined ) {

						// since we do not bother to create new bindings
						// for objects that are cached, the binding may
						// or may not exist

						binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

					}

					bindingsForPath[ firstActiveIndex ] = binding;

				}

			} else if ( objects[ index ] !== knownObject ) {

				console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
					'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

			} // else the object is already where we want it to be

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	remove() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined && index >= nCachedObjects ) {

				// move existing object into the CACHED region

				const lastCachedIndex = nCachedObjects ++,
					firstActiveObject = objects[ lastCachedIndex ];

				indicesByUUID[ firstActiveObject.uuid ] = index;
				objects[ index ] = firstActiveObject;

				indicesByUUID[ uuid ] = lastCachedIndex;
				objects[ lastCachedIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						firstActive = bindingsForPath[ lastCachedIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = firstActive;
					bindingsForPath[ lastCachedIndex ] = binding;

				}

			}

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	// remove & forget
	uncache() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_,
			nObjects = objects.length;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined ) {

				delete indicesByUUID[ uuid ];

				if ( index < nCachedObjects ) {

					// object is cached, shrink the CACHED region

					const firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ],
						lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					// last cached object takes this object's place
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					// last object goes to the activated slot and pop
					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							last = bindingsForPath[ lastIndex ];

						bindingsForPath[ index ] = lastCached;
						bindingsForPath[ firstActiveIndex ] = last;
						bindingsForPath.pop();

					}

				} else {

					// object is active, just swap with the last and pop

					const lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					if ( lastIndex > 0 ) {

						indicesByUUID[ lastObject.uuid ] = index;

					}

					objects[ index ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ];

						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
						bindingsForPath.pop();

					}

				} // cached or active

			} // if object is known

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	// Internal interface used by befriended PropertyBinding.Composite:

	subscribe_( path, parsedPath ) {

		// returns an array of bindings for the given path that is changed
		// according to the contained objects in the group

		const indicesByPath = this._bindingsIndicesByPath;
		let index = indicesByPath[ path ];
		const bindings = this._bindings;

		if ( index !== undefined ) return bindings[ index ];

		const paths = this._paths,
			parsedPaths = this._parsedPaths,
			objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			bindingsForPath = new Array( nObjects );

		index = bindings.length;

		indicesByPath[ path ] = index;

		paths.push( path );
		parsedPaths.push( parsedPath );
		bindings.push( bindingsForPath );

		for ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

			const object = objects[ i ];
			bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

		}

		return bindingsForPath;

	}

	unsubscribe_( path ) {

		// tells the group to forget about a property path and no longer
		// update the array previously obtained with 'subscribe_'

		const indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ];

		if ( index !== undefined ) {

			const paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				lastBindingsIndex = bindings.length - 1,
				lastBindings = bindings[ lastBindingsIndex ],
				lastBindingsPath = path[ lastBindingsIndex ];

			indicesByPath[ lastBindingsPath ] = index;

			bindings[ index ] = lastBindings;
			bindings.pop();

			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
			parsedPaths.pop();

			paths[ index ] = paths[ lastBindingsIndex ];
			paths.pop();

		}

	}

}

class AnimationAction {

	constructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {

		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot;
		this.blendMode = blendMode;

		const tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );

		const interpolantSettings = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};

		for ( let i = 0; i !== nTracks; ++ i ) {

			const interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings;

		}

		this._interpolantSettings = interpolantSettings;

		this._interpolants = interpolants; // bound by the mixer

		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );

		this._cacheIndex = null; // for the memory manager
		this._byClipCacheIndex = null; // for the memory manager

		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;

		this.loop = LoopRepeat;
		this._loopCount = - 1;

		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;

		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;

		this.timeScale = 1;
		this._effectiveTimeScale = 1;

		this.weight = 1;
		this._effectiveWeight = 1;

		this.repetitions = Infinity; // no. of repetitions when looping

		this.paused = false; // true -> zero effective time scale
		this.enabled = true; // false -> zero effective weight

		this.clampWhenFinished = false;// keep feeding the last frame?

		this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd = true;// clips for start, loop and end

	}

	// State & Scheduling

	play() {

		this._mixer._activateAction( this );

		return this;

	}

	stop() {

		this._mixer._deactivateAction( this );

		return this.reset();

	}

	reset() {

		this.paused = false;
		this.enabled = true;

		this.time = 0; // restart clip
		this._loopCount = - 1;// forget previous loops
		this._startTime = null;// forget scheduling

		return this.stopFading().stopWarping();

	}

	isRunning() {

		return this.enabled && ! this.paused && this.timeScale !== 0 &&
			this._startTime === null && this._mixer._isActiveAction( this );

	}

	// return true when play has been called
	isScheduled() {

		return this._mixer._isActiveAction( this );

	}

	startAt( time ) {

		this._startTime = time;

		return this;

	}

	setLoop( mode, repetitions ) {

		this.loop = mode;
		this.repetitions = repetitions;

		return this;

	}

	// Weight

	// set the weight stopping any scheduled fading
	// although .enabled = false yields an effective weight of zero, this
	// method does *not* change .enabled, because it would be confusing
	setEffectiveWeight( weight ) {

		this.weight = weight;

		// note: same logic as when updated at runtime
		this._effectiveWeight = this.enabled ? weight : 0;

		return this.stopFading();

	}

	// return the weight considering fading and .enabled
	getEffectiveWeight() {

		return this._effectiveWeight;

	}

	fadeIn( duration ) {

		return this._scheduleFading( duration, 0, 1 );

	}

	fadeOut( duration ) {

		return this._scheduleFading( duration, 1, 0 );

	}

	crossFadeFrom( fadeOutAction, duration, warp ) {

		fadeOutAction.fadeOut( duration );
		this.fadeIn( duration );

		if ( warp ) {

			const fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration,

				startEndRatio = fadeOutDuration / fadeInDuration,
				endStartRatio = fadeInDuration / fadeOutDuration;

			fadeOutAction.warp( 1.0, startEndRatio, duration );
			this.warp( endStartRatio, 1.0, duration );

		}

		return this;

	}

	crossFadeTo( fadeInAction, duration, warp ) {

		return fadeInAction.crossFadeFrom( this, duration, warp );

	}

	stopFading() {

		const weightInterpolant = this._weightInterpolant;

		if ( weightInterpolant !== null ) {

			this._weightInterpolant = null;
			this._mixer._takeBackControlInterpolant( weightInterpolant );

		}

		return this;

	}

	// Time Scale Control

	// set the time scale stopping any scheduled warping
	// although .paused = true yields an effective time scale of zero, this
	// method does *not* change .paused, because it would be confusing
	setEffectiveTimeScale( timeScale ) {

		this.timeScale = timeScale;
		this._effectiveTimeScale = this.paused ? 0 : timeScale;

		return this.stopWarping();

	}

	// return the time scale considering warping and .paused
	getEffectiveTimeScale() {

		return this._effectiveTimeScale;

	}

	setDuration( duration ) {

		this.timeScale = this._clip.duration / duration;

		return this.stopWarping();

	}

	syncWith( action ) {

		this.time = action.time;
		this.timeScale = action.timeScale;

		return this.stopWarping();

	}

	halt( duration ) {

		return this.warp( this._effectiveTimeScale, 0, duration );

	}

	warp( startTimeScale, endTimeScale, duration ) {

		const mixer = this._mixer,
			now = mixer.time,
			timeScale = this.timeScale;

		let interpolant = this._timeScaleInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._timeScaleInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		times[ 1 ] = now + duration;

		values[ 0 ] = startTimeScale / timeScale;
		values[ 1 ] = endTimeScale / timeScale;

		return this;

	}

	stopWarping() {

		const timeScaleInterpolant = this._timeScaleInterpolant;

		if ( timeScaleInterpolant !== null ) {

			this._timeScaleInterpolant = null;
			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

		}

		return this;

	}

	// Object Accessors

	getMixer() {

		return this._mixer;

	}

	getClip() {

		return this._clip;

	}

	getRoot() {

		return this._localRoot || this._mixer._root;

	}

	// Interna

	_update( time, deltaTime, timeDirection, accuIndex ) {

		// called by the mixer

		if ( ! this.enabled ) {

			// call ._updateWeight() to update ._effectiveWeight

			this._updateWeight( time );
			return;

		}

		const startTime = this._startTime;

		if ( startTime !== null ) {

			// check for scheduled start of action

			const timeRunning = ( time - startTime ) * timeDirection;
			if ( timeRunning < 0 || timeDirection === 0 ) {

				deltaTime = 0;

			} else {


				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;

			}

		}

		// apply time scale and advance time

		deltaTime *= this._updateTimeScale( time );
		const clipTime = this._updateTime( deltaTime );

		// note: _updateTime may disable the action resulting in
		// an effective weight of 0

		const weight = this._updateWeight( time );

		if ( weight > 0 ) {

			const interpolants = this._interpolants;
			const propertyMixers = this._propertyBindings;

			switch ( this.blendMode ) {

				case AdditiveAnimationBlendMode:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulateAdditive( weight );

					}

					break;

				case NormalAnimationBlendMode:
				default:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulate( accuIndex, weight );

					}

			}

		}

	}

	_updateWeight( time ) {

		let weight = 0;

		if ( this.enabled ) {

			weight = this.weight;
			const interpolant = this._weightInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				weight *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopFading();

					if ( interpolantValue === 0 ) {

						// faded out, disable
						this.enabled = false;

					}

				}

			}

		}

		this._effectiveWeight = weight;
		return weight;

	}

	_updateTimeScale( time ) {

		let timeScale = 0;

		if ( ! this.paused ) {

			timeScale = this.timeScale;

			const interpolant = this._timeScaleInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				timeScale *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopWarping();

					if ( timeScale === 0 ) {

						// motion has halted, pause
						this.paused = true;

					} else {

						// warp done - apply final time scale
						this.timeScale = timeScale;

					}

				}

			}

		}

		this._effectiveTimeScale = timeScale;
		return timeScale;

	}

	_updateTime( deltaTime ) {

		const duration = this._clip.duration;
		const loop = this.loop;

		let time = this.time + deltaTime;
		let loopCount = this._loopCount;

		const pingPong = ( loop === LoopPingPong );

		if ( deltaTime === 0 ) {

			if ( loopCount === - 1 ) return time;

			return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

		}

		if ( loop === LoopOnce ) {

			if ( loopCount === - 1 ) {

				// just started

				this._loopCount = 0;
				this._setEndings( true, true, false );

			}

			handle_stop: {

				if ( time >= duration ) {

					time = duration;

				} else if ( time < 0 ) {

					time = 0;

				} else {

					this.time = time;

					break handle_stop;

				}

				if ( this.clampWhenFinished ) this.paused = true;
				else this.enabled = false;

				this.time = time;

				this._mixer.dispatchEvent( {
					type: 'finished', action: this,
					direction: deltaTime < 0 ? - 1 : 1
				} );

			}

		} else { // repetitive Repeat or PingPong

			if ( loopCount === - 1 ) {

				// just started

				if ( deltaTime >= 0 ) {

					loopCount = 0;

					this._setEndings( true, this.repetitions === 0, pingPong );

				} else {

					// when looping in reverse direction, the initial
					// transition through zero counts as a repetition,
					// so leave loopCount at -1

					this._setEndings( this.repetitions === 0, true, pingPong );

				}

			}

			if ( time >= duration || time < 0 ) {

				// wrap around

				const loopDelta = Math.floor( time / duration ); // signed
				time -= duration * loopDelta;

				loopCount += Math.abs( loopDelta );

				const pending = this.repetitions - loopCount;

				if ( pending <= 0 ) {

					// have to stop (switch state, clamp time, fire event)

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					time = deltaTime > 0 ? duration : 0;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime > 0 ? 1 : - 1
					} );

				} else {

					// keep running

					if ( pending === 1 ) {

						// entering the last round

						const atStart = deltaTime < 0;
						this._setEndings( atStart, ! atStart, pingPong );

					} else {

						this._setEndings( false, false, pingPong );

					}

					this._loopCount = loopCount;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'loop', action: this, loopDelta: loopDelta
					} );

				}

			} else {

				this.time = time;

			}

			if ( pingPong && ( loopCount & 1 ) === 1 ) {

				// invert time for the "pong round"

				return duration - time;

			}

		}

		return time;

	}

	_setEndings( atStart, atEnd, pingPong ) {

		const settings = this._interpolantSettings;

		if ( pingPong ) {

			settings.endingStart = ZeroSlopeEnding;
			settings.endingEnd = ZeroSlopeEnding;

		} else {

			// assuming for LoopOnce atStart == atEnd == true

			if ( atStart ) {

				settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingStart = WrapAroundEnding;

			}

			if ( atEnd ) {

				settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingEnd 	 = WrapAroundEnding;

			}

		}

	}

	_scheduleFading( duration, weightNow, weightThen ) {

		const mixer = this._mixer, now = mixer.time;
		let interpolant = this._weightInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._weightInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		values[ 0 ] = weightNow;
		times[ 1 ] = now + duration;
		values[ 1 ] = weightThen;

		return this;

	}

}

const _controlInterpolantsResultBuffer = new Float32Array( 1 );


class AnimationMixer extends EventDispatcher {

	constructor( root ) {

		super();

		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;
		this.time = 0;
		this.timeScale = 1.0;

	}

	_bindAction( action, prototypeAction ) {

		const root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName;

		let bindingsByName = bindingsByRoot[ rootUuid ];

		if ( bindingsByName === undefined ) {

			bindingsByName = {};
			bindingsByRoot[ rootUuid ] = bindingsByName;

		}

		for ( let i = 0; i !== nTracks; ++ i ) {

			const track = tracks[ i ],
				trackName = track.name;

			let binding = bindingsByName[ trackName ];

			if ( binding !== undefined ) {

				++ binding.referenceCount;
				bindings[ i ] = binding;

			} else {

				binding = bindings[ i ];

				if ( binding !== undefined ) {

					// existing binding, make sure the cache knows

					if ( binding._cacheIndex === null ) {

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

					}

					continue;

				}

				const path = prototypeAction && prototypeAction.
					_propertyBindings[ i ].binding.parsedPath;

				binding = new PropertyMixer(
					PropertyBinding.create( root, trackName, path ),
					track.ValueTypeName, track.getValueSize() );

				++ binding.referenceCount;
				this._addInactiveBinding( binding, rootUuid, trackName );

				bindings[ i ] = binding;

			}

			interpolants[ i ].resultBuffer = binding.buffer;

		}

	}

	_activateAction( action ) {

		if ( ! this._isActiveAction( action ) ) {

			if ( action._cacheIndex === null ) {

				// this action has been forgotten by the cache, but the user
				// appears to be still using it -> rebind

				const rootUuid = ( action._localRoot || this._root ).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[ clipUuid ];

				this._bindAction( action,
					actionsForClip && actionsForClip.knownActions[ 0 ] );

				this._addInactiveAction( action, clipUuid, rootUuid );

			}

			const bindings = action._propertyBindings;

			// increment reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( binding.useCount ++ === 0 ) {

					this._lendBinding( binding );
					binding.saveOriginalState();

				}

			}

			this._lendAction( action );

		}

	}

	_deactivateAction( action ) {

		if ( this._isActiveAction( action ) ) {

			const bindings = action._propertyBindings;

			// decrement reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( -- binding.useCount === 0 ) {

					binding.restoreOriginalState();
					this._takeBackBinding( binding );

				}

			}

			this._takeBackAction( action );

		}

	}

	// Memory manager

	_initMemoryManager() {

		this._actions = []; // 'nActiveActions' followed by inactive ones
		this._nActiveActions = 0;

		this._actionsByClip = {};
		// inside:
		// {
		// 	knownActions: Array< AnimationAction > - used as prototypes
		// 	actionByRoot: AnimationAction - lookup
		// }


		this._bindings = []; // 'nActiveBindings' followed by inactive ones
		this._nActiveBindings = 0;

		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		this._controlInterpolants = []; // same game as above
		this._nActiveControlInterpolants = 0;

		const scope = this;

		this.stats = {

			actions: {
				get total() {

					return scope._actions.length;

				},
				get inUse() {

					return scope._nActiveActions;

				}
			},
			bindings: {
				get total() {

					return scope._bindings.length;

				},
				get inUse() {

					return scope._nActiveBindings;

				}
			},
			controlInterpolants: {
				get total() {

					return scope._controlInterpolants.length;

				},
				get inUse() {

					return scope._nActiveControlInterpolants;

				}
			}

		};

	}

	// Memory management for AnimationAction objects

	_isActiveAction( action ) {

		const index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;

	}

	_addInactiveAction( action, clipUuid, rootUuid ) {

		const actions = this._actions,
			actionsByClip = this._actionsByClip;

		let actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip === undefined ) {

			actionsForClip = {

				knownActions: [ action ],
				actionByRoot: {}

			};

			action._byClipCacheIndex = 0;

			actionsByClip[ clipUuid ] = actionsForClip;

		} else {

			const knownActions = actionsForClip.knownActions;

			action._byClipCacheIndex = knownActions.length;
			knownActions.push( action );

		}

		action._cacheIndex = actions.length;
		actions.push( action );

		actionsForClip.actionByRoot[ rootUuid ] = action;

	}

	_removeInactiveAction( action ) {

		const actions = this._actions,
			lastInactiveAction = actions[ actions.length - 1 ],
			cacheIndex = action._cacheIndex;

		lastInactiveAction._cacheIndex = cacheIndex;
		actions[ cacheIndex ] = lastInactiveAction;
		actions.pop();

		action._cacheIndex = null;


		const clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ],
			knownActionsForClip = actionsForClip.knownActions,

			lastKnownAction =
				knownActionsForClip[ knownActionsForClip.length - 1 ],

			byClipCacheIndex = action._byClipCacheIndex;

		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		knownActionsForClip.pop();

		action._byClipCacheIndex = null;


		const actionByRoot = actionsForClip.actionByRoot,
			rootUuid = ( action._localRoot || this._root ).uuid;

		delete actionByRoot[ rootUuid ];

		if ( knownActionsForClip.length === 0 ) {

			delete actionsByClip[ clipUuid ];

		}

		this._removeInactiveBindingsForAction( action );

	}

	_removeInactiveBindingsForAction( action ) {

		const bindings = action._propertyBindings;

		for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

			const binding = bindings[ i ];

			if ( -- binding.referenceCount === 0 ) {

				this._removeInactiveBinding( binding );

			}

		}

	}

	_lendAction( action ) {

		// [ active actions |  inactive actions  ]
		// [  active actions >| inactive actions ]
		//                 s        a
		//                  <-swap->
		//                 a        s

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			lastActiveIndex = this._nActiveActions ++,

			firstInactiveAction = actions[ lastActiveIndex ];

		action._cacheIndex = lastActiveIndex;
		actions[ lastActiveIndex ] = action;

		firstInactiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = firstInactiveAction;

	}

	_takeBackAction( action ) {

		// [  active actions  | inactive actions ]
		// [ active actions |< inactive actions  ]
		//        a        s
		//         <-swap->
		//        s        a

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			firstInactiveIndex = -- this._nActiveActions,

			lastActiveAction = actions[ firstInactiveIndex ];

		action._cacheIndex = firstInactiveIndex;
		actions[ firstInactiveIndex ] = action;

		lastActiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = lastActiveAction;

	}

	// Memory management for PropertyMixer objects

	_addInactiveBinding( binding, rootUuid, trackName ) {

		const bindingsByRoot = this._bindingsByRootAndName,
			bindings = this._bindings;

		let bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName === undefined ) {

			bindingByName = {};
			bindingsByRoot[ rootUuid ] = bindingByName;

		}

		bindingByName[ trackName ] = binding;

		binding._cacheIndex = bindings.length;
		bindings.push( binding );

	}

	_removeInactiveBinding( binding ) {

		const bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			lastInactiveBinding = bindings[ bindings.length - 1 ],
			cacheIndex = binding._cacheIndex;

		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[ cacheIndex ] = lastInactiveBinding;
		bindings.pop();

		delete bindingByName[ trackName ];

		if ( Object.keys( bindingByName ).length === 0 ) {

			delete bindingsByRoot[ rootUuid ];

		}

	}

	_lendBinding( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			lastActiveIndex = this._nActiveBindings ++,

			firstInactiveBinding = bindings[ lastActiveIndex ];

		binding._cacheIndex = lastActiveIndex;
		bindings[ lastActiveIndex ] = binding;

		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = firstInactiveBinding;

	}

	_takeBackBinding( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			firstInactiveIndex = -- this._nActiveBindings,

			lastActiveBinding = bindings[ firstInactiveIndex ];

		binding._cacheIndex = firstInactiveIndex;
		bindings[ firstInactiveIndex ] = binding;

		lastActiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = lastActiveBinding;

	}


	// Memory management of Interpolants for weight and time scale

	_lendControlInterpolant() {

		const interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants ++;

		let interpolant = interpolants[ lastActiveIndex ];

		if ( interpolant === undefined ) {

			interpolant = new LinearInterpolant(
				new Float32Array( 2 ), new Float32Array( 2 ),
				1, _controlInterpolantsResultBuffer );

			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[ lastActiveIndex ] = interpolant;

		}

		return interpolant;

	}

	_takeBackControlInterpolant( interpolant ) {

		const interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,

			firstInactiveIndex = -- this._nActiveControlInterpolants,

			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[ firstInactiveIndex ] = interpolant;

		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[ prevIndex ] = lastActiveInterpolant;

	}

	// return an action for a clip optionally using a custom root target
	// object (this method allocates a lot of dynamic memory in case a
	// previously unknown clip/root combination is specified)
	clipAction( clip, optionalRoot, blendMode ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid;

		let clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;

		const clipUuid = clipObject !== null ? clipObject.uuid : clip;

		const actionsForClip = this._actionsByClip[ clipUuid ];
		let prototypeAction = null;

		if ( blendMode === undefined ) {

			if ( clipObject !== null ) {

				blendMode = clipObject.blendMode;

			} else {

				blendMode = NormalAnimationBlendMode;

			}

		}

		if ( actionsForClip !== undefined ) {

			const existingAction = actionsForClip.actionByRoot[ rootUuid ];

			if ( existingAction !== undefined && existingAction.blendMode === blendMode ) {

				return existingAction;

			}

			// we know the clip, so we don't have to parse all
			// the bindings again but can just copy
			prototypeAction = actionsForClip.knownActions[ 0 ];

			// also, take the clip from the prototype action
			if ( clipObject === null )
				clipObject = prototypeAction._clip;

		}

		// clip must be known when specified via string
		if ( clipObject === null ) return null;

		// allocate all resources required to run it
		const newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );

		this._bindAction( newAction, prototypeAction );

		// and make the action known to the memory manager
		this._addInactiveAction( newAction, clipUuid, rootUuid );

		return newAction;

	}

	// get an existing action
	existingAction( clip, optionalRoot ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
				AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			return actionsForClip.actionByRoot[ rootUuid ] || null;

		}

		return null;

	}

	// deactivates all previously scheduled actions
	stopAllAction() {

		const actions = this._actions,
			nActions = this._nActiveActions;

		for ( let i = nActions - 1; i >= 0; -- i ) {

			actions[ i ].stop();

		}

		return this;

	}

	// advance the time and update apply the animation
	update( deltaTime ) {

		deltaTime *= this.timeScale;

		const actions = this._actions,
			nActions = this._nActiveActions,

			time = this.time += deltaTime,
			timeDirection = Math.sign( deltaTime ),

			accuIndex = this._accuIndex ^= 1;

		// run active actions

		for ( let i = 0; i !== nActions; ++ i ) {

			const action = actions[ i ];

			action._update( time, deltaTime, timeDirection, accuIndex );

		}

		// update scene graph

		const bindings = this._bindings,
			nBindings = this._nActiveBindings;

		for ( let i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].apply( accuIndex );

		}

		return this;

	}

	// Allows you to seek to a specific time in an animation.
	setTime( timeInSeconds ) {

		this.time = 0; // Zero out time attribute for AnimationMixer object;
		for ( let i = 0; i < this._actions.length; i ++ ) {

			this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

		}

		return this.update( timeInSeconds ); // Update used to set exact time. Returns "this" AnimationMixer object.

	}

	// return this mixer's root target object
	getRoot() {

		return this._root;

	}

	// free all resources specific to a particular clip
	uncacheClip( clip ) {

		const actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			// note: just calling _removeInactiveAction would mess up the
			// iteration state and also require updating the state we can
			// just throw away

			const actionsToRemove = actionsForClip.knownActions;

			for ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				const action = actionsToRemove[ i ];

				this._deactivateAction( action );

				const cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[ actions.length - 1 ];

				action._cacheIndex = null;
				action._byClipCacheIndex = null;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				this._removeInactiveBindingsForAction( action );

			}

			delete actionsByClip[ clipUuid ];

		}

	}

	// free all resources specific to a particular root target object
	uncacheRoot( root ) {

		const rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;

		for ( const clipUuid in actionsByClip ) {

			const actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				action = actionByRoot[ rootUuid ];

			if ( action !== undefined ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

		const bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName !== undefined ) {

			for ( const trackName in bindingByName ) {

				const binding = bindingByName[ trackName ];
				binding.restoreOriginalState();
				this._removeInactiveBinding( binding );

			}

		}

	}

	// remove a targeted clip from the cache
	uncacheAction( clip, optionalRoot ) {

		const action = this.existingAction( clip, optionalRoot );

		if ( action !== null ) {

			this._deactivateAction( action );
			this._removeInactiveAction( action );

		}

	}

}

class Uniform {

	constructor( value ) {

		this.value = value;

	}

	clone() {

		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

	}

}

let _id = 0;

class UniformsGroup extends EventDispatcher {

	constructor() {

		super();

		this.isUniformsGroup = true;

		Object.defineProperty( this, 'id', { value: _id ++ } );

		this.name = '';

		this.usage = StaticDrawUsage;
		this.uniforms = [];

	}

	add( uniform ) {

		this.uniforms.push( uniform );

		return this;

	}

	remove( uniform ) {

		const index = this.uniforms.indexOf( uniform );

		if ( index !== - 1 ) this.uniforms.splice( index, 1 );

		return this;

	}

	setName( name ) {

		this.name = name;

		return this;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

		return this;

	}

	copy( source ) {

		this.name = source.name;
		this.usage = source.usage;

		const uniformsSource = source.uniforms;

		this.uniforms.length = 0;

		for ( let i = 0, l = uniformsSource.length; i < l; i ++ ) {

			const uniforms = Array.isArray( uniformsSource[ i ] ) ? uniformsSource[ i ] : [ uniformsSource[ i ] ];

			for ( let j = 0; j < uniforms.length; j ++ ) {

				this.uniforms.push( uniforms[ j ].clone() );

			}

		}

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

class InstancedInterleavedBuffer extends InterleavedBuffer {

	constructor( array, stride, meshPerAttribute = 1 ) {

		super( array, stride );

		this.isInstancedInterleavedBuffer = true;

		this.meshPerAttribute = meshPerAttribute;

	}

	copy( source ) {

		super.copy( source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

	clone( data ) {

		const ib = super.clone( data );

		ib.meshPerAttribute = this.meshPerAttribute;

		return ib;

	}

	toJSON( data ) {

		const json = super.toJSON( data );

		json.isInstancedInterleavedBuffer = true;
		json.meshPerAttribute = this.meshPerAttribute;

		return json;

	}

}

class GLBufferAttribute {

	constructor( buffer, type, itemSize, elementSize, count ) {

		this.isGLBufferAttribute = true;

		this.name = '';

		this.buffer = buffer;
		this.type = type;
		this.itemSize = itemSize;
		this.elementSize = elementSize;
		this.count = count;

		this.version = 0;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	setBuffer( buffer ) {

		this.buffer = buffer;

		return this;

	}

	setType( type, elementSize ) {

		this.type = type;
		this.elementSize = elementSize;

		return this;

	}

	setItemSize( itemSize ) {

		this.itemSize = itemSize;

		return this;

	}

	setCount( count ) {

		this.count = count;

		return this;

	}

}

const _matrix = /*@__PURE__*/ new Matrix4();

class Raycaster {

	constructor( origin, direction, near = 0, far = Infinity ) {

		this.ray = new Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near;
		this.far = far;
		this.camera = null;
		this.layers = new Layers();

		this.params = {
			Mesh: {},
			Line: { threshold: 1 },
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

	}

	set( origin, direction ) {

		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set( origin, direction );

	}

	setFromCamera( coords, camera ) {

		if ( camera.isPerspectiveCamera ) {

			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
			this.camera = camera;

		} else if ( camera.isOrthographicCamera ) {

			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
			this.camera = camera;

		} else {

			console.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );

		}

	}

	setFromXRController( controller ) {

		_matrix.identity().extractRotation( controller.matrixWorld );

		this.ray.origin.setFromMatrixPosition( controller.matrixWorld );
		this.ray.direction.set( 0, 0, - 1 ).applyMatrix4( _matrix );

		return this;

	}

	intersectObject( object, recursive = true, intersects = [] ) {

		intersect( object, this, intersects, recursive );

		intersects.sort( ascSort );

		return intersects;

	}

	intersectObjects( objects, recursive = true, intersects = [] ) {

		for ( let i = 0, l = objects.length; i < l; i ++ ) {

			intersect( objects[ i ], this, intersects, recursive );

		}

		intersects.sort( ascSort );

		return intersects;

	}

}

function ascSort( a, b ) {

	return a.distance - b.distance;

}

function intersect( object, raycaster, intersects, recursive ) {

	if ( object.layers.test( raycaster.layers ) ) {

		object.raycast( raycaster, intersects );

	}

	if ( recursive === true ) {

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			intersect( children[ i ], raycaster, intersects, true );

		}

	}

}

/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * phi (the polar angle) is measured from the positive y-axis. The positive y-axis is up.
 * theta (the azimuthal angle) is measured from the positive z-axis.
 */
class Spherical {

	constructor( radius = 1, phi = 0, theta = 0 ) {

		this.radius = radius;
		this.phi = phi; // polar angle
		this.theta = theta; // azimuthal angle

		return this;

	}

	set( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

		return this;

	}

	copy( other ) {

		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;

		return this;

	}

	// restrict phi to be between EPS and PI-EPS
	makeSafe() {

		const EPS = 0.000001;
		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + y * y + z * z );

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( x, z );
			this.phi = Math.acos( clamp( y / this.radius, - 1, 1 ) );

		}

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */

class Cylindrical {

	constructor( radius = 1, theta = 0, y = 0 ) {

		this.radius = radius; // distance from the origin to a point in the x-z plane
		this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
		this.y = y; // height above the x-z plane

		return this;

	}

	set( radius, theta, y ) {

		this.radius = radius;
		this.theta = theta;
		this.y = y;

		return this;

	}

	copy( other ) {

		this.radius = other.radius;
		this.theta = other.theta;
		this.y = other.y;

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + z * z );
		this.theta = Math.atan2( x, z );
		this.y = y;

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$4 = /*@__PURE__*/ new Vector2();

class Box2 {

	constructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {

		this.isBox2 = true;

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$4.copy( size ).multiplyScalar( 0.5 );
		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = + Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	}

	getCenter( target ) {

		return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	}

	intersectsBox( box ) {

		// using 4 splitting planes to rule out intersections

		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

	}

	clampPoint( point, target ) {

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		return this.clampPoint( point, _vector$4 ).distanceTo( point );

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

const _startP = /*@__PURE__*/ new Vector3();
const _startEnd = /*@__PURE__*/ new Vector3();

class Line3 {

	constructor( start = new Vector3(), end = new Vector3() ) {

		this.start = start;
		this.end = end;

	}

	set( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	}

	copy( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	}

	getCenter( target ) {

		return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	}

	delta( target ) {

		return target.subVectors( this.end, this.start );

	}

	distanceSq() {

		return this.start.distanceToSquared( this.end );

	}

	distance() {

		return this.start.distanceTo( this.end );

	}

	at( t, target ) {

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	closestPointToPointParameter( point, clampToLine ) {

		_startP.subVectors( point, this.start );
		_startEnd.subVectors( this.end, this.start );

		const startEnd2 = _startEnd.dot( _startEnd );
		const startEnd_startP = _startEnd.dot( _startP );

		let t = startEnd_startP / startEnd2;

		if ( clampToLine ) {

			t = clamp( t, 0, 1 );

		}

		return t;

	}

	closestPointToPoint( point, clampToLine, target ) {

		const t = this.closestPointToPointParameter( point, clampToLine );

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	applyMatrix4( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	}

	equals( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$3 = /*@__PURE__*/ new Vector3();

class SpotLightHelper extends Object3D {

	constructor( light, color ) {

		super();

		this.light = light;

		this.matrixAutoUpdate = false;

		this.color = color;

		this.type = 'SpotLightHelper';

		const geometry = new BufferGeometry();

		const positions = [
			0, 0, 0, 	0, 0, 1,
			0, 0, 0, 	1, 0, 1,
			0, 0, 0,	- 1, 0, 1,
			0, 0, 0, 	0, 1, 1,
			0, 0, 0, 	0, - 1, 1
		];

		for ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

			const p1 = ( i / l ) * Math.PI * 2;
			const p2 = ( j / l ) * Math.PI * 2;

			positions.push(
				Math.cos( p1 ), Math.sin( p1 ), 1,
				Math.cos( p2 ), Math.sin( p2 ), 1
			);

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

		this.cone = new LineSegments( geometry, material );
		this.add( this.cone );

		this.update();

	}

	dispose() {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	}

	update() {

		this.light.updateWorldMatrix( true, false );
		this.light.target.updateWorldMatrix( true, false );

		// update the local matrix based on the parent and light target transforms
		if ( this.parent ) {

			this.parent.updateWorldMatrix( true );

			this.matrix
				.copy( this.parent.matrixWorld )
				.invert()
				.multiply( this.light.matrixWorld );

		} else {

			this.matrix.copy( this.light.matrixWorld );

		}

		this.matrixWorld.copy( this.light.matrixWorld );

		const coneLength = this.light.distance ? this.light.distance : 1000;
		const coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		_vector$3.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( _vector$3 );

		if ( this.color !== undefined ) {

			this.cone.material.color.set( this.color );

		} else {

			this.cone.material.color.copy( this.light.color );

		}

	}

}

const _vector$2 = /*@__PURE__*/ new Vector3();
const _boneMatrix = /*@__PURE__*/ new Matrix4();
const _matrixWorldInv = /*@__PURE__*/ new Matrix4();


class SkeletonHelper extends LineSegments {

	constructor( object ) {

		const bones = getBoneList( object );

		const geometry = new BufferGeometry();

		const vertices = [];
		const colors = [];

		const color1 = new Color( 0, 0, 1 );
		const color2 = new Color( 0, 1, 0 );

		for ( let i = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				vertices.push( 0, 0, 0 );
				vertices.push( 0, 0, 0 );
				colors.push( color1.r, color1.g, color1.b );
				colors.push( color2.r, color2.g, color2.b );

			}

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );

		super( geometry, material );

		this.isSkeletonHelper = true;

		this.type = 'SkeletonHelper';

		this.root = object;
		this.bones = bones;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	}

	updateMatrixWorld( force ) {

		const bones = this.bones;

		const geometry = this.geometry;
		const position = geometry.getAttribute( 'position' );

		_matrixWorldInv.copy( this.root.matrixWorld ).invert();

		for ( let i = 0, j = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );
				_vector$2.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j, _vector$2.x, _vector$2.y, _vector$2.z );

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );
				_vector$2.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j + 1, _vector$2.x, _vector$2.y, _vector$2.z );

				j += 2;

			}

		}

		geometry.getAttribute( 'position' ).needsUpdate = true;

		super.updateMatrixWorld( force );

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}


function getBoneList( object ) {

	const boneList = [];

	if ( object.isBone === true ) {

		boneList.push( object );

	}

	for ( let i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

	}

	return boneList;

}

class PointLightHelper extends Mesh {

	constructor( light, sphereSize, color ) {

		const geometry = new SphereGeometry( sphereSize, 4, 2 );
		const material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );

		super( geometry, material );

		this.light = light;

		this.color = color;

		this.type = 'PointLightHelper';

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();


		/*
	// TODO: delete this comment?
	const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	const d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

	update() {

		this.light.updateWorldMatrix( true, false );

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color );

		}

		/*
		const d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	}

}

const _vector$1 = /*@__PURE__*/ new Vector3();
const _color1 = /*@__PURE__*/ new Color();
const _color2 = /*@__PURE__*/ new Color();

class HemisphereLightHelper extends Object3D {

	constructor( light, size, color ) {

		super();

		this.light = light;

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		this.type = 'HemisphereLightHelper';

		const geometry = new OctahedronGeometry( size );
		geometry.rotateY( Math.PI * 0.5 );

		this.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );
		if ( this.color === undefined ) this.material.vertexColors = true;

		const position = geometry.getAttribute( 'position' );
		const colors = new Float32Array( position.count * 3 );

		geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );

		this.add( new Mesh( geometry, this.material ) );

		this.update();

	}

	dispose() {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	}

	update() {

		const mesh = this.children[ 0 ];

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			const colors = mesh.geometry.getAttribute( 'color' );

			_color1.copy( this.light.color );
			_color2.copy( this.light.groundColor );

			for ( let i = 0, l = colors.count; i < l; i ++ ) {

				const color = ( i < ( l / 2 ) ) ? _color1 : _color2;

				colors.setXYZ( i, color.r, color.g, color.b );

			}

			colors.needsUpdate = true;

		}

		this.light.updateWorldMatrix( true, false );

		mesh.lookAt( _vector$1.setFromMatrixPosition( this.light.matrixWorld ).negate() );

	}

}

class GridHelper extends LineSegments {

	constructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new Color( color1 );
		color2 = new Color( color2 );

		const center = divisions / 2;
		const step = size / divisions;
		const halfSize = size / 2;

		const vertices = [], colors = [];

		for ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

			vertices.push( - halfSize, 0, k, halfSize, 0, k );
			vertices.push( k, 0, - halfSize, k, 0, halfSize );

			const color = i === center ? color1 : color2;

			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;

		}

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'GridHelper';

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

class PolarGridHelper extends LineSegments {

	constructor( radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new Color( color1 );
		color2 = new Color( color2 );

		const vertices = [];
		const colors = [];

		// create the sectors

		if ( sectors > 1 ) {

			for ( let i = 0; i < sectors; i ++ ) {

				const v = ( i / sectors ) * ( Math.PI * 2 );

				const x = Math.sin( v ) * radius;
				const z = Math.cos( v ) * radius;

				vertices.push( 0, 0, 0 );
				vertices.push( x, 0, z );

				const color = ( i & 1 ) ? color1 : color2;

				colors.push( color.r, color.g, color.b );
				colors.push( color.r, color.g, color.b );

			}

		}

		// create the rings

		for ( let i = 0; i < rings; i ++ ) {

			const color = ( i & 1 ) ? color1 : color2;

			const r = radius - ( radius / rings * i );

			for ( let j = 0; j < divisions; j ++ ) {

				// first vertex

				let v = ( j / divisions ) * ( Math.PI * 2 );

				let x = Math.sin( v ) * r;
				let z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

				// second vertex

				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

			}

		}

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'PolarGridHelper';

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

const _v1 = /*@__PURE__*/ new Vector3();
const _v2 = /*@__PURE__*/ new Vector3();
const _v3 = /*@__PURE__*/ new Vector3();

class DirectionalLightHelper extends Object3D {

	constructor( light, size, color ) {

		super();

		this.light = light;

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		this.type = 'DirectionalLightHelper';

		if ( size === undefined ) size = 1;

		let geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( [
			- size, size, 0,
			size, size, 0,
			size, - size, 0,
			- size, - size, 0,
			- size, size, 0
		], 3 ) );

		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

		this.lightPlane = new Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

		this.targetLine = new Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	}

	dispose() {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();

	}

	update() {

		this.light.updateWorldMatrix( true, false );
		this.light.target.updateWorldMatrix( true, false );

		_v1.setFromMatrixPosition( this.light.matrixWorld );
		_v2.setFromMatrixPosition( this.light.target.matrixWorld );
		_v3.subVectors( _v2, _v1 );

		this.lightPlane.lookAt( _v2 );

		if ( this.color !== undefined ) {

			this.lightPlane.material.color.set( this.color );
			this.targetLine.material.color.set( this.color );

		} else {

			this.lightPlane.material.color.copy( this.light.color );
			this.targetLine.material.color.copy( this.light.color );

		}

		this.targetLine.lookAt( _v2 );
		this.targetLine.scale.z = _v3.length();

	}

}

const _vector = /*@__PURE__*/ new Vector3();
const _camera = /*@__PURE__*/ new Camera();

/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		https://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html
 */

class CameraHelper extends LineSegments {

	constructor( camera ) {

		const geometry = new BufferGeometry();
		const material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );

		const vertices = [];
		const colors = [];

		const pointMap = {};

		// near

		addLine( 'n1', 'n2' );
		addLine( 'n2', 'n4' );
		addLine( 'n4', 'n3' );
		addLine( 'n3', 'n1' );

		// far

		addLine( 'f1', 'f2' );
		addLine( 'f2', 'f4' );
		addLine( 'f4', 'f3' );
		addLine( 'f3', 'f1' );

		// sides

		addLine( 'n1', 'f1' );
		addLine( 'n2', 'f2' );
		addLine( 'n3', 'f3' );
		addLine( 'n4', 'f4' );

		// cone

		addLine( 'p', 'n1' );
		addLine( 'p', 'n2' );
		addLine( 'p', 'n3' );
		addLine( 'p', 'n4' );

		// up

		addLine( 'u1', 'u2' );
		addLine( 'u2', 'u3' );
		addLine( 'u3', 'u1' );

		// target

		addLine( 'c', 't' );
		addLine( 'p', 'c' );

		// cross

		addLine( 'cn1', 'cn2' );
		addLine( 'cn3', 'cn4' );

		addLine( 'cf1', 'cf2' );
		addLine( 'cf3', 'cf4' );

		function addLine( a, b ) {

			addPoint( a );
			addPoint( b );

		}

		function addPoint( id ) {

			vertices.push( 0, 0, 0 );
			colors.push( 0, 0, 0 );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		super( geometry, material );

		this.type = 'CameraHelper';

		this.camera = camera;
		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

		// colors

		const colorFrustum = new Color( 0xffaa00 );
		const colorCone = new Color( 0xff0000 );
		const colorUp = new Color( 0x00aaff );
		const colorTarget = new Color( 0xffffff );
		const colorCross = new Color( 0x333333 );

		this.setColors( colorFrustum, colorCone, colorUp, colorTarget, colorCross );

	}

	setColors( frustum, cone, up, target, cross ) {

		const geometry = this.geometry;

		const colorAttribute = geometry.getAttribute( 'color' );

		// near

		colorAttribute.setXYZ( 0, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 1, frustum.r, frustum.g, frustum.b ); // n1, n2
		colorAttribute.setXYZ( 2, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 3, frustum.r, frustum.g, frustum.b ); // n2, n4
		colorAttribute.setXYZ( 4, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 5, frustum.r, frustum.g, frustum.b ); // n4, n3
		colorAttribute.setXYZ( 6, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 7, frustum.r, frustum.g, frustum.b ); // n3, n1

		// far

		colorAttribute.setXYZ( 8, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 9, frustum.r, frustum.g, frustum.b ); // f1, f2
		colorAttribute.setXYZ( 10, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 11, frustum.r, frustum.g, frustum.b ); // f2, f4
		colorAttribute.setXYZ( 12, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 13, frustum.r, frustum.g, frustum.b ); // f4, f3
		colorAttribute.setXYZ( 14, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 15, frustum.r, frustum.g, frustum.b ); // f3, f1

		// sides

		colorAttribute.setXYZ( 16, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 17, frustum.r, frustum.g, frustum.b ); // n1, f1
		colorAttribute.setXYZ( 18, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 19, frustum.r, frustum.g, frustum.b ); // n2, f2
		colorAttribute.setXYZ( 20, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 21, frustum.r, frustum.g, frustum.b ); // n3, f3
		colorAttribute.setXYZ( 22, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 23, frustum.r, frustum.g, frustum.b ); // n4, f4

		// cone

		colorAttribute.setXYZ( 24, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 25, cone.r, cone.g, cone.b ); // p, n1
		colorAttribute.setXYZ( 26, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 27, cone.r, cone.g, cone.b ); // p, n2
		colorAttribute.setXYZ( 28, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 29, cone.r, cone.g, cone.b ); // p, n3
		colorAttribute.setXYZ( 30, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 31, cone.r, cone.g, cone.b ); // p, n4

		// up

		colorAttribute.setXYZ( 32, up.r, up.g, up.b ); colorAttribute.setXYZ( 33, up.r, up.g, up.b ); // u1, u2
		colorAttribute.setXYZ( 34, up.r, up.g, up.b ); colorAttribute.setXYZ( 35, up.r, up.g, up.b ); // u2, u3
		colorAttribute.setXYZ( 36, up.r, up.g, up.b ); colorAttribute.setXYZ( 37, up.r, up.g, up.b ); // u3, u1

		// target

		colorAttribute.setXYZ( 38, target.r, target.g, target.b ); colorAttribute.setXYZ( 39, target.r, target.g, target.b ); // c, t
		colorAttribute.setXYZ( 40, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 41, cross.r, cross.g, cross.b ); // p, c

		// cross

		colorAttribute.setXYZ( 42, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 43, cross.r, cross.g, cross.b ); // cn1, cn2
		colorAttribute.setXYZ( 44, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 45, cross.r, cross.g, cross.b ); // cn3, cn4

		colorAttribute.setXYZ( 46, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 47, cross.r, cross.g, cross.b ); // cf1, cf2
		colorAttribute.setXYZ( 48, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 49, cross.r, cross.g, cross.b ); // cf3, cf4

		colorAttribute.needsUpdate = true;

	}

	update() {

		const geometry = this.geometry;
		const pointMap = this.pointMap;

		const w = 1, h = 1;

		// we need just camera projection matrix inverse
		// world matrix must be identity

		_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );

		// center / target

		setPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );
		setPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );

		// near

		setPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );
		setPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );
		setPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );
		setPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );

		// far

		setPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );
		setPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );
		setPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );
		setPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );

		// up

		setPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );
		setPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );
		setPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );

		// cross

		setPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );
		setPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );
		setPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );
		setPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );

		setPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );
		setPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );
		setPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );
		setPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );

		geometry.getAttribute( 'position' ).needsUpdate = true;

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}


function setPoint( point, pointMap, geometry, camera, x, y, z ) {

	_vector.set( x, y, z ).unproject( camera );

	const points = pointMap[ point ];

	if ( points !== undefined ) {

		const position = geometry.getAttribute( 'position' );

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			position.setXYZ( points[ i ], _vector.x, _vector.y, _vector.z );

		}

	}

}

const _box = /*@__PURE__*/ new Box3();

class BoxHelper extends LineSegments {

	constructor( object, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		const positions = new Float32Array( 8 * 3 );

		const geometry = new BufferGeometry();
		geometry.setIndex( new BufferAttribute( indices, 1 ) );
		geometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.object = object;
		this.type = 'BoxHelper';

		this.matrixAutoUpdate = false;

		this.update();

	}

	update( object ) {

		if ( object !== undefined ) {

			console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

		}

		if ( this.object !== undefined ) {

			_box.setFromObject( this.object );

		}

		if ( _box.isEmpty() ) return;

		const min = _box.min;
		const max = _box.max;

		/*
			5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		const position = this.geometry.attributes.position;
		const array = position.array;

		array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
		array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
		array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
		array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();

	}

	setFromObject( object ) {

		this.object = object;
		this.update();

		return this;

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.object = source.object;

		return this;

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

class Box3Helper extends LineSegments {

	constructor( box, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

		const positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

		const geometry = new BufferGeometry();

		geometry.setIndex( new BufferAttribute( indices, 1 ) );

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.box = box;

		this.type = 'Box3Helper';

		this.geometry.computeBoundingSphere();

	}

	updateMatrixWorld( force ) {

		const box = this.box;

		if ( box.isEmpty() ) return;

		box.getCenter( this.position );

		box.getSize( this.scale );

		this.scale.multiplyScalar( 0.5 );

		super.updateMatrixWorld( force );

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

class PlaneHelper extends Line {

	constructor( plane, size = 1, hex = 0xffff00 ) {

		const color = hex;

		const positions = [ 1, - 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.type = 'PlaneHelper';

		this.plane = plane;

		this.size = size;

		const positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];

		const geometry2 = new BufferGeometry();
		geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );

	}

	updateMatrixWorld( force ) {

		this.position.set( 0, 0, 0 );

		this.scale.set( 0.5 * this.size, 0.5 * this.size, 1 );

		this.lookAt( this.plane.normal );

		this.translateZ( - this.plane.constant );

		super.updateMatrixWorld( force );

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();
		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	}

}

const _axis = /*@__PURE__*/ new Vector3();
let _lineGeometry, _coneGeometry;

class ArrowHelper extends Object3D {

	// dir is assumed to be normalized

	constructor( dir = new Vector3( 0, 0, 1 ), origin = new Vector3( 0, 0, 0 ), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

		super();

		this.type = 'ArrowHelper';

		if ( _lineGeometry === undefined ) {

			_lineGeometry = new BufferGeometry();
			_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

			_coneGeometry = new CylinderGeometry( 0, 0.5, 1, 5, 1 );
			_coneGeometry.translate( 0, - 0.5, 0 );

		}

		this.position.copy( origin );

		this.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

	setDirection( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			_axis.set( dir.z, 0, - dir.x ).normalize();

			const radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( _axis, radians );

		}

	}

	setLength( length, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

		this.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458
		this.line.updateMatrix();

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	}

	setColor( color ) {

		this.line.material.color.set( color );
		this.cone.material.color.set( color );

	}

	copy( source ) {

		super.copy( source, false );

		this.line.copy( source.line );
		this.cone.copy( source.cone );

		return this;

	}

	dispose() {

		this.line.geometry.dispose();
		this.line.material.dispose();
		this.cone.geometry.dispose();
		this.cone.material.dispose();

	}

}

class AxesHelper extends LineSegments {

	constructor( size = 1 ) {

		const vertices = [
			0, 0, 0,	size, 0, 0,
			0, 0, 0,	0, size, 0,
			0, 0, 0,	0, 0, size
		];

		const colors = [
			1, 0, 0,	1, 0.6, 0,
			0, 1, 0,	0.6, 1, 0,
			0, 0, 1,	0, 0.6, 1
		];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'AxesHelper';

	}

	setColors( xAxisColor, yAxisColor, zAxisColor ) {

		const color = new Color();
		const array = this.geometry.attributes.color.array;

		color.set( xAxisColor );
		color.toArray( array, 0 );
		color.toArray( array, 3 );

		color.set( yAxisColor );
		color.toArray( array, 6 );
		color.toArray( array, 9 );

		color.set( zAxisColor );
		color.toArray( array, 12 );
		color.toArray( array, 15 );

		this.geometry.attributes.color.needsUpdate = true;

		return this;

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

class ShapePath {

	constructor() {

		this.type = 'ShapePath';

		this.color = new Color();

		this.subPaths = [];
		this.currentPath = null;

	}

	moveTo( x, y ) {

		this.currentPath = new Path();
		this.subPaths.push( this.currentPath );
		this.currentPath.moveTo( x, y );

		return this;

	}

	lineTo( x, y ) {

		this.currentPath.lineTo( x, y );

		return this;

	}

	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

		return this;

	}

	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

		return this;

	}

	splineThru( pts ) {

		this.currentPath.splineThru( pts );

		return this;

	}

	toShapes( isCCW ) {

		function toShapesNoHoles( inSubpaths ) {

			const shapes = [];

			for ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {

				const tmpPath = inSubpaths[ i ];

				const tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );

			}

			return shapes;

		}

		function isPointInsidePolygon( inPt, inPolygon ) {

			const polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			let inside = false;
			for ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

				let edgeLowPt = inPolygon[ p ];
				let edgeHighPt = inPolygon[ q ];

				let edgeDx = edgeHighPt.x - edgeLowPt.x;
				let edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

					// not parallel
					if ( edgeDy < 0 ) {

						edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

					}

					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y === edgeLowPt.y ) {

						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!

					} else {

						const perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt

					}

				} else {

					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;

				}

			}

			return	inside;

		}

		const isClockWise = ShapeUtils.isClockWise;

		const subPaths = this.subPaths;
		if ( subPaths.length === 0 ) return [];

		let solid, tmpPath, tmpShape;
		const shapes = [];

		if ( subPaths.length === 1 ) {

			tmpPath = subPaths[ 0 ];
			tmpShape = new Shape();
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		let holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		const betterShapeHoles = [];
		const newShapes = [];
		let newShapeHoles = [];
		let mainIdx = 0;
		let tmpPoints;

		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];

		for ( let i = 0, l = subPaths.length; i < l; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.curves = tmpPath.curves;

				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {

			let ambiguous = false;
			let toChange = 0;

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				betterShapeHoles[ sIdx ] = [];

			}

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				const sho = newShapeHoles[ sIdx ];

				for ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {

					const ho = sho[ hIdx ];
					let hole_unassigned = true;

					for ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

							if ( sIdx !== s2Idx )	toChange ++;

							if ( hole_unassigned ) {

								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );

							} else {

								ambiguous = true;

							}

						}

					}

					if ( hole_unassigned ) {

						betterShapeHoles[ sIdx ].push( ho );

					}

				}

			}

			if ( toChange > 0 && ambiguous === false ) {

				newShapeHoles = betterShapeHoles;

			}

		}

		let tmpHoles;

		for ( let i = 0, il = newShapes.length; i < il; i ++ ) {

			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];

			for ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

				tmpShape.holes.push( tmpHoles[ j ].h );

			}

		}

		//console.log("shape", shapes);

		return shapes;

	}

}

class WebGLMultipleRenderTargets extends WebGLRenderTarget { // @deprecated, r162

	constructor( width = 1, height = 1, count = 1, options = {} ) {

		console.warn( 'THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.' );

		super( width, height, { ...options, count } );

		this.isWebGLMultipleRenderTargets = true;

	}

	get texture() {

		return this.textures;

	}

}

if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
		revision: REVISION,
	} } ) );

}

if ( typeof window !== 'undefined' ) {

	if ( window.__THREE__ ) {

		console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

	} else {

		window.__THREE__ = REVISION;

	}

}




/***/ }),

/***/ "./node_modules/three/examples/jsm/controls/OrbitControls.js":
/*!*******************************************************************!*\
  !*** ./node_modules/three/examples/jsm/controls/OrbitControls.js ***!
  \*******************************************************************/
/*! exports provided: OrbitControls */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrbitControls", function() { return OrbitControls; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");


// OrbitControls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

const _changeEvent = { type: 'change' };
const _startEvent = { type: 'start' };
const _endEvent = { type: 'end' };
const _ray = new three__WEBPACK_IMPORTED_MODULE_0__["Ray"]();
const _plane = new three__WEBPACK_IMPORTED_MODULE_0__["Plane"]();
const TILT_LIMIT = Math.cos( 70 * three__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].DEG2RAD );

class OrbitControls extends three__WEBPACK_IMPORTED_MODULE_0__["EventDispatcher"] {

	constructor( object, domElement ) {

		super();

		this.object = object;
		this.domElement = domElement;
		this.domElement.style.touchAction = 'none'; // disable touch scroll

		// Set to false to disable this control
		this.enabled = true;

		// "target" sets the location of focus, where the object orbits around
		this.target = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		// Sets the 3D cursor (similar to Blender), from which the maxTargetRadius takes effect
		this.cursor = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		// How far you can dolly in and out ( PerspectiveCamera only )
		this.minDistance = 0;
		this.maxDistance = Infinity;

		// How far you can zoom in and out ( OrthographicCamera only )
		this.minZoom = 0;
		this.maxZoom = Infinity;

		// Limit camera target within a spherical area around the cursor
		this.minTargetRadius = 0;
		this.maxTargetRadius = Infinity;

		// How far you can orbit vertically, upper and lower limits.
		// Range is 0 to Math.PI radians.
		this.minPolarAngle = 0; // radians
		this.maxPolarAngle = Math.PI; // radians

		// How far you can orbit horizontally, upper and lower limits.
		// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
		this.minAzimuthAngle = - Infinity; // radians
		this.maxAzimuthAngle = Infinity; // radians

		// Set to true to enable damping (inertia)
		// If damping is enabled, you must call controls.update() in your animation loop
		this.enableDamping = false;
		this.dampingFactor = 0.05;

		// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
		// Set to false to disable zooming
		this.enableZoom = true;
		this.zoomSpeed = 1.0;

		// Set to false to disable rotating
		this.enableRotate = true;
		this.rotateSpeed = 1.0;

		// Set to false to disable panning
		this.enablePan = true;
		this.panSpeed = 1.0;
		this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
		this.keyPanSpeed = 7.0;	// pixels moved per arrow key push
		this.zoomToCursor = false;

		// Set to true to automatically rotate around the target
		// If auto-rotate is enabled, you must call controls.update() in your animation loop
		this.autoRotate = false;
		this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60

		// The four arrow keys
		this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };

		// Mouse buttons
		this.mouseButtons = { LEFT: three__WEBPACK_IMPORTED_MODULE_0__["MOUSE"].ROTATE, MIDDLE: three__WEBPACK_IMPORTED_MODULE_0__["MOUSE"].DOLLY, RIGHT: three__WEBPACK_IMPORTED_MODULE_0__["MOUSE"].PAN };

		// Touch fingers
		this.touches = { ONE: three__WEBPACK_IMPORTED_MODULE_0__["TOUCH"].ROTATE, TWO: three__WEBPACK_IMPORTED_MODULE_0__["TOUCH"].DOLLY_PAN };

		// for reset
		this.target0 = this.target.clone();
		this.position0 = this.object.position.clone();
		this.zoom0 = this.object.zoom;

		// the target DOM element for key events
		this._domElementKeyEvents = null;

		//
		// public methods
		//

		this.getPolarAngle = function () {

			return spherical.phi;

		};

		this.getAzimuthalAngle = function () {

			return spherical.theta;

		};

		this.getDistance = function () {

			return this.object.position.distanceTo( this.target );

		};

		this.listenToKeyEvents = function ( domElement ) {

			domElement.addEventListener( 'keydown', onKeyDown );
			this._domElementKeyEvents = domElement;

		};

		this.stopListenToKeyEvents = function () {

			this._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );
			this._domElementKeyEvents = null;

		};

		this.saveState = function () {

			scope.target0.copy( scope.target );
			scope.position0.copy( scope.object.position );
			scope.zoom0 = scope.object.zoom;

		};

		this.reset = function () {

			scope.target.copy( scope.target0 );
			scope.object.position.copy( scope.position0 );
			scope.object.zoom = scope.zoom0;

			scope.object.updateProjectionMatrix();
			scope.dispatchEvent( _changeEvent );

			scope.update();

			state = STATE.NONE;

		};

		// this method is exposed, but perhaps it would be better if we can make it private...
		this.update = function () {

			const offset = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

			// so camera.up is the orbit axis
			const quat = new three__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]().setFromUnitVectors( object.up, new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]( 0, 1, 0 ) );
			const quatInverse = quat.clone().invert();

			const lastPosition = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
			const lastQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();
			const lastTargetPosition = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

			const twoPI = 2 * Math.PI;

			return function update( deltaTime = null ) {

				const position = scope.object.position;

				offset.copy( position ).sub( scope.target );

				// rotate offset to "y-axis-is-up" space
				offset.applyQuaternion( quat );

				// angle from z-axis around y-axis
				spherical.setFromVector3( offset );

				if ( scope.autoRotate && state === STATE.NONE ) {

					rotateLeft( getAutoRotationAngle( deltaTime ) );

				}

				if ( scope.enableDamping ) {

					spherical.theta += sphericalDelta.theta * scope.dampingFactor;
					spherical.phi += sphericalDelta.phi * scope.dampingFactor;

				} else {

					spherical.theta += sphericalDelta.theta;
					spherical.phi += sphericalDelta.phi;

				}

				// restrict theta to be between desired limits

				let min = scope.minAzimuthAngle;
				let max = scope.maxAzimuthAngle;

				if ( isFinite( min ) && isFinite( max ) ) {

					if ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;

					if ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;

					if ( min <= max ) {

						spherical.theta = Math.max( min, Math.min( max, spherical.theta ) );

					} else {

						spherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?
							Math.max( min, spherical.theta ) :
							Math.min( max, spherical.theta );

					}

				}

				// restrict phi to be between desired limits
				spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

				spherical.makeSafe();


				// move target to panned location

				if ( scope.enableDamping === true ) {

					scope.target.addScaledVector( panOffset, scope.dampingFactor );

				} else {

					scope.target.add( panOffset );

				}

				// Limit the target distance from the cursor to create a sphere around the center of interest
				scope.target.sub( scope.cursor );
				scope.target.clampLength( scope.minTargetRadius, scope.maxTargetRadius );
				scope.target.add( scope.cursor );

				let zoomChanged = false;
				// adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera
				// we adjust zoom later in these cases
				if ( scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera ) {

					spherical.radius = clampDistance( spherical.radius );

				} else {

					const prevRadius = spherical.radius;
					spherical.radius = clampDistance( spherical.radius * scale );
					zoomChanged = prevRadius != spherical.radius;

				}

				offset.setFromSpherical( spherical );

				// rotate offset back to "camera-up-vector-is-up" space
				offset.applyQuaternion( quatInverse );

				position.copy( scope.target ).add( offset );

				scope.object.lookAt( scope.target );

				if ( scope.enableDamping === true ) {

					sphericalDelta.theta *= ( 1 - scope.dampingFactor );
					sphericalDelta.phi *= ( 1 - scope.dampingFactor );

					panOffset.multiplyScalar( 1 - scope.dampingFactor );

				} else {

					sphericalDelta.set( 0, 0, 0 );

					panOffset.set( 0, 0, 0 );

				}

				// adjust camera position
				if ( scope.zoomToCursor && performCursorZoom ) {

					let newRadius = null;
					if ( scope.object.isPerspectiveCamera ) {

						// move the camera down the pointer ray
						// this method avoids floating point error
						const prevRadius = offset.length();
						newRadius = clampDistance( prevRadius * scale );

						const radiusDelta = prevRadius - newRadius;
						scope.object.position.addScaledVector( dollyDirection, radiusDelta );
						scope.object.updateMatrixWorld();

						zoomChanged = !! radiusDelta;

					} else if ( scope.object.isOrthographicCamera ) {

						// adjust the ortho camera position based on zoom changes
						const mouseBefore = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]( mouse.x, mouse.y, 0 );
						mouseBefore.unproject( scope.object );

						const prevZoom = scope.object.zoom;
						scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );
						scope.object.updateProjectionMatrix();

						zoomChanged = prevZoom !== scope.object.zoom;

						const mouseAfter = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]( mouse.x, mouse.y, 0 );
						mouseAfter.unproject( scope.object );

						scope.object.position.sub( mouseAfter ).add( mouseBefore );
						scope.object.updateMatrixWorld();

						newRadius = offset.length();

					} else {

						console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.' );
						scope.zoomToCursor = false;

					}

					// handle the placement of the target
					if ( newRadius !== null ) {

						if ( this.screenSpacePanning ) {

							// position the orbit target in front of the new camera position
							scope.target.set( 0, 0, - 1 )
								.transformDirection( scope.object.matrix )
								.multiplyScalar( newRadius )
								.add( scope.object.position );

						} else {

							// get the ray and translation plane to compute target
							_ray.origin.copy( scope.object.position );
							_ray.direction.set( 0, 0, - 1 ).transformDirection( scope.object.matrix );

							// if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid
							// extremely large values
							if ( Math.abs( scope.object.up.dot( _ray.direction ) ) < TILT_LIMIT ) {

								object.lookAt( scope.target );

							} else {

								_plane.setFromNormalAndCoplanarPoint( scope.object.up, scope.target );
								_ray.intersectPlane( _plane, scope.target );

							}

						}

					}

				} else if ( scope.object.isOrthographicCamera ) {

					const prevZoom = scope.object.zoom;
					scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );

					if ( prevZoom !== scope.object.zoom ) {

						scope.object.updateProjectionMatrix();
						zoomChanged = true;

					}

				}

				scale = 1;
				performCursorZoom = false;

				// update condition is:
				// min(camera displacement, camera rotation in radians)^2 > EPS
				// using small-angle approximation cos(x/2) = 1 - x^2 / 8

				if ( zoomChanged ||
					lastPosition.distanceToSquared( scope.object.position ) > EPS ||
					8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ||
					lastTargetPosition.distanceToSquared( scope.target ) > EPS ) {

					scope.dispatchEvent( _changeEvent );

					lastPosition.copy( scope.object.position );
					lastQuaternion.copy( scope.object.quaternion );
					lastTargetPosition.copy( scope.target );

					return true;

				}

				return false;

			};

		}();

		this.dispose = function () {

			scope.domElement.removeEventListener( 'contextmenu', onContextMenu );

			scope.domElement.removeEventListener( 'pointerdown', onPointerDown );
			scope.domElement.removeEventListener( 'pointercancel', onPointerUp );
			scope.domElement.removeEventListener( 'wheel', onMouseWheel );

			scope.domElement.removeEventListener( 'pointermove', onPointerMove );
			scope.domElement.removeEventListener( 'pointerup', onPointerUp );

			const document = scope.domElement.getRootNode(); // offscreen canvas compatibility

			document.removeEventListener( 'keydown', interceptControlDown, { capture: true } );

			if ( scope._domElementKeyEvents !== null ) {

				scope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );
				scope._domElementKeyEvents = null;

			}

			//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

		};

		//
		// internals
		//

		const scope = this;

		const STATE = {
			NONE: - 1,
			ROTATE: 0,
			DOLLY: 1,
			PAN: 2,
			TOUCH_ROTATE: 3,
			TOUCH_PAN: 4,
			TOUCH_DOLLY_PAN: 5,
			TOUCH_DOLLY_ROTATE: 6
		};

		let state = STATE.NONE;

		const EPS = 0.000001;

		// current position in spherical coordinates
		const spherical = new three__WEBPACK_IMPORTED_MODULE_0__["Spherical"]();
		const sphericalDelta = new three__WEBPACK_IMPORTED_MODULE_0__["Spherical"]();

		let scale = 1;
		const panOffset = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		const rotateStart = new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();
		const rotateEnd = new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();
		const rotateDelta = new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();

		const panStart = new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();
		const panEnd = new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();
		const panDelta = new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();

		const dollyStart = new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();
		const dollyEnd = new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();
		const dollyDelta = new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();

		const dollyDirection = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
		const mouse = new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();
		let performCursorZoom = false;

		const pointers = [];
		const pointerPositions = {};

		let controlActive = false;

		function getAutoRotationAngle( deltaTime ) {

			if ( deltaTime !== null ) {

				return ( 2 * Math.PI / 60 * scope.autoRotateSpeed ) * deltaTime;

			} else {

				return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

			}

		}

		function getZoomScale( delta ) {

			const normalizedDelta = Math.abs( delta * 0.01 );
			return Math.pow( 0.95, scope.zoomSpeed * normalizedDelta );

		}

		function rotateLeft( angle ) {

			sphericalDelta.theta -= angle;

		}

		function rotateUp( angle ) {

			sphericalDelta.phi -= angle;

		}

		const panLeft = function () {

			const v = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

			return function panLeft( distance, objectMatrix ) {

				v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
				v.multiplyScalar( - distance );

				panOffset.add( v );

			};

		}();

		const panUp = function () {

			const v = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

			return function panUp( distance, objectMatrix ) {

				if ( scope.screenSpacePanning === true ) {

					v.setFromMatrixColumn( objectMatrix, 1 );

				} else {

					v.setFromMatrixColumn( objectMatrix, 0 );
					v.crossVectors( scope.object.up, v );

				}

				v.multiplyScalar( distance );

				panOffset.add( v );

			};

		}();

		// deltaX and deltaY are in pixels; right and down are positive
		const pan = function () {

			const offset = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

			return function pan( deltaX, deltaY ) {

				const element = scope.domElement;

				if ( scope.object.isPerspectiveCamera ) {

					// perspective
					const position = scope.object.position;
					offset.copy( position ).sub( scope.target );
					let targetDistance = offset.length();

					// half of the fov is center to top of screen
					targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

					// we use only clientHeight here so aspect ratio does not distort speed
					panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
					panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

				} else if ( scope.object.isOrthographicCamera ) {

					// orthographic
					panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
					panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

				} else {

					// camera neither orthographic nor perspective
					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
					scope.enablePan = false;

				}

			};

		}();

		function dollyOut( dollyScale ) {

			if ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {

				scale /= dollyScale;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		function dollyIn( dollyScale ) {

			if ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {

				scale *= dollyScale;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		function updateZoomParameters( x, y ) {

			if ( ! scope.zoomToCursor ) {

				return;

			}

			performCursorZoom = true;

			const rect = scope.domElement.getBoundingClientRect();
			const dx = x - rect.left;
			const dy = y - rect.top;
			const w = rect.width;
			const h = rect.height;

			mouse.x = ( dx / w ) * 2 - 1;
			mouse.y = - ( dy / h ) * 2 + 1;

			dollyDirection.set( mouse.x, mouse.y, 1 ).unproject( scope.object ).sub( scope.object.position ).normalize();

		}

		function clampDistance( dist ) {

			return Math.max( scope.minDistance, Math.min( scope.maxDistance, dist ) );

		}

		//
		// event callbacks - update the object state
		//

		function handleMouseDownRotate( event ) {

			rotateStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownDolly( event ) {

			updateZoomParameters( event.clientX, event.clientX );
			dollyStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownPan( event ) {

			panStart.set( event.clientX, event.clientY );

		}

		function handleMouseMoveRotate( event ) {

			rotateEnd.set( event.clientX, event.clientY );

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			const element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

			scope.update();

		}

		function handleMouseMoveDolly( event ) {

			dollyEnd.set( event.clientX, event.clientY );

			dollyDelta.subVectors( dollyEnd, dollyStart );

			if ( dollyDelta.y > 0 ) {

				dollyOut( getZoomScale( dollyDelta.y ) );

			} else if ( dollyDelta.y < 0 ) {

				dollyIn( getZoomScale( dollyDelta.y ) );

			}

			dollyStart.copy( dollyEnd );

			scope.update();

		}

		function handleMouseMovePan( event ) {

			panEnd.set( event.clientX, event.clientY );

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

			scope.update();

		}

		function handleMouseWheel( event ) {

			updateZoomParameters( event.clientX, event.clientY );

			if ( event.deltaY < 0 ) {

				dollyIn( getZoomScale( event.deltaY ) );

			} else if ( event.deltaY > 0 ) {

				dollyOut( getZoomScale( event.deltaY ) );

			}

			scope.update();

		}

		function handleKeyDown( event ) {

			let needsUpdate = false;

			switch ( event.code ) {

				case scope.keys.UP:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateUp( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( 0, scope.keyPanSpeed );

					}

					needsUpdate = true;
					break;

				case scope.keys.BOTTOM:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateUp( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( 0, - scope.keyPanSpeed );

					}

					needsUpdate = true;
					break;

				case scope.keys.LEFT:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateLeft( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( scope.keyPanSpeed, 0 );

					}

					needsUpdate = true;
					break;

				case scope.keys.RIGHT:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateLeft( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( - scope.keyPanSpeed, 0 );

					}

					needsUpdate = true;
					break;

			}

			if ( needsUpdate ) {

				// prevent the browser from scrolling on cursor keys
				event.preventDefault();

				scope.update();

			}


		}

		function handleTouchStartRotate( event ) {

			if ( pointers.length === 1 ) {

				rotateStart.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				rotateStart.set( x, y );

			}

		}

		function handleTouchStartPan( event ) {

			if ( pointers.length === 1 ) {

				panStart.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				panStart.set( x, y );

			}

		}

		function handleTouchStartDolly( event ) {

			const position = getSecondPointerPosition( event );

			const dx = event.pageX - position.x;
			const dy = event.pageY - position.y;

			const distance = Math.sqrt( dx * dx + dy * dy );

			dollyStart.set( 0, distance );

		}

		function handleTouchStartDollyPan( event ) {

			if ( scope.enableZoom ) handleTouchStartDolly( event );

			if ( scope.enablePan ) handleTouchStartPan( event );

		}

		function handleTouchStartDollyRotate( event ) {

			if ( scope.enableZoom ) handleTouchStartDolly( event );

			if ( scope.enableRotate ) handleTouchStartRotate( event );

		}

		function handleTouchMoveRotate( event ) {

			if ( pointers.length == 1 ) {

				rotateEnd.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				rotateEnd.set( x, y );

			}

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			const element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

		}

		function handleTouchMovePan( event ) {

			if ( pointers.length === 1 ) {

				panEnd.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				panEnd.set( x, y );

			}

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

		}

		function handleTouchMoveDolly( event ) {

			const position = getSecondPointerPosition( event );

			const dx = event.pageX - position.x;
			const dy = event.pageY - position.y;

			const distance = Math.sqrt( dx * dx + dy * dy );

			dollyEnd.set( 0, distance );

			dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

			dollyOut( dollyDelta.y );

			dollyStart.copy( dollyEnd );

			const centerX = ( event.pageX + position.x ) * 0.5;
			const centerY = ( event.pageY + position.y ) * 0.5;

			updateZoomParameters( centerX, centerY );

		}

		function handleTouchMoveDollyPan( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enablePan ) handleTouchMovePan( event );

		}

		function handleTouchMoveDollyRotate( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enableRotate ) handleTouchMoveRotate( event );

		}

		//
		// event handlers - FSM: listen for events and reset state
		//

		function onPointerDown( event ) {

			if ( scope.enabled === false ) return;

			if ( pointers.length === 0 ) {

				scope.domElement.setPointerCapture( event.pointerId );

				scope.domElement.addEventListener( 'pointermove', onPointerMove );
				scope.domElement.addEventListener( 'pointerup', onPointerUp );

			}

			//

			if ( isTrackingPointer( event ) ) return;

			//

			addPointer( event );

			if ( event.pointerType === 'touch' ) {

				onTouchStart( event );

			} else {

				onMouseDown( event );

			}

		}

		function onPointerMove( event ) {

			if ( scope.enabled === false ) return;

			if ( event.pointerType === 'touch' ) {

				onTouchMove( event );

			} else {

				onMouseMove( event );

			}

		}

		function onPointerUp( event ) {

			removePointer( event );

			switch ( pointers.length ) {

				case 0:

					scope.domElement.releasePointerCapture( event.pointerId );

					scope.domElement.removeEventListener( 'pointermove', onPointerMove );
					scope.domElement.removeEventListener( 'pointerup', onPointerUp );

					scope.dispatchEvent( _endEvent );

					state = STATE.NONE;

					break;

				case 1:

					const pointerId = pointers[ 0 ];
					const position = pointerPositions[ pointerId ];

					// minimal placeholder event - allows state correction on pointer-up
					onTouchStart( { pointerId: pointerId, pageX: position.x, pageY: position.y } );

					break;

			}

		}

		function onMouseDown( event ) {

			let mouseAction;

			switch ( event.button ) {

				case 0:

					mouseAction = scope.mouseButtons.LEFT;
					break;

				case 1:

					mouseAction = scope.mouseButtons.MIDDLE;
					break;

				case 2:

					mouseAction = scope.mouseButtons.RIGHT;
					break;

				default:

					mouseAction = - 1;

			}

			switch ( mouseAction ) {

				case three__WEBPACK_IMPORTED_MODULE_0__["MOUSE"].DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseDownDolly( event );

					state = STATE.DOLLY;

					break;

				case three__WEBPACK_IMPORTED_MODULE_0__["MOUSE"].ROTATE:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					} else {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					}

					break;

				case three__WEBPACK_IMPORTED_MODULE_0__["MOUSE"].PAN:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					} else {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( _startEvent );

			}

		}

		function onMouseMove( event ) {

			switch ( state ) {

				case STATE.ROTATE:

					if ( scope.enableRotate === false ) return;

					handleMouseMoveRotate( event );

					break;

				case STATE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseMoveDolly( event );

					break;

				case STATE.PAN:

					if ( scope.enablePan === false ) return;

					handleMouseMovePan( event );

					break;

			}

		}

		function onMouseWheel( event ) {

			if ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;

			event.preventDefault();

			scope.dispatchEvent( _startEvent );

			handleMouseWheel( customWheelEvent( event ) );

			scope.dispatchEvent( _endEvent );

		}

		function customWheelEvent( event ) {

			const mode = event.deltaMode;

			// minimal wheel event altered to meet delta-zoom demand
			const newEvent = {
				clientX: event.clientX,
				clientY: event.clientY,
				deltaY: event.deltaY,
			};

			switch ( mode ) {

				case 1: // LINE_MODE
					newEvent.deltaY *= 16;
					break;

				case 2: // PAGE_MODE
					newEvent.deltaY *= 100;
					break;

			}

			// detect if event was triggered by pinching
			if ( event.ctrlKey && ! controlActive ) {

				newEvent.deltaY *= 10;

			}

			return newEvent;

		}

		function interceptControlDown( event ) {

			if ( event.key === 'Control' ) {

				controlActive = true;


				const document = scope.domElement.getRootNode(); // offscreen canvas compatibility

				document.addEventListener( 'keyup', interceptControlUp, { passive: true, capture: true } );

			}

		}

		function interceptControlUp( event ) {

			if ( event.key === 'Control' ) {

				controlActive = false;


				const document = scope.domElement.getRootNode(); // offscreen canvas compatibility

				document.removeEventListener( 'keyup', interceptControlUp, { passive: true, capture: true } );

			}

		}

		function onKeyDown( event ) {

			if ( scope.enabled === false || scope.enablePan === false ) return;

			handleKeyDown( event );

		}

		function onTouchStart( event ) {

			trackPointer( event );

			switch ( pointers.length ) {

				case 1:

					switch ( scope.touches.ONE ) {

						case three__WEBPACK_IMPORTED_MODULE_0__["TOUCH"].ROTATE:

							if ( scope.enableRotate === false ) return;

							handleTouchStartRotate( event );

							state = STATE.TOUCH_ROTATE;

							break;

						case three__WEBPACK_IMPORTED_MODULE_0__["TOUCH"].PAN:

							if ( scope.enablePan === false ) return;

							handleTouchStartPan( event );

							state = STATE.TOUCH_PAN;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				case 2:

					switch ( scope.touches.TWO ) {

						case three__WEBPACK_IMPORTED_MODULE_0__["TOUCH"].DOLLY_PAN:

							if ( scope.enableZoom === false && scope.enablePan === false ) return;

							handleTouchStartDollyPan( event );

							state = STATE.TOUCH_DOLLY_PAN;

							break;

						case three__WEBPACK_IMPORTED_MODULE_0__["TOUCH"].DOLLY_ROTATE:

							if ( scope.enableZoom === false && scope.enableRotate === false ) return;

							handleTouchStartDollyRotate( event );

							state = STATE.TOUCH_DOLLY_ROTATE;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( _startEvent );

			}

		}

		function onTouchMove( event ) {

			trackPointer( event );

			switch ( state ) {

				case STATE.TOUCH_ROTATE:

					if ( scope.enableRotate === false ) return;

					handleTouchMoveRotate( event );

					scope.update();

					break;

				case STATE.TOUCH_PAN:

					if ( scope.enablePan === false ) return;

					handleTouchMovePan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_PAN:

					if ( scope.enableZoom === false && scope.enablePan === false ) return;

					handleTouchMoveDollyPan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_ROTATE:

					if ( scope.enableZoom === false && scope.enableRotate === false ) return;

					handleTouchMoveDollyRotate( event );

					scope.update();

					break;

				default:

					state = STATE.NONE;

			}

		}

		function onContextMenu( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

		}

		function addPointer( event ) {

			pointers.push( event.pointerId );

		}

		function removePointer( event ) {

			delete pointerPositions[ event.pointerId ];

			for ( let i = 0; i < pointers.length; i ++ ) {

				if ( pointers[ i ] == event.pointerId ) {

					pointers.splice( i, 1 );
					return;

				}

			}

		}

		function isTrackingPointer( event ) {

			for ( let i = 0; i < pointers.length; i ++ ) {

				if ( pointers[ i ] == event.pointerId ) return true;

			}

			return false;

		}

		function trackPointer( event ) {

			let position = pointerPositions[ event.pointerId ];

			if ( position === undefined ) {

				position = new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();
				pointerPositions[ event.pointerId ] = position;

			}

			position.set( event.pageX, event.pageY );

		}

		function getSecondPointerPosition( event ) {

			const pointerId = ( event.pointerId === pointers[ 0 ] ) ? pointers[ 1 ] : pointers[ 0 ];

			return pointerPositions[ pointerId ];

		}

		//

		scope.domElement.addEventListener( 'contextmenu', onContextMenu );

		scope.domElement.addEventListener( 'pointerdown', onPointerDown );
		scope.domElement.addEventListener( 'pointercancel', onPointerUp );
		scope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );

		const document = scope.domElement.getRootNode(); // offscreen canvas compatibility

		document.addEventListener( 'keydown', interceptControlDown, { passive: true, capture: true } );

		// force an update at start

		this.update();

	}

}




/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/MTLLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/MTLLoader.js ***!
  \**************************************************************/
/*! exports provided: MTLLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MTLLoader", function() { return MTLLoader; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");


/**
 * Loads a Wavefront .mtl file specifying materials
 */

class MTLLoader extends three__WEBPACK_IMPORTED_MODULE_0__["Loader"] {

	constructor( manager ) {

		super( manager );

	}

	/**
	 * Loads and parses a MTL asset from a URL.
	 *
	 * @param {String} url - URL to the MTL file.
	 * @param {Function} [onLoad] - Callback invoked with the loaded object.
	 * @param {Function} [onProgress] - Callback for download progress.
	 * @param {Function} [onError] - Callback for download errors.
	 *
	 * @see setPath setResourcePath
	 *
	 * @note In order for relative texture references to resolve correctly
	 * you must call setResourcePath() explicitly prior to load.
	 */
	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const path = ( this.path === '' ) ? three__WEBPACK_IMPORTED_MODULE_0__["LoaderUtils"].extractUrlBase( url ) : this.path;

		const loader = new three__WEBPACK_IMPORTED_MODULE_0__["FileLoader"]( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( text, path ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	setMaterialOptions( value ) {

		this.materialOptions = value;
		return this;

	}

	/**
	 * Parses a MTL file.
	 *
	 * @param {String} text - Content of MTL file
	 * @return {MaterialCreator}
	 *
	 * @see setPath setResourcePath
	 *
	 * @note In order for relative texture references to resolve correctly
	 * you must call setResourcePath() explicitly prior to parse.
	 */
	parse( text, path ) {

		const lines = text.split( '\n' );
		let info = {};
		const delimiter_pattern = /\s+/;
		const materialsInfo = {};

		for ( let i = 0; i < lines.length; i ++ ) {

			let line = lines[ i ];
			line = line.trim();

			if ( line.length === 0 || line.charAt( 0 ) === '#' ) {

				// Blank line or comment ignore
				continue;

			}

			const pos = line.indexOf( ' ' );

			let key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;
			key = key.toLowerCase();

			let value = ( pos >= 0 ) ? line.substring( pos + 1 ) : '';
			value = value.trim();

			if ( key === 'newmtl' ) {

				// New material

				info = { name: value };
				materialsInfo[ value ] = info;

			} else {

				if ( key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke' ) {

					const ss = value.split( delimiter_pattern, 3 );
					info[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];

				} else {

					info[ key ] = value;

				}

			}

		}

		const materialCreator = new MaterialCreator( this.resourcePath || path, this.materialOptions );
		materialCreator.setCrossOrigin( this.crossOrigin );
		materialCreator.setManager( this.manager );
		materialCreator.setMaterials( materialsInfo );
		return materialCreator;

	}

}

/**
 * Create a new MTLLoader.MaterialCreator
 * @param baseUrl - Url relative to which textures are loaded
 * @param options - Set of options on how to construct the materials
 *                  side: Which side to apply the material
 *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide
 *                  wrap: What type of wrapping to apply for textures
 *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping
 *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255
 *                                Default: false, assumed to be already normalized
 *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's
 *                                  Default: false
 * @constructor
 */

class MaterialCreator {

	constructor( baseUrl = '', options = {} ) {

		this.baseUrl = baseUrl;
		this.options = options;
		this.materialsInfo = {};
		this.materials = {};
		this.materialsArray = [];
		this.nameLookup = {};

		this.crossOrigin = 'anonymous';

		this.side = ( this.options.side !== undefined ) ? this.options.side : three__WEBPACK_IMPORTED_MODULE_0__["FrontSide"];
		this.wrap = ( this.options.wrap !== undefined ) ? this.options.wrap : three__WEBPACK_IMPORTED_MODULE_0__["RepeatWrapping"];

	}

	setCrossOrigin( value ) {

		this.crossOrigin = value;
		return this;

	}

	setManager( value ) {

		this.manager = value;

	}

	setMaterials( materialsInfo ) {

		this.materialsInfo = this.convert( materialsInfo );
		this.materials = {};
		this.materialsArray = [];
		this.nameLookup = {};

	}

	convert( materialsInfo ) {

		if ( ! this.options ) return materialsInfo;

		const converted = {};

		for ( const mn in materialsInfo ) {

			// Convert materials info into normalized form based on options

			const mat = materialsInfo[ mn ];

			const covmat = {};

			converted[ mn ] = covmat;

			for ( const prop in mat ) {

				let save = true;
				let value = mat[ prop ];
				const lprop = prop.toLowerCase();

				switch ( lprop ) {

					case 'kd':
					case 'ka':
					case 'ks':

						// Diffuse color (color under white light) using RGB values

						if ( this.options && this.options.normalizeRGB ) {

							value = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];

						}

						if ( this.options && this.options.ignoreZeroRGBs ) {

							if ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {

								// ignore

								save = false;

							}

						}

						break;

					default:

						break;

				}

				if ( save ) {

					covmat[ lprop ] = value;

				}

			}

		}

		return converted;

	}

	preload() {

		for ( const mn in this.materialsInfo ) {

			this.create( mn );

		}

	}

	getIndex( materialName ) {

		return this.nameLookup[ materialName ];

	}

	getAsArray() {

		let index = 0;

		for ( const mn in this.materialsInfo ) {

			this.materialsArray[ index ] = this.create( mn );
			this.nameLookup[ mn ] = index;
			index ++;

		}

		return this.materialsArray;

	}

	create( materialName ) {

		if ( this.materials[ materialName ] === undefined ) {

			this.createMaterial_( materialName );

		}

		return this.materials[ materialName ];

	}

	createMaterial_( materialName ) {

		// Create material

		const scope = this;
		const mat = this.materialsInfo[ materialName ];
		const params = {

			name: materialName,
			side: this.side

		};

		function resolveURL( baseUrl, url ) {

			if ( typeof url !== 'string' || url === '' )
				return '';

			// Absolute URL
			if ( /^https?:\/\//i.test( url ) ) return url;

			return baseUrl + url;

		}

		function setMapForType( mapType, value ) {

			if ( params[ mapType ] ) return; // Keep the first encountered texture

			const texParams = scope.getTextureParams( value, params );
			const map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) );

			map.repeat.copy( texParams.scale );
			map.offset.copy( texParams.offset );

			map.wrapS = scope.wrap;
			map.wrapT = scope.wrap;

			if ( mapType === 'map' || mapType === 'emissiveMap' ) {

				map.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__["SRGBColorSpace"];

			}

			params[ mapType ] = map;

		}

		for ( const prop in mat ) {

			const value = mat[ prop ];
			let n;

			if ( value === '' ) continue;

			switch ( prop.toLowerCase() ) {

				// Ns is material specular exponent

				case 'kd':

					// Diffuse color (color under white light) using RGB values

					params.color = new three__WEBPACK_IMPORTED_MODULE_0__["Color"]().fromArray( value ).convertSRGBToLinear();

					break;

				case 'ks':

					// Specular color (color when light is reflected from shiny surface) using RGB values
					params.specular = new three__WEBPACK_IMPORTED_MODULE_0__["Color"]().fromArray( value ).convertSRGBToLinear();

					break;

				case 'ke':

					// Emissive using RGB values
					params.emissive = new three__WEBPACK_IMPORTED_MODULE_0__["Color"]().fromArray( value ).convertSRGBToLinear();

					break;

				case 'map_kd':

					// Diffuse texture map

					setMapForType( 'map', value );

					break;

				case 'map_ks':

					// Specular map

					setMapForType( 'specularMap', value );

					break;

				case 'map_ke':

					// Emissive map

					setMapForType( 'emissiveMap', value );

					break;

				case 'norm':

					setMapForType( 'normalMap', value );

					break;

				case 'map_bump':
				case 'bump':

					// Bump texture map

					setMapForType( 'bumpMap', value );

					break;

				case 'map_d':

					// Alpha map

					setMapForType( 'alphaMap', value );
					params.transparent = true;

					break;

				case 'ns':

					// The specular exponent (defines the focus of the specular highlight)
					// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.

					params.shininess = parseFloat( value );

					break;

				case 'd':
					n = parseFloat( value );

					if ( n < 1 ) {

						params.opacity = n;
						params.transparent = true;

					}

					break;

				case 'tr':
					n = parseFloat( value );

					if ( this.options && this.options.invertTrProperty ) n = 1 - n;

					if ( n > 0 ) {

						params.opacity = 1 - n;
						params.transparent = true;

					}

					break;

				default:
					break;

			}

		}

		this.materials[ materialName ] = new three__WEBPACK_IMPORTED_MODULE_0__["MeshPhongMaterial"]( params );
		return this.materials[ materialName ];

	}

	getTextureParams( value, matParams ) {

		const texParams = {

			scale: new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"]( 1, 1 ),
			offset: new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"]( 0, 0 )

		 };

		const items = value.split( /\s+/ );
		let pos;

		pos = items.indexOf( '-bm' );

		if ( pos >= 0 ) {

			matParams.bumpScale = parseFloat( items[ pos + 1 ] );
			items.splice( pos, 2 );

		}

		pos = items.indexOf( '-s' );

		if ( pos >= 0 ) {

			texParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );
			items.splice( pos, 4 ); // we expect 3 parameters here!

		}

		pos = items.indexOf( '-o' );

		if ( pos >= 0 ) {

			texParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );
			items.splice( pos, 4 ); // we expect 3 parameters here!

		}

		texParams.url = items.join( ' ' ).trim();
		return texParams;

	}

	loadTexture( url, mapping, onLoad, onProgress, onError ) {

		const manager = ( this.manager !== undefined ) ? this.manager : three__WEBPACK_IMPORTED_MODULE_0__["DefaultLoadingManager"];
		let loader = manager.getHandler( url );

		if ( loader === null ) {

			loader = new three__WEBPACK_IMPORTED_MODULE_0__["TextureLoader"]( manager );

		}

		if ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );

		const texture = loader.load( url, onLoad, onProgress, onError );

		if ( mapping !== undefined ) texture.mapping = mapping;

		return texture;

	}

}




/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/OBJLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/OBJLoader.js ***!
  \**************************************************************/
/*! exports provided: OBJLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OBJLoader", function() { return OBJLoader; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");


// o object_name | g group_name
const _object_pattern = /^[og]\s*(.+)?/;
// mtllib file_reference
const _material_library_pattern = /^mtllib /;
// usemtl material_name
const _material_use_pattern = /^usemtl /;
// usemap map_name
const _map_use_pattern = /^usemap /;
const _face_vertex_data_separator_pattern = /\s+/;

const _vA = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vB = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vC = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

const _ab = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _cb = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

const _color = new three__WEBPACK_IMPORTED_MODULE_0__["Color"]();

function ParserState() {

	const state = {
		objects: [],
		object: {},

		vertices: [],
		normals: [],
		colors: [],
		uvs: [],

		materials: {},
		materialLibraries: [],

		startObject: function ( name, fromDeclaration ) {

			// If the current object (initial from reset) is not from a g/o declaration in the parsed
			// file. We need to use it for the first parsed g/o to keep things in sync.
			if ( this.object && this.object.fromDeclaration === false ) {

				this.object.name = name;
				this.object.fromDeclaration = ( fromDeclaration !== false );
				return;

			}

			const previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );

			if ( this.object && typeof this.object._finalize === 'function' ) {

				this.object._finalize( true );

			}

			this.object = {
				name: name || '',
				fromDeclaration: ( fromDeclaration !== false ),

				geometry: {
					vertices: [],
					normals: [],
					colors: [],
					uvs: [],
					hasUVIndices: false
				},
				materials: [],
				smooth: true,

				startMaterial: function ( name, libraries ) {

					const previous = this._finalize( false );

					// New usemtl declaration overwrites an inherited material, except if faces were declared
					// after the material, then it must be preserved for proper MultiMaterial continuation.
					if ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {

						this.materials.splice( previous.index, 1 );

					}

					const material = {
						index: this.materials.length,
						name: name || '',
						mtllib: ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),
						smooth: ( previous !== undefined ? previous.smooth : this.smooth ),
						groupStart: ( previous !== undefined ? previous.groupEnd : 0 ),
						groupEnd: - 1,
						groupCount: - 1,
						inherited: false,

						clone: function ( index ) {

							const cloned = {
								index: ( typeof index === 'number' ? index : this.index ),
								name: this.name,
								mtllib: this.mtllib,
								smooth: this.smooth,
								groupStart: 0,
								groupEnd: - 1,
								groupCount: - 1,
								inherited: false
							};
							cloned.clone = this.clone.bind( cloned );
							return cloned;

						}
					};

					this.materials.push( material );

					return material;

				},

				currentMaterial: function () {

					if ( this.materials.length > 0 ) {

						return this.materials[ this.materials.length - 1 ];

					}

					return undefined;

				},

				_finalize: function ( end ) {

					const lastMultiMaterial = this.currentMaterial();
					if ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) {

						lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
						lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
						lastMultiMaterial.inherited = false;

					}

					// Ignore objects tail materials if no face declarations followed them before a new o/g started.
					if ( end && this.materials.length > 1 ) {

						for ( let mi = this.materials.length - 1; mi >= 0; mi -- ) {

							if ( this.materials[ mi ].groupCount <= 0 ) {

								this.materials.splice( mi, 1 );

							}

						}

					}

					// Guarantee at least one empty material, this makes the creation later more straight forward.
					if ( end && this.materials.length === 0 ) {

						this.materials.push( {
							name: '',
							smooth: this.smooth
						} );

					}

					return lastMultiMaterial;

				}
			};

			// Inherit previous objects material.
			// Spec tells us that a declared material must be set to all objects until a new material is declared.
			// If a usemtl declaration is encountered while this new object is being parsed, it will
			// overwrite the inherited material. Exception being that there was already face declarations
			// to the inherited material, then it will be preserved for proper MultiMaterial continuation.

			if ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {

				const declared = previousMaterial.clone( 0 );
				declared.inherited = true;
				this.object.materials.push( declared );

			}

			this.objects.push( this.object );

		},

		finalize: function () {

			if ( this.object && typeof this.object._finalize === 'function' ) {

				this.object._finalize( true );

			}

		},

		parseVertexIndex: function ( value, len ) {

			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

		},

		parseNormalIndex: function ( value, len ) {

			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

		},

		parseUVIndex: function ( value, len ) {

			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 2 ) * 2;

		},

		addVertex: function ( a, b, c ) {

			const src = this.vertices;
			const dst = this.object.geometry.vertices;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

		},

		addVertexPoint: function ( a ) {

			const src = this.vertices;
			const dst = this.object.geometry.vertices;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );

		},

		addVertexLine: function ( a ) {

			const src = this.vertices;
			const dst = this.object.geometry.vertices;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );

		},

		addNormal: function ( a, b, c ) {

			const src = this.normals;
			const dst = this.object.geometry.normals;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

		},

		addFaceNormal: function ( a, b, c ) {

			const src = this.vertices;
			const dst = this.object.geometry.normals;

			_vA.fromArray( src, a );
			_vB.fromArray( src, b );
			_vC.fromArray( src, c );

			_cb.subVectors( _vC, _vB );
			_ab.subVectors( _vA, _vB );
			_cb.cross( _ab );

			_cb.normalize();

			dst.push( _cb.x, _cb.y, _cb.z );
			dst.push( _cb.x, _cb.y, _cb.z );
			dst.push( _cb.x, _cb.y, _cb.z );

		},

		addColor: function ( a, b, c ) {

			const src = this.colors;
			const dst = this.object.geometry.colors;

			if ( src[ a ] !== undefined ) dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			if ( src[ b ] !== undefined ) dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			if ( src[ c ] !== undefined ) dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

		},

		addUV: function ( a, b, c ) {

			const src = this.uvs;
			const dst = this.object.geometry.uvs;

			dst.push( src[ a + 0 ], src[ a + 1 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ] );

		},

		addDefaultUV: function () {

			const dst = this.object.geometry.uvs;

			dst.push( 0, 0 );
			dst.push( 0, 0 );
			dst.push( 0, 0 );

		},

		addUVLine: function ( a ) {

			const src = this.uvs;
			const dst = this.object.geometry.uvs;

			dst.push( src[ a + 0 ], src[ a + 1 ] );

		},

		addFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {

			const vLen = this.vertices.length;

			let ia = this.parseVertexIndex( a, vLen );
			let ib = this.parseVertexIndex( b, vLen );
			let ic = this.parseVertexIndex( c, vLen );

			this.addVertex( ia, ib, ic );
			this.addColor( ia, ib, ic );

			// normals

			if ( na !== undefined && na !== '' ) {

				const nLen = this.normals.length;

				ia = this.parseNormalIndex( na, nLen );
				ib = this.parseNormalIndex( nb, nLen );
				ic = this.parseNormalIndex( nc, nLen );

				this.addNormal( ia, ib, ic );

			} else {

				this.addFaceNormal( ia, ib, ic );

			}

			// uvs

			if ( ua !== undefined && ua !== '' ) {

				const uvLen = this.uvs.length;

				ia = this.parseUVIndex( ua, uvLen );
				ib = this.parseUVIndex( ub, uvLen );
				ic = this.parseUVIndex( uc, uvLen );

				this.addUV( ia, ib, ic );

				this.object.geometry.hasUVIndices = true;

			} else {

				// add placeholder values (for inconsistent face definitions)

				this.addDefaultUV();

			}

		},

		addPointGeometry: function ( vertices ) {

			this.object.geometry.type = 'Points';

			const vLen = this.vertices.length;

			for ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {

				const index = this.parseVertexIndex( vertices[ vi ], vLen );

				this.addVertexPoint( index );
				this.addColor( index );

			}

		},

		addLineGeometry: function ( vertices, uvs ) {

			this.object.geometry.type = 'Line';

			const vLen = this.vertices.length;
			const uvLen = this.uvs.length;

			for ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {

				this.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );

			}

			for ( let uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {

				this.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );

			}

		}

	};

	state.startObject( '', false );

	return state;

}

//

class OBJLoader extends three__WEBPACK_IMPORTED_MODULE_0__["Loader"] {

	constructor( manager ) {

		super( manager );

		this.materials = null;

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new three__WEBPACK_IMPORTED_MODULE_0__["FileLoader"]( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( text ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	setMaterials( materials ) {

		this.materials = materials;

		return this;

	}

	parse( text ) {

		const state = new ParserState();

		if ( text.indexOf( '\r\n' ) !== - 1 ) {

			// This is faster than String.split with regex that splits on both
			text = text.replace( /\r\n/g, '\n' );

		}

		if ( text.indexOf( '\\\n' ) !== - 1 ) {

			// join lines separated by a line continuation character (\)
			text = text.replace( /\\\n/g, '' );

		}

		const lines = text.split( '\n' );
		let result = [];

		for ( let i = 0, l = lines.length; i < l; i ++ ) {

			const line = lines[ i ].trimStart();

			if ( line.length === 0 ) continue;

			const lineFirstChar = line.charAt( 0 );

			// @todo invoke passed in handler if any
			if ( lineFirstChar === '#' ) continue; // skip comments

			if ( lineFirstChar === 'v' ) {

				const data = line.split( _face_vertex_data_separator_pattern );

				switch ( data[ 0 ] ) {

					case 'v':
						state.vertices.push(
							parseFloat( data[ 1 ] ),
							parseFloat( data[ 2 ] ),
							parseFloat( data[ 3 ] )
						);
						if ( data.length >= 7 ) {

							_color.setRGB(
								parseFloat( data[ 4 ] ),
								parseFloat( data[ 5 ] ),
								parseFloat( data[ 6 ] )
							).convertSRGBToLinear();

							state.colors.push( _color.r, _color.g, _color.b );

						} else {

							// if no colors are defined, add placeholders so color and vertex indices match

							state.colors.push( undefined, undefined, undefined );

						}

						break;
					case 'vn':
						state.normals.push(
							parseFloat( data[ 1 ] ),
							parseFloat( data[ 2 ] ),
							parseFloat( data[ 3 ] )
						);
						break;
					case 'vt':
						state.uvs.push(
							parseFloat( data[ 1 ] ),
							parseFloat( data[ 2 ] )
						);
						break;

				}

			} else if ( lineFirstChar === 'f' ) {

				const lineData = line.slice( 1 ).trim();
				const vertexData = lineData.split( _face_vertex_data_separator_pattern );
				const faceVertices = [];

				// Parse the face vertex data into an easy to work with format

				for ( let j = 0, jl = vertexData.length; j < jl; j ++ ) {

					const vertex = vertexData[ j ];

					if ( vertex.length > 0 ) {

						const vertexParts = vertex.split( '/' );
						faceVertices.push( vertexParts );

					}

				}

				// Draw an edge between the first vertex and all subsequent vertices to form an n-gon

				const v1 = faceVertices[ 0 ];

				for ( let j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {

					const v2 = faceVertices[ j ];
					const v3 = faceVertices[ j + 1 ];

					state.addFace(
						v1[ 0 ], v2[ 0 ], v3[ 0 ],
						v1[ 1 ], v2[ 1 ], v3[ 1 ],
						v1[ 2 ], v2[ 2 ], v3[ 2 ]
					);

				}

			} else if ( lineFirstChar === 'l' ) {

				const lineParts = line.substring( 1 ).trim().split( ' ' );
				let lineVertices = [];
				const lineUVs = [];

				if ( line.indexOf( '/' ) === - 1 ) {

					lineVertices = lineParts;

				} else {

					for ( let li = 0, llen = lineParts.length; li < llen; li ++ ) {

						const parts = lineParts[ li ].split( '/' );

						if ( parts[ 0 ] !== '' ) lineVertices.push( parts[ 0 ] );
						if ( parts[ 1 ] !== '' ) lineUVs.push( parts[ 1 ] );

					}

				}

				state.addLineGeometry( lineVertices, lineUVs );

			} else if ( lineFirstChar === 'p' ) {

				const lineData = line.slice( 1 ).trim();
				const pointData = lineData.split( ' ' );

				state.addPointGeometry( pointData );

			} else if ( ( result = _object_pattern.exec( line ) ) !== null ) {

				// o object_name
				// or
				// g group_name

				// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
				// let name = result[ 0 ].slice( 1 ).trim();
				const name = ( ' ' + result[ 0 ].slice( 1 ).trim() ).slice( 1 );

				state.startObject( name );

			} else if ( _material_use_pattern.test( line ) ) {

				// material

				state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );

			} else if ( _material_library_pattern.test( line ) ) {

				// mtl file

				state.materialLibraries.push( line.substring( 7 ).trim() );

			} else if ( _map_use_pattern.test( line ) ) {

				// the line is parsed but ignored since the loader assumes textures are defined MTL files
				// (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)

				console.warn( 'THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.' );

			} else if ( lineFirstChar === 's' ) {

				result = line.split( ' ' );

				// smooth shading

				// @todo Handle files that have varying smooth values for a set of faces inside one geometry,
				// but does not define a usemtl for each face set.
				// This should be detected and a dummy material created (later MultiMaterial and geometry groups).
				// This requires some care to not create extra material on each smooth value for "normal" obj files.
				// where explicit usemtl defines geometry groups.
				// Example asset: examples/models/obj/cerberus/Cerberus.obj

				/*
					 * http://paulbourke.net/dataformats/obj/
					 *
					 * From chapter "Grouping" Syntax explanation "s group_number":
					 * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
					 * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
					 * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
					 * than 0."
					 */
				if ( result.length > 1 ) {

					const value = result[ 1 ].trim().toLowerCase();
					state.object.smooth = ( value !== '0' && value !== 'off' );

				} else {

					// ZBrush can produce "s" lines #11707
					state.object.smooth = true;

				}

				const material = state.object.currentMaterial();
				if ( material ) material.smooth = state.object.smooth;

			} else {

				// Handle null terminated files without exception
				if ( line === '\0' ) continue;

				console.warn( 'THREE.OBJLoader: Unexpected line: "' + line + '"' );

			}

		}

		state.finalize();

		const container = new three__WEBPACK_IMPORTED_MODULE_0__["Group"]();
		container.materialLibraries = [].concat( state.materialLibraries );

		const hasPrimitives = ! ( state.objects.length === 1 && state.objects[ 0 ].geometry.vertices.length === 0 );

		if ( hasPrimitives === true ) {

			for ( let i = 0, l = state.objects.length; i < l; i ++ ) {

				const object = state.objects[ i ];
				const geometry = object.geometry;
				const materials = object.materials;
				const isLine = ( geometry.type === 'Line' );
				const isPoints = ( geometry.type === 'Points' );
				let hasVertexColors = false;

				// Skip o/g line declarations that did not follow with any faces
				if ( geometry.vertices.length === 0 ) continue;

				const buffergeometry = new three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]();

				buffergeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( geometry.vertices, 3 ) );

				if ( geometry.normals.length > 0 ) {

					buffergeometry.setAttribute( 'normal', new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( geometry.normals, 3 ) );

				}

				if ( geometry.colors.length > 0 ) {

					hasVertexColors = true;
					buffergeometry.setAttribute( 'color', new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( geometry.colors, 3 ) );

				}

				if ( geometry.hasUVIndices === true ) {

					buffergeometry.setAttribute( 'uv', new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( geometry.uvs, 2 ) );

				}

				// Create materials

				const createdMaterials = [];

				for ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {

					const sourceMaterial = materials[ mi ];
					const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;
					let material = state.materials[ materialHash ];

					if ( this.materials !== null ) {

						material = this.materials.create( sourceMaterial.name );

						// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
						if ( isLine && material && ! ( material instanceof three__WEBPACK_IMPORTED_MODULE_0__["LineBasicMaterial"] ) ) {

							const materialLine = new three__WEBPACK_IMPORTED_MODULE_0__["LineBasicMaterial"]();
							three__WEBPACK_IMPORTED_MODULE_0__["Material"].prototype.copy.call( materialLine, material );
							materialLine.color.copy( material.color );
							material = materialLine;

						} else if ( isPoints && material && ! ( material instanceof three__WEBPACK_IMPORTED_MODULE_0__["PointsMaterial"] ) ) {

							const materialPoints = new three__WEBPACK_IMPORTED_MODULE_0__["PointsMaterial"]( { size: 10, sizeAttenuation: false } );
							three__WEBPACK_IMPORTED_MODULE_0__["Material"].prototype.copy.call( materialPoints, material );
							materialPoints.color.copy( material.color );
							materialPoints.map = material.map;
							material = materialPoints;

						}

					}

					if ( material === undefined ) {

						if ( isLine ) {

							material = new three__WEBPACK_IMPORTED_MODULE_0__["LineBasicMaterial"]();

						} else if ( isPoints ) {

							material = new three__WEBPACK_IMPORTED_MODULE_0__["PointsMaterial"]( { size: 1, sizeAttenuation: false } );

						} else {

							material = new three__WEBPACK_IMPORTED_MODULE_0__["MeshPhongMaterial"]();

						}

						material.name = sourceMaterial.name;
						material.flatShading = sourceMaterial.smooth ? false : true;
						material.vertexColors = hasVertexColors;

						state.materials[ materialHash ] = material;

					}

					createdMaterials.push( material );

				}

				// Create mesh

				let mesh;

				if ( createdMaterials.length > 1 ) {

					for ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {

						const sourceMaterial = materials[ mi ];
						buffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );

					}

					if ( isLine ) {

						mesh = new three__WEBPACK_IMPORTED_MODULE_0__["LineSegments"]( buffergeometry, createdMaterials );

					} else if ( isPoints ) {

						mesh = new three__WEBPACK_IMPORTED_MODULE_0__["Points"]( buffergeometry, createdMaterials );

					} else {

						mesh = new three__WEBPACK_IMPORTED_MODULE_0__["Mesh"]( buffergeometry, createdMaterials );

					}

				} else {

					if ( isLine ) {

						mesh = new three__WEBPACK_IMPORTED_MODULE_0__["LineSegments"]( buffergeometry, createdMaterials[ 0 ] );

					} else if ( isPoints ) {

						mesh = new three__WEBPACK_IMPORTED_MODULE_0__["Points"]( buffergeometry, createdMaterials[ 0 ] );

					} else {

						mesh = new three__WEBPACK_IMPORTED_MODULE_0__["Mesh"]( buffergeometry, createdMaterials[ 0 ] );

					}

				}

				mesh.name = object.name;

				container.add( mesh );

			}

		} else {

			// if there is only the default parser state object with no geometry data, interpret data as point cloud

			if ( state.vertices.length > 0 ) {

				const material = new three__WEBPACK_IMPORTED_MODULE_0__["PointsMaterial"]( { size: 1, sizeAttenuation: false } );

				const buffergeometry = new three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]();

				buffergeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( state.vertices, 3 ) );

				if ( state.colors.length > 0 && state.colors[ 0 ] !== undefined ) {

					buffergeometry.setAttribute( 'color', new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( state.colors, 3 ) );
					material.vertexColors = true;

				}

				const points = new three__WEBPACK_IMPORTED_MODULE_0__["Points"]( buffergeometry, material );
				container.add( points );

			}

		}

		return container;

	}

}




/***/ }),

/***/ "./src/Open_Sans_Bold.json":
/*!*********************************!*\
  !*** ./src/Open_Sans_Bold.json ***!
  \*********************************/
/*! exports provided: glyphs, familyName, ascender, descender, underlinePosition, underlineThickness, boundingBox, resolution, original_font_information, cssFontWeight, cssFontStyle, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"glyphs\":{\"0\":{\"ha\":793,\"x_min\":50,\"x_max\":743,\"o\":\"m 743 496 q 658 111 743 236 q 396 -14 573 -14 q 137 115 224 -14 q 50 496 50 244 q 135 883 50 758 q 396 1007 220 1007 q 655 877 568 1007 q 743 496 743 747 m 258 496 q 290 234 258 313 q 396 155 321 155 q 502 235 469 155 q 534 496 534 315 q 502 758 534 678 q 396 838 469 838 q 290 758 322 838 q 258 496 258 678 z \"},\"1\":{\"ha\":793,\"x_min\":82,\"x_max\":574,\"o\":\"m 574 0 l 364 0 l 364 574 l 366 668 l 370 771 q 297 703 317 719 l 183 611 l 82 737 l 401 991 l 574 991 l 574 0 z \"},\"2\":{\"ha\":793,\"x_min\":53,\"x_max\":749,\"o\":\"m 749 0 l 56 0 l 56 146 l 304 397 q 449 554 415 511 q 498 635 483 598 q 513 713 513 673 q 480 802 513 772 q 392 831 447 831 q 280 804 334 831 q 167 729 226 778 l 53 864 q 174 952 126 926 q 279 992 222 978 q 407 1006 336 1006 q 571 972 500 1006 q 682 877 642 938 q 721 737 721 816 q 697 609 721 669 q 622 486 673 549 q 444 306 572 422 l 317 186 l 317 176 l 749 176 l 749 0 z \"},\"3\":{\"ha\":793,\"x_min\":53,\"x_max\":739,\"o\":\"m 710 770 q 654 612 710 677 q 496 522 597 547 l 496 518 q 677 445 616 503 q 739 289 739 387 q 635 66 739 146 q 339 -14 532 -14 q 53 40 178 -14 l 53 218 q 180 171 111 189 q 317 153 249 153 q 470 188 420 153 q 519 301 519 223 q 463 400 519 371 q 281 429 406 429 l 205 429 l 205 590 l 282 590 q 451 620 397 590 q 504 724 504 650 q 363 836 504 836 q 263 820 314 836 q 151 764 213 804 l 54 908 q 378 1006 190 1006 q 621 943 532 1006 q 710 770 710 881 z \"},\"4\":{\"ha\":793,\"x_min\":24,\"x_max\":771,\"o\":\"m 771 205 l 652 205 l 652 0 l 447 0 l 447 205 l 24 205 l 24 351 l 458 991 l 652 991 l 652 368 l 771 368 l 771 205 m 447 368 l 447 536 q 450 659 447 578 q 456 751 454 739 l 450 751 q 390 643 425 696 l 208 368 l 447 368 z \"},\"5\":{\"ha\":793,\"x_min\":68,\"x_max\":730,\"o\":\"m 416 633 q 645 553 560 633 q 730 332 730 472 q 628 76 730 165 q 335 -14 526 -14 q 68 40 170 -14 l 68 221 q 193 175 121 193 q 328 157 264 157 q 519 314 519 157 q 321 464 519 464 q 241 457 285 464 q 171 441 198 450 l 87 486 l 125 991 l 663 991 l 663 814 l 309 814 l 290 619 l 314 624 q 416 633 355 633 z \"},\"6\":{\"ha\":793,\"x_min\":49,\"x_max\":749,\"o\":\"m 49 421 q 173 859 49 715 q 546 1003 298 1003 q 679 993 631 1003 l 679 825 q 559 839 618 839 q 384 806 452 839 q 281 710 315 774 q 241 529 248 646 l 250 529 q 465 644 317 644 q 673 561 598 644 q 749 330 749 477 q 659 79 749 172 q 411 -14 570 -14 q 219 37 301 -14 q 93 186 138 88 q 49 421 49 283 m 407 154 q 510 199 474 154 q 546 328 546 244 q 512 442 546 400 q 411 484 479 484 q 302 442 347 484 q 257 346 257 401 q 299 210 257 265 q 407 154 342 154 z \"},\"7\":{\"ha\":793,\"x_min\":37,\"x_max\":749,\"o\":\"m 154 0 l 526 814 l 37 814 l 37 990 l 749 990 l 749 859 l 374 0 l 154 0 z \"},\"8\":{\"ha\":793,\"x_min\":49,\"x_max\":745,\"o\":\"m 397 1004 q 627 940 540 1004 q 714 765 714 875 q 672 630 714 689 q 536 524 630 570 q 696 399 648 464 q 745 257 745 334 q 649 61 745 135 q 397 -14 553 -14 q 142 56 235 -14 q 49 252 49 125 q 94 402 49 336 q 239 518 139 468 q 117 633 154 572 q 79 766 79 694 q 168 939 79 873 q 397 1004 256 1004 m 243 264 q 283 173 243 205 q 395 140 324 140 q 511 174 473 140 q 550 262 550 208 q 512 348 550 308 q 387 432 473 387 q 243 264 243 366 m 396 851 q 310 824 342 851 q 277 750 277 796 q 303 677 277 709 q 397 611 329 645 q 490 675 464 642 q 517 750 517 707 q 483 824 517 797 q 396 851 449 851 z \"},\"9\":{\"ha\":793,\"x_min\":45,\"x_max\":745,\"o\":\"m 745 568 q 621 131 745 275 q 248 -14 498 -14 q 114 -4 159 -14 l 114 164 q 233 150 171 150 q 406 181 338 150 q 510 278 474 212 q 551 460 546 344 l 543 460 q 452 370 504 396 q 323 345 401 345 q 119 428 194 345 q 45 659 45 511 q 135 910 45 818 q 382 1003 226 1003 q 574 951 492 1003 q 701 802 656 900 q 745 568 745 704 m 386 835 q 284 790 321 835 q 248 661 248 745 q 281 547 248 589 q 382 505 314 505 q 491 547 446 505 q 536 643 536 589 q 494 779 536 724 q 386 835 452 835 z \"},\" \":{\"ha\":361,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\"!\":{\"ha\":397,\"x_min\":79,\"x_max\":317,\"o\":\"m 282 329 l 117 329 l 82 991 l 317 991 l 282 329 m 79 97 q 110 183 79 154 q 199 212 140 212 q 286 182 255 212 q 317 97 317 153 q 286 13 317 43 q 199 -18 254 -18 q 111 12 142 -18 q 79 97 79 42 z \"},\"\\\"\":{\"ha\":656,\"x_min\":90,\"x_max\":566,\"o\":\"m 279 991 l 252 633 l 118 633 l 90 991 l 279 991 m 566 991 l 538 633 l 404 633 l 376 991 l 566 991 z \"},\"#\":{\"ha\":897,\"x_min\":31,\"x_max\":867,\"o\":\"m 677 572 l 646 415 l 821 415 l 821 275 l 619 275 l 567 0 l 418 0 l 471 275 l 339 275 l 288 0 l 142 0 l 192 275 l 31 275 l 31 415 l 218 415 l 250 572 l 79 572 l 79 714 l 275 714 l 328 990 l 476 990 l 424 714 l 558 714 l 611 990 l 757 990 l 704 714 l 867 714 l 867 572 l 677 572 m 366 415 l 498 415 l 530 572 l 397 572 l 366 415 z \"},\"$\":{\"ha\":793,\"x_min\":60,\"x_max\":741,\"o\":\"m 741 310 q 663 137 741 202 q 444 58 585 71 l 444 -81 l 351 -81 l 351 56 q 61 114 186 59 l 61 293 q 203 241 120 264 q 351 215 286 219 l 351 425 l 306 443 q 116 558 172 496 q 60 711 60 620 q 137 873 60 810 q 351 950 214 937 l 351 1054 l 444 1054 l 444 953 q 725 890 600 946 l 661 732 q 444 785 555 775 l 444 585 q 632 496 576 534 q 714 414 688 459 q 741 310 741 370 m 536 300 q 513 348 536 328 q 444 389 490 368 l 444 220 q 536 300 536 235 m 264 711 q 284 662 264 682 q 351 623 305 643 l 351 782 q 264 711 264 769 z \"},\"%\":{\"ha\":1251,\"x_min\":43,\"x_max\":1208,\"o\":\"m 214 694 q 229 566 214 608 q 278 524 244 524 q 343 694 343 524 q 278 864 343 864 q 229 822 244 864 q 214 694 214 781 m 514 696 q 454 461 514 540 q 277 383 393 383 q 104 464 165 383 q 43 696 43 544 q 277 1006 43 1006 q 453 925 391 1006 q 514 696 514 845 m 981 991 l 431 0 l 268 0 l 818 991 l 981 991 m 908 298 q 923 170 908 212 q 972 127 939 127 q 1038 298 1038 127 q 972 468 1038 468 q 923 426 939 468 q 908 298 908 385 m 1208 300 q 1148 66 1208 144 q 971 -12 1088 -12 q 798 68 859 -12 q 737 300 737 149 q 971 610 737 610 q 1147 529 1086 610 q 1208 300 1208 449 z \"},\"&\":{\"ha\":1042,\"x_min\":56,\"x_max\":1042,\"o\":\"m 1042 0 l 786 0 l 708 77 q 415 -14 578 -14 q 153 62 250 -14 q 56 268 56 138 q 97 426 56 361 q 237 549 138 492 q 163 660 186 607 q 140 777 140 713 q 219 943 140 880 q 431 1006 298 1006 q 632 947 557 1006 q 708 790 708 888 q 661 643 708 709 q 510 515 614 576 l 703 328 q 786 532 751 407 l 1002 532 q 935 353 977 440 q 838 199 892 266 l 1042 0 m 273 288 q 317 195 273 229 q 429 160 361 160 q 583 201 515 160 l 358 425 q 296 363 319 395 q 273 288 273 330 m 517 768 q 492 825 517 804 q 429 846 468 846 q 358 824 384 846 q 332 762 332 802 q 396 631 332 703 q 486 695 454 663 q 517 768 517 726 z \"},\"'\":{\"ha\":370,\"x_min\":90,\"x_max\":279,\"o\":\"m 279 991 l 252 633 l 118 633 l 90 991 l 279 991 z \"},\"(\":{\"ha\":471,\"x_min\":56,\"x_max\":429,\"o\":\"m 56 380 q 108 717 56 560 q 260 991 161 873 l 429 991 q 285 704 334 861 q 236 382 236 547 q 286 61 236 216 q 428 -220 336 -94 l 260 -220 q 108 50 160 -104 q 56 380 56 203 z \"},\")\":{\"ha\":471,\"x_min\":41,\"x_max\":415,\"o\":\"m 415 380 q 362 48 415 202 q 211 -220 310 -106 l 43 -220 q 184 60 134 -95 q 235 382 235 215 q 186 704 235 547 q 41 991 137 861 l 211 991 q 363 716 311 873 q 415 380 415 559 z \"},\"*\":{\"ha\":757,\"x_min\":43,\"x_max\":714,\"o\":\"m 467 1055 l 439 806 l 692 876 l 714 705 l 484 689 l 635 488 l 481 406 l 375 618 l 282 407 l 122 488 l 272 689 l 43 707 l 69 876 l 317 806 l 289 1055 l 467 1055 z \"},\"+\":{\"ha\":793,\"x_min\":60,\"x_max\":733,\"o\":\"m 322 415 l 60 415 l 60 564 l 322 564 l 322 828 l 471 828 l 471 564 l 733 564 l 733 415 l 471 415 l 471 154 l 322 154 l 322 415 z \"},\",\":{\"ha\":403,\"x_min\":43,\"x_max\":311,\"o\":\"m 311 146 q 192 -179 276 9 l 43 -179 q 111 161 87 1 l 301 161 l 311 146 z \"},\"-\":{\"ha\":447,\"x_min\":41,\"x_max\":406,\"o\":\"m 41 288 l 41 457 l 406 457 l 406 288 l 41 288 z \"},\".\":{\"ha\":396,\"x_min\":79,\"x_max\":317,\"o\":\"m 79 97 q 110 183 79 154 q 199 212 140 212 q 286 182 255 212 q 317 97 317 153 q 286 13 317 43 q 199 -18 254 -18 q 111 12 142 -18 q 79 97 79 42 z \"},\"/\":{\"ha\":574,\"x_min\":9,\"x_max\":567,\"o\":\"m 567 991 l 197 0 l 9 0 l 379 991 l 567 991 z \"},\":\":{\"ha\":396,\"x_min\":79,\"x_max\":317,\"o\":\"m 79 97 q 110 183 79 154 q 199 212 140 212 q 286 182 255 212 q 317 97 317 153 q 286 13 317 43 q 199 -18 254 -18 q 111 12 142 -18 q 79 97 79 42 m 79 657 q 110 743 79 714 q 199 772 140 772 q 286 743 255 772 q 317 657 317 713 q 285 572 317 602 q 199 542 254 542 q 111 572 142 542 q 79 657 79 602 z \"},\";\":{\"ha\":403,\"x_min\":43,\"x_max\":317,\"o\":\"m 301 161 l 311 146 q 192 -179 276 9 l 43 -179 q 111 161 87 1 l 301 161 m 79 657 q 110 743 79 714 q 199 772 140 772 q 286 743 255 772 q 317 657 317 713 q 285 572 317 602 q 199 542 254 542 q 111 572 142 542 q 79 657 79 602 z \"},\"<\":{\"ha\":793,\"x_min\":60,\"x_max\":733,\"o\":\"m 733 138 l 60 435 l 60 532 l 733 868 l 733 705 l 269 490 l 733 300 l 733 138 z \"},\"=\":{\"ha\":793,\"x_min\":60,\"x_max\":733,\"o\":\"m 60 546 l 60 694 l 733 694 l 733 546 l 60 546 m 60 283 l 60 432 l 733 432 l 733 283 l 60 283 z \"},\">\":{\"ha\":793,\"x_min\":60,\"x_max\":733,\"o\":\"m 60 300 l 524 490 l 60 705 l 60 868 l 733 532 l 733 435 l 60 138 l 60 300 z \"},\"?\":{\"ha\":663,\"x_min\":4,\"x_max\":629,\"o\":\"m 187 329 l 187 379 q 215 492 187 444 q 317 595 243 541 q 411 677 388 646 q 433 749 433 709 q 401 816 433 793 q 310 839 368 839 q 78 772 208 839 l 4 921 q 325 1006 155 1006 q 547 939 465 1006 q 629 760 629 871 q 595 631 629 685 q 467 509 562 576 q 384 435 401 460 q 367 370 367 410 l 367 329 l 187 329 m 165 97 q 196 183 165 154 q 285 212 227 212 q 372 182 341 212 q 403 97 403 153 q 372 13 403 43 q 285 -18 340 -18 q 197 12 228 -18 q 165 97 165 42 z \"},\"@\":{\"ha\":1246,\"x_min\":69,\"x_max\":1177,\"o\":\"m 1177 510 q 1145 331 1177 412 q 1057 204 1114 250 q 925 158 1000 158 q 836 182 875 158 q 781 245 798 206 l 770 245 q 583 158 696 158 q 394 230 463 158 q 325 428 325 302 q 416 659 325 571 q 653 746 507 746 q 782 735 711 746 q 897 708 852 724 l 882 376 q 933 282 882 282 q 1002 346 977 282 q 1028 511 1028 409 q 983 704 1028 621 q 855 832 937 788 q 667 876 772 876 q 429 820 530 876 q 274 657 328 764 q 220 412 220 551 q 320 125 220 225 q 610 25 420 25 q 768 41 682 25 q 937 87 854 57 l 937 -43 q 615 -104 792 -104 q 213 31 357 -104 q 69 408 69 167 q 143 712 69 576 q 352 927 216 849 q 665 1004 488 1004 q 932 943 814 1004 q 1113 770 1049 882 q 1177 510 1177 657 m 482 425 q 599 282 482 282 q 692 325 660 282 q 730 465 724 368 l 739 615 q 661 623 705 623 q 529 570 576 623 q 482 425 482 517 z \"},\"A\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 z \"},\"B\":{\"ha\":933,\"x_min\":125,\"x_max\":860,\"o\":\"m 125 991 l 433 991 q 740 931 644 991 q 835 741 835 871 q 793 595 835 652 q 682 526 751 538 l 682 519 q 818 441 777 498 q 860 288 860 383 q 762 76 860 152 q 496 0 664 0 l 125 0 l 125 991 m 335 599 l 457 599 q 581 625 543 599 q 619 713 619 652 q 577 794 619 770 q 446 819 536 819 l 335 819 l 335 599 m 335 432 l 335 174 l 472 174 q 600 207 559 174 q 642 309 642 240 q 465 432 642 432 l 335 432 z \"},\"C\":{\"ha\":885,\"x_min\":81,\"x_max\":836,\"o\":\"m 546 831 q 362 742 427 831 q 297 493 297 652 q 546 161 297 161 q 799 214 650 161 l 799 37 q 526 -14 677 -14 q 195 118 310 -14 q 81 494 81 249 q 137 765 81 649 q 299 944 193 882 q 546 1006 404 1006 q 836 936 690 1006 l 768 765 q 656 811 713 791 q 546 831 600 831 z \"},\"D\":{\"ha\":1028,\"x_min\":125,\"x_max\":947,\"o\":\"m 947 505 q 808 130 947 260 q 406 0 669 0 l 125 0 l 125 991 l 436 991 q 813 863 679 991 q 947 505 947 735 m 729 500 q 447 819 729 819 l 335 819 l 335 174 l 425 174 q 729 500 729 174 z \"},\"E\":{\"ha\":778,\"x_min\":125,\"x_max\":696,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 z \"},\"F\":{\"ha\":762,\"x_min\":125,\"x_max\":693,\"o\":\"m 332 0 l 125 0 l 125 991 l 693 991 l 693 819 l 332 819 l 332 564 l 668 564 l 668 392 l 332 392 l 332 0 z \"},\"G\":{\"ha\":1006,\"x_min\":81,\"x_max\":895,\"o\":\"m 501 557 l 895 557 l 895 43 q 714 -1 799 12 q 542 -14 630 -14 q 199 118 317 -14 q 81 497 81 250 q 218 871 81 737 q 599 1006 355 1006 q 893 945 751 1006 l 823 777 q 597 831 715 831 q 379 739 461 831 q 297 493 297 648 q 363 247 297 332 q 555 161 429 161 q 689 175 621 161 l 689 382 l 501 382 l 501 557 z \"},\"H\":{\"ha\":1063,\"x_min\":125,\"x_max\":937,\"o\":\"m 937 0 l 728 0 l 728 428 l 335 428 l 335 0 l 125 0 l 125 991 l 335 991 l 335 603 l 728 603 l 728 991 l 937 991 l 937 0 z \"},\"J\":{\"ha\":460,\"x_min\":-103,\"x_max\":335,\"o\":\"m 21 -292 q -103 -277 -50 -292 l -103 -102 q -4 -115 -49 -115 q 95 -72 65 -115 q 125 62 125 -29 l 125 991 l 335 991 l 335 64 q 256 -201 335 -110 q 21 -292 176 -292 z \"},\"K\":{\"ha\":922,\"x_min\":125,\"x_max\":922,\"o\":\"m 922 0 l 684 0 l 424 418 l 335 354 l 335 0 l 125 0 l 125 991 l 335 991 l 335 538 l 418 654 l 686 991 l 920 991 l 574 553 l 922 0 z \"},\"L\":{\"ha\":785,\"x_min\":125,\"x_max\":737,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 174 l 737 174 l 737 0 l 125 0 z \"},\"M\":{\"ha\":1310,\"x_min\":125,\"x_max\":1185,\"o\":\"m 545 0 l 306 778 l 300 778 q 313 461 313 541 l 313 0 l 125 0 l 125 991 l 411 991 l 646 233 l 650 233 l 899 991 l 1185 991 l 1185 0 l 989 0 l 989 469 q 990 546 989 503 q 999 777 991 589 l 993 777 l 737 0 l 545 0 z \"},\"N\":{\"ha\":1129,\"x_min\":125,\"x_max\":1004,\"o\":\"m 1004 0 l 737 0 l 306 750 l 300 750 q 313 467 313 551 l 313 0 l 125 0 l 125 991 l 390 991 l 821 249 l 825 249 q 815 522 815 442 l 815 991 l 1004 991 l 1004 0 z \"},\"O\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 z \"},\"P\":{\"ha\":872,\"x_min\":125,\"x_max\":810,\"o\":\"m 335 525 l 404 525 q 549 563 501 525 q 597 675 597 602 q 557 784 597 749 q 431 819 517 819 l 335 819 l 335 525 m 810 682 q 710 437 810 522 q 425 353 610 353 l 335 353 l 335 0 l 125 0 l 125 991 l 441 991 q 716 914 622 991 q 810 682 810 836 z \"},\"Q\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 963 204 1025 322 q 781 31 901 85 l 1019 -236 l 750 -236 l 568 -14 l 553 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 z \"},\"R\":{\"ha\":917,\"x_min\":125,\"x_max\":917,\"o\":\"m 335 551 l 403 551 q 550 585 503 551 q 597 689 597 618 q 549 789 597 760 q 399 819 500 819 l 335 819 l 335 551 m 335 380 l 335 0 l 125 0 l 125 991 l 414 991 q 713 918 616 991 q 810 694 810 844 q 762 539 810 607 q 625 432 713 471 q 917 0 849 98 l 684 0 l 447 380 l 335 380 z \"},\"S\":{\"ha\":765,\"x_min\":64,\"x_max\":710,\"o\":\"m 710 275 q 613 64 710 141 q 345 -14 517 -14 q 64 46 186 -14 l 64 241 q 234 178 164 197 q 361 160 303 160 q 467 186 430 160 q 504 265 504 213 q 488 317 504 294 q 440 361 471 340 q 311 428 408 382 q 175 510 220 471 q 102 602 130 549 q 75 724 75 654 q 164 930 75 855 q 411 1006 254 1006 q 558 987 488 1006 q 705 936 629 969 l 637 772 q 506 818 558 805 q 404 831 454 831 q 313 803 345 831 q 281 730 281 775 q 294 682 281 703 q 335 642 307 661 q 468 572 363 623 q 659 439 607 506 q 710 275 710 372 z \"},\"T\":{\"ha\":804,\"x_min\":28,\"x_max\":777,\"o\":\"m 507 0 l 297 0 l 297 817 l 28 817 l 28 991 l 777 991 l 777 817 l 507 817 l 507 0 z \"},\"U\":{\"ha\":1050,\"x_min\":118,\"x_max\":932,\"o\":\"m 932 991 l 932 350 q 883 157 932 240 q 741 31 833 75 q 521 -14 648 -14 q 224 84 330 -14 q 118 353 118 182 l 118 991 l 328 991 l 328 385 q 374 216 328 270 q 526 163 420 163 q 676 217 629 163 q 722 386 722 271 l 722 991 l 932 991 z \"},\"V\":{\"ha\":903,\"x_min\":0,\"x_max\":903,\"o\":\"m 690 991 l 903 991 l 566 0 l 336 0 l 0 991 l 212 991 l 399 401 q 431 280 414 349 q 452 183 448 210 q 503 401 459 245 l 690 991 z \"},\"W\":{\"ha\":1343,\"x_min\":0,\"x_max\":1343,\"o\":\"m 1090 0 l 851 0 l 717 521 q 691 636 709 549 q 671 753 673 723 q 650 635 667 716 q 625 519 634 554 l 492 0 l 253 0 l 0 991 l 207 991 l 334 450 q 382 191 367 300 q 400 310 386 229 q 428 436 415 391 l 572 991 l 771 991 l 916 436 q 939 322 925 399 q 961 191 954 245 q 983 322 968 243 q 1010 450 998 401 l 1136 991 l 1343 991 l 1090 0 z \"},\"X\":{\"ha\":926,\"x_min\":0,\"x_max\":926,\"o\":\"m 926 0 l 686 0 l 456 375 l 225 0 l 0 0 l 329 511 l 21 991 l 253 991 l 467 635 l 676 991 l 903 991 l 591 500 l 926 0 z \"},\"Y\":{\"ha\":867,\"x_min\":0,\"x_max\":867,\"o\":\"m 433 583 l 640 991 l 867 991 l 538 386 l 538 0 l 329 0 l 329 379 l 0 991 l 228 991 l 433 583 z \"},\"Z\":{\"ha\":804,\"x_min\":33,\"x_max\":771,\"o\":\"m 771 0 l 33 0 l 33 136 l 509 818 l 46 818 l 46 991 l 758 991 l 758 856 l 283 174 l 771 174 l 771 0 z \"},\"[\":{\"ha\":460,\"x_min\":97,\"x_max\":425,\"o\":\"m 425 -220 l 97 -220 l 97 991 l 425 991 l 425 848 l 273 848 l 273 -77 l 425 -77 l 425 -220 z \"},\"\\\\\":{\"ha\":574,\"x_min\":8,\"x_max\":566,\"o\":\"m 196 991 l 566 0 l 378 0 l 8 991 l 196 991 z \"},\"]\":{\"ha\":460,\"x_min\":35,\"x_max\":363,\"o\":\"m 35 -77 l 186 -77 l 186 848 l 35 848 l 35 991 l 363 991 l 363 -220 l 35 -220 l 35 -77 z \"},\"^\":{\"ha\":739,\"x_min\":5,\"x_max\":736,\"o\":\"m 5 353 l 302 997 l 400 997 l 736 353 l 574 353 l 355 789 l 165 353 l 5 353 z \"},\"_\":{\"ha\":571,\"x_min\":-3,\"x_max\":574,\"o\":\"m 574 -220 l -3 -220 l -3 -125 l 574 -125 l 574 -220 z \"},\"`\":{\"ha\":843,\"x_min\":225,\"x_max\":616,\"o\":\"m 479 842 q 354 938 437 871 q 225 1050 271 1005 l 225 1064 l 457 1064 q 616 860 500 996 l 616 842 l 479 842 z \"},\"a\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 z \"},\"b\":{\"ha\":879,\"x_min\":109,\"x_max\":817,\"o\":\"m 530 772 q 741 668 665 772 q 817 380 817 563 q 738 90 817 193 q 525 -14 660 -14 q 315 83 391 -14 l 301 83 l 267 0 l 109 0 l 109 1055 l 315 1055 l 315 810 q 307 660 315 763 l 315 660 q 530 772 388 772 m 464 607 q 352 560 387 607 q 315 404 317 513 l 315 382 q 352 207 315 260 q 467 154 388 154 q 568 213 530 154 q 606 383 606 271 q 568 551 606 495 q 464 607 530 607 z \"},\"c\":{\"ha\":714,\"x_min\":62,\"x_max\":671,\"o\":\"m 416 -14 q 62 375 62 -14 q 159 670 62 568 q 435 772 255 772 q 671 721 566 772 l 610 561 q 519 593 561 581 q 435 606 477 606 q 273 376 273 606 q 435 154 273 154 q 545 170 494 154 q 647 220 596 186 l 647 43 q 546 -1 597 11 q 416 -14 494 -14 z \"},\"d\":{\"ha\":879,\"x_min\":62,\"x_max\":771,\"o\":\"m 349 -14 q 139 90 215 -14 q 62 378 62 194 q 140 668 62 564 q 354 772 218 772 q 572 661 497 772 l 579 661 q 564 812 564 746 l 564 1055 l 771 1055 l 771 0 l 612 0 l 572 98 l 564 98 q 349 -14 493 -14 m 421 151 q 537 197 500 151 q 578 354 574 243 l 578 376 q 540 551 578 498 q 418 604 503 604 q 310 546 349 604 q 272 375 272 487 q 311 207 272 263 q 421 151 349 151 z \"},\"e\":{\"ha\":821,\"x_min\":62,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 z \"},\"f\":{\"ha\":538,\"x_min\":28,\"x_max\":600,\"o\":\"m 528 603 l 349 603 l 349 0 l 142 0 l 142 603 l 28 603 l 28 703 l 142 758 l 142 814 q 205 1003 142 943 q 410 1063 269 1063 q 600 1031 517 1063 l 547 879 q 432 899 485 899 q 368 872 388 899 q 349 806 349 846 l 349 758 l 528 758 l 528 603 z \"},\"g\":{\"ha\":785,\"x_min\":4,\"x_max\":768,\"o\":\"m 768 758 l 768 653 l 650 623 q 682 509 682 572 q 597 318 682 387 q 361 250 512 250 l 323 252 l 293 256 q 261 201 261 231 q 375 157 261 157 l 504 157 q 694 103 629 157 q 760 -54 760 50 q 649 -260 760 -187 q 330 -334 538 -334 q 88 -278 172 -334 q 4 -123 4 -223 q 47 -9 4 -55 q 172 57 90 37 q 117 101 140 71 q 93 167 93 132 q 118 239 93 210 q 191 296 143 268 q 96 378 131 321 q 61 513 61 435 q 142 705 61 637 q 372 772 222 772 q 448 767 404 772 q 504 758 492 761 l 768 758 m 183 -107 q 224 -174 183 -150 q 339 -199 265 -199 q 513 -168 450 -199 q 576 -85 576 -138 q 539 -26 576 -42 q 424 -9 502 -9 l 317 -9 q 221 -36 260 -9 q 183 -107 183 -63 m 258 510 q 287 412 258 448 q 372 376 315 376 q 458 412 431 376 q 485 510 485 448 q 372 647 485 647 q 258 510 258 647 z \"},\"h\":{\"ha\":913,\"x_min\":109,\"x_max\":808,\"o\":\"m 808 0 l 602 0 l 602 443 q 479 607 602 607 q 354 548 393 607 q 315 357 315 489 l 315 0 l 109 0 l 109 1055 l 315 1055 l 315 840 q 311 722 315 815 l 306 661 l 317 661 q 536 772 386 772 q 739 701 670 772 q 808 494 808 629 l 808 0 z \"},\"i\":{\"ha\":424,\"x_min\":100,\"x_max\":325,\"o\":\"m 100 954 q 212 1055 100 1055 q 325 954 325 1055 q 297 879 325 906 q 212 852 269 852 q 100 954 100 852 m 315 0 l 109 0 l 109 758 l 315 758 l 315 0 z \"},\"j\":{\"ha\":424,\"x_min\":-89,\"x_max\":325,\"o\":\"m 47 -334 q -89 -317 -32 -334 l -89 -154 q 8 -167 -41 -167 q 84 -138 60 -167 q 109 -52 109 -109 l 109 758 l 315 758 l 315 -82 q 245 -268 315 -203 q 47 -334 176 -334 m 100 954 q 212 1055 100 1055 q 325 954 325 1055 q 297 879 325 906 q 212 852 269 852 q 100 954 100 852 z \"},\"k\":{\"ha\":861,\"x_min\":109,\"x_max\":861,\"o\":\"m 307 412 l 397 528 l 610 758 l 843 758 l 542 429 l 861 0 l 623 0 l 404 307 l 315 236 l 315 0 l 109 0 l 109 1055 l 315 1055 l 315 585 l 304 412 l 307 412 z \"},\"l\":{\"ha\":424,\"x_min\":109,\"x_max\":315,\"o\":\"m 315 0 l 109 0 l 109 1055 l 315 1055 l 315 0 z \"},\"m\":{\"ha\":1364,\"x_min\":109,\"x_max\":1260,\"o\":\"m 787 0 l 581 0 l 581 443 q 553 566 581 525 q 467 607 526 607 q 351 549 387 607 q 315 357 315 490 l 315 0 l 109 0 l 109 758 l 267 758 l 294 661 l 306 661 q 394 743 336 713 q 526 772 452 772 q 757 661 696 772 l 775 661 q 865 743 806 714 q 999 772 924 772 q 1194 706 1128 772 q 1260 494 1260 640 l 1260 0 l 1053 0 l 1053 443 q 1025 566 1053 525 q 939 607 998 607 q 825 553 863 607 q 787 380 787 498 l 787 0 z \"},\"n\":{\"ha\":913,\"x_min\":109,\"x_max\":808,\"o\":\"m 808 0 l 602 0 l 602 443 q 572 566 602 525 q 479 607 543 607 q 354 549 393 607 q 315 357 315 491 l 315 0 l 109 0 l 109 758 l 267 758 l 294 661 l 306 661 q 401 744 340 716 q 539 772 462 772 q 740 701 671 772 q 808 494 808 629 l 808 0 z \"},\"o\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 z \"},\"p\":{\"ha\":879,\"x_min\":109,\"x_max\":817,\"o\":\"m 525 -14 q 315 83 391 -14 l 304 83 q 315 -26 315 -12 l 315 -334 l 109 -334 l 109 758 l 277 758 l 306 660 l 315 660 q 530 772 388 772 q 741 669 665 772 q 817 380 817 565 q 781 170 817 259 q 680 33 745 80 q 525 -14 614 -14 m 464 607 q 352 560 387 607 q 315 404 317 513 l 315 382 q 352 207 315 260 q 467 154 388 154 q 606 383 606 154 q 571 551 606 495 q 464 607 537 607 z \"},\"q\":{\"ha\":879,\"x_min\":62,\"x_max\":771,\"o\":\"m 422 149 q 538 194 501 149 q 578 351 574 239 l 578 376 q 540 551 578 498 q 419 604 503 604 q 273 375 273 604 q 310 205 273 261 q 422 149 346 149 m 349 -14 q 138 90 214 -14 q 62 378 62 193 q 140 668 62 564 q 353 772 218 772 q 478 745 425 772 q 572 661 532 718 l 578 661 l 596 758 l 771 758 l 771 -334 l 564 -334 l 564 -16 q 572 98 564 26 l 564 98 q 475 15 530 43 q 349 -14 420 -14 z \"},\"r\":{\"ha\":631,\"x_min\":109,\"x_max\":602,\"o\":\"m 532 772 q 602 766 574 772 l 586 572 q 525 579 561 579 q 371 528 426 579 q 315 386 315 477 l 315 0 l 109 0 l 109 758 l 265 758 l 296 631 l 306 631 q 401 733 341 694 q 532 772 461 772 z \"},\"s\":{\"ha\":690,\"x_min\":62,\"x_max\":637,\"o\":\"m 637 225 q 556 47 637 109 q 314 -14 475 -14 q 173 -2 231 -14 q 64 31 115 9 l 64 201 q 194 156 121 174 q 321 138 266 138 q 433 203 433 138 q 418 242 433 227 q 367 277 404 258 q 269 322 330 296 q 141 390 182 359 q 81 461 100 421 q 62 561 62 502 q 141 717 62 662 q 363 772 219 772 q 629 713 500 772 l 567 564 q 460 604 510 588 q 359 619 411 619 q 268 570 268 619 q 297 522 268 542 q 427 461 327 501 q 557 394 515 425 q 618 322 598 363 q 637 225 637 281 z \"},\"t\":{\"ha\":603,\"x_min\":32,\"x_max\":558,\"o\":\"m 428 151 q 558 175 482 151 l 558 21 q 368 -14 481 -14 q 188 49 244 -14 q 131 237 131 112 l 131 603 l 32 603 l 32 690 l 146 760 l 205 920 l 338 920 l 338 758 l 550 758 l 550 603 l 338 603 l 338 237 q 362 172 338 193 q 428 151 387 151 z \"},\"u\":{\"ha\":913,\"x_min\":104,\"x_max\":804,\"o\":\"m 646 0 l 618 97 l 607 97 q 513 15 574 44 q 374 -14 452 -14 q 172 58 240 -14 q 104 264 104 130 l 104 758 l 311 758 l 311 315 q 340 192 311 233 q 433 151 370 151 q 559 209 520 151 q 597 401 597 267 l 597 758 l 804 758 l 804 0 l 646 0 z \"},\"v\":{\"ha\":790,\"x_min\":0,\"x_max\":790,\"o\":\"m 289 0 l 0 758 l 216 758 l 363 326 q 393 171 387 244 l 397 171 q 428 326 401 236 l 574 758 l 790 758 l 501 0 l 289 0 z \"},\"w\":{\"ha\":1189,\"x_min\":14,\"x_max\":1175,\"o\":\"m 732 0 l 673 265 l 595 600 l 590 600 l 452 0 l 229 0 l 14 758 l 220 758 l 307 422 q 350 174 328 332 l 354 174 q 378 337 357 225 l 389 395 l 482 758 l 710 758 l 799 395 q 807 351 802 380 q 819 289 813 321 q 828 224 824 256 q 833 174 833 193 l 838 174 q 859 308 844 222 q 882 422 875 393 l 972 758 l 1175 758 l 957 0 l 732 0 z \"},\"x\":{\"ha\":803,\"x_min\":7,\"x_max\":796,\"o\":\"m 264 387 l 20 758 l 254 758 l 401 517 l 550 758 l 785 758 l 538 387 l 796 0 l 561 0 l 401 260 l 241 0 l 7 0 l 264 387 z \"},\"y\":{\"ha\":790,\"x_min\":0,\"x_max\":790,\"o\":\"m 0 758 l 227 758 l 370 332 q 395 200 388 276 l 399 200 q 428 332 406 270 l 568 758 l 790 758 l 469 -97 q 343 -275 425 -216 q 153 -334 262 -334 q 47 -322 99 -334 l 47 -158 q 129 -167 85 -167 q 225 -133 184 -167 q 289 -32 266 -100 l 301 5 l 0 758 z \"},\"z\":{\"ha\":677,\"x_min\":37,\"x_max\":636,\"o\":\"m 636 0 l 37 0 l 37 122 l 389 600 l 58 600 l 58 758 l 624 758 l 624 624 l 282 158 l 636 158 l 636 0 z \"},\"{\":{\"ha\":547,\"x_min\":21,\"x_max\":492,\"o\":\"m 195 183 q 150 273 195 242 q 21 304 106 304 l 21 467 q 151 496 106 467 q 195 582 195 526 l 195 587 l 195 803 q 260 949 195 907 q 492 991 326 991 l 492 839 q 399 813 425 837 q 374 743 374 789 l 374 541 q 215 390 370 413 l 215 382 q 374 238 374 358 l 374 232 l 374 29 q 399 -41 374 -17 q 492 -66 424 -64 l 492 -220 q 260 -177 326 -220 q 195 -31 195 -135 l 195 183 z \"},\"|\":{\"ha\":765,\"x_min\":309,\"x_max\":457,\"o\":\"m 309 1051 l 457 1051 l 457 -315 l 309 -315 l 309 1051 z \"},\"}\":{\"ha\":547,\"x_min\":56,\"x_max\":526,\"o\":\"m 353 -31 q 325 -145 353 -106 q 233 -202 297 -184 q 56 -220 169 -220 l 56 -66 q 148 -42 123 -65 q 174 29 174 -19 l 174 232 l 174 239 q 214 334 174 298 q 332 382 254 370 l 332 390 q 174 541 178 413 l 174 743 q 149 814 174 791 q 56 839 123 837 l 56 991 q 233 974 169 991 q 325 917 298 956 q 353 803 353 878 l 353 587 l 353 581 q 394 495 353 524 q 526 467 436 467 l 526 304 q 397 277 441 304 q 353 183 353 249 l 353 -31 z \"},\"~\":{\"ha\":793,\"x_min\":60,\"x_max\":733,\"o\":\"m 218 456 q 139 433 181 456 q 60 374 96 410 l 60 530 q 233 604 130 604 q 327 593 283 604 q 421 561 370 583 q 575 524 509 524 q 654 545 611 524 q 733 606 696 567 l 733 449 q 559 375 665 375 q 474 384 515 375 q 372 418 433 393 q 218 456 283 456 z \"},\" \":{\"ha\":361,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\"¡\":{\"ha\":397,\"x_min\":79,\"x_max\":317,\"o\":\"m 114 411 l 279 411 l 314 -250 l 79 -250 l 114 411 m 317 643 q 286 557 317 586 q 197 528 256 528 q 110 557 141 528 q 79 643 79 587 q 111 728 79 698 q 197 758 142 758 q 286 728 254 758 q 317 643 317 699 z \"},\"¢\":{\"ha\":793,\"x_min\":97,\"x_max\":705,\"o\":\"m 382 119 q 97 503 97 159 q 168 776 97 680 q 382 893 239 872 l 382 1006 l 503 1006 l 503 899 q 705 848 615 892 l 644 689 q 553 721 595 709 q 469 733 511 733 q 348 676 387 733 q 309 504 309 620 q 469 282 309 282 q 570 293 525 282 q 682 334 614 303 l 682 161 q 503 114 596 120 l 503 -14 l 382 -14 l 382 119 z \"},\"£\":{\"ha\":793,\"x_min\":56,\"x_max\":766,\"o\":\"m 475 1006 q 739 950 607 1006 l 676 794 q 492 838 570 838 q 410 807 439 838 q 382 721 382 777 l 382 590 l 636 590 l 636 441 l 382 441 l 382 345 q 279 176 382 229 l 766 176 l 766 0 l 56 0 l 56 168 q 152 237 125 198 q 178 343 178 275 l 178 441 l 57 441 l 57 590 l 178 590 l 178 722 q 255 932 178 859 q 475 1006 333 1006 z \"},\"¤\":{\"ha\":793,\"x_min\":77,\"x_max\":717,\"o\":\"m 127 490 q 164 624 127 559 l 77 710 l 176 810 l 262 724 q 396 760 324 760 q 529 722 467 760 l 615 810 l 717 713 l 629 625 q 665 490 665 565 q 629 355 665 418 l 714 271 l 615 172 l 529 257 q 396 222 465 222 q 261 257 318 222 l 176 174 l 78 272 l 164 357 q 127 490 127 420 m 268 490 q 305 400 268 438 q 396 363 342 363 q 489 400 451 363 q 526 490 526 437 q 488 582 526 545 q 396 619 450 619 q 306 581 343 619 q 268 490 268 543 z \"},\"¥\":{\"ha\":793,\"x_min\":4,\"x_max\":787,\"o\":\"m 396 583 l 575 991 l 787 991 l 528 485 l 660 485 l 660 364 l 493 364 l 493 271 l 660 271 l 660 150 l 493 150 l 493 0 l 298 0 l 298 150 l 131 150 l 131 271 l 298 271 l 298 364 l 131 364 l 131 485 l 260 485 l 4 991 l 218 991 l 396 583 z \"},\"¦\":{\"ha\":765,\"x_min\":309,\"x_max\":457,\"o\":\"m 309 1051 l 457 1051 l 457 498 l 309 498 l 309 1051 m 309 237 l 457 237 l 457 -315 l 309 -315 l 309 237 z \"},\"§\":{\"ha\":675,\"x_min\":72,\"x_max\":607,\"o\":\"m 82 546 q 106 644 82 600 q 172 715 131 688 q 82 873 82 772 q 158 1016 82 962 q 357 1069 233 1069 q 603 1013 472 1069 l 547 884 q 453 923 501 905 q 353 940 406 940 q 273 924 298 940 q 248 876 248 909 q 281 818 248 843 q 392 762 315 793 q 555 662 503 719 q 607 530 607 604 q 522 354 607 410 q 586 291 564 327 q 607 205 607 256 q 526 46 607 105 q 309 -14 445 -14 q 72 40 171 -14 l 72 180 q 194 133 127 153 q 309 114 261 114 q 440 193 440 114 q 428 236 440 220 q 385 270 415 252 q 300 310 354 287 q 129 413 176 360 q 82 546 82 467 m 233 561 q 277 480 233 515 q 400 414 321 445 q 453 513 453 452 q 419 591 453 559 q 294 656 385 623 q 251 620 269 646 q 233 561 233 593 z \"},\"¨\":{\"ha\":843,\"x_min\":189,\"x_max\":654,\"o\":\"m 189 953 q 215 1021 189 997 q 283 1044 240 1044 q 354 1019 328 1044 q 379 953 379 994 q 353 887 379 912 q 283 863 328 863 q 215 886 240 863 q 189 953 189 910 m 463 953 q 490 1022 463 1000 q 558 1044 517 1044 q 628 1020 602 1044 q 654 953 654 996 q 628 887 654 911 q 558 863 602 863 q 490 885 517 863 q 463 953 463 907 z \"},\"©\":{\"ha\":1156,\"x_min\":68,\"x_max\":1088,\"o\":\"m 607 685 q 505 635 541 685 q 469 496 469 585 q 607 306 469 306 q 690 316 646 306 q 774 346 735 326 l 774 216 q 603 178 692 178 q 389 262 465 178 q 313 497 313 347 q 388 729 313 646 q 597 812 463 812 q 804 760 699 812 l 754 646 q 607 685 677 685 m 68 496 q 136 750 68 631 q 322 937 203 869 q 578 1006 441 1006 q 832 938 713 1006 q 1019 751 951 870 q 1088 496 1088 633 q 1022 245 1088 362 q 838 57 956 127 q 578 -14 719 -14 q 319 57 437 -14 q 134 244 200 127 q 68 496 68 361 m 164 496 q 220 289 164 385 q 372 137 275 193 q 578 82 468 82 q 785 138 689 82 q 936 290 881 193 q 991 496 991 386 q 936 703 991 607 q 784 854 880 799 q 578 909 688 909 q 371 854 467 909 q 219 702 275 798 q 164 496 164 606 z \"},\"ª\":{\"ha\":532,\"x_min\":32,\"x_max\":472,\"o\":\"m 380 518 l 359 593 q 288 532 330 553 q 196 510 246 510 q 74 550 117 510 q 32 661 32 589 q 88 772 32 735 q 269 815 144 809 l 336 818 q 250 897 336 897 q 103 856 195 897 l 58 947 q 157 986 103 969 q 278 1003 211 1003 q 421 955 371 1003 q 472 818 472 907 l 472 518 l 380 518 m 171 663 q 186 625 171 637 q 224 612 202 612 q 306 641 276 612 q 336 713 336 669 l 336 737 l 269 733 q 171 663 171 726 z \"},\"«\":{\"ha\":854,\"x_min\":56,\"x_max\":799,\"o\":\"m 56 389 l 307 697 l 456 616 l 267 380 l 456 144 l 307 64 l 56 371 l 56 389 m 399 389 l 650 697 l 799 616 l 610 380 l 799 144 l 650 64 l 399 371 l 399 389 z \"},\"¬\":{\"ha\":793,\"x_min\":60,\"x_max\":733,\"o\":\"m 733 168 l 585 168 l 585 415 l 60 415 l 60 564 l 733 564 l 733 168 z \"},\"­\":{\"ha\":447,\"x_min\":41,\"x_max\":406,\"o\":\"m 41 288 l 41 457 l 406 457 l 406 288 l 41 288 z \"},\"®\":{\"ha\":1156,\"x_min\":68,\"x_max\":1088,\"o\":\"m 785 614 q 688 456 785 498 l 848 184 l 676 184 l 555 414 l 524 414 l 524 184 l 368 184 l 368 806 l 547 806 q 727 758 670 806 q 785 614 785 711 m 524 528 l 545 528 q 609 547 589 528 q 628 611 628 566 q 609 673 628 655 q 543 692 590 692 l 524 692 l 524 528 m 68 496 q 136 750 68 631 q 322 937 203 869 q 578 1006 441 1006 q 832 938 713 1006 q 1019 751 951 870 q 1088 496 1088 633 q 1022 245 1088 362 q 838 57 956 127 q 578 -14 719 -14 q 319 57 437 -14 q 134 244 200 127 q 68 496 68 361 m 164 496 q 220 289 164 385 q 372 137 275 193 q 578 82 468 82 q 785 138 689 82 q 936 290 881 193 q 991 496 991 386 q 936 703 991 607 q 784 854 880 799 q 578 909 688 909 q 371 854 467 909 q 219 702 275 798 q 164 496 164 606 z \"},\"¯\":{\"ha\":694,\"x_min\":-4,\"x_max\":699,\"o\":\"m 699 1055 l -4 1055 l -4 1192 l 699 1192 l 699 1055 z \"},\"°\":{\"ha\":595,\"x_min\":62,\"x_max\":532,\"o\":\"m 62 771 q 94 888 62 833 q 179 974 125 942 q 297 1006 233 1006 q 414 975 359 1006 q 500 888 469 943 q 532 771 532 833 q 500 653 532 708 q 414 568 469 599 q 297 538 360 538 q 131 605 199 538 q 62 771 62 673 m 192 771 q 222 697 192 728 q 297 667 252 667 q 372 698 342 667 q 403 771 403 729 q 372 846 403 814 q 297 878 341 878 q 223 846 254 878 q 192 771 192 815 z \"},\"±\":{\"ha\":793,\"x_min\":60,\"x_max\":733,\"o\":\"m 322 457 l 60 457 l 60 606 l 322 606 l 322 869 l 471 869 l 471 606 l 733 606 l 733 457 l 471 457 l 471 196 l 322 196 l 322 457 m 60 0 l 60 149 l 733 149 l 733 0 l 60 0 z \"},\"²\":{\"ha\":526,\"x_min\":32,\"x_max\":476,\"o\":\"m 476 397 l 37 397 l 37 511 l 189 660 q 278 758 258 728 q 297 822 297 788 q 281 861 297 848 q 237 875 264 875 q 115 815 182 875 l 32 918 q 260 1006 132 1006 q 406 961 353 1006 q 460 836 460 916 q 428 728 460 779 q 309 597 396 677 l 237 533 l 476 533 l 476 397 z \"},\"³\":{\"ha\":526,\"x_min\":40,\"x_max\":471,\"o\":\"m 452 847 q 336 713 452 750 l 336 704 q 435 653 400 690 q 471 562 471 616 q 411 433 471 480 q 225 386 351 386 q 40 433 128 386 l 40 562 q 224 501 140 501 q 321 574 321 501 q 291 628 321 610 q 208 646 261 646 l 132 646 l 132 754 l 195 754 q 278 772 251 754 q 306 828 306 789 q 289 871 306 854 q 237 888 272 888 q 177 875 205 888 q 110 835 149 862 l 41 930 q 135 983 83 962 q 256 1004 186 1004 q 397 961 342 1004 q 452 847 452 918 z \"},\"´\":{\"ha\":843,\"x_min\":225,\"x_max\":616,\"o\":\"m 225 842 l 225 860 q 385 1064 342 996 l 616 1064 l 616 1050 q 496 945 581 1015 q 363 842 411 876 l 225 842 z \"},\"µ\":{\"ha\":917,\"x_min\":109,\"x_max\":808,\"o\":\"m 315 315 q 345 192 315 233 q 439 151 375 151 q 563 210 524 151 q 602 401 602 269 l 602 758 l 808 758 l 808 0 l 652 0 l 623 102 l 612 102 q 543 15 584 44 q 443 -14 503 -14 q 366 2 401 -14 q 309 47 330 18 l 312 -10 l 315 -117 l 315 -334 l 109 -334 l 109 758 l 315 758 l 315 315 z \"},\"¶\":{\"ha\":909,\"x_min\":77,\"x_max\":791,\"o\":\"m 791 -176 l 682 -176 l 682 920 l 570 920 l 570 -176 l 460 -176 l 460 379 q 361 367 418 367 q 145 452 214 367 q 77 707 77 536 q 151 969 77 883 q 382 1055 224 1055 l 791 1055 l 791 -176 z \"},\"·\":{\"ha\":396,\"x_min\":79,\"x_max\":317,\"o\":\"m 79 490 q 110 576 79 547 q 199 606 140 606 q 286 576 255 606 q 317 490 317 546 q 285 405 317 435 q 199 375 254 375 q 111 405 142 375 q 79 490 79 435 z \"},\"¸\":{\"ha\":285,\"x_min\":-25,\"x_max\":283,\"o\":\"m 283 -170 q 232 -295 283 -256 q 74 -334 181 -334 q -25 -319 21 -334 l -25 -205 q 24 -215 -7 -210 q 72 -220 55 -220 q 121 -178 121 -220 q 8 -104 121 -121 l 61 0 l 192 0 l 174 -41 q 254 -92 224 -58 q 283 -170 283 -126 z \"},\"¹\":{\"ha\":526,\"x_min\":62,\"x_max\":396,\"o\":\"m 396 397 l 235 397 l 235 700 l 237 776 l 240 840 q 189 787 222 816 l 136 746 l 62 832 l 267 991 l 396 991 l 396 397 z \"},\"º\":{\"ha\":539,\"x_min\":39,\"x_max\":500,\"o\":\"m 500 757 q 438 575 500 641 q 268 510 376 510 q 101 577 164 510 q 39 757 39 644 q 99 937 39 871 q 271 1003 160 1003 q 437 936 374 1003 q 500 757 500 869 m 176 757 q 198 655 176 689 q 269 621 220 621 q 339 655 318 621 q 361 757 361 689 q 339 858 361 825 q 269 892 318 892 q 198 858 220 892 q 176 757 176 825 z \"},\"»\":{\"ha\":854,\"x_min\":56,\"x_max\":799,\"o\":\"m 799 371 l 547 64 l 399 144 l 587 380 l 399 616 l 547 697 l 799 389 l 799 371 m 456 371 l 204 64 l 56 144 l 244 380 l 56 616 l 204 697 l 456 389 l 456 371 z \"},\"¼\":{\"ha\":1223,\"x_min\":31,\"x_max\":1141,\"o\":\"m 365 397 l 203 397 l 203 700 l 205 776 l 209 840 q 158 787 191 816 l 105 746 l 31 832 l 235 991 l 365 991 l 365 397 m 929 991 l 379 0 l 217 0 l 767 991 l 929 991 m 1141 103 l 1056 103 l 1056 1 l 895 1 l 895 103 l 635 103 l 635 208 l 896 599 l 1056 599 l 1056 217 l 1141 217 l 1141 103 m 895 217 l 895 328 q 899 453 895 387 q 874 399 892 435 q 846 347 857 362 l 760 217 l 895 217 z \"},\"½\":{\"ha\":1223,\"x_min\":31,\"x_max\":1164,\"o\":\"m 365 397 l 203 397 l 203 700 l 205 776 l 209 840 q 158 787 191 816 l 105 746 l 31 832 l 235 991 l 365 991 l 365 397 m 929 991 l 379 0 l 217 0 l 767 991 l 929 991 m 1164 1 l 725 1 l 725 115 l 877 263 q 965 361 946 331 q 985 425 985 391 q 968 465 985 451 q 925 478 952 478 q 803 418 870 478 l 720 522 q 947 609 819 609 q 1094 564 1040 609 q 1147 439 1147 519 q 1116 331 1147 382 q 996 201 1084 280 l 925 136 l 1164 136 l 1164 1 z \"},\"¾\":{\"ha\":1223,\"x_min\":61,\"x_max\":1161,\"o\":\"m 473 847 q 357 713 473 750 l 357 704 q 456 653 421 690 q 492 562 492 616 q 432 433 492 480 q 246 386 372 386 q 61 433 149 386 l 61 562 q 245 501 161 501 q 342 574 342 501 q 312 628 342 610 q 229 646 282 646 l 153 646 l 153 754 l 216 754 q 299 772 272 754 q 327 828 327 789 q 310 871 327 854 q 258 888 293 888 q 198 875 227 888 q 131 835 170 862 l 62 930 q 156 983 104 962 q 277 1004 207 1004 q 418 961 363 1004 q 473 847 473 918 m 977 991 l 427 0 l 265 0 l 815 991 l 977 991 m 1161 103 l 1076 103 l 1076 1 l 915 1 l 915 103 l 655 103 l 655 208 l 916 599 l 1076 599 l 1076 217 l 1161 217 l 1161 103 m 915 217 l 915 328 q 919 453 915 387 q 895 399 913 435 q 867 347 877 362 l 781 217 l 915 217 z \"},\"¿\":{\"ha\":663,\"x_min\":41,\"x_max\":667,\"o\":\"m 484 411 l 484 361 q 453 246 484 294 q 350 146 423 198 q 257 63 276 93 q 237 -9 237 33 q 267 -73 237 -48 q 357 -98 296 -98 q 471 -79 410 -98 q 597 -31 532 -59 l 667 -180 q 516 -242 600 -218 q 361 -265 433 -265 q 126 -200 212 -265 q 41 -20 41 -134 q 74 107 41 54 q 204 232 107 161 q 287 304 269 279 q 304 371 304 330 l 304 411 l 484 411 m 505 643 q 475 557 505 586 q 386 528 444 528 q 299 557 330 528 q 268 643 268 587 q 299 728 268 698 q 386 758 331 758 q 474 728 443 758 q 505 643 505 699 z \"},\"À\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 484 1071 q 358 1167 441 1101 q 229 1279 275 1234 l 229 1293 l 461 1293 q 621 1089 504 1225 l 621 1071 l 484 1071 z \"},\"Á\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 367 1071 l 367 1089 q 526 1293 484 1225 l 758 1293 l 758 1279 q 638 1174 723 1244 q 505 1071 553 1105 l 367 1071 z \"},\"Â\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 636 1071 q 477 1190 530 1134 q 322 1071 425 1135 l 184 1071 l 184 1089 q 358 1293 313 1217 l 600 1293 q 673 1197 621 1258 q 774 1089 725 1137 l 774 1071 l 636 1071 z \"},\"Ã\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 368 1142 q 328 1124 347 1142 q 300 1069 309 1106 l 199 1069 q 255 1223 206 1168 q 383 1279 303 1279 q 438 1268 411 1279 q 491 1243 465 1257 q 542 1219 517 1230 q 591 1208 567 1208 q 632 1226 612 1208 q 660 1280 651 1244 l 761 1280 q 704 1126 753 1182 q 576 1071 655 1071 q 522 1082 549 1071 q 469 1106 495 1093 q 418 1131 443 1120 q 368 1142 393 1142 z \"},\"Ä\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 248 1182 q 273 1250 248 1226 q 342 1274 298 1274 q 412 1249 387 1274 q 437 1182 437 1223 q 412 1117 437 1141 q 342 1092 386 1092 q 273 1116 298 1092 q 248 1182 248 1139 m 521 1182 q 548 1252 521 1230 q 616 1274 576 1274 q 687 1249 661 1274 q 713 1182 713 1225 q 686 1116 713 1141 q 616 1092 660 1092 q 548 1114 576 1092 q 521 1182 521 1136 z \"},\"Å\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 650 1063 q 602 945 650 989 q 478 900 554 900 q 356 943 402 900 q 310 1061 310 987 q 356 1178 310 1135 q 478 1222 401 1222 q 602 1177 553 1222 q 650 1063 650 1133 m 543 1061 q 525 1109 543 1092 q 478 1126 507 1126 q 431 1109 450 1126 q 413 1061 413 1092 q 429 1013 413 1031 q 478 996 446 996 q 525 1013 507 996 q 543 1061 543 1031 z \"},\"Æ\":{\"ha\":1322,\"x_min\":0,\"x_max\":1240,\"o\":\"m 1240 0 l 648 0 l 648 236 l 315 236 l 214 0 l 0 0 l 444 991 l 1240 991 l 1240 819 l 859 819 l 859 602 l 1215 602 l 1215 429 l 859 429 l 859 174 l 1240 174 l 1240 0 m 392 412 l 648 412 l 648 812 l 562 812 l 392 412 z \"},\"Ç\":{\"ha\":885,\"x_min\":81,\"x_max\":836,\"o\":\"m 546 831 q 362 742 427 831 q 297 493 297 652 q 546 161 297 161 q 799 214 650 161 l 799 37 q 526 -14 677 -14 q 195 118 310 -14 q 81 494 81 249 q 137 765 81 649 q 299 944 193 882 q 546 1006 404 1006 q 836 936 690 1006 l 768 765 q 656 811 713 791 q 546 831 600 831 m 650 -170 q 599 -295 650 -256 q 441 -334 548 -334 q 342 -319 388 -334 l 342 -205 q 391 -215 360 -210 q 439 -220 422 -220 q 488 -178 488 -220 q 375 -104 488 -121 l 428 0 l 559 0 l 541 -41 q 621 -92 591 -58 q 650 -170 650 -126 z \"},\"È\":{\"ha\":778,\"x_min\":125,\"x_max\":696,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 430 1071 q 304 1167 387 1101 q 176 1279 222 1234 l 176 1293 l 408 1293 q 567 1089 450 1225 l 567 1071 l 430 1071 z \"},\"É\":{\"ha\":778,\"x_min\":125,\"x_max\":696,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 288 1071 l 288 1089 q 447 1293 404 1225 l 679 1293 l 679 1279 q 558 1174 644 1244 q 425 1071 473 1105 l 288 1071 z \"},\"Ê\":{\"ha\":778,\"x_min\":119,\"x_max\":708,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 570 1071 q 412 1190 464 1134 q 256 1071 359 1135 l 119 1071 l 119 1089 q 292 1293 247 1217 l 534 1293 q 607 1197 555 1258 q 708 1089 659 1137 l 708 1071 l 570 1071 z \"},\"Ë\":{\"ha\":778,\"x_min\":125,\"x_max\":696,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 184 1182 q 210 1250 184 1226 q 279 1274 235 1274 q 349 1249 323 1274 q 374 1182 374 1223 q 349 1117 374 1141 q 279 1092 323 1092 q 210 1116 235 1092 q 184 1182 184 1139 m 458 1182 q 485 1252 458 1230 q 553 1274 513 1274 q 624 1249 597 1274 q 650 1182 650 1225 q 623 1116 650 1141 q 553 1092 597 1092 q 485 1114 513 1092 q 458 1182 458 1136 z \"},\"Ð\":{\"ha\":1028,\"x_min\":32,\"x_max\":947,\"o\":\"m 32 576 l 125 576 l 125 991 l 436 991 q 813 863 679 991 q 947 505 947 735 q 808 130 947 260 q 406 0 669 0 l 125 0 l 125 404 l 32 404 l 32 576 m 729 500 q 659 738 729 657 q 446 819 588 819 l 335 819 l 335 576 l 496 576 l 496 404 l 335 404 l 335 174 l 424 174 q 729 500 729 174 z \"},\"Ñ\":{\"ha\":1129,\"x_min\":125,\"x_max\":1004,\"o\":\"m 1004 0 l 737 0 l 306 750 l 300 750 q 313 467 313 551 l 313 0 l 125 0 l 125 991 l 390 991 l 821 249 l 825 249 q 815 522 815 442 l 815 991 l 1004 991 l 1004 0 m 453 1142 q 413 1124 432 1142 q 385 1069 393 1106 l 283 1069 q 339 1223 291 1168 q 468 1279 388 1279 q 523 1268 496 1279 q 575 1243 549 1257 q 627 1219 602 1230 q 676 1208 652 1208 q 716 1226 697 1208 q 745 1280 736 1244 l 846 1280 q 789 1126 838 1182 q 661 1071 740 1071 q 607 1082 633 1071 q 554 1106 580 1093 q 503 1131 528 1120 q 453 1142 477 1142 z \"},\"Ò\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 559 1071 q 433 1167 516 1101 q 304 1279 351 1234 l 304 1293 l 536 1293 q 696 1089 579 1225 l 696 1071 l 559 1071 z \"},\"Ó\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 446 1071 l 446 1089 q 606 1293 563 1225 l 838 1293 l 838 1279 q 717 1174 802 1244 q 584 1071 632 1105 l 446 1071 z \"},\"Ô\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 710 1071 q 551 1190 604 1134 q 396 1071 498 1135 l 258 1071 l 258 1089 q 432 1293 387 1217 l 674 1293 q 747 1197 695 1258 q 848 1089 799 1137 l 848 1071 l 710 1071 z \"},\"Õ\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 442 1142 q 402 1124 421 1142 q 374 1069 382 1106 l 273 1069 q 329 1223 280 1168 q 457 1279 377 1279 q 512 1268 485 1279 q 565 1243 538 1257 q 616 1219 591 1230 q 665 1208 641 1208 q 706 1226 686 1208 q 734 1280 725 1244 l 835 1280 q 778 1126 827 1182 q 650 1071 729 1071 q 596 1082 623 1071 q 543 1106 569 1093 q 492 1131 517 1120 q 442 1142 467 1142 z \"},\"Ö\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 321 1182 q 347 1250 321 1226 q 416 1274 372 1274 q 486 1249 460 1274 q 511 1182 511 1223 q 486 1117 511 1141 q 416 1092 460 1092 q 347 1116 372 1092 q 321 1182 321 1139 m 595 1182 q 622 1252 595 1230 q 690 1274 650 1274 q 761 1249 734 1274 q 787 1182 787 1225 q 760 1116 787 1141 q 690 1092 734 1092 q 622 1114 650 1092 q 595 1182 595 1136 z \"},\"×\":{\"ha\":793,\"x_min\":87,\"x_max\":705,\"o\":\"m 290 490 l 87 694 l 191 799 l 395 596 l 602 799 l 705 697 l 498 490 l 703 285 l 602 182 l 395 386 l 191 183 l 89 286 l 290 490 z \"},\"Ø\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 325 31 419 -14 l 264 -61 l 154 12 l 215 104 q 81 498 81 236 q 203 877 81 746 q 554 1007 326 1007 q 787 960 688 1007 l 844 1044 l 953 974 l 893 885 q 1025 497 1025 753 m 301 497 q 339 289 301 368 l 682 802 q 554 832 625 832 q 365 748 429 832 q 301 497 301 663 m 804 497 q 770 699 804 619 l 431 189 q 553 163 482 163 q 804 497 804 163 z \"},\"Ù\":{\"ha\":1050,\"x_min\":118,\"x_max\":932,\"o\":\"m 932 991 l 932 350 q 883 157 932 240 q 741 31 833 75 q 521 -14 648 -14 q 224 84 330 -14 q 118 353 118 182 l 118 991 l 328 991 l 328 385 q 374 216 328 270 q 526 163 420 163 q 676 217 629 163 q 722 386 722 271 l 722 991 l 932 991 m 509 1071 q 383 1167 466 1101 q 254 1279 300 1234 l 254 1293 l 486 1293 q 646 1089 529 1225 l 646 1071 l 509 1071 z \"},\"Ú\":{\"ha\":1050,\"x_min\":118,\"x_max\":932,\"o\":\"m 932 991 l 932 350 q 883 157 932 240 q 741 31 833 75 q 521 -14 648 -14 q 224 84 330 -14 q 118 353 118 182 l 118 991 l 328 991 l 328 385 q 374 216 328 270 q 526 163 420 163 q 676 217 629 163 q 722 386 722 271 l 722 991 l 932 991 m 408 1071 l 408 1089 q 568 1293 525 1225 l 800 1293 l 800 1279 q 679 1174 764 1244 q 546 1071 594 1105 l 408 1071 z \"},\"Û\":{\"ha\":1050,\"x_min\":118,\"x_max\":932,\"o\":\"m 932 991 l 932 350 q 883 157 932 240 q 741 31 833 75 q 521 -14 648 -14 q 224 84 330 -14 q 118 353 118 182 l 118 991 l 328 991 l 328 385 q 374 216 328 270 q 526 163 420 163 q 676 217 629 163 q 722 386 722 271 l 722 991 l 932 991 m 682 1071 q 524 1190 576 1134 q 368 1071 471 1135 l 231 1071 l 231 1089 q 404 1293 359 1217 l 646 1293 q 719 1197 667 1258 q 820 1089 771 1137 l 820 1071 l 682 1071 z \"},\"Ü\":{\"ha\":1050,\"x_min\":118,\"x_max\":932,\"o\":\"m 932 991 l 932 350 q 883 157 932 240 q 741 31 833 75 q 521 -14 648 -14 q 224 84 330 -14 q 118 353 118 182 l 118 991 l 328 991 l 328 385 q 374 216 328 270 q 526 163 420 163 q 676 217 629 163 q 722 386 722 271 l 722 991 l 932 991 m 294 1182 q 319 1250 294 1226 q 388 1274 345 1274 q 458 1249 433 1274 q 484 1182 484 1223 q 458 1117 484 1141 q 388 1092 432 1092 q 319 1116 345 1092 q 294 1182 294 1139 m 567 1182 q 594 1252 567 1230 q 663 1274 622 1274 q 733 1249 707 1274 q 759 1182 759 1225 q 732 1116 759 1141 q 663 1092 706 1092 q 594 1114 622 1092 q 567 1182 567 1136 z \"},\"Ý\":{\"ha\":867,\"x_min\":0,\"x_max\":867,\"o\":\"m 433 583 l 640 991 l 867 991 l 538 386 l 538 0 l 329 0 l 329 379 l 0 991 l 228 991 l 433 583 m 313 1071 l 313 1089 q 472 1293 429 1225 l 704 1293 l 704 1279 q 584 1174 669 1244 q 450 1071 498 1105 l 313 1071 z \"},\"Þ\":{\"ha\":872,\"x_min\":125,\"x_max\":810,\"o\":\"m 810 522 q 713 283 810 367 q 439 199 616 199 l 335 199 l 335 0 l 125 0 l 125 991 l 335 991 l 335 836 l 456 836 q 719 755 628 836 q 810 522 810 675 m 335 368 l 403 368 q 549 404 501 368 q 597 522 597 439 q 554 630 597 595 q 419 665 511 665 l 335 665 l 335 368 z \"},\"ß\":{\"ha\":987,\"x_min\":109,\"x_max\":939,\"o\":\"m 847 842 q 833 765 847 798 q 797 707 819 732 q 750 661 775 681 q 703 625 725 642 q 667 595 682 609 q 653 566 653 581 q 671 530 653 547 q 734 485 689 512 q 868 390 833 423 q 921 315 904 357 q 939 221 939 274 q 860 45 939 104 q 627 -14 781 -14 q 511 -4 559 -14 q 421 29 462 6 l 421 193 q 513 152 457 169 q 612 135 569 135 q 726 218 726 135 q 715 263 726 246 q 677 301 705 281 q 599 350 649 321 q 480 439 513 399 q 447 534 447 479 q 471 614 447 578 q 542 683 494 650 q 615 747 594 720 q 636 806 636 774 q 593 874 636 846 q 482 901 550 901 q 359 866 404 901 q 315 765 315 830 l 315 0 l 109 0 l 109 772 q 208 986 109 909 q 482 1063 307 1063 q 747 1003 648 1063 q 847 842 847 943 z \"},\"à\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 416 842 q 291 938 374 871 q 162 1050 208 1005 l 162 1064 l 394 1064 q 553 860 437 996 l 553 842 l 416 842 z \"},\"á\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 299 842 l 299 860 q 458 1064 416 996 l 690 1064 l 690 1050 q 570 945 655 1015 q 437 842 485 876 l 299 842 z \"},\"â\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 572 841 q 413 960 465 904 q 258 841 360 905 l 120 841 l 120 859 q 294 1063 248 987 l 536 1063 q 609 967 557 1028 q 709 859 661 907 l 709 841 l 572 841 z \"},\"ã\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 317 913 q 276 895 296 913 q 248 840 257 877 l 147 840 q 203 994 155 939 q 332 1050 252 1050 q 386 1039 359 1050 q 439 1014 413 1027 q 490 990 465 1001 q 540 979 515 979 q 580 997 561 979 q 608 1051 600 1015 l 709 1051 q 653 897 702 953 q 525 842 604 842 q 470 853 497 842 q 417 877 444 864 q 366 902 391 890 q 317 913 341 913 z \"},\"ä\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 193 953 q 219 1021 193 997 q 288 1044 244 1044 q 358 1019 332 1044 q 383 953 383 994 q 357 887 383 912 q 288 863 332 863 q 219 886 244 863 q 193 953 193 910 m 467 953 q 494 1022 467 1000 q 562 1044 522 1044 q 632 1020 606 1044 q 659 953 659 996 q 632 887 659 911 q 562 863 606 863 q 494 885 522 863 q 467 953 467 907 z \"},\"å\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 599 1003 q 551 885 599 930 q 427 840 503 840 q 304 884 351 840 q 258 1002 258 927 q 304 1119 258 1075 q 427 1162 350 1162 q 550 1118 501 1162 q 599 1003 599 1073 m 492 1002 q 473 1049 492 1032 q 427 1067 455 1067 q 380 1049 398 1067 q 361 1002 361 1032 q 378 954 361 971 q 427 936 394 936 q 473 954 455 936 q 492 1002 492 971 z \"},\"æ\":{\"ha\":1274,\"x_min\":58,\"x_max\":1214,\"o\":\"m 901 -14 q 732 21 808 -14 q 607 126 656 55 q 474 17 541 47 q 300 -14 407 -14 q 124 51 191 -14 q 58 227 58 115 q 140 405 58 347 q 386 468 222 462 l 515 472 l 515 529 q 485 598 515 576 q 403 621 455 621 q 196 568 308 621 l 129 705 q 415 774 257 774 q 647 685 569 774 q 750 750 692 728 q 890 772 809 772 q 1127 679 1040 772 q 1214 428 1214 586 l 1214 328 l 724 328 q 776 190 727 239 q 913 140 825 140 q 1171 200 1046 140 l 1171 40 q 1055 0 1117 14 q 901 -14 992 -14 m 515 351 l 439 349 q 313 316 355 346 q 271 225 271 287 q 366 138 271 138 q 475 179 434 138 q 515 289 515 220 l 515 351 m 886 625 q 728 465 739 625 l 1019 465 q 982 583 1018 541 q 886 625 946 625 z \"},\"ç\":{\"ha\":714,\"x_min\":62,\"x_max\":671,\"o\":\"m 416 -14 q 62 375 62 -14 q 159 670 62 568 q 435 772 255 772 q 671 721 566 772 l 610 561 q 519 593 561 581 q 435 606 477 606 q 273 376 273 606 q 435 154 273 154 q 545 170 494 154 q 647 220 596 186 l 647 43 q 546 -1 597 11 q 416 -14 494 -14 m 546 -170 q 495 -295 546 -256 q 336 -334 444 -334 q 237 -319 283 -334 l 237 -205 q 287 -215 256 -210 q 334 -220 317 -220 q 383 -178 383 -220 q 271 -104 383 -121 l 323 0 l 454 0 l 436 -41 q 516 -92 486 -58 q 546 -170 546 -126 z \"},\"è\":{\"ha\":821,\"x_min\":62,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 420 842 q 295 938 378 871 q 166 1050 212 1005 l 166 1064 l 398 1064 q 557 860 441 996 l 557 842 l 420 842 z \"},\"é\":{\"ha\":821,\"x_min\":62,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 303 842 l 303 860 q 463 1064 420 996 l 694 1064 l 694 1050 q 574 945 659 1015 q 441 842 489 876 l 303 842 z \"},\"ê\":{\"ha\":821,\"x_min\":62,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 583 842 q 425 961 477 905 q 269 842 372 906 l 132 842 l 132 860 q 305 1064 260 988 l 547 1064 q 620 968 568 1029 q 721 860 672 907 l 721 842 l 583 842 z \"},\"ë\":{\"ha\":821,\"x_min\":62,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 201 953 q 227 1021 201 997 q 296 1044 252 1044 q 366 1019 340 1044 q 391 953 391 994 q 366 887 391 912 q 296 863 340 863 q 227 886 252 863 q 201 953 201 910 m 475 953 q 502 1022 475 1000 q 570 1044 530 1044 q 641 1020 614 1044 q 667 953 667 996 q 640 887 667 911 q 570 863 614 863 q 502 885 530 863 q 475 953 475 907 z \"},\"ì\":{\"ha\":424,\"x_min\":-68,\"x_max\":323,\"o\":\"m 315 0 l 109 0 l 109 758 l 315 758 l 315 0 m 186 842 q 60 938 143 871 q -68 1050 -22 1005 l -68 1064 l 163 1064 q 323 860 206 996 l 323 842 l 186 842 z \"},\"í\":{\"ha\":424,\"x_min\":98,\"x_max\":490,\"o\":\"m 315 0 l 109 0 l 109 758 l 315 758 l 315 0 m 98 842 l 98 860 q 258 1064 215 996 l 490 1064 l 490 1050 q 369 945 454 1015 q 236 842 284 876 l 98 842 z \"},\"î\":{\"ha\":424,\"x_min\":-83,\"x_max\":507,\"o\":\"m 315 0 l 109 0 l 109 758 l 315 758 l 315 0 m 369 842 q 210 961 262 905 q 55 842 157 906 l -83 842 l -83 860 q 91 1064 45 988 l 333 1064 q 406 968 354 1029 q 507 860 458 907 l 507 842 l 369 842 z \"},\"ï\":{\"ha\":424,\"x_min\":-20,\"x_max\":446,\"o\":\"m 315 0 l 109 0 l 109 758 l 315 758 l 315 0 m -20 953 q 6 1021 -20 997 q 75 1044 31 1044 q 145 1019 119 1044 q 170 953 170 994 q 144 887 170 912 q 75 863 119 863 q 6 886 31 863 q -20 953 -20 910 m 254 953 q 281 1022 254 1000 q 349 1044 309 1044 q 419 1020 393 1044 q 446 953 446 996 q 419 887 446 911 q 349 863 393 863 q 281 885 309 863 q 254 953 254 907 z \"},\"ð\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 346 884 q 243 946 292 920 l 311 1065 q 486 970 409 1021 l 639 1064 l 707 960 l 591 889 q 747 669 697 792 q 798 389 798 546 q 699 93 798 199 q 428 -14 601 -14 q 162 79 262 -14 q 62 332 62 172 q 151 582 62 490 q 389 675 239 675 q 575 608 528 675 l 581 611 q 450 802 535 721 l 294 705 l 227 811 l 346 884 m 586 361 q 545 478 586 434 q 431 522 503 522 q 311 476 349 522 q 273 330 273 429 q 314 187 273 235 q 431 139 355 139 q 550 195 514 139 q 586 361 586 250 z \"},\"ñ\":{\"ha\":913,\"x_min\":109,\"x_max\":808,\"o\":\"m 808 0 l 602 0 l 602 443 q 572 566 602 525 q 479 607 543 607 q 354 549 393 607 q 315 357 315 491 l 315 0 l 109 0 l 109 758 l 267 758 l 294 661 l 306 661 q 401 744 340 716 q 539 772 462 772 q 740 701 671 772 q 808 494 808 629 l 808 0 m 345 913 q 304 895 323 913 q 276 840 285 877 l 175 840 q 231 994 182 939 q 359 1050 279 1050 q 414 1039 387 1050 q 467 1014 441 1027 q 518 990 493 1001 q 568 979 543 979 q 608 997 589 979 q 636 1051 627 1015 l 737 1051 q 681 897 730 953 q 553 842 631 842 q 498 853 525 842 q 445 877 471 864 q 394 902 419 890 q 345 913 369 913 z \"},\"ò\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 415 842 q 290 938 372 871 q 161 1050 207 1005 l 161 1064 l 393 1064 q 552 860 435 996 l 552 842 l 415 842 z \"},\"ó\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 317 842 l 317 860 q 476 1064 433 996 l 708 1064 l 708 1050 q 588 945 673 1015 q 454 842 503 876 l 317 842 z \"},\"ô\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 586 842 q 427 961 479 905 q 272 842 374 906 l 134 842 l 134 860 q 308 1064 262 988 l 550 1064 q 623 968 571 1029 q 724 860 675 907 l 724 842 l 586 842 z \"},\"õ\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 318 913 q 278 895 297 913 q 250 840 258 877 l 149 840 q 204 994 156 939 q 333 1050 253 1050 q 388 1039 361 1050 q 440 1014 414 1027 q 492 990 467 1001 q 541 979 517 979 q 582 997 562 979 q 610 1051 601 1015 l 711 1051 q 654 897 703 953 q 526 842 605 842 q 472 853 498 842 q 419 877 445 864 q 368 902 393 890 q 318 913 342 913 z \"},\"ö\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 197 953 q 223 1021 197 997 q 292 1044 248 1044 q 362 1019 336 1044 q 387 953 387 994 q 361 887 387 912 q 292 863 336 863 q 223 886 248 863 q 197 953 197 910 m 471 953 q 498 1022 471 1000 q 566 1044 526 1044 q 636 1020 610 1044 q 663 953 663 996 q 636 887 663 911 q 566 863 610 863 q 498 885 526 863 q 471 953 471 907 z \"},\"÷\":{\"ha\":793,\"x_min\":60,\"x_max\":733,\"o\":\"m 60 415 l 60 564 l 733 564 l 733 415 l 60 415 m 301 253 q 326 330 301 304 q 396 355 351 355 q 466 329 441 355 q 490 253 490 302 q 465 178 490 205 q 396 150 440 150 q 327 176 352 150 q 301 253 301 203 m 301 726 q 326 803 301 777 q 396 829 351 829 q 466 802 441 829 q 490 726 490 774 q 465 651 490 679 q 396 624 440 624 q 327 650 352 624 q 301 726 301 677 z \"},\"ø\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 269 17 342 -14 l 224 -52 l 119 20 l 165 87 q 62 380 62 193 q 159 669 62 566 q 432 772 256 772 q 600 737 522 772 l 637 793 l 741 720 l 701 663 q 798 380 798 557 m 273 380 q 286 268 273 317 l 501 590 q 429 606 472 606 q 310 550 347 606 q 273 380 273 494 m 586 380 q 578 476 586 435 l 368 163 q 431 153 394 153 q 550 210 513 153 q 586 380 586 267 z \"},\"ù\":{\"ha\":913,\"x_min\":104,\"x_max\":804,\"o\":\"m 646 0 l 618 97 l 607 97 q 513 15 574 44 q 374 -14 452 -14 q 172 58 240 -14 q 104 264 104 130 l 104 758 l 311 758 l 311 315 q 340 192 311 233 q 433 151 370 151 q 559 209 520 151 q 597 401 597 267 l 597 758 l 804 758 l 804 0 l 646 0 m 420 842 q 295 938 378 871 q 166 1050 212 1005 l 166 1064 l 398 1064 q 557 860 441 996 l 557 842 l 420 842 z \"},\"ú\":{\"ha\":913,\"x_min\":104,\"x_max\":804,\"o\":\"m 646 0 l 618 97 l 607 97 q 513 15 574 44 q 374 -14 452 -14 q 172 58 240 -14 q 104 264 104 130 l 104 758 l 311 758 l 311 315 q 340 192 311 233 q 433 151 370 151 q 559 209 520 151 q 597 401 597 267 l 597 758 l 804 758 l 804 0 l 646 0 m 338 842 l 338 860 q 497 1064 454 996 l 729 1064 l 729 1050 q 609 945 694 1015 q 475 842 524 876 l 338 842 z \"},\"û\":{\"ha\":913,\"x_min\":104,\"x_max\":804,\"o\":\"m 646 0 l 618 97 l 607 97 q 513 15 574 44 q 374 -14 452 -14 q 172 58 240 -14 q 104 264 104 130 l 104 758 l 311 758 l 311 315 q 340 192 311 233 q 433 151 370 151 q 559 209 520 151 q 597 401 597 267 l 597 758 l 804 758 l 804 0 l 646 0 m 611 842 q 452 961 505 905 q 297 842 399 906 l 159 842 l 159 860 q 333 1064 288 988 l 575 1064 q 648 968 596 1029 q 749 860 700 907 l 749 842 l 611 842 z \"},\"ü\":{\"ha\":913,\"x_min\":104,\"x_max\":804,\"o\":\"m 646 0 l 618 97 l 607 97 q 513 15 574 44 q 374 -14 452 -14 q 172 58 240 -14 q 104 264 104 130 l 104 758 l 311 758 l 311 315 q 340 192 311 233 q 433 151 370 151 q 559 209 520 151 q 597 401 597 267 l 597 758 l 804 758 l 804 0 l 646 0 m 221 953 q 247 1021 221 997 q 315 1044 272 1044 q 386 1019 360 1044 q 411 953 411 994 q 385 887 411 912 q 315 863 359 863 q 247 886 272 863 q 221 953 221 910 m 494 953 q 522 1022 494 1000 q 590 1044 549 1044 q 660 1020 634 1044 q 686 953 686 996 q 660 887 686 911 q 590 863 633 863 q 522 885 549 863 q 494 953 494 907 z \"},\"ý\":{\"ha\":790,\"x_min\":0,\"x_max\":790,\"o\":\"m 0 758 l 227 758 l 370 332 q 395 200 388 276 l 399 200 q 428 332 406 270 l 568 758 l 790 758 l 469 -97 q 343 -275 425 -216 q 153 -334 262 -334 q 47 -322 99 -334 l 47 -158 q 129 -167 85 -167 q 225 -133 184 -167 q 289 -32 266 -100 l 301 5 l 0 758 m 267 842 l 267 860 q 426 1064 383 996 l 658 1064 l 658 1050 q 537 945 623 1015 q 404 842 452 876 l 267 842 z \"},\"þ\":{\"ha\":879,\"x_min\":109,\"x_max\":817,\"o\":\"m 315 660 q 404 744 349 715 q 530 772 459 772 q 741 668 665 772 q 817 380 817 563 q 741 91 817 195 q 530 -14 665 -14 q 315 79 386 -14 l 306 79 l 311 37 l 315 -26 l 315 -334 l 109 -334 l 109 1055 l 315 1055 l 315 790 l 311 709 l 306 660 l 315 660 m 464 607 q 352 560 387 607 q 315 404 317 513 l 315 382 q 352 207 315 260 q 467 154 388 154 q 606 383 606 154 q 571 551 606 495 q 464 607 537 607 z \"},\"ÿ\":{\"ha\":790,\"x_min\":0,\"x_max\":790,\"o\":\"m 0 758 l 227 758 l 370 332 q 395 200 388 276 l 399 200 q 428 332 406 270 l 568 758 l 790 758 l 469 -97 q 343 -275 425 -216 q 153 -334 262 -334 q 47 -322 99 -334 l 47 -158 q 129 -167 85 -167 q 225 -133 184 -167 q 289 -32 266 -100 l 301 5 l 0 758 m 165 953 q 190 1021 165 997 q 259 1044 216 1044 q 329 1019 304 1044 q 355 953 355 994 q 329 887 355 912 q 259 863 303 863 q 190 886 216 863 q 165 953 165 910 m 438 953 q 466 1022 438 1000 q 534 1044 493 1044 q 604 1020 578 1044 q 630 953 630 996 q 604 887 630 911 q 534 863 577 863 q 466 885 493 863 q 438 953 438 907 z \"},\"Ā\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 252 1214 l 711 1214 l 711 1071 l 252 1071 l 252 1214 z \"},\"ā\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 199 985 l 659 985 l 659 842 l 199 842 l 199 985 z \"},\"Ă\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 746 1300 q 663 1133 738 1196 q 476 1071 589 1071 q 288 1133 358 1071 q 212 1300 218 1194 l 328 1300 q 346 1250 330 1268 q 391 1223 362 1232 q 477 1215 420 1215 q 628 1300 617 1215 l 746 1300 z \"},\"ă\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 696 1071 q 613 904 688 966 q 426 842 538 842 q 238 903 308 842 q 162 1071 168 965 l 277 1071 q 296 1021 280 1039 q 341 994 312 1002 q 427 986 370 986 q 578 1071 567 986 l 696 1071 z \"},\"Ą\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 754 -154 q 769 -196 754 -182 q 808 -210 785 -210 q 886 -197 846 -210 l 886 -318 q 781 -334 831 -334 q 657 -291 704 -334 q 611 -178 611 -248 q 637 -92 611 -132 q 733 0 663 -52 l 854 0 q 781 -82 807 -45 q 754 -154 754 -119 z \"},\"ą\":{\"ha\":839,\"x_min\":58,\"x_max\":746,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 614 -154 q 629 -196 614 -182 q 668 -210 644 -210 q 746 -197 705 -210 l 746 -318 q 640 -334 690 -334 q 517 -291 564 -334 q 471 -178 471 -248 q 496 -92 471 -132 q 593 0 522 -52 l 714 0 q 640 -82 667 -45 q 614 -154 614 -119 z \"},\"Ć\":{\"ha\":885,\"x_min\":81,\"x_max\":836,\"o\":\"m 546 831 q 362 742 427 831 q 297 493 297 652 q 546 161 297 161 q 799 214 650 161 l 799 37 q 526 -14 677 -14 q 195 118 310 -14 q 81 494 81 249 q 137 765 81 649 q 299 944 193 882 q 546 1006 404 1006 q 836 936 690 1006 l 768 765 q 656 811 713 791 q 546 831 600 831 m 406 1071 l 406 1089 q 565 1293 522 1225 l 797 1293 l 797 1279 q 676 1174 762 1244 q 543 1071 591 1105 l 406 1071 z \"},\"ć\":{\"ha\":714,\"x_min\":62,\"x_max\":692,\"o\":\"m 416 -14 q 62 375 62 -14 q 159 670 62 568 q 435 772 255 772 q 671 721 566 772 l 610 561 q 519 593 561 581 q 435 606 477 606 q 273 376 273 606 q 435 154 273 154 q 545 170 494 154 q 647 220 596 186 l 647 43 q 546 -1 597 11 q 416 -14 494 -14 m 300 842 l 300 860 q 460 1064 417 996 l 692 1064 l 692 1050 q 571 945 656 1015 q 438 842 486 876 l 300 842 z \"},\"Ĉ\":{\"ha\":885,\"x_min\":81,\"x_max\":836,\"o\":\"m 546 831 q 362 742 427 831 q 297 493 297 652 q 546 161 297 161 q 799 214 650 161 l 799 37 q 526 -14 677 -14 q 195 118 310 -14 q 81 494 81 249 q 137 765 81 649 q 299 944 193 882 q 546 1006 404 1006 q 836 936 690 1006 l 768 765 q 656 811 713 791 q 546 831 600 831 m 693 1071 q 534 1190 587 1134 q 379 1071 481 1135 l 241 1071 l 241 1089 q 415 1293 370 1217 l 657 1293 q 730 1197 678 1258 q 831 1089 782 1137 l 831 1071 l 693 1071 z \"},\"ĉ\":{\"ha\":714,\"x_min\":62,\"x_max\":704,\"o\":\"m 416 -14 q 62 375 62 -14 q 159 670 62 568 q 435 772 255 772 q 671 721 566 772 l 610 561 q 519 593 561 581 q 435 606 477 606 q 273 376 273 606 q 435 154 273 154 q 545 170 494 154 q 647 220 596 186 l 647 43 q 546 -1 597 11 q 416 -14 494 -14 m 566 842 q 408 961 460 905 q 252 842 355 906 l 115 842 l 115 860 q 288 1064 243 988 l 530 1064 q 603 968 551 1029 q 704 860 655 907 l 704 842 l 566 842 z \"},\"Ċ\":{\"ha\":885,\"x_min\":81,\"x_max\":836,\"o\":\"m 546 831 q 362 742 427 831 q 297 493 297 652 q 546 161 297 161 q 799 214 650 161 l 799 37 q 526 -14 677 -14 q 195 118 310 -14 q 81 494 81 249 q 137 765 81 649 q 299 944 193 882 q 546 1006 404 1006 q 836 936 690 1006 l 768 765 q 656 811 713 791 q 546 831 600 831 m 420 1183 q 533 1284 420 1284 q 646 1183 646 1284 q 617 1108 646 1135 q 533 1082 589 1082 q 420 1183 420 1082 z \"},\"ċ\":{\"ha\":714,\"x_min\":62,\"x_max\":671,\"o\":\"m 416 -14 q 62 375 62 -14 q 159 670 62 568 q 435 772 255 772 q 671 721 566 772 l 610 561 q 519 593 561 581 q 435 606 477 606 q 273 376 273 606 q 435 154 273 154 q 545 170 494 154 q 647 220 596 186 l 647 43 q 546 -1 597 11 q 416 -14 494 -14 m 313 954 q 426 1055 313 1055 q 538 954 538 1055 q 510 879 538 906 q 426 852 482 852 q 313 954 313 852 z \"},\"Č\":{\"ha\":885,\"x_min\":81,\"x_max\":836,\"o\":\"m 546 831 q 362 742 427 831 q 297 493 297 652 q 546 161 297 161 q 799 214 650 161 l 799 37 q 526 -14 677 -14 q 195 118 310 -14 q 81 494 81 249 q 137 765 81 649 q 299 944 193 882 q 546 1006 404 1006 q 836 936 690 1006 l 768 765 q 656 811 713 791 q 546 831 600 831 m 832 1293 l 832 1275 q 727 1161 775 1218 q 659 1071 680 1105 l 416 1071 q 360 1147 397 1103 q 243 1275 323 1192 l 243 1293 l 380 1293 q 536 1174 480 1230 q 694 1293 593 1233 l 832 1293 z \"},\"č\":{\"ha\":714,\"x_min\":62,\"x_max\":715,\"o\":\"m 416 -14 q 62 375 62 -14 q 159 670 62 568 q 435 772 255 772 q 671 721 566 772 l 610 561 q 519 593 561 581 q 435 606 477 606 q 273 376 273 606 q 435 154 273 154 q 545 170 494 154 q 647 220 596 186 l 647 43 q 546 -1 597 11 q 416 -14 494 -14 m 715 1064 l 715 1046 q 611 932 659 989 q 542 842 563 876 l 300 842 q 243 918 280 873 q 126 1046 207 962 l 126 1064 l 264 1064 q 419 945 363 1001 q 578 1064 476 1004 l 715 1064 z \"},\"Ď\":{\"ha\":1028,\"x_min\":125,\"x_max\":947,\"o\":\"m 947 505 q 808 130 947 260 q 406 0 669 0 l 125 0 l 125 991 l 436 991 q 813 863 679 991 q 947 505 947 735 m 729 500 q 447 819 729 819 l 335 819 l 335 174 l 425 174 q 729 500 729 174 m 786 1293 l 786 1275 q 681 1161 729 1218 q 612 1071 633 1105 l 370 1071 q 314 1147 351 1103 q 197 1275 277 1192 l 197 1293 l 334 1293 q 490 1174 434 1230 q 648 1293 547 1233 l 786 1293 z \"},\"ď\":{\"ha\":879,\"x_min\":62,\"x_max\":1067,\"o\":\"m 349 -14 q 139 90 215 -14 q 62 378 62 194 q 140 668 62 564 q 354 772 218 772 q 572 661 497 772 l 579 661 q 564 812 564 746 l 564 1055 l 771 1055 l 771 0 l 612 0 l 572 98 l 564 98 q 349 -14 493 -14 m 421 151 q 537 197 500 151 q 578 354 574 243 l 578 376 q 540 551 578 498 q 418 604 503 604 q 310 546 349 604 q 272 375 272 487 q 311 207 272 263 q 421 151 349 151 m 833 851 q 857 948 844 884 q 876 1055 870 1012 l 1067 1055 l 1067 1042 q 954 833 1013 922 l 833 833 l 833 851 z \"},\"Đ\":{\"ha\":1028,\"x_min\":32,\"x_max\":947,\"o\":\"m 32 576 l 125 576 l 125 991 l 436 991 q 813 863 679 991 q 947 505 947 735 q 808 130 947 260 q 406 0 669 0 l 125 0 l 125 404 l 32 404 l 32 576 m 729 500 q 659 738 729 657 q 446 819 588 819 l 335 819 l 335 576 l 496 576 l 496 404 l 335 404 l 335 174 l 424 174 q 729 500 729 174 z \"},\"đ\":{\"ha\":901,\"x_min\":62,\"x_max\":876,\"o\":\"m 342 -14 q 137 84 212 -14 q 62 357 62 182 q 130 639 62 548 q 349 730 197 730 q 479 702 422 730 q 572 619 536 673 l 579 619 q 564 777 564 708 l 564 811 l 350 811 l 350 946 l 564 946 l 564 1055 l 771 1055 l 771 946 l 876 946 l 876 811 l 771 811 l 771 0 l 603 0 l 559 98 l 551 98 q 342 -14 481 -14 m 429 151 q 539 193 504 151 q 578 336 575 235 l 578 355 q 544 518 578 475 q 419 562 509 562 q 316 515 344 562 q 288 354 288 469 q 321 202 288 253 q 429 151 355 151 z \"},\"Ē\":{\"ha\":778,\"x_min\":125,\"x_max\":696,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 186 1214 l 646 1214 l 646 1071 l 186 1071 l 186 1214 z \"},\"ē\":{\"ha\":821,\"x_min\":62,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 189 985 l 648 985 l 648 842 l 189 842 l 189 985 z \"},\"Ĕ\":{\"ha\":778,\"x_min\":125,\"x_max\":696,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 673 1300 q 590 1133 665 1196 q 403 1071 515 1071 q 215 1133 285 1071 q 139 1300 144 1194 l 254 1300 q 273 1250 257 1268 q 318 1223 289 1232 q 404 1215 347 1215 q 555 1300 544 1215 l 673 1300 z \"},\"ĕ\":{\"ha\":821,\"x_min\":62,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 688 1071 q 605 904 680 966 q 418 842 530 842 q 230 903 300 842 q 154 1071 159 965 l 269 1071 q 288 1021 272 1039 q 333 994 304 1002 q 419 986 361 986 q 570 1071 559 986 l 688 1071 z \"},\"Ė\":{\"ha\":778,\"x_min\":125,\"x_max\":696,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 305 1164 q 418 1265 305 1265 q 530 1164 530 1265 q 502 1089 530 1116 q 418 1062 474 1062 q 305 1164 305 1062 z \"},\"ė\":{\"ha\":821,\"x_min\":62,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 316 954 q 429 1055 316 1055 q 541 954 541 1055 q 513 879 541 906 q 429 852 485 852 q 316 954 316 852 z \"},\"Ę\":{\"ha\":778,\"x_min\":125,\"x_max\":696,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 533 -154 q 548 -196 533 -182 q 587 -210 564 -210 q 665 -197 625 -210 l 665 -318 q 559 -334 610 -334 q 436 -291 483 -334 q 390 -178 390 -248 q 416 -92 390 -132 q 512 0 441 -52 l 633 0 q 559 -82 586 -45 q 533 -154 533 -119 z \"},\"ę\":{\"ha\":821,\"x_min\":62,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 540 -140 q 555 -182 540 -169 q 594 -196 570 -196 q 672 -184 631 -196 l 672 -304 q 566 -320 616 -320 q 443 -277 490 -320 q 397 -164 397 -234 q 422 -79 397 -119 q 519 14 448 -39 l 640 14 q 566 -68 593 -31 q 540 -140 540 -105 z \"},\"Ě\":{\"ha\":778,\"x_min\":119,\"x_max\":708,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 708 1293 l 708 1275 q 603 1161 651 1218 q 534 1071 555 1105 l 292 1071 q 236 1147 273 1103 q 119 1275 199 1192 l 119 1293 l 256 1293 q 412 1174 356 1230 q 570 1293 469 1233 l 708 1293 z \"},\"ě\":{\"ha\":821,\"x_min\":62,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 717 1064 l 717 1046 q 612 932 660 989 q 543 842 564 876 l 301 842 q 245 918 281 873 q 127 1046 208 962 l 127 1064 l 265 1064 q 420 945 365 1001 q 579 1064 477 1004 l 717 1064 z \"},\"Ĝ\":{\"ha\":1006,\"x_min\":81,\"x_max\":895,\"o\":\"m 501 557 l 895 557 l 895 43 q 714 -1 799 12 q 542 -14 630 -14 q 199 118 317 -14 q 81 497 81 250 q 218 871 81 737 q 599 1006 355 1006 q 893 945 751 1006 l 823 777 q 597 831 715 831 q 379 739 461 831 q 297 493 297 648 q 363 247 297 332 q 555 161 429 161 q 689 175 621 161 l 689 382 l 501 382 l 501 557 m 703 1071 q 544 1190 596 1134 q 389 1071 491 1135 l 251 1071 l 251 1089 q 425 1293 379 1217 l 667 1293 q 740 1197 688 1258 q 840 1089 791 1137 l 840 1071 l 703 1071 z \"},\"ĝ\":{\"ha\":785,\"x_min\":4,\"x_max\":768,\"o\":\"m 768 758 l 768 653 l 650 623 q 682 509 682 572 q 597 318 682 387 q 361 250 512 250 l 323 252 l 293 256 q 261 201 261 231 q 375 157 261 157 l 504 157 q 694 103 629 157 q 760 -54 760 50 q 649 -260 760 -187 q 330 -334 538 -334 q 88 -278 172 -334 q 4 -123 4 -223 q 47 -9 4 -55 q 172 57 90 37 q 117 101 140 71 q 93 167 93 132 q 118 239 93 210 q 191 296 143 268 q 96 378 131 321 q 61 513 61 435 q 142 705 61 637 q 372 772 222 772 q 448 767 404 772 q 504 758 492 761 l 768 758 m 183 -107 q 224 -174 183 -150 q 339 -199 265 -199 q 513 -168 450 -199 q 576 -85 576 -138 q 539 -26 576 -42 q 424 -9 502 -9 l 317 -9 q 221 -36 260 -9 q 183 -107 183 -63 m 258 510 q 287 412 258 448 q 372 376 315 376 q 458 412 431 376 q 485 510 485 448 q 372 647 485 647 q 258 510 258 647 m 553 842 q 395 961 447 905 q 239 842 342 906 l 102 842 l 102 860 q 275 1064 230 988 l 517 1064 q 590 968 538 1029 q 691 860 642 907 l 691 842 l 553 842 z \"},\"Ğ\":{\"ha\":1006,\"x_min\":81,\"x_max\":895,\"o\":\"m 501 557 l 895 557 l 895 43 q 714 -1 799 12 q 542 -14 630 -14 q 199 118 317 -14 q 81 497 81 250 q 218 871 81 737 q 599 1006 355 1006 q 893 945 751 1006 l 823 777 q 597 831 715 831 q 379 739 461 831 q 297 493 297 648 q 363 247 297 332 q 555 161 429 161 q 689 175 621 161 l 689 382 l 501 382 l 501 557 m 817 1300 q 734 1133 808 1196 q 547 1071 659 1071 q 358 1133 429 1071 q 283 1300 288 1194 l 398 1300 q 417 1250 401 1268 q 461 1223 433 1232 q 548 1215 490 1215 q 699 1300 688 1215 l 817 1300 z \"},\"ğ\":{\"ha\":785,\"x_min\":4,\"x_max\":768,\"o\":\"m 768 758 l 768 653 l 650 623 q 682 509 682 572 q 597 318 682 387 q 361 250 512 250 l 323 252 l 293 256 q 261 201 261 231 q 375 157 261 157 l 504 157 q 694 103 629 157 q 760 -54 760 50 q 649 -260 760 -187 q 330 -334 538 -334 q 88 -278 172 -334 q 4 -123 4 -223 q 47 -9 4 -55 q 172 57 90 37 q 117 101 140 71 q 93 167 93 132 q 118 239 93 210 q 191 296 143 268 q 96 378 131 321 q 61 513 61 435 q 142 705 61 637 q 372 772 222 772 q 448 767 404 772 q 504 758 492 761 l 768 758 m 183 -107 q 224 -174 183 -150 q 339 -199 265 -199 q 513 -168 450 -199 q 576 -85 576 -138 q 539 -26 576 -42 q 424 -9 502 -9 l 317 -9 q 221 -36 260 -9 q 183 -107 183 -63 m 258 510 q 287 412 258 448 q 372 376 315 376 q 458 412 431 376 q 485 510 485 448 q 372 647 485 647 q 258 510 258 647 m 667 1071 q 585 904 659 966 q 397 842 510 842 q 209 903 279 842 q 134 1071 139 965 l 249 1071 q 268 1021 252 1039 q 312 994 283 1002 q 399 986 341 986 q 549 1071 538 986 l 667 1071 z \"},\"Ġ\":{\"ha\":1006,\"x_min\":81,\"x_max\":895,\"o\":\"m 501 557 l 895 557 l 895 43 q 714 -1 799 12 q 542 -14 630 -14 q 199 118 317 -14 q 81 497 81 250 q 218 871 81 737 q 599 1006 355 1006 q 893 945 751 1006 l 823 777 q 597 831 715 831 q 379 739 461 831 q 297 493 297 648 q 363 247 297 332 q 555 161 429 161 q 689 175 621 161 l 689 382 l 501 382 l 501 557 m 444 1183 q 557 1284 444 1284 q 669 1183 669 1284 q 641 1108 669 1135 q 557 1082 613 1082 q 444 1183 444 1082 z \"},\"ġ\":{\"ha\":785,\"x_min\":4,\"x_max\":768,\"o\":\"m 768 758 l 768 653 l 650 623 q 682 509 682 572 q 597 318 682 387 q 361 250 512 250 l 323 252 l 293 256 q 261 201 261 231 q 375 157 261 157 l 504 157 q 694 103 629 157 q 760 -54 760 50 q 649 -260 760 -187 q 330 -334 538 -334 q 88 -278 172 -334 q 4 -123 4 -223 q 47 -9 4 -55 q 172 57 90 37 q 117 101 140 71 q 93 167 93 132 q 118 239 93 210 q 191 296 143 268 q 96 378 131 321 q 61 513 61 435 q 142 705 61 637 q 372 772 222 772 q 448 767 404 772 q 504 758 492 761 l 768 758 m 183 -107 q 224 -174 183 -150 q 339 -199 265 -199 q 513 -168 450 -199 q 576 -85 576 -138 q 539 -26 576 -42 q 424 -9 502 -9 l 317 -9 q 221 -36 260 -9 q 183 -107 183 -63 m 258 510 q 287 412 258 448 q 372 376 315 376 q 458 412 431 376 q 485 510 485 448 q 372 647 485 647 q 258 510 258 647 m 279 954 q 391 1055 279 1055 q 504 954 504 1055 q 476 879 504 906 q 391 852 448 852 q 279 954 279 852 z \"},\"Ģ\":{\"ha\":1006,\"x_min\":81,\"x_max\":895,\"o\":\"m 501 557 l 895 557 l 895 43 q 714 -1 799 12 q 542 -14 630 -14 q 199 118 317 -14 q 81 497 81 250 q 218 871 81 737 q 599 1006 355 1006 q 893 945 751 1006 l 823 777 q 597 831 715 831 q 379 739 461 831 q 297 493 297 648 q 363 247 297 332 q 555 161 429 161 q 689 175 621 161 l 689 382 l 501 382 l 501 557 m 427 -289 q 450 -192 437 -256 q 469 -85 463 -128 l 660 -85 l 660 -98 q 547 -307 609 -212 l 427 -307 l 427 -289 z \"},\"ģ\":{\"ha\":785,\"x_min\":4,\"x_max\":768,\"o\":\"m 768 758 l 768 653 l 650 623 q 682 509 682 572 q 597 318 682 387 q 361 250 512 250 l 323 252 l 293 256 q 261 201 261 231 q 375 157 261 157 l 504 157 q 694 103 629 157 q 760 -54 760 50 q 649 -260 760 -187 q 330 -334 538 -334 q 88 -278 172 -334 q 4 -123 4 -223 q 47 -9 4 -55 q 172 57 90 37 q 117 101 140 71 q 93 167 93 132 q 118 239 93 210 q 191 296 143 268 q 96 378 131 321 q 61 513 61 435 q 142 705 61 637 q 372 772 222 772 q 448 767 404 772 q 504 758 492 761 l 768 758 m 183 -107 q 224 -174 183 -150 q 339 -199 265 -199 q 513 -168 450 -199 q 576 -85 576 -138 q 539 -26 576 -42 q 424 -9 502 -9 l 317 -9 q 221 -36 260 -9 q 183 -107 183 -63 m 258 510 q 287 412 258 448 q 372 376 315 376 q 458 412 431 376 q 485 510 485 448 q 372 647 485 647 q 258 510 258 647 m 521 1046 q 497 949 511 1013 q 479 842 484 885 l 288 842 l 288 856 q 400 1064 340 971 l 521 1064 l 521 1046 z \"},\"Ĥ\":{\"ha\":1063,\"x_min\":125,\"x_max\":937,\"o\":\"m 937 0 l 728 0 l 728 428 l 335 428 l 335 0 l 125 0 l 125 991 l 335 991 l 335 603 l 728 603 l 728 991 l 937 991 l 937 0 m 686 1071 q 528 1190 580 1134 q 372 1071 475 1135 l 235 1071 l 235 1089 q 408 1293 363 1217 l 650 1293 q 723 1197 671 1258 q 824 1089 775 1137 l 824 1071 l 686 1071 z \"},\"ĥ\":{\"ha\":913,\"x_min\":109,\"x_max\":808,\"o\":\"m 808 0 l 602 0 l 602 443 q 479 607 602 607 q 354 548 393 607 q 315 357 315 489 l 315 0 l 109 0 l 109 1055 l 315 1055 l 315 840 q 311 722 315 815 l 306 661 l 317 661 q 536 772 386 772 q 739 701 670 772 q 808 494 808 629 l 808 0 m 614 1108 q 455 1227 507 1171 q 300 1108 402 1173 l 162 1108 l 162 1126 q 336 1331 290 1255 l 578 1331 q 651 1235 599 1295 q 751 1126 703 1174 l 751 1108 l 614 1108 z \"},\"Ħ\":{\"ha\":1063,\"x_min\":0,\"x_max\":1063,\"o\":\"m 937 860 l 1063 860 l 1063 725 l 937 725 l 937 0 l 728 0 l 728 428 l 335 428 l 335 0 l 125 0 l 125 725 l 0 725 l 0 860 l 125 860 l 125 991 l 335 991 l 335 860 l 728 860 l 728 991 l 937 991 l 937 860 m 728 603 l 728 725 l 335 725 l 335 603 l 728 603 z \"},\"ħ\":{\"ha\":913,\"x_min\":3,\"x_max\":808,\"o\":\"m 808 0 l 602 0 l 602 401 q 479 566 602 566 q 354 506 393 566 q 315 315 315 447 l 315 0 l 109 0 l 109 811 l 3 811 l 3 946 l 109 946 l 109 1055 l 315 1055 l 315 946 l 529 946 l 529 811 l 315 811 l 315 799 q 306 619 315 743 l 318 619 q 538 730 387 730 q 740 659 671 730 q 808 453 808 588 l 808 0 z \"},\"ĩ\":{\"ha\":424,\"x_min\":-68,\"x_max\":494,\"o\":\"m 315 0 l 109 0 l 109 758 l 315 758 l 315 0 m 101 913 q 61 895 80 913 q 33 840 41 877 l -68 840 q -13 994 -61 939 q 116 1050 36 1050 q 171 1039 144 1050 q 223 1014 197 1027 q 275 990 250 1001 q 324 979 300 979 q 365 997 345 979 q 393 1051 384 1015 l 494 1051 q 437 897 486 953 q 309 842 388 842 q 255 853 281 842 q 202 877 228 864 q 151 902 176 890 q 101 913 125 913 z \"},\"ī\":{\"ha\":424,\"x_min\":-16,\"x_max\":444,\"o\":\"m 315 0 l 109 0 l 109 758 l 315 758 l 315 0 m -16 985 l 444 985 l 444 842 l -16 842 l -16 985 z \"},\"ĭ\":{\"ha\":424,\"x_min\":-55,\"x_max\":479,\"o\":\"m 315 0 l 109 0 l 109 758 l 315 758 l 315 0 m 479 1071 q 396 904 471 966 q 209 842 321 842 q 21 903 91 842 q -55 1071 -50 965 l 60 1071 q 79 1021 63 1039 q 124 994 95 1002 q 210 986 153 986 q 361 1071 350 986 l 479 1071 z \"},\"į\":{\"ha\":424,\"x_min\":29,\"x_max\":325,\"o\":\"m 100 954 q 212 1055 100 1055 q 325 954 325 1055 q 297 879 325 906 q 212 852 269 852 q 100 954 100 852 m 315 0 l 109 0 l 109 758 l 315 758 l 315 0 m 172 -154 q 188 -196 172 -182 q 227 -210 203 -210 q 304 -197 264 -210 l 304 -318 q 199 -334 249 -334 q 76 -291 122 -334 q 29 -178 29 -248 q 55 -92 29 -132 q 151 0 81 -52 l 273 0 q 199 -82 225 -45 q 172 -154 172 -119 z \"},\"ı\":{\"ha\":424,\"x_min\":109,\"x_max\":315,\"o\":\"m 315 0 l 109 0 l 109 758 l 315 758 l 315 0 z \"},\"ĳ\":{\"ha\":821,\"x_min\":100,\"x_max\":722,\"o\":\"m 100 954 q 212 1055 100 1055 q 325 954 325 1055 q 297 879 325 906 q 212 852 269 852 q 100 954 100 852 m 315 0 l 109 0 l 109 758 l 315 758 l 315 0 m 445 -334 q 309 -317 366 -334 l 309 -154 q 406 -167 356 -167 q 482 -138 458 -167 q 506 -52 506 -109 l 506 758 l 713 758 l 713 -82 q 643 -268 713 -203 q 445 -334 573 -334 m 497 954 q 610 1055 497 1055 q 722 954 722 1055 q 694 879 722 906 q 610 852 666 852 q 497 954 497 852 z \"},\"Ĵ\":{\"ha\":460,\"x_min\":-103,\"x_max\":527,\"o\":\"m 21 -292 q -103 -277 -50 -292 l -103 -102 q -4 -115 -49 -115 q 95 -72 65 -115 q 125 62 125 -29 l 125 991 l 335 991 l 335 64 q 256 -201 335 -110 q 21 -292 176 -292 m 389 1071 q 231 1190 283 1134 q 75 1071 178 1135 l -62 1071 l -62 1089 q 111 1293 66 1217 l 353 1293 q 426 1197 374 1258 q 527 1089 478 1137 l 527 1071 l 389 1071 z \"},\"ĵ\":{\"ha\":424,\"x_min\":-89,\"x_max\":504,\"o\":\"m 47 -334 q -89 -317 -32 -334 l -89 -154 q 8 -167 -41 -167 q 84 -138 60 -167 q 109 -52 109 -109 l 109 758 l 315 758 l 315 -82 q 245 -268 315 -203 q 47 -334 176 -334 m 366 842 q 208 961 260 905 q 52 842 155 906 l -85 842 l -85 860 q 88 1064 43 988 l 330 1064 q 403 968 351 1029 q 504 860 455 907 l 504 842 l 366 842 z \"},\"Ķ\":{\"ha\":922,\"x_min\":125,\"x_max\":922,\"o\":\"m 922 0 l 684 0 l 424 418 l 335 354 l 335 0 l 125 0 l 125 991 l 335 991 l 335 538 l 418 654 l 686 991 l 920 991 l 574 553 l 922 0 m 343 -289 q 367 -192 353 -256 q 385 -85 380 -128 l 576 -85 l 576 -98 q 464 -307 526 -212 l 343 -307 l 343 -289 z \"},\"ķ\":{\"ha\":861,\"x_min\":109,\"x_max\":861,\"o\":\"m 307 412 l 397 528 l 610 758 l 843 758 l 542 429 l 861 0 l 623 0 l 404 307 l 315 236 l 315 0 l 109 0 l 109 1055 l 315 1055 l 315 585 l 304 412 l 307 412 m 317 -289 q 340 -192 327 -256 q 359 -85 353 -128 l 550 -85 l 550 -98 q 437 -307 499 -212 l 317 -307 l 317 -289 z \"},\"ĸ\":{\"ha\":861,\"x_min\":109,\"x_max\":861,\"o\":\"m 314 395 l 410 510 l 623 758 l 843 758 l 545 411 l 861 0 l 625 0 l 412 289 l 315 228 l 315 0 l 109 0 l 109 758 l 315 758 l 315 559 l 313 450 l 311 395 l 314 395 z \"},\"Ĺ\":{\"ha\":785,\"x_min\":125,\"x_max\":737,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 174 l 737 174 l 737 0 l 125 0 m 181 1071 l 181 1089 q 340 1293 298 1225 l 572 1293 l 572 1279 q 452 1174 537 1244 q 319 1071 367 1105 l 181 1071 z \"},\"ĺ\":{\"ha\":424,\"x_min\":109,\"x_max\":513,\"o\":\"m 315 0 l 109 0 l 109 1055 l 315 1055 l 315 0 m 121 1109 l 121 1128 q 281 1332 238 1263 l 513 1332 l 513 1318 q 392 1213 477 1282 q 259 1109 307 1143 l 121 1109 z \"},\"Ļ\":{\"ha\":785,\"x_min\":125,\"x_max\":737,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 174 l 737 174 l 737 0 l 125 0 m 288 -289 q 311 -192 298 -256 q 330 -85 324 -128 l 521 -85 l 521 -98 q 408 -307 470 -212 l 288 -307 l 288 -289 z \"},\"ļ\":{\"ha\":424,\"x_min\":67,\"x_max\":315,\"o\":\"m 315 0 l 109 0 l 109 1055 l 315 1055 l 315 0 m 67 -289 q 91 -192 77 -256 q 109 -85 104 -128 l 300 -85 l 300 -98 q 188 -307 250 -212 l 67 -307 l 67 -289 z \"},\"Ľ\":{\"ha\":785,\"x_min\":125,\"x_max\":737,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 174 l 737 174 l 737 0 l 125 0 m 490 788 q 514 885 500 821 q 532 992 527 949 l 724 992 l 724 979 q 611 770 669 859 l 490 770 l 490 788 z \"},\"ľ\":{\"ha\":424,\"x_min\":109,\"x_max\":611,\"o\":\"m 315 0 l 109 0 l 109 1055 l 315 1055 l 315 0 m 378 851 q 401 948 388 884 q 420 1055 414 1012 l 611 1055 l 611 1042 q 498 833 557 922 l 378 833 l 378 851 z \"},\"Ŀ\":{\"ha\":785,\"x_min\":125,\"x_max\":737,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 174 l 737 174 l 737 0 l 125 0 m 479 509 q 591 610 479 610 q 704 509 704 610 q 676 434 704 461 q 591 408 648 408 q 479 509 479 408 z \"},\"ŀ\":{\"ha\":595,\"x_min\":109,\"x_max\":623,\"o\":\"m 315 0 l 109 0 l 109 1055 l 315 1055 l 315 0 m 398 471 q 511 572 398 572 q 623 471 623 572 q 595 396 623 423 q 511 370 567 370 q 398 471 398 370 z \"},\"Ł\":{\"ha\":785,\"x_min\":1,\"x_max\":737,\"o\":\"m 125 0 l 125 334 l 78 306 l 1 439 l 125 514 l 125 991 l 335 991 l 335 642 l 432 701 l 511 568 l 335 461 l 335 174 l 737 174 l 737 0 l 125 0 z \"},\"ł\":{\"ha\":458,\"x_min\":0,\"x_max\":458,\"o\":\"m 332 631 l 379 660 l 458 526 l 332 450 l 332 0 l 125 0 l 125 323 l 77 294 l 0 428 l 125 504 l 125 1055 l 332 1055 l 332 631 z \"},\"Ń\":{\"ha\":1129,\"x_min\":125,\"x_max\":1004,\"o\":\"m 1004 0 l 737 0 l 306 750 l 300 750 q 313 467 313 551 l 313 0 l 125 0 l 125 991 l 390 991 l 821 249 l 825 249 q 815 522 815 442 l 815 991 l 1004 991 l 1004 0 m 445 1071 l 445 1089 q 604 1293 562 1225 l 836 1293 l 836 1279 q 716 1174 801 1244 q 583 1071 631 1105 l 445 1071 z \"},\"ń\":{\"ha\":913,\"x_min\":109,\"x_max\":808,\"o\":\"m 808 0 l 602 0 l 602 443 q 572 566 602 525 q 479 607 543 607 q 354 549 393 607 q 315 357 315 491 l 315 0 l 109 0 l 109 758 l 267 758 l 294 661 l 306 661 q 401 744 340 716 q 539 772 462 772 q 740 701 671 772 q 808 494 808 629 l 808 0 m 340 842 l 340 860 q 500 1064 457 996 l 732 1064 l 732 1050 q 611 945 696 1015 q 478 842 526 876 l 340 842 z \"},\"Ņ\":{\"ha\":1129,\"x_min\":125,\"x_max\":1004,\"o\":\"m 1004 0 l 737 0 l 306 750 l 300 750 q 313 467 313 551 l 313 0 l 125 0 l 125 991 l 390 991 l 821 249 l 825 249 q 815 522 815 442 l 815 991 l 1004 991 l 1004 0 m 406 -289 q 429 -192 416 -256 q 448 -85 442 -128 l 639 -85 l 639 -98 q 526 -307 588 -212 l 406 -307 l 406 -289 z \"},\"ņ\":{\"ha\":913,\"x_min\":109,\"x_max\":808,\"o\":\"m 808 0 l 602 0 l 602 443 q 572 566 602 525 q 479 607 543 607 q 354 549 393 607 q 315 357 315 491 l 315 0 l 109 0 l 109 758 l 267 758 l 294 661 l 306 661 q 401 744 340 716 q 539 772 462 772 q 740 701 671 772 q 808 494 808 629 l 808 0 m 317 -289 q 340 -192 327 -256 q 359 -85 353 -128 l 550 -85 l 550 -98 q 437 -307 499 -212 l 317 -307 l 317 -289 z \"},\"Ň\":{\"ha\":1129,\"x_min\":125,\"x_max\":1004,\"o\":\"m 1004 0 l 737 0 l 306 750 l 300 750 q 313 467 313 551 l 313 0 l 125 0 l 125 991 l 390 991 l 821 249 l 825 249 q 815 522 815 442 l 815 991 l 1004 991 l 1004 0 m 877 1293 l 877 1275 q 772 1161 820 1218 q 703 1071 724 1105 l 461 1071 q 405 1147 441 1103 q 288 1275 368 1192 l 288 1293 l 425 1293 q 581 1174 525 1230 q 739 1293 637 1233 l 877 1293 z \"},\"ň\":{\"ha\":913,\"x_min\":109,\"x_max\":808,\"o\":\"m 808 0 l 602 0 l 602 443 q 572 566 602 525 q 479 607 543 607 q 354 549 393 607 q 315 357 315 491 l 315 0 l 109 0 l 109 758 l 267 758 l 294 661 l 306 661 q 401 744 340 716 q 539 772 462 772 q 740 701 671 772 q 808 494 808 629 l 808 0 m 768 1064 l 768 1046 q 664 932 711 989 q 595 842 616 876 l 353 842 q 296 918 333 873 q 179 1046 260 962 l 179 1064 l 317 1064 q 472 945 416 1001 q 631 1064 529 1004 l 768 1064 z \"},\"ŉ\":{\"ha\":1082,\"x_min\":4,\"x_max\":978,\"o\":\"m 978 0 l 771 0 l 771 443 q 742 566 771 525 q 649 607 713 607 q 524 549 562 607 q 485 357 485 491 l 485 0 l 278 0 l 278 758 l 436 758 l 464 661 l 475 661 q 571 744 510 716 q 709 772 631 772 q 909 701 841 772 q 978 494 978 629 l 978 0 m 262 991 l 272 977 q 153 652 238 843 l 4 652 q 72 991 51 852 l 262 991 z \"},\"Ŋ\":{\"ha\":1129,\"x_min\":125,\"x_max\":1004,\"o\":\"m 689 -292 q 555 -277 612 -292 l 555 -102 q 668 -115 618 -115 q 782 -84 742 -115 q 828 3 822 -54 l 306 750 l 300 750 q 313 467 313 551 l 313 0 l 125 0 l 125 991 l 390 991 l 821 387 l 825 387 l 820 490 q 815 661 815 564 l 815 991 l 1004 991 l 1004 0 q 923 -216 1004 -140 q 689 -292 841 -292 z \"},\"ŋ\":{\"ha\":913,\"x_min\":109,\"x_max\":808,\"o\":\"m 562 -334 q 437 -317 490 -334 l 437 -154 q 518 -167 477 -167 q 602 -52 602 -167 l 602 458 q 479 607 602 607 q 354 549 393 607 q 315 357 315 491 l 315 0 l 109 0 l 109 758 l 267 758 l 294 661 l 307 661 q 401 744 341 715 q 539 772 460 772 q 740 701 671 772 q 808 494 808 629 l 808 -82 q 745 -269 808 -203 q 562 -334 681 -334 z \"},\"Ō\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 324 1214 l 784 1214 l 784 1071 l 324 1071 l 324 1214 z \"},\"ō\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 200 985 l 660 985 l 660 842 l 200 842 l 200 985 z \"},\"Ŏ\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 821 1300 q 739 1133 813 1196 q 551 1071 664 1071 q 363 1133 433 1071 q 288 1300 293 1194 l 403 1300 q 421 1250 406 1268 q 466 1223 437 1232 q 553 1215 495 1215 q 703 1300 692 1215 l 821 1300 z \"},\"ŏ\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 696 1071 q 613 904 688 966 q 426 842 538 842 q 238 903 308 842 q 162 1071 168 965 l 277 1071 q 296 1021 280 1039 q 341 994 312 1002 q 427 986 370 986 q 578 1071 567 986 l 696 1071 z \"},\"Ő\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 324 1071 l 324 1089 q 404 1206 366 1147 q 456 1293 441 1265 l 660 1293 l 660 1279 q 561 1175 638 1243 q 433 1071 484 1107 l 324 1071 m 593 1071 l 593 1089 q 726 1293 688 1219 l 930 1293 l 930 1279 q 845 1188 913 1250 q 703 1071 777 1126 l 593 1071 z \"},\"ő\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 189 842 l 189 860 q 269 977 231 918 q 321 1064 307 1036 l 525 1064 l 525 1050 q 426 946 503 1014 q 298 842 349 878 l 189 842 m 458 842 l 458 860 q 591 1064 553 990 l 795 1064 l 795 1050 q 710 959 778 1021 q 568 842 642 897 l 458 842 z \"},\"Œ\":{\"ha\":1352,\"x_min\":81,\"x_max\":1270,\"o\":\"m 1270 0 l 677 0 q 604 -10 652 -6 q 525 -14 555 -14 q 195 120 309 -14 q 81 498 81 254 q 196 876 81 745 q 526 1007 311 1007 q 612 1002 568 1007 q 681 991 657 998 l 1270 991 l 1270 819 l 888 819 l 888 602 l 1244 602 l 1244 429 l 888 429 l 888 174 l 1270 174 l 1270 0 m 526 832 q 355 747 414 832 q 297 497 297 662 q 355 247 297 332 q 525 163 414 163 q 610 170 569 163 q 677 189 652 177 l 677 804 q 609 825 654 817 q 526 832 564 832 z \"},\"œ\":{\"ha\":1358,\"x_min\":62,\"x_max\":1299,\"o\":\"m 981 -14 q 696 92 797 -14 q 431 -14 600 -14 q 237 34 321 -14 q 107 171 153 81 q 62 380 62 260 q 158 670 62 568 q 429 772 254 772 q 573 746 505 772 q 689 667 641 719 q 949 772 787 772 q 1206 681 1114 772 q 1299 428 1299 589 l 1299 328 l 793 328 l 793 322 q 848 188 798 236 q 989 140 899 140 q 1124 155 1061 140 q 1255 200 1187 169 l 1255 40 q 1136 0 1200 14 q 981 -14 1072 -14 m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 953 625 q 847 586 889 625 q 799 465 805 547 l 1104 465 q 1063 583 1103 541 q 953 625 1023 625 z \"},\"Ŕ\":{\"ha\":917,\"x_min\":125,\"x_max\":917,\"o\":\"m 335 551 l 403 551 q 550 585 503 551 q 597 689 597 618 q 549 789 597 760 q 399 819 500 819 l 335 819 l 335 551 m 335 380 l 335 0 l 125 0 l 125 991 l 414 991 q 713 918 616 991 q 810 694 810 844 q 762 539 810 607 q 625 432 713 471 q 917 0 849 98 l 684 0 l 447 380 l 335 380 m 323 1071 l 323 1089 q 483 1293 440 1225 l 715 1293 l 715 1279 q 594 1174 680 1244 q 461 1071 509 1105 l 323 1071 z \"},\"ŕ\":{\"ha\":631,\"x_min\":109,\"x_max\":621,\"o\":\"m 532 772 q 602 766 574 772 l 586 572 q 525 579 561 579 q 371 528 426 579 q 315 386 315 477 l 315 0 l 109 0 l 109 758 l 265 758 l 296 631 l 306 631 q 401 733 341 694 q 532 772 461 772 m 229 842 l 229 860 q 389 1064 346 996 l 621 1064 l 621 1050 q 500 945 585 1015 q 367 842 415 876 l 229 842 z \"},\"Ŗ\":{\"ha\":917,\"x_min\":125,\"x_max\":917,\"o\":\"m 335 551 l 403 551 q 550 585 503 551 q 597 689 597 618 q 549 789 597 760 q 399 819 500 819 l 335 819 l 335 551 m 335 380 l 335 0 l 125 0 l 125 991 l 414 991 q 713 918 616 991 q 810 694 810 844 q 762 539 810 607 q 625 432 713 471 q 917 0 849 98 l 684 0 l 447 380 l 335 380 m 359 -289 q 383 -192 370 -256 q 401 -85 396 -128 l 593 -85 l 593 -98 q 480 -307 542 -212 l 359 -307 l 359 -289 z \"},\"ŗ\":{\"ha\":631,\"x_min\":67,\"x_max\":602,\"o\":\"m 532 772 q 602 766 574 772 l 586 572 q 525 579 561 579 q 371 528 426 579 q 315 386 315 477 l 315 0 l 109 0 l 109 758 l 265 758 l 296 631 l 306 631 q 401 733 341 694 q 532 772 461 772 m 67 -289 q 91 -192 77 -256 q 109 -85 104 -128 l 300 -85 l 300 -98 q 188 -307 250 -212 l 67 -307 l 67 -289 z \"},\"Ř\":{\"ha\":917,\"x_min\":125,\"x_max\":917,\"o\":\"m 335 551 l 403 551 q 550 585 503 551 q 597 689 597 618 q 549 789 597 760 q 399 819 500 819 l 335 819 l 335 551 m 335 380 l 335 0 l 125 0 l 125 991 l 414 991 q 713 918 616 991 q 810 694 810 844 q 762 539 810 607 q 625 432 713 471 q 917 0 849 98 l 684 0 l 447 380 l 335 380 m 750 1293 l 750 1275 q 645 1161 693 1218 q 576 1071 597 1105 l 334 1071 q 278 1147 315 1103 q 161 1275 241 1192 l 161 1293 l 298 1293 q 454 1174 398 1230 q 612 1293 511 1233 l 750 1293 z \"},\"ř\":{\"ha\":631,\"x_min\":56,\"x_max\":646,\"o\":\"m 532 772 q 602 766 574 772 l 586 572 q 525 579 561 579 q 371 528 426 579 q 315 386 315 477 l 315 0 l 109 0 l 109 758 l 265 758 l 296 631 l 306 631 q 401 733 341 694 q 532 772 461 772 m 646 1064 l 646 1046 q 541 932 589 989 q 472 842 493 876 l 230 842 q 174 918 210 873 q 56 1046 137 962 l 56 1064 l 194 1064 q 349 945 294 1001 q 508 1064 406 1004 l 646 1064 z \"},\"Ś\":{\"ha\":765,\"x_min\":64,\"x_max\":710,\"o\":\"m 710 275 q 613 64 710 141 q 345 -14 517 -14 q 64 46 186 -14 l 64 241 q 234 178 164 197 q 361 160 303 160 q 467 186 430 160 q 504 265 504 213 q 488 317 504 294 q 440 361 471 340 q 311 428 408 382 q 175 510 220 471 q 102 602 130 549 q 75 724 75 654 q 164 930 75 855 q 411 1006 254 1006 q 558 987 488 1006 q 705 936 629 969 l 637 772 q 506 818 558 805 q 404 831 454 831 q 313 803 345 831 q 281 730 281 775 q 294 682 281 703 q 335 642 307 661 q 468 572 363 623 q 659 439 607 506 q 710 275 710 372 m 278 1071 l 278 1089 q 437 1293 395 1225 l 669 1293 l 669 1279 q 549 1174 634 1244 q 416 1071 464 1105 l 278 1071 z \"},\"ś\":{\"ha\":690,\"x_min\":62,\"x_max\":637,\"o\":\"m 637 225 q 556 47 637 109 q 314 -14 475 -14 q 173 -2 231 -14 q 64 31 115 9 l 64 201 q 194 156 121 174 q 321 138 266 138 q 433 203 433 138 q 418 242 433 227 q 367 277 404 258 q 269 322 330 296 q 141 390 182 359 q 81 461 100 421 q 62 561 62 502 q 141 717 62 662 q 363 772 219 772 q 629 713 500 772 l 567 564 q 460 604 510 588 q 359 619 411 619 q 268 570 268 619 q 297 522 268 542 q 427 461 327 501 q 557 394 515 425 q 618 322 598 363 q 637 225 637 281 m 232 842 l 232 860 q 391 1064 349 996 l 623 1064 l 623 1050 q 503 945 588 1015 q 370 842 418 876 l 232 842 z \"},\"Ŝ\":{\"ha\":765,\"x_min\":64,\"x_max\":710,\"o\":\"m 710 275 q 613 64 710 141 q 345 -14 517 -14 q 64 46 186 -14 l 64 241 q 234 178 164 197 q 361 160 303 160 q 467 186 430 160 q 504 265 504 213 q 488 317 504 294 q 440 361 471 340 q 311 428 408 382 q 175 510 220 471 q 102 602 130 549 q 75 724 75 654 q 164 930 75 855 q 411 1006 254 1006 q 558 987 488 1006 q 705 936 629 969 l 637 772 q 506 818 558 805 q 404 831 454 831 q 313 803 345 831 q 281 730 281 775 q 294 682 281 703 q 335 642 307 661 q 468 572 363 623 q 659 439 607 506 q 710 275 710 372 m 563 1071 q 404 1190 456 1134 q 249 1071 351 1135 l 111 1071 l 111 1089 q 285 1293 239 1217 l 527 1293 q 600 1197 548 1258 q 701 1089 652 1137 l 701 1071 l 563 1071 z \"},\"ŝ\":{\"ha\":690,\"x_min\":62,\"x_max\":652,\"o\":\"m 637 225 q 556 47 637 109 q 314 -14 475 -14 q 173 -2 231 -14 q 64 31 115 9 l 64 201 q 194 156 121 174 q 321 138 266 138 q 433 203 433 138 q 418 242 433 227 q 367 277 404 258 q 269 322 330 296 q 141 390 182 359 q 81 461 100 421 q 62 561 62 502 q 141 717 62 662 q 363 772 219 772 q 629 713 500 772 l 567 564 q 460 604 510 588 q 359 619 411 619 q 268 570 268 619 q 297 522 268 542 q 427 461 327 501 q 557 394 515 425 q 618 322 598 363 q 637 225 637 281 m 515 842 q 356 961 408 905 q 201 842 303 906 l 63 842 l 63 860 q 237 1064 191 988 l 479 1064 q 552 968 500 1029 q 652 860 604 907 l 652 842 l 515 842 z \"},\"Ş\":{\"ha\":765,\"x_min\":64,\"x_max\":710,\"o\":\"m 710 275 q 613 64 710 141 q 345 -14 517 -14 q 64 46 186 -14 l 64 241 q 234 178 164 197 q 361 160 303 160 q 467 186 430 160 q 504 265 504 213 q 488 317 504 294 q 440 361 471 340 q 311 428 408 382 q 175 510 220 471 q 102 602 130 549 q 75 724 75 654 q 164 930 75 855 q 411 1006 254 1006 q 558 987 488 1006 q 705 936 629 969 l 637 772 q 506 818 558 805 q 404 831 454 831 q 313 803 345 831 q 281 730 281 775 q 294 682 281 703 q 335 642 307 661 q 468 572 363 623 q 659 439 607 506 q 710 275 710 372 m 524 -170 q 472 -295 524 -256 q 314 -334 421 -334 q 215 -319 261 -334 l 215 -205 q 264 -215 233 -210 q 312 -220 295 -220 q 361 -178 361 -220 q 248 -104 361 -121 l 301 0 l 432 0 l 414 -41 q 494 -92 464 -58 q 524 -170 524 -126 z \"},\"ş\":{\"ha\":690,\"x_min\":62,\"x_max\":637,\"o\":\"m 637 225 q 556 47 637 109 q 314 -14 475 -14 q 173 -2 231 -14 q 64 31 115 9 l 64 201 q 194 156 121 174 q 321 138 266 138 q 433 203 433 138 q 418 242 433 227 q 367 277 404 258 q 269 322 330 296 q 141 390 182 359 q 81 461 100 421 q 62 561 62 502 q 141 717 62 662 q 363 772 219 772 q 629 713 500 772 l 567 564 q 460 604 510 588 q 359 619 411 619 q 268 570 268 619 q 297 522 268 542 q 427 461 327 501 q 557 394 515 425 q 618 322 598 363 q 637 225 637 281 m 488 -170 q 436 -295 488 -256 q 278 -334 385 -334 q 179 -319 225 -334 l 179 -205 q 228 -215 197 -210 q 276 -220 259 -220 q 325 -178 325 -220 q 212 -104 325 -121 l 265 0 l 396 0 l 378 -41 q 458 -92 428 -58 q 488 -170 488 -126 z \"},\"Š\":{\"ha\":765,\"x_min\":64,\"x_max\":710,\"o\":\"m 710 275 q 613 64 710 141 q 345 -14 517 -14 q 64 46 186 -14 l 64 241 q 234 178 164 197 q 361 160 303 160 q 467 186 430 160 q 504 265 504 213 q 488 317 504 294 q 440 361 471 340 q 311 428 408 382 q 175 510 220 471 q 102 602 130 549 q 75 724 75 654 q 164 930 75 855 q 411 1006 254 1006 q 558 987 488 1006 q 705 936 629 969 l 637 772 q 506 818 558 805 q 404 831 454 831 q 313 803 345 831 q 281 730 281 775 q 294 682 281 703 q 335 642 307 661 q 468 572 363 623 q 659 439 607 506 q 710 275 710 372 m 701 1293 l 701 1275 q 596 1161 644 1218 q 527 1071 548 1105 l 285 1071 q 229 1147 265 1103 q 111 1275 192 1192 l 111 1293 l 249 1293 q 404 1174 349 1230 q 563 1293 461 1233 l 701 1293 z \"},\"š\":{\"ha\":690,\"x_min\":62,\"x_max\":659,\"o\":\"m 637 225 q 556 47 637 109 q 314 -14 475 -14 q 173 -2 231 -14 q 64 31 115 9 l 64 201 q 194 156 121 174 q 321 138 266 138 q 433 203 433 138 q 418 242 433 227 q 367 277 404 258 q 269 322 330 296 q 141 390 182 359 q 81 461 100 421 q 62 561 62 502 q 141 717 62 662 q 363 772 219 772 q 629 713 500 772 l 567 564 q 460 604 510 588 q 359 619 411 619 q 268 570 268 619 q 297 522 268 542 q 427 461 327 501 q 557 394 515 425 q 618 322 598 363 q 637 225 637 281 m 659 1064 l 659 1046 q 554 932 602 989 q 486 842 507 876 l 243 842 q 187 918 224 873 q 70 1046 151 962 l 70 1064 l 208 1064 q 363 945 307 1001 q 522 1064 420 1004 l 659 1064 z \"},\"Ț\":{\"ha\":804,\"x_min\":28,\"x_max\":777,\"o\":\"m 507 0 l 297 0 l 297 817 l 28 817 l 28 991 l 777 991 l 777 817 l 507 817 l 507 0 m 265 -289 q 289 -192 275 -256 q 307 -85 302 -128 l 498 -85 l 498 -98 q 386 -307 448 -212 l 265 -307 l 265 -289 z \"},\"ț\":{\"ha\":603,\"x_min\":32,\"x_max\":558,\"o\":\"m 428 151 q 558 175 482 151 l 558 21 q 368 -14 481 -14 q 188 49 244 -14 q 131 237 131 112 l 131 603 l 32 603 l 32 690 l 146 760 l 205 920 l 338 920 l 338 758 l 550 758 l 550 603 l 338 603 l 338 237 q 362 172 338 193 q 428 151 387 151 m 203 -289 q 227 -192 214 -256 q 245 -85 240 -128 l 437 -85 l 437 -98 q 324 -307 386 -212 l 203 -307 l 203 -289 z \"},\"Ť\":{\"ha\":804,\"x_min\":28,\"x_max\":777,\"o\":\"m 507 0 l 297 0 l 297 817 l 28 817 l 28 991 l 777 991 l 777 817 l 507 817 l 507 0 m 698 1293 l 698 1275 q 593 1161 641 1218 q 524 1071 545 1105 l 282 1071 q 226 1147 262 1103 q 109 1275 189 1192 l 109 1293 l 246 1293 q 401 1174 346 1230 q 560 1293 458 1233 l 698 1293 z \"},\"ť\":{\"ha\":603,\"x_min\":32,\"x_max\":654,\"o\":\"m 428 151 q 558 175 482 151 l 558 21 q 368 -14 481 -14 q 188 49 244 -14 q 131 237 131 112 l 131 603 l 32 603 l 32 690 l 146 760 l 205 920 l 338 920 l 338 758 l 550 758 l 550 603 l 338 603 l 338 237 q 362 172 338 193 q 428 151 387 151 m 420 865 q 444 962 431 898 q 463 1069 457 1025 l 654 1069 l 654 1055 q 541 847 600 936 l 420 847 l 420 865 z \"},\"Ŧ\":{\"ha\":804,\"x_min\":28,\"x_max\":777,\"o\":\"m 507 0 l 297 0 l 297 404 l 129 404 l 129 576 l 297 576 l 297 817 l 28 817 l 28 991 l 777 991 l 777 817 l 507 817 l 507 576 l 675 576 l 675 404 l 507 404 l 507 0 z \"},\"ŧ\":{\"ha\":603,\"x_min\":32,\"x_max\":558,\"o\":\"m 428 151 q 558 175 482 151 l 558 21 q 472 -5 523 4 q 372 -14 422 -14 q 189 48 246 -14 q 131 237 131 110 l 131 338 l 45 338 l 45 472 l 131 472 l 131 603 l 32 603 l 32 690 l 146 760 l 205 920 l 338 920 l 338 758 l 550 758 l 550 603 l 338 603 l 338 472 l 526 472 l 526 338 l 338 338 l 338 237 q 362 172 338 193 q 428 151 387 151 z \"},\"Ũ\":{\"ha\":1050,\"x_min\":118,\"x_max\":932,\"o\":\"m 932 991 l 932 350 q 883 157 932 240 q 741 31 833 75 q 521 -14 648 -14 q 224 84 330 -14 q 118 353 118 182 l 118 991 l 328 991 l 328 385 q 374 216 328 270 q 526 163 420 163 q 676 217 629 163 q 722 386 722 271 l 722 991 l 932 991 m 416 1142 q 375 1124 395 1142 q 347 1069 356 1106 l 246 1069 q 302 1223 254 1168 q 431 1279 351 1279 q 485 1268 458 1279 q 538 1243 512 1257 q 589 1219 564 1230 q 639 1208 614 1208 q 679 1226 660 1208 q 707 1280 699 1244 l 808 1280 q 752 1126 801 1182 q 624 1071 703 1071 q 569 1082 596 1071 q 516 1106 543 1093 q 465 1131 490 1120 q 416 1142 440 1142 z \"},\"ũ\":{\"ha\":913,\"x_min\":104,\"x_max\":804,\"o\":\"m 646 0 l 618 97 l 607 97 q 513 15 574 44 q 374 -14 452 -14 q 172 58 240 -14 q 104 264 104 130 l 104 758 l 311 758 l 311 315 q 340 192 311 233 q 433 151 370 151 q 559 209 520 151 q 597 401 597 267 l 597 758 l 804 758 l 804 0 l 646 0 m 343 913 q 303 895 322 913 q 275 840 283 877 l 174 840 q 230 994 181 939 q 358 1050 278 1050 q 413 1039 386 1050 q 466 1014 439 1027 q 517 990 492 1001 q 566 979 542 979 q 607 997 587 979 q 635 1051 626 1015 l 736 1051 q 679 897 728 953 q 551 842 630 842 q 497 853 524 842 q 444 877 470 864 q 393 902 418 890 q 343 913 368 913 z \"},\"Ū\":{\"ha\":1050,\"x_min\":118,\"x_max\":932,\"o\":\"m 932 991 l 932 350 q 883 157 932 240 q 741 31 833 75 q 521 -14 648 -14 q 224 84 330 -14 q 118 353 118 182 l 118 991 l 328 991 l 328 385 q 374 216 328 270 q 526 163 420 163 q 676 217 629 163 q 722 386 722 271 l 722 991 l 932 991 m 296 1214 l 756 1214 l 756 1071 l 296 1071 l 296 1214 z \"},\"ū\":{\"ha\":913,\"x_min\":104,\"x_max\":804,\"o\":\"m 646 0 l 618 97 l 607 97 q 513 15 574 44 q 374 -14 452 -14 q 172 58 240 -14 q 104 264 104 130 l 104 758 l 311 758 l 311 315 q 340 192 311 233 q 433 151 370 151 q 559 209 520 151 q 597 401 597 267 l 597 758 l 804 758 l 804 0 l 646 0 m 224 985 l 684 985 l 684 842 l 224 842 l 224 985 z \"},\"Ŭ\":{\"ha\":1050,\"x_min\":118,\"x_max\":932,\"o\":\"m 932 991 l 932 350 q 883 157 932 240 q 741 31 833 75 q 521 -14 648 -14 q 224 84 330 -14 q 118 353 118 182 l 118 991 l 328 991 l 328 385 q 374 216 328 270 q 526 163 420 163 q 676 217 629 163 q 722 386 722 271 l 722 991 l 932 991 m 792 1300 q 709 1133 784 1196 q 522 1071 635 1071 q 334 1133 404 1071 q 258 1300 264 1194 l 374 1300 q 392 1250 376 1268 q 437 1223 408 1232 q 524 1215 466 1215 q 674 1300 663 1215 l 792 1300 z \"},\"ŭ\":{\"ha\":913,\"x_min\":104,\"x_max\":804,\"o\":\"m 646 0 l 618 97 l 607 97 q 513 15 574 44 q 374 -14 452 -14 q 172 58 240 -14 q 104 264 104 130 l 104 758 l 311 758 l 311 315 q 340 192 311 233 q 433 151 370 151 q 559 209 520 151 q 597 401 597 267 l 597 758 l 804 758 l 804 0 l 646 0 m 721 1071 q 638 904 713 966 q 451 842 564 842 q 263 903 333 842 q 187 1071 193 965 l 302 1071 q 321 1021 305 1039 q 366 994 337 1002 q 452 986 395 986 q 603 1071 592 986 l 721 1071 z \"},\"Ů\":{\"ha\":1050,\"x_min\":118,\"x_max\":932,\"o\":\"m 932 991 l 932 350 q 883 157 932 240 q 741 31 833 75 q 521 -14 648 -14 q 224 84 330 -14 q 118 353 118 182 l 118 991 l 328 991 l 328 385 q 374 216 328 270 q 526 163 420 163 q 676 217 629 163 q 722 386 722 271 l 722 991 l 932 991 m 696 1232 q 648 1114 696 1159 q 524 1069 600 1069 q 401 1113 448 1069 q 355 1231 355 1156 q 401 1348 355 1304 q 524 1392 447 1392 q 647 1347 598 1392 q 696 1232 696 1302 m 589 1231 q 570 1279 589 1261 q 524 1296 552 1296 q 477 1279 495 1296 q 458 1231 458 1261 q 475 1183 458 1200 q 524 1165 491 1165 q 570 1183 552 1165 q 589 1231 589 1200 z \"},\"ů\":{\"ha\":913,\"x_min\":104,\"x_max\":804,\"o\":\"m 646 0 l 618 97 l 607 97 q 513 15 574 44 q 374 -14 452 -14 q 172 58 240 -14 q 104 264 104 130 l 104 758 l 311 758 l 311 315 q 340 192 311 233 q 433 151 370 151 q 559 209 520 151 q 597 401 597 267 l 597 758 l 804 758 l 804 0 l 646 0 m 624 1003 q 576 885 624 930 q 452 840 528 840 q 330 884 376 840 q 283 1002 283 927 q 329 1119 283 1075 q 452 1162 375 1162 q 575 1118 526 1162 q 624 1003 624 1073 m 517 1002 q 498 1049 517 1032 q 452 1067 480 1067 q 405 1049 423 1067 q 387 1002 387 1032 q 403 954 387 971 q 452 936 419 936 q 498 954 480 936 q 517 1002 517 971 z \"},\"Ű\":{\"ha\":1050,\"x_min\":118,\"x_max\":932,\"o\":\"m 932 991 l 932 350 q 883 157 932 240 q 741 31 833 75 q 521 -14 648 -14 q 224 84 330 -14 q 118 353 118 182 l 118 991 l 328 991 l 328 385 q 374 216 328 270 q 526 163 420 163 q 676 217 629 163 q 722 386 722 271 l 722 991 l 932 991 m 299 1071 l 299 1089 q 379 1206 341 1147 q 431 1293 416 1265 l 635 1293 l 635 1279 q 536 1175 613 1243 q 408 1071 458 1107 l 299 1071 m 568 1071 l 568 1089 q 701 1293 663 1219 l 905 1293 l 905 1279 q 820 1188 888 1250 q 678 1071 751 1126 l 568 1071 z \"},\"ű\":{\"ha\":913,\"x_min\":104,\"x_max\":839,\"o\":\"m 646 0 l 618 97 l 607 97 q 513 15 574 44 q 374 -14 452 -14 q 172 58 240 -14 q 104 264 104 130 l 104 758 l 311 758 l 311 315 q 340 192 311 233 q 433 151 370 151 q 559 209 520 151 q 597 401 597 267 l 597 758 l 804 758 l 804 0 l 646 0 m 233 842 l 233 860 q 313 977 275 918 q 365 1064 351 1036 l 569 1064 l 569 1050 q 470 946 547 1014 q 342 842 393 878 l 233 842 m 503 842 l 503 860 q 635 1064 597 990 l 839 1064 l 839 1050 q 754 959 822 1021 q 612 842 686 897 l 503 842 z \"},\"Ų\":{\"ha\":1050,\"x_min\":118,\"x_max\":932,\"o\":\"m 932 991 l 932 350 q 883 157 932 240 q 741 31 833 75 q 521 -14 648 -14 q 224 84 330 -14 q 118 353 118 182 l 118 991 l 328 991 l 328 385 q 374 216 328 270 q 526 163 420 163 q 676 217 629 163 q 722 386 722 271 l 722 991 l 932 991 m 546 -154 q 561 -196 546 -182 q 600 -210 576 -210 q 678 -197 637 -210 l 678 -318 q 572 -334 623 -334 q 449 -291 496 -334 q 403 -178 403 -248 q 429 -92 403 -132 q 525 0 454 -52 l 646 0 q 572 -82 599 -45 q 546 -154 546 -119 z \"},\"ų\":{\"ha\":913,\"x_min\":104,\"x_max\":804,\"o\":\"m 646 0 l 618 97 l 607 97 q 513 15 574 44 q 374 -14 452 -14 q 172 58 240 -14 q 104 264 104 130 l 104 758 l 311 758 l 311 315 q 340 192 311 233 q 433 151 370 151 q 559 209 520 151 q 597 401 597 267 l 597 758 l 804 758 l 804 0 l 646 0 m 665 -154 q 681 -196 665 -182 q 720 -210 696 -210 q 798 -197 757 -210 l 798 -318 q 692 -334 742 -334 q 569 -291 615 -334 q 522 -178 522 -248 q 548 -92 522 -132 q 644 0 574 -52 l 766 0 q 692 -82 718 -45 q 665 -154 665 -119 z \"},\"Ŵ\":{\"ha\":1343,\"x_min\":0,\"x_max\":1343,\"o\":\"m 1090 0 l 851 0 l 717 521 q 691 636 709 549 q 671 753 673 723 q 650 635 667 716 q 625 519 634 554 l 492 0 l 253 0 l 0 991 l 207 991 l 334 450 q 382 191 367 300 q 400 310 386 229 q 428 436 415 391 l 572 991 l 771 991 l 916 436 q 939 322 925 399 q 961 191 954 245 q 983 322 968 243 q 1010 450 998 401 l 1136 991 l 1343 991 l 1090 0 m 828 1071 q 669 1190 722 1134 q 514 1071 616 1135 l 376 1071 l 376 1089 q 550 1293 505 1217 l 792 1293 q 865 1197 813 1258 q 966 1089 917 1137 l 966 1071 l 828 1071 z \"},\"ŵ\":{\"ha\":1189,\"x_min\":14,\"x_max\":1175,\"o\":\"m 732 0 l 673 265 l 595 600 l 590 600 l 452 0 l 229 0 l 14 758 l 220 758 l 307 422 q 350 174 328 332 l 354 174 q 378 337 357 225 l 389 395 l 482 758 l 710 758 l 799 395 q 807 351 802 380 q 819 289 813 321 q 828 224 824 256 q 833 174 833 193 l 838 174 q 859 308 844 222 q 882 422 875 393 l 972 758 l 1175 758 l 957 0 l 732 0 m 751 842 q 593 961 645 905 q 437 842 540 906 l 300 842 l 300 860 q 473 1064 428 988 l 715 1064 q 788 968 736 1029 q 889 860 840 907 l 889 842 l 751 842 z \"},\"Ŷ\":{\"ha\":867,\"x_min\":0,\"x_max\":867,\"o\":\"m 433 583 l 640 991 l 867 991 l 538 386 l 538 0 l 329 0 l 329 379 l 0 991 l 228 991 l 433 583 m 591 1071 q 433 1190 485 1134 q 277 1071 380 1135 l 140 1071 l 140 1089 q 313 1293 268 1217 l 555 1293 q 628 1197 576 1258 q 729 1089 680 1137 l 729 1071 l 591 1071 z \"},\"ŷ\":{\"ha\":790,\"x_min\":0,\"x_max\":790,\"o\":\"m 0 758 l 227 758 l 370 332 q 395 200 388 276 l 399 200 q 428 332 406 270 l 568 758 l 790 758 l 469 -97 q 343 -275 425 -216 q 153 -334 262 -334 q 47 -322 99 -334 l 47 -158 q 129 -167 85 -167 q 225 -133 184 -167 q 289 -32 266 -100 l 301 5 l 0 758 m 553 842 q 395 961 447 905 q 239 842 342 906 l 102 842 l 102 860 q 275 1064 230 988 l 517 1064 q 590 968 538 1029 q 691 860 642 907 l 691 842 l 553 842 z \"},\"Ÿ\":{\"ha\":867,\"x_min\":0,\"x_max\":867,\"o\":\"m 433 583 l 640 991 l 867 991 l 538 386 l 538 0 l 329 0 l 329 379 l 0 991 l 228 991 l 433 583 m 201 1182 q 227 1250 201 1226 q 296 1274 252 1274 q 366 1249 340 1274 q 391 1182 391 1223 q 366 1117 391 1141 q 296 1092 340 1092 q 227 1116 252 1092 q 201 1182 201 1139 m 475 1182 q 502 1252 475 1230 q 570 1274 530 1274 q 641 1249 614 1274 q 667 1182 667 1225 q 640 1116 667 1141 q 570 1092 614 1092 q 502 1114 530 1092 q 475 1182 475 1136 z \"},\"Ź\":{\"ha\":804,\"x_min\":33,\"x_max\":771,\"o\":\"m 771 0 l 33 0 l 33 136 l 509 818 l 46 818 l 46 991 l 758 991 l 758 856 l 283 174 l 771 174 l 771 0 m 278 1071 l 278 1089 q 437 1293 395 1225 l 669 1293 l 669 1279 q 549 1174 634 1244 q 416 1071 464 1105 l 278 1071 z \"},\"ź\":{\"ha\":677,\"x_min\":37,\"x_max\":636,\"o\":\"m 636 0 l 37 0 l 37 122 l 389 600 l 58 600 l 58 758 l 624 758 l 624 624 l 282 158 l 636 158 l 636 0 m 239 842 l 239 860 q 398 1064 355 996 l 630 1064 l 630 1050 q 510 945 595 1015 q 376 842 425 876 l 239 842 z \"},\"Ż\":{\"ha\":804,\"x_min\":33,\"x_max\":771,\"o\":\"m 771 0 l 33 0 l 33 136 l 509 818 l 46 818 l 46 991 l 758 991 l 758 856 l 283 174 l 771 174 l 771 0 m 289 1183 q 401 1284 289 1284 q 514 1183 514 1284 q 486 1108 514 1135 q 401 1082 458 1082 q 289 1183 289 1082 z \"},\"ż\":{\"ha\":677,\"x_min\":37,\"x_max\":636,\"o\":\"m 636 0 l 37 0 l 37 122 l 389 600 l 58 600 l 58 758 l 624 758 l 624 624 l 282 158 l 636 158 l 636 0 m 223 954 q 336 1055 223 1055 q 448 954 448 1055 q 420 879 448 906 q 336 852 392 852 q 223 954 223 852 z \"},\"Ž\":{\"ha\":804,\"x_min\":33,\"x_max\":771,\"o\":\"m 771 0 l 33 0 l 33 136 l 509 818 l 46 818 l 46 991 l 758 991 l 758 856 l 283 174 l 771 174 l 771 0 m 705 1293 l 705 1275 q 601 1161 648 1218 q 532 1071 553 1105 l 290 1071 q 233 1147 270 1103 q 116 1275 197 1192 l 116 1293 l 254 1293 q 409 1174 353 1230 q 568 1293 466 1233 l 705 1293 z \"},\"ž\":{\"ha\":677,\"x_min\":37,\"x_max\":646,\"o\":\"m 636 0 l 37 0 l 37 122 l 389 600 l 58 600 l 58 758 l 624 758 l 624 624 l 282 158 l 636 158 l 636 0 m 646 1064 l 646 1046 q 541 932 589 989 q 472 842 493 876 l 230 842 q 174 918 210 873 q 56 1046 137 962 l 56 1064 l 194 1064 q 349 945 294 1001 q 508 1064 406 1004 l 646 1064 z \"},\"ſ\":{\"ha\":532,\"x_min\":109,\"x_max\":564,\"o\":\"m 401 899 q 315 806 315 899 l 315 0 l 109 0 l 109 814 q 172 1003 109 943 q 375 1063 236 1063 q 564 1031 482 1063 l 515 879 q 401 899 453 899 z \"},\"ƒ\":{\"ha\":793,\"x_min\":134,\"x_max\":726,\"o\":\"m 505 -82 q 441 -268 505 -202 q 258 -334 378 -334 q 134 -317 186 -334 l 134 -154 q 214 -167 174 -167 q 298 -52 298 -167 l 298 546 l 184 546 l 184 646 l 298 701 l 298 757 q 358 945 298 885 q 549 1006 417 1006 q 726 974 650 1006 l 677 822 q 579 842 622 842 q 505 749 505 842 l 505 701 l 660 701 l 660 546 l 505 546 l 505 -82 z \"},\"Ǻ\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 650 991 q 618 892 650 934 l 958 0 l 733 0 l 661 224 l 298 224 l 225 0 l 0 0 l 339 892 q 310 990 310 931 q 356 1108 310 1065 q 478 1152 402 1152 q 601 1108 552 1152 q 650 991 650 1064 m 616 400 l 547 596 q 479 799 489 752 q 420 618 467 751 l 345 400 l 616 400 m 396 1189 l 396 1200 q 463 1269 427 1228 q 514 1331 499 1310 l 746 1331 l 746 1322 q 668 1265 730 1305 q 533 1189 606 1226 l 396 1189 m 543 990 q 525 1038 543 1021 q 478 1055 507 1055 q 431 1038 450 1055 q 412 990 412 1021 q 471 925 412 928 l 484 925 q 526 944 509 926 q 543 990 543 961 z \"},\"ǻ\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 319 1189 l 319 1200 q 387 1269 351 1228 q 437 1331 422 1310 l 669 1331 l 669 1322 q 600 1271 655 1306 q 457 1189 544 1235 l 319 1189 m 597 975 q 549 857 597 902 q 425 812 501 812 q 303 856 349 812 q 257 974 257 899 q 303 1091 257 1047 q 425 1135 349 1135 q 549 1090 500 1135 q 597 975 597 1045 m 490 974 q 472 1022 490 1004 q 425 1039 454 1039 q 378 1022 397 1039 q 359 974 359 1004 q 376 926 359 943 q 425 908 393 908 q 472 926 454 908 q 490 974 490 943 z \"},\"Ǽ\":{\"ha\":1322,\"x_min\":0,\"x_max\":1240,\"o\":\"m 1240 0 l 648 0 l 648 236 l 315 236 l 214 0 l 0 0 l 444 991 l 1240 991 l 1240 819 l 859 819 l 859 602 l 1215 602 l 1215 429 l 859 429 l 859 174 l 1240 174 l 1240 0 m 392 412 l 648 412 l 648 812 l 562 812 l 392 412 m 681 1071 l 681 1089 q 840 1293 798 1225 l 1072 1293 l 1072 1279 q 952 1174 1037 1244 q 819 1071 867 1105 l 681 1071 z \"},\"ǽ\":{\"ha\":1274,\"x_min\":58,\"x_max\":1214,\"o\":\"m 901 -14 q 732 21 808 -14 q 607 126 656 55 q 474 17 541 47 q 300 -14 407 -14 q 124 51 191 -14 q 58 227 58 115 q 140 405 58 347 q 386 468 222 462 l 515 472 l 515 529 q 485 598 515 576 q 403 621 455 621 q 196 568 308 621 l 129 705 q 415 774 257 774 q 647 685 569 774 q 750 750 692 728 q 890 772 809 772 q 1127 679 1040 772 q 1214 428 1214 586 l 1214 328 l 724 328 q 776 190 727 239 q 913 140 825 140 q 1171 200 1046 140 l 1171 40 q 1055 0 1117 14 q 901 -14 992 -14 m 515 351 l 439 349 q 313 316 355 346 q 271 225 271 287 q 366 138 271 138 q 475 179 434 138 q 515 289 515 220 l 515 351 m 886 625 q 728 465 739 625 l 1019 465 q 982 583 1018 541 q 886 625 946 625 m 541 842 l 541 860 q 700 1064 657 996 l 932 1064 l 932 1050 q 811 945 897 1015 q 678 842 726 876 l 541 842 z \"},\"Ǿ\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 325 31 419 -14 l 264 -61 l 154 12 l 215 104 q 81 498 81 236 q 203 877 81 746 q 554 1007 326 1007 q 787 960 688 1007 l 844 1044 l 953 974 l 893 885 q 1025 497 1025 753 m 301 497 q 339 289 301 368 l 682 802 q 554 832 625 832 q 365 748 429 832 q 301 497 301 663 m 804 497 q 770 699 804 619 l 431 189 q 553 163 482 163 q 804 497 804 163 m 432 1071 l 432 1089 q 591 1293 549 1225 l 823 1293 l 823 1279 q 703 1174 788 1244 q 570 1071 618 1105 l 432 1071 z \"},\"ǿ\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 269 17 342 -14 l 224 -52 l 119 20 l 165 87 q 62 380 62 193 q 159 669 62 566 q 432 772 256 772 q 600 737 522 772 l 637 793 l 741 720 l 701 663 q 798 380 798 557 m 273 380 q 286 268 273 317 l 501 590 q 429 606 472 606 q 310 550 347 606 q 273 380 273 494 m 586 380 q 578 476 586 435 l 368 163 q 431 153 394 153 q 550 210 513 153 q 586 380 586 267 m 309 842 l 309 860 q 468 1064 425 996 l 700 1064 l 700 1050 q 579 945 665 1015 q 446 842 494 876 l 309 842 z \"},\"Ș\":{\"ha\":765,\"x_min\":64,\"x_max\":710,\"o\":\"m 710 275 q 613 64 710 141 q 345 -14 517 -14 q 64 46 186 -14 l 64 241 q 234 178 164 197 q 361 160 303 160 q 467 186 430 160 q 504 265 504 213 q 488 317 504 294 q 440 361 471 340 q 311 428 408 382 q 175 510 220 471 q 102 602 130 549 q 75 724 75 654 q 164 930 75 855 q 411 1006 254 1006 q 558 987 488 1006 q 705 936 629 969 l 637 772 q 506 818 558 805 q 404 831 454 831 q 313 803 345 831 q 281 730 281 775 q 294 682 281 703 q 335 642 307 661 q 468 572 363 623 q 659 439 607 506 q 710 275 710 372 m 234 -289 q 257 -192 244 -256 q 276 -85 271 -128 l 467 -85 l 467 -98 q 355 -307 416 -212 l 234 -307 l 234 -289 z \"},\"ș\":{\"ha\":690,\"x_min\":62,\"x_max\":637,\"o\":\"m 637 225 q 556 47 637 109 q 314 -14 475 -14 q 173 -2 231 -14 q 64 31 115 9 l 64 201 q 194 156 121 174 q 321 138 266 138 q 433 203 433 138 q 418 242 433 227 q 367 277 404 258 q 269 322 330 296 q 141 390 182 359 q 81 461 100 421 q 62 561 62 502 q 141 717 62 662 q 363 772 219 772 q 629 713 500 772 l 567 564 q 460 604 510 588 q 359 619 411 619 q 268 570 268 619 q 297 522 268 542 q 427 461 327 501 q 557 394 515 425 q 618 322 598 363 q 637 225 637 281 m 199 -289 q 223 -192 210 -256 q 241 -85 236 -128 l 433 -85 l 433 -98 q 320 -307 382 -212 l 199 -307 l 199 -289 z \"},\"ˆ\":{\"ha\":843,\"x_min\":126,\"x_max\":715,\"o\":\"m 578 842 q 419 961 471 905 q 264 842 366 906 l 126 842 l 126 860 q 300 1064 254 988 l 542 1064 q 615 968 563 1029 q 715 860 667 907 l 715 842 l 578 842 z \"},\"ˇ\":{\"ha\":843,\"x_min\":126,\"x_max\":715,\"o\":\"m 715 1064 l 715 1046 q 611 932 659 989 q 542 842 563 876 l 300 842 q 243 918 280 873 q 126 1046 207 962 l 126 1064 l 264 1064 q 419 945 363 1001 q 578 1064 476 1004 l 715 1064 z \"},\"ˉ\":{\"ha\":843,\"x_min\":192,\"x_max\":652,\"o\":\"m 192 985 l 652 985 l 652 842 l 192 842 l 192 985 z \"},\"˘\":{\"ha\":843,\"x_min\":154,\"x_max\":688,\"o\":\"m 688 1071 q 605 904 680 966 q 418 842 530 842 q 230 903 300 842 q 154 1071 159 965 l 269 1071 q 288 1021 272 1039 q 333 994 304 1002 q 419 986 361 986 q 570 1071 559 986 l 688 1071 z \"},\"˙\":{\"ha\":424,\"x_min\":100,\"x_max\":325,\"o\":\"m 100 954 q 212 1055 100 1055 q 325 954 325 1055 q 297 879 325 906 q 212 852 269 852 q 100 954 100 852 z \"},\"˚\":{\"ha\":802,\"x_min\":231,\"x_max\":571,\"o\":\"m 571 1003 q 523 885 571 930 q 399 840 475 840 q 277 884 323 840 q 231 1002 231 927 q 276 1119 231 1075 q 399 1162 322 1162 q 522 1118 473 1162 q 571 1003 571 1073 m 464 1002 q 446 1049 464 1032 q 399 1067 427 1067 q 352 1049 370 1067 q 334 1002 334 1032 q 350 954 334 971 q 399 936 366 936 q 446 954 427 936 q 464 1002 464 971 z \"},\"˛\":{\"ha\":286,\"x_min\":7,\"x_max\":282,\"o\":\"m 150 -154 q 165 -196 150 -182 q 204 -210 180 -210 q 282 -197 241 -210 l 282 -318 q 176 -334 227 -334 q 53 -291 100 -334 q 7 -178 7 -248 q 33 -92 7 -132 q 129 0 58 -52 l 250 0 q 176 -82 203 -45 q 150 -154 150 -119 z \"},\"˜\":{\"ha\":843,\"x_min\":140,\"x_max\":703,\"o\":\"m 310 913 q 270 895 289 913 q 241 840 250 877 l 140 840 q 196 994 148 939 q 325 1050 245 1050 q 379 1039 353 1050 q 432 1014 406 1027 q 484 990 458 1001 q 533 979 509 979 q 573 997 554 979 q 602 1051 593 1015 l 703 1051 q 646 897 695 953 q 518 842 597 842 q 464 853 490 842 q 411 877 437 864 q 359 902 385 890 q 310 913 334 913 z \"},\"˝\":{\"ha\":817,\"x_min\":106,\"x_max\":711,\"o\":\"m 106 842 l 106 860 q 185 977 148 918 q 237 1064 223 1036 l 441 1064 l 441 1050 q 342 946 420 1014 q 215 842 265 878 l 106 842 m 375 842 l 375 860 q 507 1064 469 990 l 711 1064 l 711 1050 q 626 959 694 1021 q 485 842 558 897 l 375 842 z \"},\"΄\":{\"ha\":802,\"x_min\":319,\"x_max\":567,\"o\":\"m 319 863 q 350 974 332 899 q 375 1105 368 1048 l 567 1105 l 567 1089 q 440 842 514 963 l 319 842 l 319 863 z \"},\"΅\":{\"ha\":802,\"x_min\":126,\"x_max\":675,\"o\":\"m 126 953 q 150 1023 126 1001 q 214 1044 174 1044 q 277 1023 252 1044 q 302 953 302 1001 q 277 885 302 907 q 214 863 252 863 q 150 885 174 863 q 126 953 126 907 m 497 953 q 586 1044 497 1044 q 650 1023 625 1044 q 675 953 675 1001 q 650 885 675 907 q 586 863 625 863 q 521 885 545 863 q 497 953 497 907 m 330 960 q 354 1057 340 993 q 372 1164 367 1120 l 550 1164 l 550 1150 q 424 942 511 1063 l 330 942 l 330 960 z \"},\"Ά\":{\"ha\":958,\"x_min\":-38,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m -38 791 q -8 903 -26 828 q 18 1034 10 977 l 210 1034 l 210 1018 q 83 770 157 892 l -38 770 l -38 791 z \"},\"·\":{\"ha\":396,\"x_min\":79,\"x_max\":317,\"o\":\"m 79 489 q 110 575 79 546 q 199 604 140 604 q 286 574 255 604 q 317 489 317 545 q 286 405 317 435 q 199 374 254 374 q 111 404 142 374 q 79 489 79 434 z \"},\"Έ\":{\"ha\":875,\"x_min\":-67,\"x_max\":793,\"o\":\"m 793 0 l 222 0 l 222 991 l 793 991 l 793 819 l 432 819 l 432 602 l 768 602 l 768 429 l 432 429 l 432 174 l 793 174 l 793 0 m -67 791 q -37 903 -55 828 q -12 1034 -19 977 l 180 1034 l 180 1018 q 54 770 127 892 l -67 770 l -67 791 z \"},\"Ή\":{\"ha\":1160,\"x_min\":-67,\"x_max\":1034,\"o\":\"m 1034 0 l 825 0 l 825 428 l 432 428 l 432 0 l 222 0 l 222 991 l 432 991 l 432 603 l 825 603 l 825 991 l 1034 991 l 1034 0 m -67 791 q -37 903 -55 828 q -12 1034 -19 977 l 180 1034 l 180 1018 q 54 770 127 892 l -67 770 l -67 791 z \"},\"Ό\":{\"ha\":1161,\"x_min\":-39,\"x_max\":1080,\"o\":\"m 1080 497 q 958 119 1080 251 q 608 -14 836 -14 q 258 119 380 -14 q 136 498 136 251 q 259 877 136 746 q 610 1007 381 1007 q 959 876 838 1007 q 1080 497 1080 744 m 357 497 q 420 247 357 331 q 608 163 483 163 q 860 497 860 163 q 610 832 860 832 q 420 748 484 832 q 357 497 357 663 m -39 791 q -9 903 -27 828 q 16 1034 9 977 l 208 1034 l 208 1018 q 81 770 155 892 l -39 770 l -39 791 z \"},\"Ύ\":{\"ha\":1061,\"x_min\":-81,\"x_max\":1061,\"o\":\"m 628 583 l 835 991 l 1061 991 l 732 386 l 732 0 l 524 0 l 524 379 l 195 991 l 422 991 l 628 583 m -81 791 q -51 903 -69 828 q -26 1034 -33 977 l 166 1034 l 166 1018 q 39 770 113 892 l -81 770 l -81 791 z \"},\"Ώ\":{\"ha\":1092,\"x_min\":-39,\"x_max\":1115,\"o\":\"m 607 832 q 418 758 484 832 q 351 547 351 683 q 396 324 351 410 q 532 189 441 238 l 532 0 l 98 0 l 98 176 l 350 176 q 191 348 247 239 q 135 591 135 457 q 193 811 135 716 q 358 956 251 905 q 607 1007 465 1007 q 951 894 823 1007 q 1079 590 1079 781 q 1023 349 1079 456 q 861 176 966 241 l 1115 176 l 1115 0 l 679 0 l 679 189 q 818 326 773 238 q 863 549 863 413 q 796 758 863 684 q 607 832 729 832 m -39 791 q -9 903 -27 828 q 16 1034 9 977 l 208 1034 l 208 1018 q 81 770 155 892 l -39 770 l -39 791 z \"},\"ΐ\":{\"ha\":566,\"x_min\":-37,\"x_max\":536,\"o\":\"m 315 758 l 315 237 q 340 172 315 193 q 406 151 365 151 q 536 175 460 151 l 536 21 q 358 -14 463 -14 q 169 49 229 -14 q 109 237 109 112 l 109 758 l 315 758 m -37 953 q -13 1023 -37 1001 q 50 1044 11 1044 q 114 1023 89 1044 q 139 953 139 1001 q 114 885 139 907 q 50 863 89 863 q -13 885 11 863 q -37 953 -37 907 m 334 953 q 422 1044 334 1044 q 486 1023 461 1044 q 511 953 511 1001 q 486 885 511 907 q 422 863 461 863 q 358 885 382 863 q 334 953 334 907 m 167 960 q 190 1057 177 993 q 209 1164 203 1120 l 387 1164 l 387 1150 q 260 942 347 1063 l 167 942 l 167 960 z \"},\"Α\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 z \"},\"Β\":{\"ha\":933,\"x_min\":125,\"x_max\":860,\"o\":\"m 125 991 l 433 991 q 740 931 644 991 q 835 741 835 871 q 793 595 835 652 q 682 526 751 538 l 682 519 q 818 441 777 498 q 860 288 860 383 q 762 76 860 152 q 496 0 664 0 l 125 0 l 125 991 m 335 599 l 457 599 q 581 625 543 599 q 619 713 619 652 q 577 794 619 770 q 446 819 536 819 l 335 819 l 335 599 m 335 432 l 335 174 l 472 174 q 600 207 559 174 q 642 309 642 240 q 465 432 642 432 l 335 432 z \"},\"Γ\":{\"ha\":779,\"x_min\":125,\"x_max\":751,\"o\":\"m 751 991 l 751 818 l 335 818 l 335 0 l 125 0 l 125 991 l 751 991 z \"},\"Δ\":{\"ha\":914,\"x_min\":39,\"x_max\":875,\"o\":\"m 39 121 l 339 996 l 576 996 l 875 119 l 875 0 l 39 0 l 39 121 m 457 823 q 449 784 456 813 q 428 707 441 754 q 253 175 414 661 l 661 175 l 490 696 l 483 722 q 457 823 458 810 z \"},\"Ε\":{\"ha\":778,\"x_min\":125,\"x_max\":696,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 z \"},\"Ζ\":{\"ha\":804,\"x_min\":33,\"x_max\":771,\"o\":\"m 771 0 l 33 0 l 33 136 l 509 818 l 46 818 l 46 991 l 758 991 l 758 856 l 283 174 l 771 174 l 771 0 z \"},\"Η\":{\"ha\":1063,\"x_min\":125,\"x_max\":937,\"o\":\"m 937 0 l 728 0 l 728 428 l 335 428 l 335 0 l 125 0 l 125 991 l 335 991 l 335 603 l 728 603 l 728 991 l 937 991 l 937 0 z \"},\"Θ\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 729 590 l 729 418 l 376 418 l 376 590 l 729 590 m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 297 497 q 362 248 297 333 q 553 163 427 163 q 745 248 681 163 q 808 497 808 333 q 745 747 808 661 q 554 832 681 832 q 362 747 427 832 q 297 497 297 662 z \"},\"Κ\":{\"ha\":922,\"x_min\":125,\"x_max\":922,\"o\":\"m 922 0 l 684 0 l 424 418 l 335 354 l 335 0 l 125 0 l 125 991 l 335 991 l 335 538 l 418 654 l 686 991 l 920 991 l 574 553 l 922 0 z \"},\"Λ\":{\"ha\":903,\"x_min\":0,\"x_max\":903,\"o\":\"m 452 815 q 426 698 444 773 q 400 595 409 623 l 212 0 l 0 0 l 336 991 l 566 991 l 903 0 l 690 0 l 505 596 q 478 697 498 616 q 452 815 458 779 z \"},\"Μ\":{\"ha\":1310,\"x_min\":125,\"x_max\":1185,\"o\":\"m 545 0 l 306 778 l 300 778 q 313 461 313 541 l 313 0 l 125 0 l 125 991 l 411 991 l 646 233 l 650 233 l 899 991 l 1185 991 l 1185 0 l 989 0 l 989 469 q 990 546 989 503 q 999 777 991 589 l 993 777 l 737 0 l 545 0 z \"},\"Ν\":{\"ha\":1129,\"x_min\":125,\"x_max\":1004,\"o\":\"m 1004 0 l 737 0 l 306 750 l 300 750 q 313 467 313 551 l 313 0 l 125 0 l 125 991 l 390 991 l 821 249 l 825 249 q 815 522 815 442 l 815 991 l 1004 991 l 1004 0 z \"},\"Ξ\":{\"ha\":793,\"x_min\":56,\"x_max\":737,\"o\":\"m 139 602 l 654 602 l 654 429 l 139 429 l 139 602 m 83 991 l 710 991 l 710 819 l 83 819 l 83 991 m 737 174 l 737 0 l 56 0 l 56 174 l 737 174 z \"},\"Ο\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 z \"},\"Π\":{\"ha\":1035,\"x_min\":125,\"x_max\":909,\"o\":\"m 909 0 l 700 0 l 700 817 l 335 817 l 335 0 l 125 0 l 125 991 l 909 991 l 909 0 z \"},\"Ρ\":{\"ha\":872,\"x_min\":125,\"x_max\":810,\"o\":\"m 335 525 l 404 525 q 549 563 501 525 q 597 675 597 602 q 557 784 597 749 q 431 819 517 819 l 335 819 l 335 525 m 810 682 q 710 437 810 522 q 425 353 610 353 l 335 353 l 335 0 l 125 0 l 125 991 l 441 991 q 716 914 622 991 q 810 682 810 836 z \"},\"Σ\":{\"ha\":823,\"x_min\":53,\"x_max\":777,\"o\":\"m 53 0 l 53 165 l 372 519 l 61 831 l 61 991 l 736 991 l 736 819 l 439 819 q 285 827 404 819 l 593 521 l 269 165 q 463 174 432 174 l 777 174 l 777 0 l 53 0 z \"},\"Τ\":{\"ha\":804,\"x_min\":28,\"x_max\":777,\"o\":\"m 507 0 l 297 0 l 297 817 l 28 817 l 28 991 l 777 991 l 777 817 l 507 817 l 507 0 z \"},\"Υ\":{\"ha\":867,\"x_min\":0,\"x_max\":867,\"o\":\"m 433 583 l 640 991 l 867 991 l 538 386 l 538 0 l 329 0 l 329 379 l 0 991 l 228 991 l 433 583 z \"},\"Φ\":{\"ha\":1194,\"x_min\":62,\"x_max\":1132,\"o\":\"m 692 301 l 701 301 q 872 358 810 301 q 935 515 935 416 q 877 664 935 608 q 720 720 819 720 l 692 720 l 692 301 m 503 -14 l 503 139 l 488 139 q 267 183 361 139 q 117 317 172 228 q 62 514 62 406 q 111 704 62 619 q 251 836 159 788 q 467 884 342 884 l 503 884 l 503 1006 l 692 1006 l 692 884 l 728 884 q 943 836 851 884 q 1083 704 1034 788 q 1132 514 1132 619 q 1077 317 1132 406 q 928 183 1023 228 q 707 139 833 139 l 692 139 l 692 -14 l 503 -14 m 503 720 l 475 720 q 317 664 375 720 q 260 515 260 608 q 321 359 260 418 q 493 301 382 301 l 503 301 l 503 720 z \"},\"Χ\":{\"ha\":926,\"x_min\":0,\"x_max\":926,\"o\":\"m 926 0 l 686 0 l 456 375 l 225 0 l 0 0 l 329 511 l 21 991 l 253 991 l 467 635 l 676 991 l 903 991 l 591 500 l 926 0 z \"},\"Ψ\":{\"ha\":1217,\"x_min\":74,\"x_max\":1143,\"o\":\"m 1143 667 q 1042 386 1143 476 q 737 296 941 296 l 703 296 l 703 0 l 514 0 l 514 296 l 479 296 q 173 386 273 296 q 74 664 74 475 l 74 991 l 271 991 l 271 667 q 321 513 271 560 q 493 465 372 465 l 514 465 l 514 991 l 703 991 l 703 465 l 724 465 q 894 514 842 465 q 946 664 946 564 l 946 991 l 1143 991 l 1143 667 z \"},\"Ω\":{\"ha\":1092,\"x_min\":37,\"x_max\":1054,\"o\":\"m 546 832 q 357 758 423 832 q 290 547 290 683 q 335 324 290 410 q 471 189 380 238 l 471 0 l 37 0 l 37 176 l 289 176 q 130 348 186 239 q 74 591 74 457 q 132 811 74 716 q 297 956 190 905 q 546 1007 404 1007 q 890 894 762 1007 q 1018 590 1018 781 q 962 349 1018 456 q 800 176 905 241 l 1054 176 l 1054 0 l 618 0 l 618 189 q 757 326 712 238 q 802 549 802 413 q 735 758 802 684 q 546 832 668 832 z \"},\"Ϋ\":{\"ha\":867,\"x_min\":0,\"x_max\":867,\"o\":\"m 433 583 l 640 991 l 867 991 l 538 386 l 538 0 l 329 0 l 329 379 l 0 991 l 228 991 l 433 583 m 203 1182 q 228 1250 203 1226 q 297 1274 254 1274 q 367 1249 342 1274 q 393 1182 393 1223 q 367 1117 393 1141 q 297 1092 341 1092 q 228 1116 254 1092 q 203 1182 203 1139 m 476 1182 q 504 1252 476 1230 q 572 1274 531 1274 q 642 1249 616 1274 q 668 1182 668 1225 q 642 1116 668 1141 q 572 1092 615 1092 q 504 1114 531 1092 q 476 1182 476 1136 z \"},\"ά\":{\"ha\":899,\"x_min\":62,\"x_max\":868,\"o\":\"m 422 151 q 539 200 503 151 q 578 370 575 248 l 578 378 q 540 553 578 500 q 419 606 503 606 q 273 375 273 606 q 310 207 273 263 q 422 151 346 151 m 359 -14 q 141 90 220 -14 q 62 376 62 193 q 145 668 62 565 q 375 771 227 771 q 507 743 455 771 q 593 657 559 714 l 603 657 q 648 758 619 721 l 819 758 q 784 607 798 692 q 771 452 771 522 l 771 240 q 828 160 771 160 q 868 167 850 160 l 868 4 q 826 -8 857 -3 q 775 -14 795 -14 q 659 13 699 -14 q 596 100 619 39 l 582 100 q 359 -14 507 -14 m 353 863 q 383 974 365 899 q 408 1105 401 1048 l 600 1105 l 600 1089 q 473 842 547 963 l 353 842 l 353 863 z \"},\"έ\":{\"ha\":771,\"x_min\":53,\"x_max\":720,\"o\":\"m 570 467 l 570 323 l 456 323 q 307 301 357 323 q 257 231 257 279 q 439 146 257 146 q 583 161 509 146 q 718 204 658 176 l 718 39 q 424 -14 602 -14 q 148 42 243 -14 q 53 210 53 98 q 96 328 53 282 q 237 392 140 373 l 237 399 q 93 574 93 432 q 179 721 93 669 q 424 772 265 772 q 581 757 502 772 q 720 715 660 741 l 656 566 q 528 609 575 598 q 429 619 481 619 q 315 602 353 619 q 278 549 278 585 q 323 485 278 504 q 465 467 368 467 l 570 467 m 345 863 q 375 974 357 899 q 400 1105 393 1048 l 592 1105 l 592 1089 q 465 842 539 963 l 345 842 l 345 863 z \"},\"ή\":{\"ha\":913,\"x_min\":109,\"x_max\":808,\"o\":\"m 808 -334 l 602 -334 l 602 443 q 572 566 602 525 q 479 607 543 607 q 354 549 393 607 q 315 357 315 491 l 315 0 l 109 0 l 109 758 l 267 758 l 294 661 l 306 661 q 401 744 340 716 q 539 772 462 772 q 740 701 671 772 q 808 494 808 629 l 808 -334 m 400 863 q 430 974 412 899 q 456 1105 448 1048 l 648 1105 l 648 1089 q 521 842 595 963 l 400 842 l 400 863 z \"},\"ί\":{\"ha\":566,\"x_min\":109,\"x_max\":536,\"o\":\"m 315 758 l 315 237 q 340 172 315 193 q 406 151 365 151 q 536 175 460 151 l 536 21 q 358 -14 463 -14 q 169 49 229 -14 q 109 237 109 112 l 109 758 l 315 758 m 155 863 q 185 974 167 899 q 210 1105 203 1048 l 402 1105 l 402 1089 q 275 842 349 963 l 155 842 l 155 863 z \"},\"ΰ\":{\"ha\":896,\"x_min\":97,\"x_max\":822,\"o\":\"m 446 -12 q 183 76 270 -12 q 97 346 97 163 l 97 758 l 304 758 l 304 339 q 340 196 304 240 q 453 153 376 153 q 576 216 538 153 q 615 416 615 279 q 606 562 615 489 q 567 758 596 634 l 775 758 q 812 571 802 652 q 822 411 822 491 q 729 93 822 198 q 446 -12 637 -12 m 172 953 q 196 1023 172 1001 q 260 1044 220 1044 q 323 1023 298 1044 q 349 953 349 1001 q 323 885 349 907 q 260 863 298 863 q 196 885 220 863 q 172 953 172 907 m 543 953 q 632 1044 543 1044 q 696 1023 671 1044 q 721 953 721 1001 q 696 885 721 907 q 632 863 671 863 q 567 885 591 863 q 543 953 543 907 m 376 960 q 400 1057 387 993 q 418 1164 413 1120 l 596 1164 l 596 1150 q 470 942 557 1063 l 376 942 l 376 960 z \"},\"α\":{\"ha\":899,\"x_min\":62,\"x_max\":868,\"o\":\"m 422 151 q 539 200 503 151 q 578 370 575 248 l 578 378 q 540 553 578 500 q 419 606 503 606 q 273 375 273 606 q 310 207 273 263 q 422 151 346 151 m 359 -14 q 141 90 220 -14 q 62 376 62 193 q 145 668 62 565 q 375 771 227 771 q 507 743 455 771 q 593 657 559 714 l 603 657 q 648 758 619 721 l 819 758 q 784 607 798 692 q 771 452 771 522 l 771 240 q 828 160 771 160 q 868 167 850 160 l 868 4 q 826 -8 857 -3 q 775 -14 795 -14 q 659 13 699 -14 q 596 100 619 39 l 582 100 q 359 -14 507 -14 z \"},\"β\":{\"ha\":917,\"x_min\":109,\"x_max\":868,\"o\":\"m 471 1063 q 722 992 630 1063 q 814 796 814 922 q 762 636 814 695 q 615 562 711 578 l 615 558 q 805 476 743 542 q 868 293 868 411 q 780 68 868 151 q 536 -14 691 -14 q 315 29 401 -14 l 315 -334 l 109 -334 l 109 743 q 203 979 109 895 q 471 1063 298 1063 m 465 901 q 315 724 315 901 l 315 199 q 395 164 348 178 q 484 151 443 151 q 612 193 570 151 q 654 311 654 235 q 609 425 654 386 q 478 464 564 464 l 429 464 l 429 628 l 465 628 q 570 665 532 628 q 607 771 607 702 q 570 867 607 833 q 465 901 532 901 z \"},\"γ\":{\"ha\":789,\"x_min\":1,\"x_max\":789,\"o\":\"m 441 -334 l 222 -334 q 241 -178 222 -275 q 290 8 260 -81 l 1 758 l 216 758 l 328 424 q 364 300 342 382 q 396 168 387 218 l 400 168 q 422 276 403 198 q 463 414 441 353 l 574 758 l 789 758 l 509 12 q 460 -162 478 -66 q 441 -334 441 -257 z \"},\"δ\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 329 623 q 168 854 168 725 q 250 1007 168 952 q 476 1063 332 1063 q 622 1047 551 1063 q 789 987 693 1032 l 707 842 q 586 891 644 872 q 468 909 528 909 q 393 891 418 909 q 368 842 368 873 q 415 769 368 805 q 555 686 462 734 q 739 539 680 623 q 798 347 798 456 q 702 79 798 172 q 427 -14 606 -14 q 162 71 261 -14 q 62 297 62 155 q 128 502 62 420 q 329 623 193 583 m 586 334 q 554 448 586 397 q 450 538 522 498 q 321 453 367 514 q 275 306 275 391 q 316 195 275 237 q 428 153 357 153 q 545 199 503 153 q 586 334 586 245 z \"},\"ε\":{\"ha\":771,\"x_min\":53,\"x_max\":720,\"o\":\"m 570 467 l 570 323 l 456 323 q 307 301 357 323 q 257 231 257 279 q 439 146 257 146 q 583 161 509 146 q 718 204 658 176 l 718 39 q 424 -14 602 -14 q 148 42 243 -14 q 53 210 53 98 q 96 328 53 282 q 237 392 140 373 l 237 399 q 93 574 93 432 q 179 721 93 669 q 424 772 265 772 q 581 757 502 772 q 720 715 660 741 l 656 566 q 528 609 575 598 q 429 619 481 619 q 315 602 353 619 q 278 549 278 585 q 323 485 278 504 q 465 467 368 467 l 570 467 z \"},\"ζ\":{\"ha\":692,\"x_min\":62,\"x_max\":685,\"o\":\"m 685 -25 q 591 -257 685 -126 l 383 -257 q 457 -141 430 -194 q 484 -57 484 -89 q 457 -21 484 -35 q 361 5 430 -7 q 62 317 62 58 q 151 602 62 458 q 449 916 240 745 q 381 907 430 911 q 298 904 333 904 l 102 904 l 102 1055 l 681 1055 l 681 932 q 455 718 545 819 q 320 521 366 616 q 275 326 275 426 q 289 245 275 276 q 327 197 302 215 q 386 170 351 179 q 465 151 421 160 q 631 86 578 129 q 685 -25 685 44 z \"},\"η\":{\"ha\":913,\"x_min\":109,\"x_max\":808,\"o\":\"m 808 -334 l 602 -334 l 602 443 q 572 566 602 525 q 479 607 543 607 q 354 549 393 607 q 315 357 315 491 l 315 0 l 109 0 l 109 758 l 267 758 l 294 661 l 306 661 q 401 744 340 716 q 539 772 462 772 q 740 701 671 772 q 808 494 808 629 l 808 -334 z \"},\"θ\":{\"ha\":859,\"x_min\":62,\"x_max\":796,\"o\":\"m 796 529 q 705 120 796 254 q 428 -14 614 -14 q 155 126 248 -14 q 62 529 62 265 q 153 938 62 805 q 428 1071 244 1071 q 702 933 608 1071 q 796 529 796 795 m 428 136 q 544 215 507 136 q 583 456 580 294 l 273 456 q 312 216 276 296 q 428 136 347 136 m 429 921 q 319 849 356 921 q 275 610 281 777 l 583 610 q 542 843 578 766 q 429 921 507 921 z \"},\"ι\":{\"ha\":566,\"x_min\":109,\"x_max\":536,\"o\":\"m 315 758 l 315 237 q 340 172 315 193 q 406 151 365 151 q 536 175 460 151 l 536 21 q 358 -14 463 -14 q 169 49 229 -14 q 109 237 109 112 l 109 758 l 315 758 z \"},\"κ\":{\"ha\":861,\"x_min\":109,\"x_max\":861,\"o\":\"m 314 395 l 410 510 l 623 758 l 843 758 l 545 411 l 861 0 l 625 0 l 412 289 l 315 228 l 315 0 l 109 0 l 109 758 l 315 758 l 315 559 l 313 450 l 311 395 l 314 395 z \"},\"λ\":{\"ha\":854,\"x_min\":5,\"x_max\":847,\"o\":\"m 5 0 l 326 717 l 302 779 q 247 865 278 840 q 151 890 216 890 q 82 882 117 890 l 82 1053 q 195 1064 136 1064 q 328 1040 273 1064 q 422 967 383 1017 q 496 821 461 917 l 686 297 q 737 193 711 227 q 800 160 763 160 q 847 167 823 160 l 847 7 q 793 -7 831 -1 q 728 -14 754 -14 q 606 23 653 -14 q 530 140 558 60 q 438 405 453 359 q 415 485 424 450 l 411 485 q 359 329 380 380 l 220 0 l 5 0 z \"},\"μ\":{\"ha\":917,\"x_min\":109,\"x_max\":808,\"o\":\"m 315 315 q 345 192 315 233 q 439 151 375 151 q 563 210 524 151 q 602 401 602 269 l 602 758 l 808 758 l 808 0 l 652 0 l 623 102 l 612 102 q 543 15 584 44 q 443 -14 503 -14 q 366 2 401 -14 q 309 47 330 18 l 312 -10 l 315 -117 l 315 -334 l 109 -334 l 109 758 l 315 758 l 315 315 z \"},\"ν\":{\"ha\":827,\"x_min\":4,\"x_max\":772,\"o\":\"m 4 758 l 216 758 l 364 338 l 411 183 l 416 183 q 529 421 494 287 q 564 758 564 555 l 772 758 q 743 459 772 585 q 648 221 713 333 q 475 0 583 109 l 289 0 l 4 758 z \"},\"ξ\":{\"ha\":692,\"x_min\":62,\"x_max\":685,\"o\":\"m 62 297 q 112 447 62 382 q 254 549 161 512 l 254 555 q 106 728 106 591 q 152 844 106 800 q 301 913 197 888 q 117 904 162 904 l 102 904 l 102 1055 l 647 1055 l 647 913 l 596 913 q 391 866 471 913 q 311 741 311 820 q 355 648 311 676 q 498 621 399 621 l 611 621 l 611 478 l 497 478 q 328 436 380 478 q 275 311 275 395 q 291 234 275 263 q 340 188 307 205 q 465 151 373 170 q 631 86 578 129 q 685 -25 685 44 q 591 -257 685 -126 l 383 -257 q 457 -141 430 -194 q 484 -57 484 -89 q 457 -21 484 -35 q 361 5 430 -7 q 138 105 214 31 q 62 297 62 179 z \"},\"ο\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 z \"},\"π\":{\"ha\":1026,\"x_min\":17,\"x_max\":978,\"o\":\"m 882 149 q 970 172 927 149 l 970 24 q 899 -3 942 7 q 819 -14 856 -14 q 664 42 718 -14 q 611 208 611 98 l 611 600 l 382 600 l 382 0 l 175 0 l 175 600 l 17 600 l 17 689 l 138 758 l 978 758 l 978 600 l 818 600 l 818 216 q 836 165 818 182 q 882 149 854 149 z \"},\"ρ\":{\"ha\":859,\"x_min\":82,\"x_max\":796,\"o\":\"m 796 379 q 713 90 796 194 q 482 -14 630 -14 q 292 39 378 -14 l 279 39 q 290 -143 290 -78 l 290 -334 l 82 -334 l 82 380 q 176 670 82 567 q 443 772 270 772 q 628 725 548 772 q 752 587 708 677 q 796 379 796 498 m 439 606 q 326 554 362 606 q 290 390 290 502 l 290 211 q 359 167 319 182 q 439 153 398 153 q 550 206 516 153 q 583 379 583 259 q 550 552 583 498 q 439 606 517 606 z \"},\"ς\":{\"ha\":692,\"x_min\":62,\"x_max\":685,\"o\":\"m 62 335 q 154 665 62 557 q 441 772 245 772 q 684 718 566 772 l 624 561 q 436 606 507 606 q 312 539 351 606 q 273 340 273 473 q 290 258 273 290 q 341 207 307 227 q 465 168 375 188 q 632 100 578 144 q 685 -16 685 56 q 591 -257 685 -119 l 383 -257 q 484 -46 484 -112 q 456 -7 484 -22 q 361 21 428 7 q 138 129 214 50 q 62 335 62 208 z \"},\"σ\":{\"ha\":907,\"x_min\":62,\"x_max\":879,\"o\":\"m 808 322 q 763 146 808 223 q 632 28 717 69 q 433 -14 547 -14 q 160 89 257 -14 q 62 370 62 191 q 490 760 62 760 l 879 760 l 879 608 l 686 608 q 808 322 808 479 m 275 370 q 316 208 275 264 q 436 153 356 153 q 555 204 515 153 q 596 354 596 256 q 576 491 596 429 q 510 608 556 552 l 476 608 q 321 553 366 608 q 275 370 275 497 z \"},\"τ\":{\"ha\":747,\"x_min\":28,\"x_max\":694,\"o\":\"m 425 603 l 425 237 q 450 172 425 193 q 515 151 475 151 q 646 175 570 151 l 646 21 q 468 -14 573 -14 q 279 49 339 -14 q 218 237 218 112 l 218 603 l 28 603 l 28 689 l 147 758 l 694 758 l 694 603 l 425 603 z \"},\"υ\":{\"ha\":896,\"x_min\":97,\"x_max\":822,\"o\":\"m 446 -12 q 183 76 270 -12 q 97 346 97 163 l 97 758 l 304 758 l 304 339 q 340 196 304 240 q 453 153 376 153 q 576 216 538 153 q 615 416 615 279 q 606 562 615 489 q 567 758 596 634 l 775 758 q 812 571 802 652 q 822 411 822 491 q 729 93 822 198 q 446 -12 637 -12 z \"},\"φ\":{\"ha\":1100,\"x_min\":62,\"x_max\":1038,\"o\":\"m 839 400 q 807 563 839 506 q 714 619 775 619 q 654 592 675 619 q 632 500 632 566 l 632 149 q 782 226 725 157 q 839 400 839 295 m 440 -334 l 440 -8 q 158 111 254 12 q 62 376 62 210 q 100 579 62 481 q 218 775 137 676 l 368 677 q 282 525 307 595 q 257 372 257 454 q 440 149 257 184 l 440 498 q 513 697 440 624 q 711 770 585 770 q 951 671 864 770 q 1038 401 1038 572 q 987 197 1038 286 q 845 56 937 109 q 632 -8 753 3 l 632 -334 l 440 -334 z \"},\"χ\":{\"ha\":822,\"x_min\":-33,\"x_max\":831,\"o\":\"m 163 768 q 262 751 224 768 q 328 695 301 734 q 383 574 355 657 l 433 424 l 623 758 l 831 758 l 522 241 l 654 -81 q 697 -142 673 -124 q 762 -160 721 -160 q 831 -151 795 -160 l 831 -313 q 699 -334 773 -334 q 560 -288 614 -334 q 471 -135 506 -242 l 400 86 l 187 -334 l -33 -334 l 307 267 l 216 505 q 176 574 199 553 q 114 595 152 595 q 36 582 76 595 l 36 747 q 163 768 113 768 z \"},\"ψ\":{\"ha\":1162,\"x_min\":97,\"x_max\":1089,\"o\":\"m 684 1054 l 684 147 q 851 215 803 159 q 899 392 899 271 q 844 758 899 544 l 1036 758 q 1089 390 1089 568 q 987 102 1089 204 q 684 -12 885 -1 l 684 -334 l 492 -334 l 492 -12 q 196 92 295 -6 q 97 376 97 190 l 97 758 l 294 758 l 294 371 q 338 204 294 254 q 492 146 381 154 l 492 1054 l 684 1054 z \"},\"ω\":{\"ha\":1198,\"x_min\":74,\"x_max\":1125,\"o\":\"m 819 -14 q 684 22 736 -14 q 603 129 631 58 l 596 129 q 512 20 565 54 q 379 -14 460 -14 q 154 89 234 -14 q 74 368 74 191 q 90 561 74 473 q 150 758 106 649 l 349 758 q 264 375 264 581 q 297 205 264 264 q 396 147 331 147 q 478 186 452 147 q 504 317 504 226 l 504 517 l 694 517 l 694 317 q 720 186 694 225 q 803 147 746 147 q 901 204 867 147 q 935 372 935 262 q 850 758 935 581 l 1048 758 q 1108 561 1092 648 q 1125 368 1125 473 q 1044 88 1125 190 q 819 -14 964 -14 z \"},\"ϊ\":{\"ha\":566,\"x_min\":8,\"x_max\":536,\"o\":\"m 315 758 l 315 237 q 340 172 315 193 q 406 151 365 151 q 536 175 460 151 l 536 21 q 358 -14 463 -14 q 169 49 229 -14 q 109 237 109 112 l 109 758 l 315 758 m 8 953 q 34 1021 8 997 q 102 1044 59 1044 q 173 1019 147 1044 q 198 953 198 994 q 172 887 198 912 q 102 863 146 863 q 34 886 59 863 q 8 953 8 910 m 281 953 q 309 1022 281 1000 q 377 1044 336 1044 q 447 1020 421 1044 q 473 953 473 996 q 447 887 473 911 q 377 863 420 863 q 309 885 336 863 q 281 953 281 907 z \"},\"ϋ\":{\"ha\":896,\"x_min\":97,\"x_max\":822,\"o\":\"m 446 -12 q 183 76 270 -12 q 97 346 97 163 l 97 758 l 304 758 l 304 339 q 340 196 304 240 q 453 153 376 153 q 576 216 538 153 q 615 416 615 279 q 606 562 615 489 q 567 758 596 634 l 775 758 q 812 571 802 652 q 822 411 822 491 q 729 93 822 198 q 446 -12 637 -12 m 216 953 q 241 1021 216 997 q 310 1044 267 1044 q 380 1019 355 1044 q 406 953 406 994 q 380 887 406 912 q 310 863 354 863 q 241 886 267 863 q 216 953 216 910 m 489 953 q 516 1022 489 1000 q 585 1044 544 1044 q 655 1020 629 1044 q 681 953 681 996 q 654 887 681 911 q 585 863 628 863 q 516 885 544 863 q 489 953 489 907 z \"},\"ό\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 364 863 q 394 974 376 899 q 420 1105 412 1048 l 612 1105 l 612 1089 q 485 842 559 963 l 364 842 l 364 863 z \"},\"ύ\":{\"ha\":896,\"x_min\":97,\"x_max\":822,\"o\":\"m 446 -12 q 183 76 270 -12 q 97 346 97 163 l 97 758 l 304 758 l 304 339 q 340 196 304 240 q 453 153 376 153 q 576 216 538 153 q 615 416 615 279 q 606 562 615 489 q 567 758 596 634 l 775 758 q 812 571 802 652 q 822 411 822 491 q 729 93 822 198 q 446 -12 637 -12 m 372 863 q 402 974 385 899 q 428 1105 420 1048 l 620 1105 l 620 1089 q 493 842 567 963 l 372 842 l 372 863 z \"},\"ώ\":{\"ha\":1198,\"x_min\":74,\"x_max\":1125,\"o\":\"m 819 -14 q 684 22 736 -14 q 603 129 631 58 l 596 129 q 512 20 565 54 q 379 -14 460 -14 q 154 89 234 -14 q 74 368 74 191 q 90 561 74 473 q 150 758 106 649 l 349 758 q 264 375 264 581 q 297 205 264 264 q 396 147 331 147 q 478 186 452 147 q 504 317 504 226 l 504 517 l 694 517 l 694 317 q 720 186 694 225 q 803 147 746 147 q 901 204 867 147 q 935 372 935 262 q 850 758 935 581 l 1048 758 q 1108 561 1092 648 q 1125 368 1125 473 q 1044 88 1125 190 q 819 -14 964 -14 m 529 863 q 559 974 541 899 q 585 1105 577 1048 l 777 1105 l 777 1089 q 650 842 724 963 l 529 842 l 529 863 z \"},\"Ё\":{\"ha\":778,\"x_min\":125,\"x_max\":696,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 179 1182 q 204 1250 179 1226 q 273 1274 230 1274 q 343 1249 318 1274 q 369 1182 369 1223 q 343 1117 369 1141 q 273 1092 317 1092 q 204 1116 230 1092 q 179 1182 179 1139 m 452 1182 q 480 1252 452 1230 q 548 1274 507 1274 q 618 1249 592 1274 q 644 1182 644 1225 q 618 1116 644 1141 q 548 1092 591 1092 q 480 1114 507 1092 q 452 1182 452 1136 z \"},\"Ђ\":{\"ha\":1118,\"x_min\":28,\"x_max\":1044,\"o\":\"m 768 -12 q 631 14 690 -12 l 631 187 q 747 158 698 158 q 801 169 784 158 q 826 202 818 179 q 835 262 835 225 l 835 349 q 807 433 835 409 q 714 457 779 457 l 486 457 l 486 0 l 277 0 l 277 817 l 28 817 l 28 991 l 783 991 l 783 817 l 486 817 l 486 632 l 722 632 q 961 562 877 632 q 1044 364 1044 492 l 1044 277 q 975 61 1044 135 q 768 -12 905 -12 z \"},\"Ѓ\":{\"ha\":779,\"x_min\":125,\"x_max\":751,\"o\":\"m 751 991 l 751 818 l 335 818 l 335 0 l 125 0 l 125 991 l 751 991 m 315 1071 l 315 1089 q 475 1293 432 1225 l 707 1293 l 707 1279 q 586 1174 671 1244 q 453 1071 501 1105 l 315 1071 z \"},\"Є\":{\"ha\":940,\"x_min\":81,\"x_max\":892,\"o\":\"m 571 831 q 383 766 456 831 q 302 586 311 701 l 732 586 l 732 414 l 301 414 q 378 227 310 293 q 574 161 446 161 q 854 214 690 161 l 854 37 q 713 -2 783 10 q 561 -14 644 -14 q 204 118 328 -14 q 81 494 81 249 q 141 765 81 648 q 314 943 201 881 q 581 1006 427 1006 q 744 987 669 1006 q 892 936 819 968 l 817 765 l 758 790 q 571 831 661 831 z \"},\"Ѕ\":{\"ha\":765,\"x_min\":64,\"x_max\":710,\"o\":\"m 710 275 q 613 64 710 141 q 345 -14 517 -14 q 64 46 186 -14 l 64 241 q 234 178 164 197 q 361 160 303 160 q 467 186 430 160 q 504 265 504 213 q 488 317 504 294 q 440 361 471 340 q 311 428 408 382 q 175 510 220 471 q 102 602 130 549 q 75 724 75 654 q 164 930 75 855 q 411 1006 254 1006 q 558 987 488 1006 q 705 936 629 969 l 637 772 q 506 818 558 805 q 404 831 454 831 q 313 803 345 831 q 281 730 281 775 q 294 682 281 703 q 335 642 307 661 q 468 572 363 623 q 659 439 607 506 q 710 275 710 372 z \"},\"Ј\":{\"ha\":460,\"x_min\":-103,\"x_max\":335,\"o\":\"m 21 -292 q -103 -277 -50 -292 l -103 -102 q -4 -115 -49 -115 q 95 -72 65 -115 q 125 62 125 -29 l 125 991 l 335 991 l 335 64 q 256 -201 335 -110 q 21 -292 176 -292 z \"},\"Љ\":{\"ha\":1388,\"x_min\":11,\"x_max\":1325,\"o\":\"m 864 611 l 942 611 q 1225 532 1125 611 q 1325 310 1325 454 q 1225 78 1325 155 q 930 0 1126 0 l 654 0 l 654 817 l 457 817 l 446 726 q 372 239 404 379 q 278 42 340 99 q 111 -14 216 -15 q 11 1 54 -14 l 11 174 q 85 160 50 160 q 142 193 121 160 q 181 315 163 226 q 231 607 200 404 q 283 991 262 810 l 864 991 l 864 611 m 864 172 l 928 172 q 1068 207 1023 172 q 1112 310 1112 241 q 1068 408 1112 377 q 913 439 1023 439 l 864 439 l 864 172 z \"},\"Њ\":{\"ha\":1392,\"x_min\":125,\"x_max\":1329,\"o\":\"m 1329 310 q 1230 78 1329 155 q 935 0 1130 0 l 659 0 l 659 428 l 335 428 l 335 0 l 125 0 l 125 991 l 335 991 l 335 603 l 659 603 l 659 991 l 868 991 l 868 611 l 946 611 q 1229 532 1129 611 q 1329 310 1329 454 m 868 172 l 932 172 q 1072 207 1027 172 q 1117 310 1117 241 q 1071 409 1117 378 q 917 439 1025 439 l 868 439 l 868 172 z \"},\"Ћ\":{\"ha\":1118,\"x_min\":28,\"x_max\":1044,\"o\":\"m 835 0 l 835 349 q 811 433 835 409 q 733 457 787 457 l 486 457 l 486 0 l 277 0 l 277 817 l 28 817 l 28 991 l 783 991 l 783 817 l 486 817 l 486 632 l 747 632 q 966 561 888 632 q 1044 364 1044 490 l 1044 0 l 835 0 z \"},\"Ќ\":{\"ha\":933,\"x_min\":125,\"x_max\":933,\"o\":\"m 933 0 l 694 0 l 335 503 l 335 0 l 125 0 l 125 991 l 335 991 l 335 511 l 690 991 l 914 991 l 553 515 l 933 0 m 393 1071 l 393 1089 q 553 1293 510 1225 l 785 1293 l 785 1279 q 664 1174 749 1244 q 531 1071 579 1105 l 393 1071 z \"},\"Ў\":{\"ha\":907,\"x_min\":0,\"x_max\":907,\"o\":\"m 907 991 l 600 290 q 492 100 543 158 q 372 15 441 43 q 204 -14 303 -14 q 46 7 119 -14 l 46 187 q 195 163 106 163 q 286 189 251 163 q 343 279 320 215 l 0 991 l 222 991 l 467 439 l 473 439 l 486 473 l 690 991 l 907 991 m 793 1314 q 697 1129 780 1187 q 458 1071 614 1071 q 221 1126 298 1071 q 134 1314 144 1182 l 319 1314 q 354 1216 324 1244 q 463 1187 385 1187 q 565 1218 531 1187 q 606 1314 598 1249 l 793 1314 z \"},\"Џ\":{\"ha\":1035,\"x_min\":125,\"x_max\":909,\"o\":\"m 909 0 l 619 0 l 619 -289 l 416 -289 l 416 0 l 125 0 l 125 991 l 335 991 l 335 175 l 700 175 l 700 991 l 909 991 l 909 0 z \"},\"А\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 z \"},\"Б\":{\"ha\":886,\"x_min\":125,\"x_max\":823,\"o\":\"m 335 611 l 418 611 q 718 532 612 611 q 823 310 823 454 q 414 0 823 0 l 125 0 l 125 991 l 751 991 l 751 818 l 335 818 l 335 611 m 335 172 l 406 172 q 562 207 512 172 q 611 310 611 241 q 561 409 611 378 q 389 439 511 439 l 335 439 l 335 172 z \"},\"В\":{\"ha\":933,\"x_min\":125,\"x_max\":860,\"o\":\"m 125 991 l 433 991 q 740 931 644 991 q 835 741 835 871 q 793 595 835 652 q 682 526 751 538 l 682 519 q 818 441 777 498 q 860 288 860 383 q 762 76 860 152 q 496 0 664 0 l 125 0 l 125 991 m 335 599 l 457 599 q 581 625 543 599 q 619 713 619 652 q 577 794 619 770 q 446 819 536 819 l 335 819 l 335 599 m 335 432 l 335 174 l 472 174 q 600 207 559 174 q 642 309 642 240 q 465 432 642 432 l 335 432 z \"},\"Г\":{\"ha\":779,\"x_min\":125,\"x_max\":751,\"o\":\"m 751 991 l 751 818 l 335 818 l 335 0 l 125 0 l 125 991 l 751 991 z \"},\"Д\":{\"ha\":1061,\"x_min\":7,\"x_max\":1034,\"o\":\"m 7 175 l 83 175 q 239 568 182 372 q 323 991 296 764 l 901 991 l 901 175 l 1034 175 l 1034 -289 l 831 -289 l 831 0 l 210 0 l 210 -289 l 7 -289 l 7 175 m 490 817 q 418 488 469 661 q 304 175 368 314 l 692 175 l 692 817 l 490 817 z \"},\"Е\":{\"ha\":778,\"x_min\":125,\"x_max\":696,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 z \"},\"Ж\":{\"ha\":1310,\"x_min\":0,\"x_max\":1310,\"o\":\"m 353 515 l 20 991 l 236 991 l 557 511 l 557 991 l 753 991 l 753 511 l 1074 991 l 1291 991 l 957 515 l 1310 0 l 1084 0 l 753 503 l 753 0 l 557 0 l 557 503 l 225 0 l 0 0 l 353 515 z \"},\"З\":{\"ha\":900,\"x_min\":64,\"x_max\":840,\"o\":\"m 810 760 q 742 602 810 664 q 558 522 674 539 l 558 518 q 767 443 694 505 q 840 282 840 381 q 729 66 840 145 q 422 -14 618 -14 q 72 40 204 -14 l 72 216 q 221 169 136 186 q 382 151 307 151 q 632 297 632 151 q 552 398 632 363 q 314 433 471 433 l 221 433 l 221 597 l 304 597 q 534 627 462 597 q 606 726 606 657 q 561 807 606 777 q 425 838 515 838 q 155 757 286 838 l 64 897 q 243 980 149 954 q 454 1006 338 1006 q 713 938 616 1006 q 810 760 810 870 z \"},\"И\":{\"ha\":1143,\"x_min\":125,\"x_max\":1018,\"o\":\"m 125 991 l 314 991 l 314 513 l 311 385 l 304 239 l 309 239 l 766 991 l 1018 991 l 1018 0 l 831 0 l 831 476 q 843 760 831 572 l 838 760 l 378 0 l 125 0 l 125 991 z \"},\"Й\":{\"ha\":1143,\"x_min\":125,\"x_max\":1018,\"o\":\"m 125 991 l 314 991 l 314 513 l 311 385 l 304 239 l 309 239 l 766 991 l 1018 991 l 1018 0 l 831 0 l 831 476 q 843 760 831 572 l 838 760 l 378 0 l 125 0 l 125 991 m 900 1314 q 804 1129 887 1187 q 566 1071 722 1071 q 328 1126 405 1071 q 241 1314 251 1182 l 427 1314 q 461 1216 431 1244 q 570 1187 492 1187 q 672 1218 638 1187 q 713 1314 705 1249 l 900 1314 z \"},\"К\":{\"ha\":933,\"x_min\":125,\"x_max\":933,\"o\":\"m 933 0 l 694 0 l 335 503 l 335 0 l 125 0 l 125 991 l 335 991 l 335 511 l 690 991 l 914 991 l 553 515 l 933 0 z \"},\"Л\":{\"ha\":1035,\"x_min\":11,\"x_max\":909,\"o\":\"m 909 0 l 700 0 l 700 817 l 457 817 l 446 726 q 372 239 404 379 q 278 42 340 99 q 111 -14 216 -15 q 11 1 54 -14 l 11 174 q 85 160 50 160 q 142 193 121 160 q 181 315 163 226 q 231 607 200 404 q 283 991 262 810 l 909 991 l 909 0 z \"},\"М\":{\"ha\":1310,\"x_min\":125,\"x_max\":1185,\"o\":\"m 545 0 l 306 778 l 300 778 q 313 461 313 541 l 313 0 l 125 0 l 125 991 l 411 991 l 646 233 l 650 233 l 899 991 l 1185 991 l 1185 0 l 989 0 l 989 469 q 990 546 989 503 q 999 777 991 589 l 993 777 l 737 0 l 545 0 z \"},\"Н\":{\"ha\":1063,\"x_min\":125,\"x_max\":937,\"o\":\"m 937 0 l 728 0 l 728 428 l 335 428 l 335 0 l 125 0 l 125 991 l 335 991 l 335 603 l 728 603 l 728 991 l 937 991 l 937 0 z \"},\"О\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 z \"},\"П\":{\"ha\":1035,\"x_min\":125,\"x_max\":909,\"o\":\"m 909 0 l 700 0 l 700 817 l 335 817 l 335 0 l 125 0 l 125 991 l 909 991 l 909 0 z \"},\"Р\":{\"ha\":872,\"x_min\":125,\"x_max\":810,\"o\":\"m 335 525 l 404 525 q 549 563 501 525 q 597 675 597 602 q 557 784 597 749 q 431 819 517 819 l 335 819 l 335 525 m 810 682 q 710 437 810 522 q 425 353 610 353 l 335 353 l 335 0 l 125 0 l 125 991 l 441 991 q 716 914 622 991 q 810 682 810 836 z \"},\"С\":{\"ha\":885,\"x_min\":81,\"x_max\":836,\"o\":\"m 546 831 q 362 742 427 831 q 297 493 297 652 q 546 161 297 161 q 799 214 650 161 l 799 37 q 526 -14 677 -14 q 195 118 310 -14 q 81 494 81 249 q 137 765 81 649 q 299 944 193 882 q 546 1006 404 1006 q 836 936 690 1006 l 768 765 q 656 811 713 791 q 546 831 600 831 z \"},\"Т\":{\"ha\":804,\"x_min\":28,\"x_max\":777,\"o\":\"m 507 0 l 297 0 l 297 817 l 28 817 l 28 991 l 777 991 l 777 817 l 507 817 l 507 0 z \"},\"У\":{\"ha\":907,\"x_min\":0,\"x_max\":907,\"o\":\"m 907 991 l 600 290 q 492 100 543 158 q 372 15 441 43 q 204 -14 303 -14 q 46 7 119 -14 l 46 187 q 195 163 106 163 q 286 189 251 163 q 343 279 320 215 l 0 991 l 222 991 l 467 439 l 473 439 l 486 473 l 690 991 l 907 991 z \"},\"Ф\":{\"ha\":1194,\"x_min\":62,\"x_max\":1132,\"o\":\"m 692 301 l 701 301 q 872 358 810 301 q 935 515 935 416 q 877 664 935 608 q 720 720 819 720 l 692 720 l 692 301 m 503 -14 l 503 139 l 488 139 q 267 183 361 139 q 117 317 172 228 q 62 514 62 406 q 111 704 62 619 q 251 836 159 788 q 467 884 342 884 l 503 884 l 503 1006 l 692 1006 l 692 884 l 728 884 q 943 836 851 884 q 1083 704 1034 788 q 1132 514 1132 619 q 1077 317 1132 406 q 928 183 1023 228 q 707 139 833 139 l 692 139 l 692 -14 l 503 -14 m 503 720 l 475 720 q 317 664 375 720 q 260 515 260 608 q 321 359 260 418 q 493 301 382 301 l 503 301 l 503 720 z \"},\"Х\":{\"ha\":926,\"x_min\":0,\"x_max\":926,\"o\":\"m 926 0 l 686 0 l 456 375 l 225 0 l 0 0 l 329 511 l 21 991 l 253 991 l 467 635 l 676 991 l 903 991 l 591 500 l 926 0 z \"},\"Ц\":{\"ha\":1084,\"x_min\":125,\"x_max\":1057,\"o\":\"m 909 167 l 1057 167 l 1057 -289 l 854 -289 l 854 0 l 125 0 l 125 991 l 335 991 l 335 175 l 700 175 l 700 991 l 909 991 l 909 167 z \"},\"Ч\":{\"ha\":1011,\"x_min\":74,\"x_max\":886,\"o\":\"m 886 0 l 676 0 l 676 383 q 502 335 572 348 q 370 322 433 322 q 151 390 228 322 q 74 582 74 458 l 74 991 l 283 991 l 283 642 q 317 533 283 570 q 429 497 350 497 q 540 508 485 497 q 676 547 595 519 l 676 991 l 886 991 l 886 0 z \"},\"Ш\":{\"ha\":1497,\"x_min\":125,\"x_max\":1372,\"o\":\"m 854 175 l 1162 175 l 1162 991 l 1372 991 l 1372 0 l 125 0 l 125 991 l 335 991 l 335 175 l 643 175 l 643 991 l 854 991 l 854 175 z \"},\"Щ\":{\"ha\":1547,\"x_min\":125,\"x_max\":1520,\"o\":\"m 854 175 l 1162 175 l 1162 991 l 1372 991 l 1372 167 l 1520 167 l 1520 -289 l 1317 -289 l 1317 0 l 125 0 l 125 991 l 335 991 l 335 175 l 643 175 l 643 991 l 854 991 l 854 175 m 1497 0 z \"},\"Ъ\":{\"ha\":1010,\"x_min\":0,\"x_max\":947,\"o\":\"m 947 310 q 844 78 947 155 q 538 0 741 0 l 249 0 l 249 817 l 0 817 l 0 991 l 458 991 l 458 611 l 542 611 q 842 532 736 611 q 947 310 947 454 m 458 172 l 529 172 q 685 207 635 172 q 734 310 734 241 q 684 409 734 378 q 513 439 634 439 l 458 439 l 458 172 z \"},\"Ы\":{\"ha\":1258,\"x_min\":125,\"x_max\":1133,\"o\":\"m 803 310 q 700 78 803 155 q 396 0 597 0 l 125 0 l 125 991 l 335 991 l 335 611 l 403 611 q 698 532 593 611 q 803 310 803 453 m 335 172 l 390 172 q 542 207 494 172 q 590 310 590 241 q 544 409 590 379 q 380 439 497 439 l 335 439 l 335 172 m 1133 0 l 924 0 l 924 991 l 1133 991 l 1133 0 z \"},\"Ь\":{\"ha\":886,\"x_min\":125,\"x_max\":823,\"o\":\"m 823 310 q 414 0 823 0 l 125 0 l 125 991 l 335 991 l 335 611 l 418 611 q 718 532 612 611 q 823 310 823 454 m 335 172 l 406 172 q 562 207 512 172 q 611 310 611 241 q 561 409 611 378 q 389 439 511 439 l 335 439 l 335 172 z \"},\"Э\":{\"ha\":921,\"x_min\":49,\"x_max\":840,\"o\":\"m 375 831 q 243 812 308 831 q 115 766 178 793 l 49 936 q 379 1006 206 1006 q 720 870 600 1006 q 840 494 840 735 q 716 118 840 249 q 359 -14 593 -14 q 66 37 199 -14 l 66 214 q 347 161 231 161 q 545 224 477 161 q 619 414 613 288 l 189 414 l 189 586 l 618 586 q 549 766 614 701 q 375 831 484 831 z \"},\"Ю\":{\"ha\":1486,\"x_min\":125,\"x_max\":1406,\"o\":\"m 1406 497 q 1292 120 1406 253 q 964 -14 1177 -14 q 655 99 768 -14 q 525 428 543 212 l 335 428 l 335 0 l 125 0 l 125 991 l 335 991 l 335 603 l 529 603 q 664 903 552 799 q 965 1007 775 1007 q 1293 874 1179 1007 q 1406 497 1406 741 m 741 497 q 798 247 741 332 q 964 163 854 163 q 1189 497 1189 163 q 1133 747 1189 663 q 966 832 1077 832 q 798 747 855 832 q 741 497 741 663 z \"},\"Я\":{\"ha\":924,\"x_min\":-7,\"x_max\":799,\"o\":\"m 458 380 l 227 0 l -7 0 l 275 436 q 146 541 191 470 q 102 708 102 612 q 198 918 102 844 q 476 991 295 991 l 799 991 l 799 0 l 589 0 l 589 380 l 458 380 m 589 819 l 485 819 q 359 790 404 819 q 314 693 314 761 q 357 589 314 627 q 490 551 401 551 l 589 551 l 589 819 z \"},\"а\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 z \"},\"б\":{\"ha\":864,\"x_min\":62,\"x_max\":802,\"o\":\"m 62 454 q 162 851 62 715 q 472 1022 261 986 q 778 1067 574 1040 l 802 886 q 489 843 713 876 q 361 802 404 829 q 299 725 319 775 q 273 591 278 675 l 283 591 q 378 677 319 647 q 505 707 437 707 q 724 621 646 707 q 802 375 802 535 q 703 89 802 191 q 431 -14 604 -14 q 160 111 257 -14 q 62 454 62 235 m 443 154 q 590 357 590 154 q 457 554 590 554 q 384 537 420 554 q 318 493 348 520 q 273 437 288 465 q 317 227 273 300 q 443 154 361 154 z \"},\"в\":{\"ha\":888,\"x_min\":109,\"x_max\":832,\"o\":\"m 808 559 q 770 455 808 498 q 657 400 732 412 l 657 395 q 785 339 738 385 q 832 227 832 294 q 745 58 832 116 q 497 0 659 0 l 109 0 l 109 758 l 497 758 q 731 708 653 758 q 808 559 808 657 m 618 237 q 583 302 618 282 q 479 322 549 322 l 315 322 l 315 143 l 484 143 q 584 168 549 143 q 618 237 618 193 m 599 543 q 489 612 599 612 l 315 612 l 315 463 l 465 463 q 565 481 531 463 q 599 543 599 500 z \"},\"г\":{\"ha\":664,\"x_min\":109,\"x_max\":632,\"o\":\"m 632 758 l 632 603 l 315 603 l 315 0 l 109 0 l 109 758 l 632 758 z \"},\"д\":{\"ha\":922,\"x_min\":20,\"x_max\":901,\"o\":\"m 583 151 l 583 603 l 428 603 q 381 363 411 477 q 300 151 352 250 l 583 151 m 901 -272 l 715 -272 l 715 0 l 205 0 l 205 -272 l 20 -272 l 20 151 l 83 151 q 193 406 149 252 q 254 758 237 560 l 790 758 l 790 151 l 901 151 l 901 -272 z \"},\"е\":{\"ha\":821,\"x_min\":62,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 z \"},\"ж\":{\"ha\":1213,\"x_min\":0,\"x_max\":1213,\"o\":\"m 510 390 l 510 758 l 703 758 l 703 390 l 972 758 l 1186 758 l 907 395 l 1213 0 l 991 0 l 703 385 l 703 0 l 510 0 l 510 385 l 221 0 l 0 0 l 306 395 l 26 758 l 240 758 l 510 390 z \"},\"з\":{\"ha\":771,\"x_min\":53,\"x_max\":718,\"o\":\"m 297 467 q 464 486 414 467 q 513 546 513 505 q 477 601 513 583 q 358 619 441 619 q 240 606 306 619 q 119 571 174 593 l 58 715 q 215 759 139 746 q 385 772 291 772 q 612 718 526 772 q 697 571 697 664 q 546 404 697 443 l 546 397 q 679 332 639 374 q 718 221 718 290 q 673 98 718 152 q 544 16 629 45 q 345 -14 459 -14 q 53 33 155 -14 l 53 204 q 181 161 111 177 q 315 146 250 146 q 467 169 416 146 q 517 233 517 191 q 464 301 517 279 q 301 323 411 323 l 221 323 l 221 467 l 297 467 z \"},\"и\":{\"ha\":1000,\"x_min\":109,\"x_max\":892,\"o\":\"m 309 758 l 309 458 q 293 227 309 411 l 643 758 l 892 758 l 892 0 l 692 0 l 692 302 q 705 530 692 383 l 357 0 l 109 0 l 109 758 l 309 758 z \"},\"й\":{\"ha\":1000,\"x_min\":109,\"x_max\":892,\"o\":\"m 309 758 l 309 458 q 293 227 309 411 l 643 758 l 892 758 l 892 0 l 692 0 l 692 302 q 705 530 692 383 l 357 0 l 109 0 l 109 758 l 309 758 m 831 1084 q 735 900 818 958 q 496 842 652 842 q 259 897 336 842 q 172 1084 182 953 l 357 1084 q 392 986 362 1015 q 500 958 422 958 q 603 989 569 958 q 644 1084 636 1020 l 831 1084 z \"},\"к\":{\"ha\":860,\"x_min\":109,\"x_max\":860,\"o\":\"m 606 758 l 833 758 l 533 395 l 860 0 l 625 0 l 315 385 l 315 0 l 109 0 l 109 758 l 315 758 l 315 390 l 606 758 z \"},\"л\":{\"ha\":896,\"x_min\":0,\"x_max\":787,\"o\":\"m 787 0 l 581 0 l 581 603 l 390 603 q 337 223 368 349 q 254 42 306 98 q 118 -14 202 -14 q 0 8 46 -14 l 0 174 q 66 160 33 160 q 131 216 105 160 q 178 401 157 271 q 214 758 199 531 l 787 758 l 787 0 z \"},\"м\":{\"ha\":1173,\"x_min\":109,\"x_max\":1064,\"o\":\"m 1064 0 l 871 0 l 871 597 l 860 555 q 794 339 823 412 l 660 0 l 513 0 l 376 342 q 314 551 347 416 l 301 597 l 301 0 l 109 0 l 109 758 l 393 758 l 524 435 q 561 315 544 382 q 585 199 578 247 q 620 345 607 300 q 647 427 632 389 q 782 758 662 464 l 1064 758 l 1064 0 z \"},\"н\":{\"ha\":920,\"x_min\":109,\"x_max\":811,\"o\":\"m 315 758 l 315 467 l 604 467 l 604 758 l 811 758 l 811 0 l 604 0 l 604 313 l 315 313 l 315 0 l 109 0 l 109 758 l 315 758 z \"},\"о\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 z \"},\"п\":{\"ha\":905,\"x_min\":109,\"x_max\":798,\"o\":\"m 798 758 l 798 0 l 590 0 l 590 603 l 315 603 l 315 0 l 109 0 l 109 758 l 798 758 z \"},\"р\":{\"ha\":879,\"x_min\":109,\"x_max\":817,\"o\":\"m 525 -14 q 315 83 391 -14 l 304 83 q 315 -26 315 -12 l 315 -334 l 109 -334 l 109 758 l 277 758 l 306 660 l 315 660 q 530 772 388 772 q 741 669 665 772 q 817 380 817 565 q 781 170 817 259 q 680 33 745 80 q 525 -14 614 -14 m 464 607 q 352 560 387 607 q 315 404 317 513 l 315 382 q 352 207 315 260 q 467 154 388 154 q 606 383 606 154 q 571 551 606 495 q 464 607 537 607 z \"},\"с\":{\"ha\":714,\"x_min\":62,\"x_max\":671,\"o\":\"m 416 -14 q 62 375 62 -14 q 159 670 62 568 q 435 772 255 772 q 671 721 566 772 l 610 561 q 519 593 561 581 q 435 606 477 606 q 273 376 273 606 q 435 154 273 154 q 545 170 494 154 q 647 220 596 186 l 647 43 q 546 -1 597 11 q 416 -14 494 -14 z \"},\"т\":{\"ha\":768,\"x_min\":32,\"x_max\":736,\"o\":\"m 736 758 l 736 603 l 488 603 l 488 0 l 281 0 l 281 603 l 32 603 l 32 758 l 736 758 z \"},\"у\":{\"ha\":790,\"x_min\":0,\"x_max\":790,\"o\":\"m 0 758 l 227 758 l 370 332 q 395 200 388 276 l 399 200 q 428 332 406 270 l 568 758 l 790 758 l 469 -97 q 343 -275 425 -216 q 153 -334 262 -334 q 47 -322 99 -334 l 47 -158 q 129 -167 85 -167 q 225 -133 184 -167 q 289 -32 266 -100 l 301 5 l 0 758 z \"},\"ф\":{\"ha\":1131,\"x_min\":62,\"x_max\":1068,\"o\":\"m 663 762 q 960 645 852 747 q 1068 379 1068 543 q 962 111 1068 212 q 663 -5 855 10 l 663 -334 l 471 -334 l 471 -5 q 171 115 279 12 q 62 379 62 218 q 167 650 62 551 q 471 762 271 749 l 471 1055 l 663 1055 l 663 762 m 275 379 q 328 223 275 283 q 471 151 380 163 l 471 607 q 329 533 383 595 q 275 379 275 471 m 856 379 q 805 530 856 469 q 663 604 754 591 l 663 151 q 804 224 753 163 q 856 379 856 284 z \"},\"х\":{\"ha\":803,\"x_min\":7,\"x_max\":796,\"o\":\"m 264 387 l 20 758 l 254 758 l 401 517 l 550 758 l 785 758 l 538 387 l 796 0 l 561 0 l 401 260 l 241 0 l 7 0 l 264 387 z \"},\"ц\":{\"ha\":956,\"x_min\":109,\"x_max\":936,\"o\":\"m 825 151 l 936 151 l 936 -272 l 750 -272 l 750 0 l 109 0 l 109 758 l 315 758 l 315 155 l 618 155 l 618 758 l 825 758 l 825 151 z \"},\"ч\":{\"ha\":911,\"x_min\":83,\"x_max\":803,\"o\":\"m 290 758 l 290 481 q 382 382 290 382 q 493 395 441 382 q 596 431 544 409 l 596 758 l 803 758 l 803 0 l 596 0 l 596 301 q 463 248 524 263 q 343 232 401 232 q 151 295 219 232 q 83 476 83 359 l 83 758 l 290 758 z \"},\"ш\":{\"ha\":1346,\"x_min\":109,\"x_max\":1238,\"o\":\"m 1238 0 l 109 0 l 109 758 l 315 758 l 315 155 l 570 155 l 570 758 l 777 758 l 777 155 l 1031 155 l 1031 758 l 1238 758 l 1238 0 z \"},\"щ\":{\"ha\":1368,\"x_min\":109,\"x_max\":1349,\"o\":\"m 1238 151 l 1349 151 l 1349 -272 l 1162 -272 l 1162 0 l 109 0 l 109 758 l 315 758 l 315 155 l 570 155 l 570 758 l 777 758 l 777 155 l 1031 155 l 1031 758 l 1238 758 l 1238 151 m 1346 0 z \"},\"ъ\":{\"ha\":986,\"x_min\":0,\"x_max\":937,\"o\":\"m 449 758 l 449 465 l 595 465 q 853 410 770 465 q 937 241 937 354 q 603 0 937 0 l 241 0 l 241 603 l 0 603 l 0 758 l 449 758 m 730 239 q 695 302 730 283 q 590 322 661 322 l 449 322 l 449 143 l 593 143 q 730 239 730 143 z \"},\"ы\":{\"ha\":1181,\"x_min\":109,\"x_max\":1072,\"o\":\"m 315 465 l 415 465 q 672 410 589 465 q 755 241 755 354 q 672 61 755 121 q 422 0 589 0 l 109 0 l 109 758 l 315 758 l 315 465 m 549 239 q 513 302 549 283 q 408 322 478 322 l 315 322 l 315 143 l 411 143 q 549 239 549 143 m 1072 0 l 865 0 l 865 758 l 1072 758 l 1072 0 z \"},\"ь\":{\"ha\":852,\"x_min\":109,\"x_max\":804,\"o\":\"m 315 465 l 461 465 q 720 410 636 465 q 804 241 804 354 q 469 0 804 0 l 109 0 l 109 758 l 315 758 l 315 465 m 597 239 q 562 302 597 283 q 457 322 527 322 l 315 322 l 315 143 l 460 143 q 597 239 597 143 z \"},\"э\":{\"ha\":711,\"x_min\":50,\"x_max\":648,\"o\":\"m 283 -14 q 50 33 141 -14 l 50 195 q 272 140 168 140 q 387 184 347 140 q 435 314 428 227 l 149 314 l 149 452 l 435 452 q 393 577 429 535 q 289 619 357 619 q 113 576 208 619 l 54 718 q 169 757 105 742 q 297 772 233 772 q 562 676 475 772 q 648 387 648 580 q 556 88 648 189 q 283 -14 465 -14 z \"},\"ю\":{\"ha\":1218,\"x_min\":109,\"x_max\":1156,\"o\":\"m 1156 380 q 1061 90 1156 194 q 800 -14 967 -14 q 561 71 650 -14 q 452 313 471 155 l 315 313 l 315 0 l 109 0 l 109 758 l 315 758 l 315 467 l 454 467 q 567 692 474 612 q 804 772 659 772 q 1060 667 965 772 q 1156 380 1156 562 m 660 380 q 693 210 660 267 q 803 153 726 153 q 911 210 878 153 q 945 380 945 267 q 911 550 945 494 q 802 606 878 606 q 693 549 726 606 q 660 380 660 493 z \"},\"я\":{\"ha\":823,\"x_min\":0,\"x_max\":715,\"o\":\"m 224 0 l 0 0 l 204 300 q 93 388 131 330 q 56 524 56 446 q 138 696 56 633 q 363 758 220 758 l 715 758 l 715 0 l 509 0 l 509 282 l 395 282 l 224 0 m 258 522 q 296 448 258 475 q 393 421 333 421 l 509 421 l 509 612 l 367 612 q 287 588 316 612 q 258 522 258 563 z \"},\"ё\":{\"ha\":821,\"x_min\":62,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 191 953 q 216 1021 191 997 q 285 1044 241 1044 q 355 1019 330 1044 q 380 953 380 994 q 355 887 380 912 q 285 863 329 863 q 216 886 241 863 q 191 953 191 910 m 464 953 q 491 1022 464 1000 q 559 1044 519 1044 q 630 1020 604 1044 q 656 953 656 996 q 629 887 656 911 q 559 863 603 863 q 491 885 519 863 q 464 953 464 907 z \"},\"ђ\":{\"ha\":913,\"x_min\":3,\"x_max\":808,\"o\":\"m 562 -334 q 437 -317 490 -334 l 437 -154 q 518 -167 477 -167 q 602 -52 602 -167 l 602 416 q 570 528 602 491 q 479 566 538 566 q 354 506 393 566 q 315 315 315 447 l 315 0 l 109 0 l 109 811 l 3 811 l 3 946 l 109 946 l 109 1055 l 315 1055 l 315 946 l 529 946 l 529 811 l 315 811 l 315 799 q 306 619 315 743 l 318 619 q 538 730 387 730 q 740 659 671 730 q 808 453 808 588 l 808 -82 q 745 -269 808 -203 q 562 -334 681 -334 z \"},\"ѓ\":{\"ha\":664,\"x_min\":109,\"x_max\":636,\"o\":\"m 632 758 l 632 603 l 315 603 l 315 0 l 109 0 l 109 758 l 632 758 m 245 842 l 245 860 q 404 1064 361 996 l 636 1064 l 636 1050 q 516 945 601 1015 q 382 842 431 876 l 245 842 z \"},\"є\":{\"ha\":728,\"x_min\":62,\"x_max\":684,\"o\":\"m 443 -14 q 158 85 254 -14 q 62 375 62 184 q 154 675 62 577 q 441 772 245 772 q 684 722 566 772 l 624 575 q 436 619 509 619 q 326 578 365 619 q 277 452 287 536 l 562 452 l 562 314 l 277 314 q 323 183 286 225 q 431 140 361 140 q 538 153 484 140 q 661 195 592 165 l 661 36 q 443 -14 565 -14 z \"},\"ѕ\":{\"ha\":690,\"x_min\":62,\"x_max\":637,\"o\":\"m 637 225 q 556 47 637 109 q 314 -14 475 -14 q 173 -2 231 -14 q 64 31 115 9 l 64 201 q 194 156 121 174 q 321 138 266 138 q 433 203 433 138 q 418 242 433 227 q 367 277 404 258 q 269 322 330 296 q 141 390 182 359 q 81 461 100 421 q 62 561 62 502 q 141 717 62 662 q 363 772 219 772 q 629 713 500 772 l 567 564 q 460 604 510 588 q 359 619 411 619 q 268 570 268 619 q 297 522 268 542 q 427 461 327 501 q 557 394 515 425 q 618 322 598 363 q 637 225 637 281 z \"},\"і\":{\"ha\":424,\"x_min\":100,\"x_max\":325,\"o\":\"m 100 954 q 212 1055 100 1055 q 325 954 325 1055 q 297 879 325 906 q 212 852 269 852 q 100 954 100 852 m 315 0 l 109 0 l 109 758 l 315 758 l 315 0 z \"},\"ї\":{\"ha\":424,\"x_min\":-18,\"x_max\":447,\"o\":\"m 315 0 l 109 0 l 109 758 l 315 758 l 315 0 m -18 953 q 7 1021 -18 997 q 76 1044 33 1044 q 146 1019 121 1044 q 172 953 172 994 q 146 887 172 912 q 76 863 120 863 q 7 886 33 863 q -18 953 -18 910 m 255 953 q 282 1022 255 1000 q 351 1044 310 1044 q 421 1020 395 1044 q 447 953 447 996 q 420 887 447 911 q 351 863 394 863 q 282 885 310 863 q 255 953 255 907 z \"},\"ј\":{\"ha\":424,\"x_min\":-89,\"x_max\":325,\"o\":\"m 47 -334 q -89 -317 -32 -334 l -89 -154 q 8 -167 -41 -167 q 84 -138 60 -167 q 109 -52 109 -109 l 109 758 l 315 758 l 315 -82 q 245 -268 315 -203 q 47 -334 176 -334 m 100 954 q 212 1055 100 1055 q 325 954 325 1055 q 297 879 325 906 q 212 852 269 852 q 100 954 100 852 z \"},\"љ\":{\"ha\":1234,\"x_min\":0,\"x_max\":1185,\"o\":\"m 551 0 l 551 603 l 390 603 q 337 223 368 349 q 254 42 306 98 q 118 -14 202 -14 q 0 8 46 -14 l 0 174 q 66 160 33 160 q 131 216 105 160 q 178 401 157 271 q 214 758 199 531 l 758 758 l 758 465 l 854 465 q 1104 410 1023 465 q 1185 241 1185 354 q 859 0 1185 0 l 551 0 m 978 239 q 945 302 978 283 q 846 322 911 322 l 758 322 l 758 143 l 848 143 q 978 239 978 143 z \"},\"њ\":{\"ha\":1234,\"x_min\":109,\"x_max\":1185,\"o\":\"m 758 465 l 854 465 q 1104 410 1023 465 q 1185 241 1185 354 q 859 0 1185 0 l 551 0 l 551 313 l 315 313 l 315 0 l 109 0 l 109 758 l 315 758 l 315 467 l 551 467 l 551 758 l 758 758 l 758 465 m 978 239 q 945 302 978 283 q 846 322 911 322 l 758 322 l 758 143 l 848 143 q 978 239 978 143 z \"},\"ћ\":{\"ha\":913,\"x_min\":3,\"x_max\":808,\"o\":\"m 808 0 l 602 0 l 602 401 q 479 566 602 566 q 354 506 393 566 q 315 315 315 447 l 315 0 l 109 0 l 109 811 l 3 811 l 3 946 l 109 946 l 109 1055 l 315 1055 l 315 946 l 529 946 l 529 811 l 315 811 l 315 799 q 306 619 315 743 l 318 619 q 538 730 387 730 q 740 659 671 730 q 808 453 808 588 l 808 0 z \"},\"ќ\":{\"ha\":860,\"x_min\":109,\"x_max\":860,\"o\":\"m 606 758 l 833 758 l 533 395 l 860 0 l 625 0 l 315 385 l 315 0 l 109 0 l 109 758 l 315 758 l 315 390 l 606 758 m 343 842 l 343 860 q 503 1064 460 996 l 734 1064 l 734 1050 q 614 945 699 1015 q 481 842 529 876 l 343 842 z \"},\"ў\":{\"ha\":790,\"x_min\":0,\"x_max\":790,\"o\":\"m 0 758 l 227 758 l 370 332 q 395 200 388 276 l 399 200 q 428 332 406 270 l 568 758 l 790 758 l 469 -97 q 343 -275 425 -216 q 153 -334 262 -334 q 47 -322 99 -334 l 47 -158 q 129 -167 85 -167 q 225 -133 184 -167 q 289 -32 266 -100 l 301 5 l 0 758 m 726 1084 q 630 900 713 958 q 391 842 547 842 q 154 897 231 842 q 67 1084 77 953 l 252 1084 q 287 986 257 1015 q 395 958 317 958 q 497 989 464 958 q 538 1084 531 1020 l 726 1084 z \"},\"џ\":{\"ha\":933,\"x_min\":109,\"x_max\":825,\"o\":\"m 109 0 l 109 758 l 315 758 l 315 155 l 618 155 l 618 758 l 825 758 l 825 0 l 559 0 l 559 -272 l 374 -272 l 374 0 l 109 0 z \"},\"Ґ\":{\"ha\":807,\"x_min\":125,\"x_max\":779,\"o\":\"m 335 0 l 125 0 l 125 991 l 597 991 l 597 1202 l 779 1202 l 779 818 l 335 818 l 335 0 z \"},\"ґ\":{\"ha\":711,\"x_min\":109,\"x_max\":661,\"o\":\"m 315 0 l 109 0 l 109 758 l 475 758 l 475 965 l 661 965 l 661 603 l 315 603 l 315 0 z \"},\"Ẁ\":{\"ha\":1343,\"x_min\":0,\"x_max\":1343,\"o\":\"m 1090 0 l 851 0 l 717 521 q 691 636 709 549 q 671 753 673 723 q 650 635 667 716 q 625 519 634 554 l 492 0 l 253 0 l 0 991 l 207 991 l 334 450 q 382 191 367 300 q 400 310 386 229 q 428 436 415 391 l 572 991 l 771 991 l 916 436 q 939 322 925 399 q 961 191 954 245 q 983 322 968 243 q 1010 450 998 401 l 1136 991 l 1343 991 l 1090 0 m 650 1071 q 525 1167 608 1101 q 396 1279 442 1234 l 396 1293 l 628 1293 q 787 1089 671 1225 l 787 1071 l 650 1071 z \"},\"ẁ\":{\"ha\":1189,\"x_min\":14,\"x_max\":1175,\"o\":\"m 732 0 l 673 265 l 595 600 l 590 600 l 452 0 l 229 0 l 14 758 l 220 758 l 307 422 q 350 174 328 332 l 354 174 q 378 337 357 225 l 389 395 l 482 758 l 710 758 l 799 395 q 807 351 802 380 q 819 289 813 321 q 828 224 824 256 q 833 174 833 193 l 838 174 q 859 308 844 222 q 882 422 875 393 l 972 758 l 1175 758 l 957 0 l 732 0 m 571 842 q 446 938 528 871 q 317 1050 363 1005 l 317 1064 l 549 1064 q 708 860 591 996 l 708 842 l 571 842 z \"},\"Ẃ\":{\"ha\":1343,\"x_min\":0,\"x_max\":1343,\"o\":\"m 1090 0 l 851 0 l 717 521 q 691 636 709 549 q 671 753 673 723 q 650 635 667 716 q 625 519 634 554 l 492 0 l 253 0 l 0 991 l 207 991 l 334 450 q 382 191 367 300 q 400 310 386 229 q 428 436 415 391 l 572 991 l 771 991 l 916 436 q 939 322 925 399 q 961 191 954 245 q 983 322 968 243 q 1010 450 998 401 l 1136 991 l 1343 991 l 1090 0 m 525 1071 l 525 1089 q 684 1293 642 1225 l 916 1293 l 916 1279 q 796 1174 881 1244 q 663 1071 711 1105 l 525 1071 z \"},\"ẃ\":{\"ha\":1189,\"x_min\":14,\"x_max\":1175,\"o\":\"m 732 0 l 673 265 l 595 600 l 590 600 l 452 0 l 229 0 l 14 758 l 220 758 l 307 422 q 350 174 328 332 l 354 174 q 378 337 357 225 l 389 395 l 482 758 l 710 758 l 799 395 q 807 351 802 380 q 819 289 813 321 q 828 224 824 256 q 833 174 833 193 l 838 174 q 859 308 844 222 q 882 422 875 393 l 972 758 l 1175 758 l 957 0 l 732 0 m 467 842 l 467 860 q 626 1064 583 996 l 858 1064 l 858 1050 q 738 945 823 1015 q 604 842 652 876 l 467 842 z \"},\"Ẅ\":{\"ha\":1343,\"x_min\":0,\"x_max\":1343,\"o\":\"m 1090 0 l 851 0 l 717 521 q 691 636 709 549 q 671 753 673 723 q 650 635 667 716 q 625 519 634 554 l 492 0 l 253 0 l 0 991 l 207 991 l 334 450 q 382 191 367 300 q 400 310 386 229 q 428 436 415 391 l 572 991 l 771 991 l 916 436 q 939 322 925 399 q 961 191 954 245 q 983 322 968 243 q 1010 450 998 401 l 1136 991 l 1343 991 l 1090 0 m 438 1182 q 464 1250 438 1226 q 532 1274 489 1274 q 603 1249 577 1274 q 628 1182 628 1223 q 602 1117 628 1141 q 532 1092 576 1092 q 464 1116 489 1092 q 438 1182 438 1139 m 711 1182 q 739 1252 711 1230 q 807 1274 766 1274 q 877 1249 851 1274 q 903 1182 903 1225 q 877 1116 903 1141 q 807 1092 850 1092 q 739 1114 766 1092 q 711 1182 711 1136 z \"},\"ẅ\":{\"ha\":1189,\"x_min\":14,\"x_max\":1175,\"o\":\"m 732 0 l 673 265 l 595 600 l 590 600 l 452 0 l 229 0 l 14 758 l 220 758 l 307 422 q 350 174 328 332 l 354 174 q 378 337 357 225 l 389 395 l 482 758 l 710 758 l 799 395 q 807 351 802 380 q 819 289 813 321 q 828 224 824 256 q 833 174 833 193 l 838 174 q 859 308 844 222 q 882 422 875 393 l 972 758 l 1175 758 l 957 0 l 732 0 m 361 953 q 387 1021 361 997 q 456 1044 412 1044 q 526 1019 500 1044 q 551 953 551 994 q 526 887 551 912 q 456 863 500 863 q 387 886 412 863 q 361 953 361 910 m 635 953 q 662 1022 635 1000 q 730 1044 690 1044 q 801 1020 774 1044 q 827 953 827 996 q 800 887 827 911 q 730 863 774 863 q 662 885 690 863 q 635 953 635 907 z \"},\"Ỳ\":{\"ha\":867,\"x_min\":0,\"x_max\":867,\"o\":\"m 433 583 l 640 991 l 867 991 l 538 386 l 538 0 l 329 0 l 329 379 l 0 991 l 228 991 l 433 583 m 390 1071 q 264 1167 347 1101 q 136 1279 182 1234 l 136 1293 l 368 1293 q 527 1089 410 1225 l 527 1071 l 390 1071 z \"},\"ỳ\":{\"ha\":790,\"x_min\":0,\"x_max\":790,\"o\":\"m 0 758 l 227 758 l 370 332 q 395 200 388 276 l 399 200 q 428 332 406 270 l 568 758 l 790 758 l 469 -97 q 343 -275 425 -216 q 153 -334 262 -334 q 47 -322 99 -334 l 47 -158 q 129 -167 85 -167 q 225 -133 184 -167 q 289 -32 266 -100 l 301 5 l 0 758 m 366 842 q 241 938 323 871 q 112 1050 158 1005 l 112 1064 l 344 1064 q 503 860 387 996 l 503 842 l 366 842 z \"},\"–\":{\"ha\":694,\"x_min\":56,\"x_max\":639,\"o\":\"m 56 296 l 56 452 l 639 452 l 639 296 l 56 296 z \"},\"—\":{\"ha\":1389,\"x_min\":56,\"x_max\":1333,\"o\":\"m 56 296 l 56 452 l 1333 452 l 1333 296 l 56 296 z \"},\"―\":{\"ha\":1389,\"x_min\":56,\"x_max\":1333,\"o\":\"m 56 296 l 56 452 l 1333 452 l 1333 296 l 56 296 z \"},\"‗\":{\"ha\":571,\"x_min\":-3,\"x_max\":574,\"o\":\"m 574 -314 l -3 -314 l -3 -220 l 574 -220 l 574 -314 m 574 -125 l -3 -125 l -3 -31 l 574 -31 l 574 -125 z \"},\"‘\":{\"ha\":301,\"x_min\":17,\"x_max\":285,\"o\":\"m 26 652 l 17 667 q 66 822 32 728 q 136 991 100 915 l 285 991 q 216 652 240 810 l 26 652 z \"},\"’\":{\"ha\":301,\"x_min\":17,\"x_max\":285,\"o\":\"m 275 991 l 285 977 q 165 652 251 843 l 17 652 q 85 991 64 852 l 275 991 z \"},\"‚\":{\"ha\":404,\"x_min\":43,\"x_max\":311,\"o\":\"m 311 146 q 192 -179 276 9 l 43 -179 q 111 161 87 1 l 301 161 l 311 146 z \"},\"‛\":{\"ha\":300,\"x_min\":17,\"x_max\":285,\"o\":\"m 216 991 q 285 652 241 825 l 136 652 q 63 828 96 738 q 17 977 31 919 l 26 991 l 216 991 z \"},\"“\":{\"ha\":618,\"x_min\":17,\"x_max\":602,\"o\":\"m 334 667 q 383 822 349 728 q 453 991 417 915 l 602 991 q 533 652 557 810 l 343 652 l 334 667 m 17 667 q 66 822 32 728 q 136 991 100 915 l 285 991 q 216 652 240 810 l 26 652 l 17 667 z \"},\"”\":{\"ha\":618,\"x_min\":17,\"x_max\":602,\"o\":\"m 285 977 q 165 652 251 843 l 17 652 q 85 991 64 852 l 275 991 l 285 977 m 602 977 q 482 652 568 843 l 334 652 q 401 991 380 852 l 591 991 l 602 977 z \"},\"„\":{\"ha\":720,\"x_min\":43,\"x_max\":628,\"o\":\"m 311 146 q 192 -179 276 9 l 43 -179 q 111 161 87 1 l 301 161 l 311 146 m 628 146 q 509 -179 593 9 l 359 -179 q 428 161 404 1 l 618 161 l 628 146 z \"},\"†\":{\"ha\":717,\"x_min\":83,\"x_max\":633,\"o\":\"m 633 629 l 408 650 l 446 0 l 257 0 l 294 650 l 83 629 l 83 793 l 294 772 l 257 1055 l 446 1055 l 408 772 l 633 793 l 633 629 z \"},\"‡\":{\"ha\":730,\"x_min\":83,\"x_max\":647,\"o\":\"m 422 378 l 647 399 l 647 235 l 422 256 l 460 0 l 271 0 l 309 256 l 83 235 l 83 399 l 309 378 l 277 533 l 309 677 l 83 657 l 83 821 l 309 800 l 271 1055 l 460 1055 l 422 800 l 647 821 l 647 657 l 422 677 l 454 533 l 422 378 z \"},\"•\":{\"ha\":522,\"x_min\":66,\"x_max\":456,\"o\":\"m 66 507 q 117 667 66 612 q 261 722 167 722 q 405 667 354 722 q 456 507 456 611 q 405 348 456 404 q 261 292 353 292 q 117 348 168 292 q 66 507 66 404 z \"},\"…\":{\"ha\":1187,\"x_min\":79,\"x_max\":1108,\"o\":\"m 79 97 q 110 183 79 154 q 199 212 140 212 q 286 182 255 212 q 317 97 317 153 q 286 13 317 43 q 199 -18 254 -18 q 111 12 142 -18 q 79 97 79 42 m 475 97 q 505 183 475 154 q 595 212 536 212 q 682 182 651 212 q 713 97 713 153 q 682 13 713 43 q 595 -18 650 -18 q 506 12 537 -18 q 475 97 475 42 m 871 97 q 901 183 871 154 q 990 212 932 212 q 1077 182 1046 212 q 1108 97 1108 153 q 1077 13 1108 43 q 990 -18 1046 -18 q 902 12 933 -18 q 871 97 871 42 z \"},\"‰\":{\"ha\":1779,\"x_min\":43,\"x_max\":1736,\"o\":\"m 214 694 q 229 566 214 608 q 278 524 244 524 q 343 694 343 524 q 278 864 343 864 q 229 822 244 864 q 214 694 214 781 m 514 696 q 454 461 514 540 q 277 383 393 383 q 104 464 165 383 q 43 696 43 544 q 277 1006 43 1006 q 453 925 391 1006 q 514 696 514 845 m 981 991 l 431 0 l 268 0 l 818 991 l 981 991 m 908 298 q 923 170 908 212 q 972 127 939 127 q 1038 298 1038 127 q 972 468 1038 468 q 923 426 939 468 q 908 298 908 385 m 1208 300 q 1148 66 1208 144 q 971 -12 1088 -12 q 798 68 859 -12 q 737 300 737 149 q 971 610 737 610 q 1147 529 1086 610 q 1208 300 1208 449 m 1436 298 q 1451 170 1436 212 q 1500 127 1466 127 q 1565 298 1565 127 q 1500 468 1565 468 q 1451 426 1466 468 q 1436 298 1436 385 m 1736 300 q 1676 66 1736 145 q 1499 -12 1617 -12 q 1326 68 1388 -12 q 1265 300 1265 149 q 1499 610 1265 610 q 1675 529 1613 610 q 1736 300 1736 449 m 1251 0 z \"},\"′\":{\"ha\":370,\"x_min\":90,\"x_max\":279,\"o\":\"m 279 991 l 252 633 l 118 633 l 90 991 l 279 991 z \"},\"″\":{\"ha\":656,\"x_min\":90,\"x_max\":566,\"o\":\"m 279 991 l 252 633 l 118 633 l 90 991 l 279 991 m 566 991 l 538 633 l 404 633 l 376 991 l 566 991 z \"},\"‹\":{\"ha\":511,\"x_min\":56,\"x_max\":456,\"o\":\"m 56 389 l 307 697 l 456 616 l 267 380 l 456 144 l 307 64 l 56 371 l 56 389 z \"},\"›\":{\"ha\":511,\"x_min\":56,\"x_max\":456,\"o\":\"m 456 371 l 204 64 l 56 144 l 244 380 l 56 616 l 204 697 l 456 389 l 456 371 z \"},\"‼\":{\"ha\":791,\"x_min\":79,\"x_max\":713,\"o\":\"m 678 329 l 513 329 l 478 991 l 713 991 l 678 329 m 475 97 q 506 183 475 154 q 595 212 536 212 q 682 182 651 212 q 713 97 713 153 q 682 13 713 43 q 595 -18 650 -18 q 507 12 538 -18 q 475 97 475 42 m 282 329 l 117 329 l 82 991 l 317 991 l 282 329 m 79 97 q 110 183 79 154 q 199 212 140 212 q 286 182 255 212 q 317 97 317 153 q 286 13 317 43 q 199 -18 254 -18 q 111 12 142 -18 q 79 97 79 42 z \"},\"⁄\":{\"ha\":180,\"x_min\":-267,\"x_max\":446,\"o\":\"m 446 991 l -104 0 l -267 0 l 283 991 l 446 991 z \"},\"ⁿ\":{\"ha\":587,\"x_min\":69,\"x_max\":528,\"o\":\"m 393 518 l 393 790 q 373 863 393 842 q 314 885 353 885 q 229 852 253 885 q 204 743 204 820 l 204 518 l 69 518 l 69 991 l 179 991 l 197 935 l 207 935 q 353 1003 256 1003 q 528 833 528 1003 l 528 518 l 393 518 z \"},\"₣\":{\"ha\":793,\"x_min\":24,\"x_max\":721,\"o\":\"m 332 298 l 546 298 l 546 178 l 332 178 l 332 0 l 125 0 l 125 178 l 24 178 l 24 298 l 125 298 l 125 991 l 721 991 l 721 819 l 332 819 l 332 591 l 696 591 l 696 419 l 332 419 l 332 298 z \"},\"₤\":{\"ha\":793,\"x_min\":56,\"x_max\":766,\"o\":\"m 478 1006 q 739 950 607 1006 l 676 794 q 579 826 623 814 q 488 838 534 838 q 408 808 433 838 q 382 721 382 779 l 382 644 l 625 644 l 625 525 l 382 525 l 382 447 l 625 447 l 625 326 l 380 326 q 353 239 377 276 q 279 176 330 203 l 766 176 l 766 0 l 56 0 l 56 168 q 149 233 123 197 q 178 326 174 269 l 57 326 l 57 447 l 178 447 l 178 525 l 57 525 l 57 644 l 178 644 l 178 722 q 255 934 178 862 q 478 1006 332 1006 z \"},\"₧\":{\"ha\":1239,\"x_min\":125,\"x_max\":1200,\"o\":\"m 321 525 l 366 525 q 508 560 460 525 q 555 675 555 595 q 513 784 555 749 q 378 819 470 819 l 321 819 l 321 525 m 754 682 q 651 437 754 522 q 357 353 547 353 l 321 353 l 321 0 l 125 0 l 125 991 l 378 991 q 658 914 562 991 q 754 682 754 836 m 1090 138 q 1200 161 1143 138 l 1200 21 q 1040 -14 1134 -14 q 879 43 930 -14 q 828 216 828 99 l 828 432 l 729 432 l 729 505 l 843 575 l 903 734 l 1007 734 l 1007 574 l 1192 574 l 1192 432 l 1007 432 l 1007 224 q 1031 160 1007 183 q 1090 138 1056 138 z \"},\"€\":{\"ha\":793,\"x_min\":45,\"x_max\":783,\"o\":\"m 545 831 q 408 783 462 831 q 339 644 355 735 l 612 644 l 612 525 l 329 525 l 328 501 l 328 469 l 329 447 l 570 447 l 570 326 l 340 326 q 558 161 375 161 q 745 200 655 161 l 745 26 q 546 -14 666 -14 q 273 77 380 -14 q 138 326 165 167 l 45 326 l 45 447 l 125 447 q 122 489 122 463 l 123 525 l 45 525 l 45 644 l 135 644 q 270 904 160 808 q 545 999 380 999 q 783 943 672 999 l 717 786 q 629 819 670 807 q 545 831 589 831 z \"},\"℅\":{\"ha\":1104,\"x_min\":43,\"x_max\":1061,\"o\":\"m 889 991 l 339 0 l 176 0 l 726 991 l 889 991 m 1061 233 q 1000 52 1061 117 q 832 -14 939 -14 q 669 53 731 -14 q 607 233 607 119 q 667 414 607 349 q 836 479 728 479 q 1000 412 938 479 q 1061 233 1061 345 m 745 233 q 766 131 745 165 q 835 97 787 97 q 902 131 881 97 q 922 233 922 165 q 902 335 922 301 q 835 368 881 368 q 766 335 787 368 q 745 233 745 301 m 285 513 q 107 575 172 513 q 43 753 43 637 q 104 936 43 873 q 283 999 166 999 q 431 965 363 999 l 393 860 q 281 888 324 888 q 207 853 231 888 q 182 754 182 819 q 277 625 182 625 q 416 654 355 625 l 416 543 q 285 513 363 513 z \"},\"ℓ\":{\"ha\":722,\"x_min\":28,\"x_max\":672,\"o\":\"m 435 129 q 502 162 475 129 q 532 265 528 196 l 672 265 q 602 52 665 116 q 414 -12 540 -12 q 220 58 290 -12 q 151 261 151 128 l 151 347 l 28 314 l 28 447 q 151 484 94 465 l 151 762 q 215 946 151 887 q 412 1004 279 1004 q 587 945 523 1004 q 652 785 652 886 q 583 575 652 663 q 350 412 514 488 l 350 254 q 435 129 350 129 m 473 781 q 412 875 473 875 q 363 849 376 875 q 350 781 350 823 l 350 558 q 441 642 410 585 q 473 781 473 699 z \"},\"№\":{\"ha\":1428,\"x_min\":92,\"x_max\":1377,\"o\":\"m 835 0 l 612 0 l 267 710 l 257 710 q 273 427 273 536 l 273 0 l 92 0 l 92 991 l 315 991 l 659 286 l 671 286 q 654 559 654 444 l 654 991 l 835 991 l 835 0 m 929 0 l 929 127 l 1362 127 l 1362 0 l 929 0 m 1377 433 q 1314 252 1377 317 q 1145 186 1252 186 q 978 253 1040 186 q 916 433 916 320 q 977 613 916 547 q 1147 679 1038 679 q 1314 611 1252 679 q 1377 433 1377 544 m 1053 433 q 1075 331 1053 366 q 1146 297 1097 297 q 1216 331 1194 297 q 1238 433 1238 366 q 1216 535 1238 501 q 1146 568 1194 568 q 1075 535 1097 568 q 1053 433 1053 501 z \"},\"™\":{\"ha\":1040,\"x_min\":11,\"x_max\":978,\"o\":\"m 258 503 l 144 503 l 144 890 l 11 890 l 11 991 l 393 991 l 393 890 l 258 890 l 258 503 m 648 503 l 536 861 l 532 861 l 534 786 l 534 503 l 424 503 l 424 991 l 591 991 l 700 646 l 815 991 l 978 991 l 978 503 l 864 503 l 864 779 l 867 861 l 863 861 l 745 503 l 648 503 z \"},\"Ω\":{\"ha\":1092,\"x_min\":37,\"x_max\":1054,\"o\":\"m 546 832 q 357 758 423 832 q 290 547 290 683 q 335 324 290 410 q 471 189 380 238 l 471 0 l 37 0 l 37 176 l 289 176 q 130 348 186 239 q 74 591 74 457 q 132 811 74 716 q 297 956 190 905 q 546 1007 404 1007 q 890 894 762 1007 q 1018 590 1018 781 q 962 349 1018 456 q 800 176 905 241 l 1054 176 l 1054 0 l 618 0 l 618 189 q 757 326 712 238 q 802 549 802 413 q 735 758 802 684 q 546 832 668 832 z \"},\"℮\":{\"ha\":860,\"x_min\":69,\"x_max\":789,\"o\":\"m 429 -24 q 241 26 323 -24 q 114 164 159 76 q 69 359 69 253 q 116 562 69 475 q 245 696 163 648 q 429 743 328 743 q 615 695 532 743 q 743 559 697 647 q 789 359 789 471 l 228 359 l 228 118 q 317 58 261 82 q 429 35 374 35 q 580 70 518 35 q 697 193 642 106 l 746 165 q 606 18 680 60 q 429 -24 532 -24 m 632 418 l 632 606 q 543 664 598 642 q 428 686 488 686 q 228 607 311 686 l 228 418 l 632 418 z \"},\"⅛\":{\"ha\":1223,\"x_min\":39,\"x_max\":1160,\"o\":\"m 913 991 l 363 0 l 201 0 l 751 991 l 913 991 m 928 606 q 1080 565 1023 606 q 1137 453 1137 524 q 1115 376 1137 410 q 1040 313 1092 342 q 1114 264 1091 285 q 1148 219 1136 243 q 1160 164 1160 194 q 1095 34 1160 85 q 928 -16 1030 -16 q 756 31 819 -16 q 694 160 694 79 q 719 240 694 204 q 802 307 743 276 q 715 453 715 368 q 774 565 715 524 q 928 606 833 606 m 847 160 q 867 110 847 130 q 925 91 886 91 q 985 110 965 91 q 1006 160 1006 130 q 916 245 1006 215 q 847 160 847 215 m 926 499 q 882 483 897 499 q 867 448 867 467 q 884 403 867 420 q 928 372 902 386 q 970 401 954 385 q 987 448 987 418 q 973 483 987 467 q 926 499 959 499 m 373 397 l 212 397 l 212 700 l 214 776 l 217 840 q 166 787 199 816 l 113 746 l 39 832 l 243 991 l 373 991 l 373 397 z \"},\"⅜\":{\"ha\":1223,\"x_min\":40,\"x_max\":1183,\"o\":\"m 961 991 l 411 0 l 249 0 l 799 991 l 961 991 m 951 606 q 1104 565 1047 606 q 1161 453 1161 524 q 1138 376 1161 410 q 1064 313 1116 342 q 1137 264 1115 285 q 1172 219 1160 243 q 1183 164 1183 194 q 1119 34 1183 85 q 951 -16 1054 -16 q 780 31 842 -16 q 718 160 718 79 q 742 240 718 204 q 825 307 766 276 q 739 453 739 368 q 798 565 739 524 q 951 606 857 606 m 871 160 q 890 110 871 130 q 949 91 910 91 q 1009 110 989 91 q 1029 160 1029 130 q 939 245 1029 215 q 871 160 871 215 m 950 499 q 906 483 921 499 q 890 448 890 467 q 908 403 890 420 q 951 372 926 386 q 994 401 977 385 q 1011 448 1011 418 q 997 483 1011 467 q 950 499 983 499 m 452 847 q 336 713 452 750 l 336 704 q 435 653 400 690 q 471 562 471 616 q 411 433 471 480 q 225 386 351 386 q 40 433 128 386 l 40 562 q 224 501 140 501 q 321 574 321 501 q 291 628 321 610 q 208 646 261 646 l 132 646 l 132 754 l 195 754 q 278 772 251 754 q 306 828 306 789 q 289 871 306 854 q 237 888 272 888 q 177 875 205 888 q 110 835 149 862 l 41 930 q 135 983 83 962 q 256 1004 186 1004 q 397 961 342 1004 q 452 847 452 918 z \"},\"⅝\":{\"ha\":1223,\"x_min\":61,\"x_max\":1183,\"o\":\"m 961 991 l 411 0 l 249 0 l 799 991 l 961 991 m 951 606 q 1104 565 1047 606 q 1161 453 1161 524 q 1138 376 1161 410 q 1064 313 1116 342 q 1137 264 1115 285 q 1172 219 1160 243 q 1183 164 1183 194 q 1119 34 1183 85 q 951 -16 1054 -16 q 780 31 842 -16 q 718 160 718 79 q 742 240 718 204 q 825 307 766 276 q 739 453 739 368 q 798 565 739 524 q 951 606 857 606 m 871 160 q 890 110 871 130 q 949 91 910 91 q 1009 110 989 91 q 1029 160 1029 130 q 939 245 1029 215 q 871 160 871 215 m 950 499 q 906 483 921 499 q 890 448 890 467 q 908 403 890 420 q 951 372 926 386 q 994 401 977 385 q 1011 448 1011 418 q 997 483 1011 467 q 950 499 983 499 m 273 781 q 430 730 370 781 q 489 593 489 680 q 425 440 489 494 q 236 386 360 386 q 61 421 129 386 l 61 551 q 140 515 95 530 q 222 501 185 501 q 339 590 339 501 q 310 654 339 633 q 225 676 280 676 q 144 664 182 676 l 71 693 l 96 991 l 448 991 l 448 867 l 207 867 l 196 775 q 273 781 234 781 z \"},\"⅞\":{\"ha\":1223,\"x_min\":45,\"x_max\":1145,\"o\":\"m 900 991 l 350 0 l 188 0 l 738 991 l 900 991 m 913 606 q 1066 565 1009 606 q 1123 453 1123 524 q 1100 376 1123 410 q 1026 313 1078 342 q 1099 264 1077 285 q 1134 219 1122 243 q 1145 164 1145 194 q 1081 34 1145 85 q 913 -16 1016 -16 q 742 31 804 -16 q 680 160 680 79 q 704 240 680 204 q 787 307 728 276 q 701 453 701 368 q 760 565 701 524 q 913 606 819 606 m 833 160 q 852 110 833 130 q 911 91 872 91 q 971 110 951 91 q 991 160 991 130 q 901 245 991 215 q 833 160 833 215 m 912 499 q 868 483 883 499 q 852 448 852 467 q 870 403 852 420 q 913 372 888 386 q 956 401 939 385 q 973 448 973 418 q 959 483 973 467 q 912 499 945 499 m 110 397 l 340 867 l 45 867 l 45 991 l 498 991 l 498 890 l 281 397 l 110 397 z \"},\"∂\":{\"ha\":807,\"x_min\":40,\"x_max\":761,\"o\":\"m 761 624 q 702 296 761 448 q 545 65 644 144 q 318 -14 446 -14 q 112 58 183 -14 q 40 271 40 130 q 91 494 40 389 q 225 651 141 599 q 418 704 310 704 q 546 676 489 704 q 410 836 530 836 q 321 818 373 836 q 211 761 269 800 l 211 945 q 439 1006 326 1006 q 679 907 597 1006 q 761 624 761 809 m 326 151 q 453 245 396 151 q 532 479 510 338 q 496 532 522 515 q 433 550 469 550 q 347 513 386 550 q 283 404 308 477 q 258 254 258 330 q 326 151 258 151 z \"},\"∆\":{\"ha\":914,\"x_min\":39,\"x_max\":875,\"o\":\"m 39 121 l 339 996 l 576 996 l 875 119 l 875 0 l 39 0 l 39 121 m 457 823 q 449 784 456 813 q 428 707 441 754 q 253 175 414 661 l 661 175 l 490 696 l 483 722 q 457 823 458 810 z \"},\"∏\":{\"ha\":1029,\"x_min\":113,\"x_max\":917,\"o\":\"m 701 -310 l 701 817 l 328 817 l 328 -310 l 113 -310 l 113 991 l 917 991 l 917 -310 l 701 -310 z \"},\"∑\":{\"ha\":876,\"x_min\":28,\"x_max\":869,\"o\":\"m 28 -310 l 28 -195 l 418 371 l 39 879 l 39 991 l 829 991 l 829 821 l 317 821 l 652 375 l 300 -138 l 869 -138 l 869 -310 l 28 -310 z \"},\"−\":{\"ha\":793,\"x_min\":60,\"x_max\":733,\"o\":\"m 60 415 l 60 564 l 733 564 l 733 415 l 60 415 z \"},\"√\":{\"ha\":762,\"x_min\":25,\"x_max\":865,\"o\":\"m 450 -9 l 326 -9 l 144 490 l 25 490 l 25 635 l 245 635 l 385 250 l 717 1192 l 865 1192 l 450 -9 z \"},\"∞\":{\"ha\":982,\"x_min\":77,\"x_max\":905,\"o\":\"m 905 486 q 844 323 905 390 q 690 257 782 257 q 488 376 571 257 q 398 293 448 324 q 294 261 348 261 q 138 323 199 261 q 77 490 77 386 q 138 653 77 588 q 294 718 199 718 q 492 600 414 718 q 690 715 576 715 q 845 653 785 715 q 905 486 905 590 m 301 399 q 414 490 361 399 q 361 559 388 536 q 300 582 334 582 q 238 556 262 582 q 215 489 215 530 q 238 424 215 448 q 301 399 262 399 m 681 578 q 567 488 622 578 q 682 395 621 395 q 743 422 720 395 q 766 488 766 449 q 743 552 766 527 q 681 578 719 578 z \"},\"∫\":{\"ha\":572,\"x_min\":0,\"x_max\":572,\"o\":\"m 465 882 q 410 857 431 882 q 390 789 390 833 l 390 -77 q 323 -269 390 -203 q 132 -334 257 -334 q 0 -306 58 -334 l 0 -134 q 107 -160 62 -160 q 182 -64 182 -160 l 182 799 q 248 990 182 924 q 440 1055 313 1055 q 572 1028 514 1055 l 572 856 q 465 882 512 882 z \"},\"≈\":{\"ha\":793,\"x_min\":60,\"x_max\":733,\"o\":\"m 218 589 q 139 567 181 589 q 60 507 96 544 l 60 664 q 233 738 130 738 q 327 727 283 738 q 421 694 370 716 q 575 657 509 657 q 654 679 611 657 q 733 739 696 701 l 733 583 q 559 509 665 509 q 474 517 515 509 q 372 551 433 526 q 218 589 283 589 m 218 319 q 139 296 181 319 q 60 237 96 273 l 60 393 q 233 467 130 467 q 327 456 283 467 q 421 424 370 446 q 575 387 509 387 q 654 408 611 387 q 733 469 696 430 l 733 312 q 559 238 665 238 q 474 247 515 238 q 372 281 433 256 q 218 319 283 319 z \"},\"≠\":{\"ha\":793,\"x_min\":60,\"x_max\":733,\"o\":\"m 380 283 l 294 97 l 158 154 l 218 283 l 60 283 l 60 432 l 288 432 l 342 547 l 60 547 l 60 694 l 410 694 l 498 885 l 635 827 l 572 694 l 733 694 l 733 547 l 504 547 l 450 432 l 733 432 l 733 283 l 380 283 z \"},\"≤\":{\"ha\":793,\"x_min\":58,\"x_max\":733,\"o\":\"m 58 0 l 58 149 l 732 149 l 732 0 l 58 0 m 733 179 l 60 476 l 60 574 l 733 909 l 733 747 l 269 532 l 733 342 l 733 179 z \"},\"≥\":{\"ha\":793,\"x_min\":60,\"x_max\":733,\"o\":\"m 60 0 l 60 149 l 733 149 l 733 0 l 60 0 m 60 342 l 524 532 l 60 747 l 60 909 l 733 574 l 733 476 l 60 179 l 60 342 z \"},\"◊\":{\"ha\":810,\"x_min\":60,\"x_max\":749,\"o\":\"m 749 498 l 443 0 l 366 0 l 60 498 l 366 999 l 443 999 l 749 498 m 570 498 l 404 777 l 239 498 l 404 221 l 570 498 z \"},\"ﬁ\":{\"ha\":961,\"x_min\":28,\"x_max\":863,\"o\":\"m 528 603 l 349 603 l 349 0 l 142 0 l 142 603 l 28 603 l 28 703 l 142 758 l 142 814 q 205 1003 142 943 q 410 1063 269 1063 q 600 1031 517 1063 l 547 879 q 432 899 485 899 q 368 872 388 899 q 349 806 349 846 l 349 758 l 528 758 l 528 603 m 637 954 q 750 1055 637 1055 q 863 954 863 1055 q 834 879 863 906 q 750 852 806 852 q 637 954 637 852 m 853 0 l 646 0 l 646 758 l 853 758 l 853 0 z \"},\"ﬂ\":{\"ha\":961,\"x_min\":28,\"x_max\":853,\"o\":\"m 528 603 l 349 603 l 349 0 l 142 0 l 142 603 l 28 603 l 28 703 l 142 758 l 142 814 q 205 1003 142 943 q 410 1063 269 1063 q 600 1031 517 1063 l 547 879 q 432 899 485 899 q 368 872 388 899 q 349 806 349 846 l 349 758 l 528 758 l 528 603 m 853 0 l 646 0 l 646 1055 l 853 1055 l 853 0 z \"},\"ȷ\":{\"ha\":424,\"x_min\":-89,\"x_max\":315,\"o\":\"m 47 -334 q -89 -317 -32 -334 l -89 -154 q 8 -167 -41 -167 q 84 -138 60 -167 q 109 -52 109 -109 l 109 758 l 315 758 l 315 -82 q 245 -268 315 -203 q 47 -334 176 -334 z \"},\"⁰\":{\"ha\":526,\"x_min\":28,\"x_max\":498,\"o\":\"m 199 694 q 214 566 199 608 q 262 524 229 524 q 312 566 296 524 q 328 694 328 608 q 312 822 328 781 q 262 864 296 864 q 214 822 229 864 q 199 694 199 781 m 498 696 q 261 383 498 383 q 89 464 150 383 q 28 696 28 544 q 261 1006 28 1006 q 437 925 376 1006 q 498 696 498 845 z \"},\"⁴\":{\"ha\":526,\"x_min\":8,\"x_max\":514,\"o\":\"m 514 500 l 429 500 l 429 397 l 268 397 l 268 500 l 8 500 l 8 604 l 269 996 l 429 996 l 429 614 l 514 614 l 514 500 m 268 614 l 268 725 q 272 850 268 783 q 248 795 266 832 q 220 743 230 759 l 134 614 l 268 614 z \"},\"⁵\":{\"ha\":526,\"x_min\":57,\"x_max\":485,\"o\":\"m 269 781 q 426 730 366 781 q 485 593 485 680 q 420 440 485 494 q 232 386 356 386 q 57 421 125 386 l 57 551 q 136 515 91 530 q 218 501 181 501 q 335 590 335 501 q 306 654 335 633 q 221 676 276 676 q 140 664 178 676 l 66 693 l 92 991 l 444 991 l 444 867 l 203 867 l 192 775 q 269 781 230 781 z \"},\"⁶\":{\"ha\":526,\"x_min\":31,\"x_max\":494,\"o\":\"m 494 595 q 435 440 494 497 q 271 383 376 383 q 97 448 163 383 q 31 619 31 513 q 401 1014 31 903 l 447 904 q 267 823 328 868 q 187 720 205 779 l 195 720 q 246 765 216 749 q 326 781 276 781 q 450 733 405 781 q 494 595 494 686 m 261 504 q 322 528 301 504 q 343 595 343 552 q 323 654 343 631 q 264 677 302 677 q 176 606 176 677 q 199 532 176 561 q 261 504 222 504 z \"},\"⁷\":{\"ha\":526,\"x_min\":40,\"x_max\":493,\"o\":\"m 104 397 l 335 867 l 40 867 l 40 991 l 493 991 l 493 890 l 275 397 l 104 397 z \"},\"⁸\":{\"ha\":526,\"x_min\":31,\"x_max\":496,\"o\":\"m 264 1006 q 416 965 359 1006 q 473 852 473 924 q 451 776 473 810 q 376 713 428 742 q 450 664 427 684 q 484 618 472 643 q 496 564 496 593 q 431 434 496 484 q 264 383 366 383 q 93 431 155 383 q 31 559 31 478 q 55 640 31 604 q 138 707 79 675 q 52 852 52 767 q 111 964 52 923 q 264 1006 170 1006 m 183 559 q 203 510 183 529 q 261 490 222 490 q 321 510 301 490 q 342 559 342 529 q 252 644 342 614 q 183 559 183 614 m 262 899 q 218 883 233 899 q 203 847 203 867 q 220 802 203 819 q 264 771 238 785 q 307 801 290 784 q 323 847 323 818 q 309 883 323 867 q 262 899 295 899 z \"},\"⁹\":{\"ha\":526,\"x_min\":29,\"x_max\":492,\"o\":\"m 492 729 q 408 471 492 557 q 168 386 325 386 q 82 396 119 386 l 82 524 q 150 509 115 509 q 292 547 245 509 q 345 673 339 585 l 339 673 q 205 607 291 607 q 76 657 123 607 q 29 796 29 707 q 91 947 29 889 q 253 1004 153 1004 q 428 932 364 1004 q 492 729 492 860 m 261 884 q 203 860 225 884 q 180 791 180 836 q 199 732 180 754 q 258 710 218 710 q 319 731 296 710 q 343 782 343 753 q 320 856 343 827 q 261 884 297 884 z \"},\" \":{\"ha\":694,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":1389,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":694,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":1389,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":463,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":347,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":232,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":777,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":396,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":278,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":139,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\"​\":{\"ha\":0,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\"﻿\":{\"ha\":0,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\"￼\":{\"ha\":1389,\"x_min\":57,\"x_max\":1346,\"o\":\"m 57 823 l 57 1029 l 262 1029 l 262 954 l 132 954 l 132 823 l 57 823 m 1140 954 l 1140 1029 l 1346 1029 l 1346 823 l 1272 823 l 1272 954 l 1140 954 m 57 -260 l 57 -54 l 132 -54 l 132 -186 l 262 -186 l 262 -260 l 57 -260 m 1140 -260 l 1140 -186 l 1272 -186 l 1272 -54 l 1346 -54 l 1346 -260 l 1140 -260 m 875 -260 l 875 -186 l 1060 -186 l 1060 -260 l 875 -260 m 345 -260 l 345 -186 l 528 -186 l 528 -260 l 345 -260 m 345 954 l 345 1029 l 528 1029 l 528 954 l 345 954 m 1346 26 l 1272 26 l 1272 210 l 1346 210 l 1346 26 m 1346 558 l 1272 558 l 1272 742 l 1346 742 l 1346 558 m 610 -260 l 610 -186 l 794 -186 l 794 -260 l 610 -260 m 132 26 l 57 26 l 57 210 l 132 210 l 132 26 m 610 954 l 610 1029 l 794 1029 l 794 954 l 610 954 m 875 954 l 875 1029 l 1060 1029 l 1060 954 l 875 954 m 132 292 l 57 292 l 57 476 l 132 476 l 132 292 m 132 558 l 57 558 l 57 742 l 132 742 l 132 558 m 1346 292 l 1272 292 l 1272 476 l 1346 476 l 1346 292 m 586 427 q 540 275 586 328 q 408 222 494 222 q 276 275 322 222 q 231 427 231 328 q 276 578 231 526 q 408 631 322 631 q 540 578 494 631 q 586 427 586 526 m 317 427 q 408 293 317 293 q 500 427 500 293 q 408 559 500 559 q 317 427 317 559 m 643 625 l 760 625 q 871 603 833 625 q 909 524 909 580 q 894 467 909 490 q 848 439 878 444 l 848 436 q 905 404 888 427 q 921 343 921 381 q 884 258 921 288 q 783 228 847 228 l 643 228 l 643 625 m 726 468 l 771 468 q 814 479 802 468 q 827 513 827 491 q 812 546 827 536 q 766 555 798 555 l 726 555 l 726 468 m 726 401 l 726 297 l 777 297 q 822 312 810 297 q 835 351 835 326 q 774 401 835 401 l 726 401 m 1011 224 q 957 231 976 224 l 957 300 q 1003 294 986 294 q 1061 353 1061 294 l 1061 625 l 1146 625 l 1146 355 q 1111 257 1146 291 q 1011 224 1075 224 z \"},\"�\":{\"ha\":1389,\"x_min\":57,\"x_max\":1331,\"o\":\"m 693 1055 l 1331 419 l 693 -216 l 57 419 l 693 1055 m 737 249 l 737 281 q 752 337 737 315 q 811 392 767 359 q 906 490 881 448 q 930 593 930 533 q 867 736 930 684 q 692 789 804 789 q 575 770 638 789 q 464 722 512 751 l 519 602 q 689 656 628 656 q 753 636 732 656 q 774 585 774 616 q 757 523 774 549 q 692 461 741 498 q 615 377 635 415 q 595 289 595 339 l 595 249 l 737 249 m 576 62 q 601 -5 576 20 q 672 -29 625 -29 q 742 -4 717 -29 q 766 62 766 20 q 742 131 766 106 q 672 155 718 155 q 600 131 623 155 q 576 62 576 106 z \"},\"ǰ\":{\"ha\":424,\"x_min\":-89,\"x_max\":505,\"o\":\"m 47 -334 q -89 -317 -32 -334 l -89 -154 q 8 -167 -41 -167 q 84 -138 60 -167 q 109 -52 109 -109 l 109 758 l 315 758 l 315 -82 q 245 -268 315 -203 q 47 -334 176 -334 m 505 1064 l 505 1046 q 400 932 448 989 q 332 842 353 876 l 90 842 q 33 918 70 873 q -84 1046 -3 962 l -84 1064 l 54 1064 q 209 945 153 1001 q 368 1064 266 1004 l 505 1064 z \"},\"ʼ\":{\"ha\":301,\"x_min\":17,\"x_max\":285,\"o\":\"m 275 991 l 285 977 q 165 652 251 843 l 17 652 q 85 991 64 852 l 275 991 z \"},\"ϑ\":{\"ha\":1017,\"x_min\":28,\"x_max\":975,\"o\":\"m 672 672 q 610 850 657 787 q 494 914 563 914 q 431 895 454 914 q 407 838 407 876 q 477 717 407 760 q 672 672 547 673 m 888 517 l 889 488 l 889 457 q 782 107 889 228 q 467 -14 674 -14 q 244 42 318 -14 q 170 211 170 98 q 174 282 170 247 q 178 347 178 318 q 169 385 178 376 q 140 395 159 395 q 79 375 112 395 l 28 498 q 232 557 129 557 q 328 525 293 557 q 363 433 363 493 q 358 345 363 391 q 353 252 353 300 q 386 174 353 201 q 481 147 418 147 q 629 225 579 147 q 679 471 679 303 l 679 492 l 677 514 q 420 555 526 515 q 259 665 314 594 q 204 831 204 736 q 280 1005 204 940 q 490 1069 357 1069 q 750 970 654 1069 q 876 672 846 871 l 975 672 l 975 517 l 888 517 z \"},\"ϒ\":{\"ha\":876,\"x_min\":0,\"x_max\":872,\"o\":\"m 432 578 q 515 753 474 670 q 591 896 555 836 q 666 978 626 956 q 770 1000 705 1000 q 872 982 827 1000 l 872 827 q 825 835 842 835 q 780 820 798 835 q 745 779 762 806 q 637 593 699 714 q 539 376 576 473 l 539 0 l 330 0 l 330 379 l 0 991 l 228 991 l 432 578 z \"},\"ϖ\":{\"ha\":1388,\"x_min\":35,\"x_max\":1353,\"o\":\"m 916 -14 q 699 129 755 -14 l 692 129 q 475 -14 636 -14 q 247 78 325 -14 q 170 340 170 170 q 212 603 170 461 l 35 603 l 35 689 l 153 758 l 1353 758 l 1353 603 l 1178 603 q 1221 340 1221 461 q 1143 78 1221 170 q 916 -14 1065 -14 m 1031 345 q 987 603 1031 459 l 401 603 q 359 347 359 467 q 391 196 359 245 q 492 147 422 147 q 574 186 549 147 q 600 317 600 225 l 600 410 l 790 410 l 790 317 q 816 186 790 225 q 899 147 842 147 q 1000 196 968 147 q 1031 345 1031 245 z \"},\"Ḿ\":{\"ha\":1310,\"x_min\":125,\"x_max\":1185,\"o\":\"m 545 0 l 306 778 l 300 778 q 313 461 313 541 l 313 0 l 125 0 l 125 991 l 411 991 l 646 233 l 650 233 l 899 991 l 1185 991 l 1185 0 l 989 0 l 989 469 q 990 546 989 503 q 999 777 991 589 l 993 777 l 737 0 l 545 0 m 531 1072 l 531 1090 q 690 1295 648 1226 l 922 1295 l 922 1280 q 802 1176 887 1245 q 669 1072 717 1106 l 531 1072 z \"},\"ḿ\":{\"ha\":1364,\"x_min\":109,\"x_max\":1260,\"o\":\"m 787 0 l 581 0 l 581 443 q 553 566 581 525 q 467 607 526 607 q 351 549 387 607 q 315 357 315 490 l 315 0 l 109 0 l 109 758 l 267 758 l 294 661 l 306 661 q 394 743 336 713 q 526 772 452 772 q 757 661 696 772 l 775 661 q 865 743 806 714 q 999 772 924 772 q 1194 706 1128 772 q 1260 494 1260 640 l 1260 0 l 1053 0 l 1053 443 q 1025 566 1053 525 q 939 607 998 607 q 825 553 863 607 q 787 380 787 498 l 787 0 m 560 842 l 560 860 q 720 1064 677 996 l 951 1064 l 951 1050 q 831 945 916 1015 q 698 842 746 876 l 560 842 z \"},\"Ḁ\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 652 -244 q 604 -362 652 -317 q 479 -407 555 -407 q 357 -363 404 -407 q 311 -245 311 -320 q 357 -129 311 -172 q 479 -85 403 -85 q 603 -130 554 -85 q 652 -244 652 -174 m 545 -245 q 526 -198 545 -215 q 479 -180 508 -180 q 433 -198 451 -180 q 414 -245 414 -215 q 431 -294 414 -276 q 479 -311 447 -311 q 526 -294 508 -311 q 545 -245 545 -276 z \"},\"ḁ\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 574 -244 q 526 -362 574 -317 q 401 -407 477 -407 q 279 -363 326 -407 q 233 -245 233 -320 q 279 -129 233 -172 q 401 -85 325 -85 q 525 -130 476 -85 q 574 -244 574 -174 m 467 -245 q 448 -198 467 -215 q 401 -180 430 -180 q 355 -198 373 -180 q 336 -245 336 -215 q 353 -294 336 -276 q 401 -311 369 -311 q 448 -294 430 -311 q 467 -245 467 -276 z \"},\"Ὅ\":{\"ha\":1161,\"x_min\":-270,\"x_max\":1080,\"o\":\"m 1080 497 q 958 119 1080 251 q 608 -14 836 -14 q 258 119 380 -14 q 136 498 136 251 q 259 877 136 746 q 610 1007 381 1007 q 959 876 838 1007 q 1080 497 1080 744 m 357 497 q 420 247 357 331 q 608 163 483 163 q 860 497 860 163 q 610 832 860 832 q 420 748 484 832 q 357 497 357 663 m -270 859 q -218 952 -270 914 q -71 1003 -167 990 l -71 953 q -144 925 -121 938 q -168 893 -168 913 q -155 875 -168 881 q -127 863 -142 869 q -99 848 -112 857 q -87 821 -87 840 q -108 780 -87 795 q -174 765 -130 765 q -245 790 -220 765 q -270 859 -270 815 m -35 789 l -22 834 q 20 993 6 934 l 198 993 l 198 979 q 58 771 170 916 l -35 771 l -35 789 z \"},\"˳\":{\"ha\":463,\"x_min\":60,\"x_max\":400,\"o\":\"m 400 -244 q 352 -362 400 -317 q 228 -407 304 -407 q 106 -363 152 -407 q 60 -245 60 -320 q 105 -129 60 -172 q 228 -85 151 -85 q 351 -130 302 -85 q 400 -244 400 -174 m 293 -245 q 275 -198 293 -215 q 228 -180 256 -180 q 181 -198 199 -180 q 163 -245 163 -215 q 179 -294 163 -276 q 228 -311 195 -311 q 275 -294 256 -311 q 293 -245 293 -276 z \"},\"ﬃ\":{\"ha\":1497,\"x_min\":28,\"x_max\":1398,\"o\":\"m 528 603 l 349 603 l 349 0 l 142 0 l 142 603 l 28 603 l 28 703 l 142 758 l 142 814 q 205 1003 142 943 q 410 1063 269 1063 q 600 1031 517 1063 l 547 879 q 432 899 485 899 q 368 872 388 899 q 349 806 349 846 l 349 758 l 528 758 l 528 603 m 1065 603 l 886 603 l 886 0 l 680 0 l 680 603 l 566 603 l 566 703 l 680 758 l 680 814 q 743 1003 680 943 q 947 1063 807 1063 q 1138 1031 1055 1063 l 1085 879 q 970 899 1023 899 q 906 872 926 899 q 886 806 886 846 l 886 758 l 1065 758 l 1065 603 m 1173 954 q 1286 1055 1173 1055 q 1398 954 1398 1055 q 1370 879 1398 906 q 1286 852 1342 852 q 1173 954 1173 852 m 1389 0 l 1182 0 l 1182 758 l 1389 758 l 1389 0 z \"},\"ﬄ\":{\"ha\":1497,\"x_min\":28,\"x_max\":1389,\"o\":\"m 528 603 l 349 603 l 349 0 l 142 0 l 142 603 l 28 603 l 28 703 l 142 758 l 142 814 q 205 1003 142 943 q 410 1063 269 1063 q 600 1031 517 1063 l 547 879 q 432 899 485 899 q 368 872 388 899 q 349 806 349 846 l 349 758 l 528 758 l 528 603 m 1065 603 l 886 603 l 886 0 l 680 0 l 680 603 l 566 603 l 566 703 l 680 758 l 680 814 q 743 1003 680 943 q 947 1063 807 1063 q 1138 1031 1055 1063 l 1085 879 q 970 899 1023 899 q 906 872 926 899 q 886 806 886 846 l 886 758 l 1065 758 l 1065 603 m 1389 0 l 1182 0 l 1182 1055 l 1389 1055 l 1389 0 z \"},\"Ơ\":{\"ha\":1146,\"x_min\":81,\"x_max\":1187,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 876 81 745 q 555 1007 326 1007 q 911 869 790 1007 q 974 1055 974 911 l 1178 1055 l 1187 1040 q 1115 852 1163 920 q 983 750 1067 784 q 1025 497 1025 642 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 1105 0 z \"},\"ơ\":{\"ha\":943,\"x_min\":62,\"x_max\":1007,\"o\":\"m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 576 749 508 772 q 692 679 644 726 q 793 872 793 709 l 997 872 l 1007 857 q 959 713 989 766 q 882 624 930 660 q 762 570 833 587 q 798 380 798 485 m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 860 0 z \"},\"Ư\":{\"ha\":1229,\"x_min\":118,\"x_max\":1243,\"o\":\"m 932 991 l 932 864 q 1006 932 982 882 q 1029 1055 1029 983 l 1234 1055 l 1243 1040 q 1185 879 1221 936 q 1087 788 1149 823 q 932 739 1025 753 l 932 350 q 883 157 932 240 q 741 31 833 75 q 521 -14 648 -14 q 224 84 330 -14 q 118 353 118 182 l 118 991 l 328 991 l 328 368 q 375 213 328 262 q 526 163 423 163 q 676 215 629 163 q 722 370 722 267 l 722 991 l 932 991 m 1050 0 z \"},\"ư\":{\"ha\":1055,\"x_min\":104,\"x_max\":1120,\"o\":\"m 646 0 l 618 97 l 606 97 q 512 16 573 45 q 374 -14 452 -14 q 172 58 240 -14 q 104 264 104 130 l 104 758 l 311 758 l 311 315 q 340 192 311 233 q 433 151 370 151 q 559 209 520 151 q 597 401 597 267 l 597 758 l 804 758 l 804 679 q 879 744 852 694 q 905 872 905 793 l 1109 872 l 1120 857 q 1061 694 1098 751 q 963 603 1025 637 q 804 554 901 568 l 804 0 l 646 0 m 913 0 z \"},\"̀\":{\"ha\":0,\"x_min\":-680,\"x_max\":-288,\"o\":\"m -425 842 q -551 938 -468 871 q -680 1050 -633 1005 l -680 1064 l -448 1064 q -288 860 -405 996 l -288 842 l -425 842 z \"},\"́\":{\"ha\":0,\"x_min\":-553,\"x_max\":-162,\"o\":\"m -553 842 l -553 860 q -394 1064 -437 996 l -162 1064 l -162 1050 q -282 945 -197 1015 q -416 842 -368 876 l -553 842 z \"},\"̃\":{\"ha\":0,\"x_min\":-716,\"x_max\":-154,\"o\":\"m -547 913 q -587 895 -568 913 q -615 840 -606 877 l -716 840 q -660 994 -709 939 q -532 1050 -612 1050 q -477 1039 -504 1050 q -424 1014 -450 1027 q -373 990 -398 1001 q -323 979 -348 979 q -283 997 -302 979 q -255 1051 -264 1015 l -154 1051 q -211 897 -161 953 q -338 842 -260 842 q -393 853 -366 842 q -446 877 -420 864 q -497 902 -472 890 q -547 913 -522 913 z \"},\"̉\":{\"ha\":0,\"x_min\":-547,\"x_max\":-239,\"o\":\"m -239 1008 q -349 875 -239 903 l -355 827 l -473 827 l -489 926 q -420 952 -438 935 q -401 994 -401 969 q -416 1027 -401 1016 q -453 1039 -430 1039 q -547 1023 -497 1039 l -547 1137 q -491 1148 -527 1144 q -428 1153 -456 1153 q -286 1115 -333 1153 q -239 1008 -239 1078 z \"},\"̣\":{\"ha\":0,\"x_min\":-547,\"x_max\":-322,\"o\":\"m -547 -191 q -435 -89 -547 -89 q -322 -191 -322 -89 q -351 -265 -322 -239 q -435 -292 -379 -292 q -547 -191 -547 -292 z \"},\"Ѐ\":{\"ha\":778,\"x_min\":125,\"x_max\":696,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 389 1071 q 263 1167 346 1101 q 134 1279 180 1234 l 134 1293 l 366 1293 q 526 1089 409 1225 l 526 1071 l 389 1071 z \"},\"Ѝ\":{\"ha\":1143,\"x_min\":125,\"x_max\":1018,\"o\":\"m 125 991 l 314 991 l 314 513 l 311 385 l 304 239 l 309 239 l 766 991 l 1018 991 l 1018 0 l 831 0 l 831 476 q 843 760 831 572 l 838 760 l 378 0 l 125 0 l 125 991 m 536 1071 q 411 1167 494 1101 q 282 1279 328 1234 l 282 1293 l 514 1293 q 673 1089 557 1225 l 673 1071 l 536 1071 z \"},\"ѐ\":{\"ha\":821,\"x_min\":62,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 420 842 q 295 938 378 871 q 166 1050 212 1005 l 166 1064 l 398 1064 q 557 860 441 996 l 557 842 l 420 842 z \"},\"ѝ\":{\"ha\":1000,\"x_min\":109,\"x_max\":892,\"o\":\"m 309 758 l 309 458 q 293 227 309 411 l 643 758 l 892 758 l 892 0 l 692 0 l 692 302 q 705 530 692 383 l 357 0 l 109 0 l 109 758 l 309 758 m 488 842 q 362 938 445 871 q 233 1050 279 1005 l 233 1064 l 465 1064 q 625 860 508 996 l 625 842 l 488 842 z \"},\"Ѡ\":{\"ha\":1511,\"x_min\":81,\"x_max\":1430,\"o\":\"m 1040 838 q 983 826 1014 838 q 907 785 953 815 l 833 930 q 937 984 877 964 q 1047 1004 996 1004 q 1330 878 1229 1004 q 1430 521 1430 751 q 1319 126 1430 267 q 1006 -14 1208 -14 q 867 11 927 -14 q 754 86 806 35 q 643 11 702 35 q 505 -14 584 -14 q 192 126 304 -14 q 81 521 81 266 q 181 877 81 750 q 464 1004 282 1004 q 573 985 514 1004 q 677 930 633 965 l 604 785 q 527 826 558 815 q 471 838 496 838 q 336 755 384 838 q 288 519 288 673 q 351 259 288 349 q 533 170 414 170 q 647 216 589 170 l 647 485 l 857 485 l 857 216 q 979 170 906 170 q 1161 259 1099 170 q 1223 519 1223 349 q 1175 755 1223 672 q 1040 838 1126 838 z \"},\"ѡ\":{\"ha\":1229,\"x_min\":4,\"x_max\":1175,\"o\":\"m 272 0 l 4 758 l 221 758 l 353 323 q 383 168 375 256 l 389 168 q 440 323 399 224 l 514 511 l 428 758 l 661 758 l 786 338 l 828 183 l 833 183 q 935 425 903 288 q 966 758 966 562 l 1175 758 q 1107 323 1175 509 q 899 0 1040 138 l 713 0 l 602 258 l 485 0 l 272 0 z \"},\"Ѣ\":{\"ha\":935,\"x_min\":0,\"x_max\":872,\"o\":\"m 383 762 l 383 611 l 467 611 q 766 532 661 611 q 872 310 872 454 q 463 0 872 0 l 174 0 l 174 762 l 0 762 l 0 918 l 174 918 l 174 1055 l 383 1055 l 383 918 l 639 918 l 639 762 l 383 762 m 383 172 l 454 172 q 610 207 561 172 q 660 310 660 241 q 610 409 660 378 q 437 439 559 439 l 383 439 l 383 172 z \"},\"ѣ\":{\"ha\":920,\"x_min\":0,\"x_max\":871,\"o\":\"m 382 603 l 382 465 l 528 465 q 787 410 703 465 q 871 241 871 354 q 536 0 871 0 l 175 0 l 175 603 l 0 603 l 0 758 l 175 758 l 175 895 l 382 895 l 382 758 l 625 758 l 625 603 l 382 603 m 664 239 q 629 302 664 283 q 524 322 593 322 l 382 322 l 382 143 l 526 143 q 664 239 664 143 z \"},\"Ѥ\":{\"ha\":1320,\"x_min\":125,\"x_max\":1271,\"o\":\"m 1111 428 l 694 428 q 774 233 703 305 q 960 161 844 161 q 1091 175 1025 161 q 1234 214 1156 189 l 1234 37 q 1095 -2 1163 10 q 946 -14 1027 -14 q 612 100 732 -14 q 475 428 492 213 l 335 428 l 335 0 l 125 0 l 125 991 l 335 991 l 335 603 l 481 603 q 640 899 511 793 q 966 1006 768 1006 q 1271 936 1122 1006 l 1203 765 q 1081 811 1142 791 q 961 831 1020 831 q 780 772 850 831 q 696 603 709 713 l 1111 603 l 1111 428 z \"},\"ѥ\":{\"ha\":1111,\"x_min\":109,\"x_max\":1061,\"o\":\"m 828 -14 q 574 68 665 -14 q 465 313 482 151 l 315 313 l 315 0 l 109 0 l 109 758 l 315 758 l 315 467 l 465 467 q 569 696 481 619 q 814 772 656 772 q 940 758 876 772 q 1057 718 1005 743 l 999 576 q 822 619 903 619 q 718 581 754 619 q 676 467 682 543 l 962 467 l 962 313 l 676 313 q 722 183 682 226 q 839 140 761 140 q 1061 195 942 140 l 1061 33 q 828 -14 969 -14 z \"},\"Ѧ\":{\"ha\":1014,\"x_min\":0,\"x_max\":1014,\"o\":\"m 810 0 l 668 428 l 600 428 l 600 0 l 415 0 l 415 428 l 346 428 l 205 0 l 0 0 l 378 996 l 635 996 l 1014 0 l 810 0 m 399 589 l 611 589 q 507 869 520 823 q 399 589 500 834 z \"},\"ѧ\":{\"ha\":889,\"x_min\":0,\"x_max\":889,\"o\":\"m 587 286 l 534 286 l 534 0 l 355 0 l 355 286 l 301 286 l 199 0 l 0 0 l 319 758 l 568 758 l 889 0 l 690 0 l 587 286 m 354 427 l 536 427 l 513 481 q 444 646 464 587 q 354 427 427 583 z \"},\"Ѩ\":{\"ha\":1396,\"x_min\":125,\"x_max\":1396,\"o\":\"m 1192 0 l 1050 428 l 982 428 l 982 0 l 798 0 l 798 428 l 728 428 l 587 0 l 382 0 l 545 428 l 335 428 l 335 0 l 125 0 l 125 991 l 335 991 l 335 603 l 611 603 l 760 996 l 1017 996 l 1396 0 l 1192 0 m 781 589 l 993 589 l 958 682 q 889 869 896 843 q 781 589 882 834 z \"},\"ѩ\":{\"ha\":1253,\"x_min\":109,\"x_max\":1253,\"o\":\"m 943 311 l 899 311 l 899 0 l 720 0 l 720 311 l 675 311 l 562 0 l 364 0 l 496 313 l 288 313 l 288 0 l 109 0 l 109 758 l 288 758 l 288 467 l 559 467 l 684 758 l 932 758 l 1253 0 l 1054 0 l 943 311 m 730 452 l 889 452 q 808 646 824 600 q 730 452 794 596 z \"},\"Ѫ\":{\"ha\":1117,\"x_min\":28,\"x_max\":1089,\"o\":\"m 28 0 l 131 307 q 227 492 170 429 q 374 579 284 555 l 119 897 l 119 991 l 1002 991 l 1002 897 l 742 579 q 890 489 833 554 q 986 307 947 425 l 1089 0 l 878 0 l 794 261 q 738 379 766 345 q 664 424 709 413 l 664 0 l 456 0 l 456 424 q 378 379 408 413 q 322 261 349 345 l 239 0 l 28 0 m 558 604 l 730 817 l 387 817 l 558 604 z \"},\"ѫ\":{\"ha\":865,\"x_min\":14,\"x_max\":851,\"o\":\"m 14 0 l 93 235 q 162 368 120 319 q 267 439 205 417 l 71 686 l 71 758 l 800 758 l 800 686 l 602 437 q 703 367 662 416 q 772 235 744 318 l 851 0 l 676 0 l 612 200 q 576 275 595 252 q 525 304 557 297 l 525 0 l 346 0 l 346 306 q 289 276 309 299 q 253 200 269 253 l 189 0 l 14 0 m 433 465 l 555 618 l 313 618 l 433 465 z \"},\"Ѭ\":{\"ha\":1491,\"x_min\":125,\"x_max\":1463,\"o\":\"m 401 0 l 504 307 q 568 428 534 393 l 335 428 l 335 0 l 125 0 l 125 991 l 335 991 l 335 603 l 728 603 l 493 897 l 493 991 l 1375 991 l 1375 897 l 1116 579 q 1264 489 1207 554 q 1360 307 1321 425 l 1463 0 l 1251 0 l 1168 261 q 1112 379 1140 345 q 1038 424 1083 413 l 1038 0 l 829 0 l 829 424 q 752 379 781 413 q 696 261 723 345 l 612 0 l 401 0 m 932 604 l 1104 817 l 761 817 l 932 604 m 374 0 z \"},\"ѭ\":{\"ha\":1222,\"x_min\":109,\"x_max\":1208,\"o\":\"m 371 0 l 450 235 q 492 313 470 292 l 288 313 l 288 0 l 109 0 l 109 758 l 288 758 l 288 467 l 602 467 l 428 686 l 428 758 l 1157 758 l 1157 686 l 958 437 q 1060 367 1019 416 q 1129 235 1101 318 l 1208 0 l 1034 0 l 970 200 q 934 273 954 249 q 882 304 913 298 l 882 0 l 703 0 l 703 306 q 646 276 666 299 q 610 200 625 253 l 546 0 l 371 0 m 790 465 l 913 618 l 669 618 l 790 465 m 357 0 z \"},\"Ѯ\":{\"ha\":878,\"x_min\":28,\"x_max\":818,\"o\":\"m 653 1204 q 736 1193 703 1204 l 736 1090 q 676 1099 718 1099 q 549 994 613 1099 q 725 909 663 971 q 787 760 787 846 q 725 602 787 665 q 555 522 663 539 l 555 518 q 749 443 680 505 q 818 282 818 380 q 704 66 818 146 q 389 -14 589 -14 q 293 -19 326 -14 q 246 -38 260 -25 q 232 -79 232 -52 q 330 -139 232 -139 q 461 -136 391 -139 l 566 -132 q 681 -160 661 -132 l 681 -315 q 640 -296 670 -304 q 572 -288 609 -288 l 450 -290 l 288 -293 q 97 -235 167 -293 q 28 -77 28 -176 q 108 94 28 41 q 361 151 188 146 q 551 188 493 154 q 610 297 610 222 q 529 398 610 363 q 292 433 449 433 l 199 433 l 199 597 l 282 597 q 511 627 439 597 q 583 726 583 657 q 538 807 583 777 q 403 838 493 838 q 134 757 262 838 l 41 897 q 160 960 98 934 q 302 997 222 985 q 149 1166 237 1078 l 149 1185 l 290 1185 q 432 1053 327 1158 q 514 1147 485 1120 q 578 1189 544 1173 q 653 1204 612 1204 z \"},\"ѯ\":{\"ha\":771,\"x_min\":21,\"x_max\":718,\"o\":\"m 604 936 q 688 925 653 936 l 688 822 q 628 831 665 831 q 521 755 571 831 q 652 685 606 732 q 697 571 697 637 q 662 465 697 507 q 555 404 626 423 l 555 397 q 681 332 643 374 q 718 221 718 290 q 619 47 718 107 q 336 -14 520 -14 q 230 -27 263 -14 q 197 -75 197 -40 q 223 -125 197 -111 q 309 -139 248 -139 q 420 -136 366 -139 q 505 -132 473 -132 q 618 -160 597 -132 l 618 -315 q 577 -296 606 -304 q 513 -288 548 -288 q 406 -290 467 -288 q 261 -293 345 -293 q 81 -241 141 -293 q 21 -85 21 -189 q 99 90 21 34 q 338 146 177 146 q 472 168 427 146 q 517 233 517 189 q 464 301 517 279 q 301 323 411 323 l 221 323 l 221 467 l 297 467 q 464 486 414 467 q 513 546 513 505 q 477 601 513 583 q 358 619 441 619 q 240 606 306 619 q 119 571 174 593 l 58 715 q 145 743 102 732 q 231 761 189 754 l 168 834 l 109 899 l 109 917 l 241 917 q 383 785 280 889 q 468 880 439 854 q 531 921 497 905 q 604 936 564 936 z \"},\"Ѱ\":{\"ha\":1217,\"x_min\":74,\"x_max\":1143,\"o\":\"m 1143 667 q 1042 386 1143 476 q 737 296 941 296 l 703 296 l 703 0 l 514 0 l 514 296 l 479 296 q 173 386 273 296 q 74 664 74 475 l 74 991 l 271 991 l 271 667 q 321 513 271 560 q 493 465 372 465 l 514 465 l 514 991 l 703 991 l 703 465 l 724 465 q 894 514 842 465 q 946 664 946 564 l 946 991 l 1143 991 l 1143 667 z \"},\"ѱ\":{\"ha\":1162,\"x_min\":97,\"x_max\":1089,\"o\":\"m 684 1054 l 684 147 q 851 215 803 159 q 899 392 899 271 q 844 758 899 544 l 1036 758 q 1089 390 1089 568 q 987 102 1089 204 q 684 -12 885 -1 l 684 -334 l 492 -334 l 492 -12 q 196 92 295 -6 q 97 376 97 190 l 97 758 l 294 758 l 294 371 q 338 204 294 254 q 492 146 381 154 l 492 1054 l 684 1054 z \"},\"Ѳ\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 553 163 q 727 228 663 163 q 804 421 791 293 l 300 421 q 375 231 313 299 q 553 163 437 163 m 554 832 q 384 773 447 832 q 302 596 321 714 l 802 596 q 723 771 785 711 q 554 832 661 832 z \"},\"ѳ\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 431 153 q 534 192 496 153 q 582 310 572 231 l 277 310 q 324 192 287 231 q 431 153 361 153 m 429 606 q 325 567 363 606 q 277 453 287 529 l 582 453 q 535 567 572 529 q 429 606 498 606 z \"},\"Ѵ\":{\"ha\":996,\"x_min\":0,\"x_max\":981,\"o\":\"m 913 825 q 860 801 882 825 q 810 697 838 777 l 566 0 l 336 0 l 0 991 l 212 991 l 408 375 q 452 172 437 267 q 500 375 463 259 l 615 728 q 684 897 652 844 q 755 975 715 949 q 854 1000 796 1000 q 981 974 933 1000 l 981 810 q 913 825 946 825 z \"},\"ѵ\":{\"ha\":840,\"x_min\":0,\"x_max\":836,\"o\":\"m 0 758 l 216 758 l 355 334 q 395 170 389 223 l 397 170 q 436 329 406 245 l 519 562 q 580 694 554 659 q 642 747 606 730 q 736 764 678 764 q 836 745 787 764 l 836 585 q 781 597 807 597 q 742 583 759 597 q 710 530 724 568 l 501 0 l 290 0 l 0 758 z \"},\"Ѷ\":{\"ha\":996,\"x_min\":0,\"x_max\":981,\"o\":\"m 913 825 q 860 801 882 825 q 810 697 838 777 l 566 0 l 336 0 l 0 991 l 212 991 l 408 375 q 452 172 437 267 q 500 375 463 259 l 615 728 q 684 897 652 844 q 755 975 715 949 q 854 1000 796 1000 q 981 974 933 1000 l 981 810 q 913 825 946 825 m 595 1071 q 479 1173 553 1104 q 382 1279 405 1242 l 382 1293 l 586 1293 q 642 1186 608 1244 q 704 1089 676 1127 l 704 1071 l 595 1071 m 325 1071 q 204 1177 275 1109 q 113 1279 134 1245 l 113 1293 l 317 1293 q 373 1186 339 1244 q 435 1089 407 1127 l 435 1071 l 325 1071 z \"},\"ѷ\":{\"ha\":840,\"x_min\":0,\"x_max\":836,\"o\":\"m 0 758 l 216 758 l 355 334 q 395 170 389 223 l 397 170 q 436 329 406 245 l 519 562 q 580 694 554 659 q 642 747 606 730 q 736 764 678 764 q 836 745 787 764 l 836 585 q 781 597 807 597 q 742 583 759 597 q 710 530 724 568 l 501 0 l 290 0 l 0 758 m 532 842 q 416 944 490 875 q 319 1050 342 1013 l 319 1064 l 524 1064 q 580 957 546 1015 q 642 860 614 898 l 642 842 l 532 842 m 262 842 q 142 948 213 880 q 50 1050 71 1016 l 50 1064 l 254 1064 q 311 957 277 1015 q 372 860 345 898 l 372 842 l 262 842 z \"},\"Ѹ\":{\"ha\":1832,\"x_min\":81,\"x_max\":1832,\"o\":\"m 1042 758 l 1268 758 l 1411 332 q 1436 200 1430 276 l 1440 200 q 1470 332 1448 270 l 1610 758 l 1832 758 l 1511 -97 q 1385 -275 1467 -216 q 1194 -334 1303 -334 q 1089 -322 1141 -334 l 1089 -158 q 1171 -167 1126 -167 q 1266 -133 1225 -167 q 1331 -32 1308 -100 l 1343 5 l 1042 758 m 970 497 q 858 116 970 245 q 525 -14 746 -14 q 193 115 305 -14 q 81 498 81 243 q 193 880 81 753 q 526 1007 306 1007 q 858 879 745 1007 q 970 497 970 751 m 297 497 q 353 243 297 323 q 525 163 408 163 q 697 240 642 163 q 753 497 753 318 q 698 753 753 674 q 526 832 644 832 q 352 751 408 832 q 297 497 297 671 z \"},\"ѹ\":{\"ha\":1590,\"x_min\":62,\"x_max\":1590,\"o\":\"m 800 758 l 1026 758 l 1169 332 q 1194 200 1187 281 l 1198 200 q 1227 332 1207 270 l 1368 758 l 1590 758 l 1270 -97 q 1144 -275 1225 -216 q 953 -334 1062 -334 q 847 -322 901 -334 l 847 -158 q 929 -167 886 -167 q 1025 -133 984 -167 q 1089 -32 1066 -100 l 1101 5 l 800 758 m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 z \"},\"Ѻ\":{\"ha\":1161,\"x_min\":81,\"x_max\":1080,\"o\":\"m 1080 497 q 978 150 1080 279 q 682 -7 876 20 q 582 -85 659 -85 q 482 -7 502 -85 q 184 148 288 18 q 81 498 81 277 q 183 846 81 718 q 484 1000 286 975 q 517 1058 494 1041 q 582 1075 541 1075 q 642 1060 618 1075 q 679 1000 667 1045 q 977 846 873 975 q 1080 497 1080 717 m 297 497 q 345 281 297 363 q 488 174 393 199 q 526 212 503 202 q 582 222 549 222 q 636 212 612 222 q 675 174 659 202 q 864 497 864 224 q 677 819 864 767 q 582 768 651 768 q 485 819 513 768 q 297 497 297 767 z \"},\"ѻ\":{\"ha\":943,\"x_min\":62,\"x_max\":880,\"o\":\"m 880 380 q 799 123 880 221 q 562 0 718 26 q 532 -56 556 -36 q 471 -75 507 -75 q 408 -55 432 -75 q 378 1 384 -35 q 144 127 227 28 q 62 380 62 227 q 145 640 62 541 q 383 761 227 739 q 471 817 396 817 q 557 761 543 817 q 794 638 709 738 q 880 380 880 539 m 273 380 q 380 155 273 197 q 413 196 393 182 q 471 211 432 211 q 521 200 500 211 q 559 154 542 189 q 643 235 616 175 q 669 380 669 295 q 642 525 669 469 q 566 600 615 581 q 533 549 554 568 q 471 530 512 530 q 411 547 434 530 q 375 600 388 564 q 273 380 273 556 z \"},\"Ѽ\":{\"ha\":1511,\"x_min\":81,\"x_max\":1430,\"o\":\"m 1040 838 q 983 826 1014 838 q 907 785 953 815 l 847 930 q 940 983 888 962 q 1047 1004 993 1004 q 1330 878 1229 1004 q 1430 521 1430 751 q 1319 126 1430 267 q 1006 -14 1208 -14 q 873 11 933 -14 q 755 90 812 35 q 644 13 703 39 q 505 -14 584 -14 q 192 126 304 -14 q 81 521 81 266 q 181 877 81 750 q 464 1004 282 1004 q 571 983 519 1004 q 664 930 623 962 l 604 785 q 527 826 558 815 q 471 838 496 838 q 336 755 384 838 q 288 519 288 673 q 347 259 288 351 q 514 167 406 167 q 642 205 579 167 q 755 310 705 243 q 869 204 806 241 q 997 167 932 167 q 1165 260 1107 167 q 1223 519 1223 353 q 1175 755 1223 672 q 1040 838 1126 838 m 1050 1402 l 1050 1271 l 1039 1271 q 825 1308 917 1271 q 738 1340 755 1335 q 704 1344 721 1344 q 658 1327 673 1344 q 636 1270 644 1310 l 513 1270 l 513 1303 q 534 1409 513 1369 q 593 1466 555 1448 q 701 1485 630 1485 q 779 1472 741 1485 q 857 1443 817 1459 q 942 1415 897 1428 q 1040 1402 987 1402 l 1050 1402 m 865 1177 q 805 1066 865 1114 q 656 1014 744 1019 l 656 1072 q 713 1101 691 1082 q 734 1141 734 1121 q 722 1160 734 1154 q 694 1172 709 1166 q 667 1186 680 1177 q 654 1214 654 1195 q 681 1270 654 1250 q 755 1289 707 1289 q 837 1259 808 1289 q 865 1177 865 1228 z \"},\"ѽ\":{\"ha\":1236,\"x_min\":62,\"x_max\":1174,\"o\":\"m 416 -14 q 152 87 241 -14 q 62 387 62 188 q 142 675 62 578 q 389 772 222 772 q 574 732 490 772 l 515 590 q 450 615 473 610 q 403 619 428 619 q 277 387 277 619 q 317 203 277 267 q 431 140 357 140 q 618 232 530 140 q 806 140 706 140 q 920 204 880 140 q 960 387 960 267 q 833 619 960 619 q 785 614 807 619 q 721 590 763 610 l 663 732 q 847 772 747 772 q 1094 675 1014 772 q 1174 387 1174 578 q 1085 88 1174 190 q 819 -14 996 -14 q 618 62 702 -14 q 416 -14 535 -14 m 908 1189 l 908 1057 l 897 1057 q 683 1094 775 1057 q 596 1126 613 1122 q 562 1131 579 1131 q 516 1113 531 1131 q 494 1055 502 1095 l 371 1055 l 371 1089 q 382 1170 371 1136 q 414 1225 394 1204 q 468 1259 433 1246 q 559 1271 503 1271 q 637 1258 599 1271 q 715 1230 675 1245 q 801 1202 755 1215 q 899 1189 846 1189 l 908 1189 m 724 962 q 662 851 724 899 q 514 800 600 804 l 514 859 q 570 887 548 867 q 593 928 593 907 q 580 947 593 941 q 553 958 568 953 q 525 972 538 964 q 513 1000 513 981 q 539 1055 513 1036 q 614 1075 566 1075 q 695 1045 667 1075 q 724 962 724 1015 z \"},\"Ѿ\":{\"ha\":1511,\"x_min\":81,\"x_max\":1430,\"o\":\"m 1040 838 q 983 826 1014 838 q 907 785 953 815 l 847 930 q 940 983 888 962 q 1047 1004 993 1004 q 1330 878 1229 1004 q 1430 521 1430 751 q 1319 126 1430 267 q 1006 -14 1208 -14 q 873 11 933 -14 q 755 90 812 35 q 644 13 703 39 q 505 -14 584 -14 q 192 126 304 -14 q 81 521 81 266 q 181 877 81 750 q 464 1004 282 1004 q 571 983 519 1004 q 664 930 623 962 l 604 785 q 527 826 558 815 q 471 838 496 838 q 336 755 384 838 q 288 519 288 673 q 351 259 288 349 q 533 170 414 170 q 647 220 587 170 l 647 485 l 857 485 l 857 227 q 979 170 918 170 q 1161 259 1099 170 q 1223 519 1223 349 q 1175 755 1223 672 q 1040 838 1126 838 m 1036 1260 l 1036 1200 l 981 1083 l 943 1083 l 909 1153 l 806 1153 l 772 1083 l 734 1083 l 701 1153 l 597 1153 l 564 1083 l 526 1083 l 472 1200 l 472 1260 l 1036 1260 z \"},\"ѿ\":{\"ha\":1229,\"x_min\":4,\"x_max\":1175,\"o\":\"m 282 0 l 4 758 l 221 758 l 353 326 q 386 171 378 251 l 390 171 q 400 208 394 189 q 518 505 406 226 l 424 758 l 640 758 l 777 338 q 788 301 781 322 q 801 259 795 280 q 814 217 808 237 q 823 183 820 197 l 829 183 q 934 419 901 286 q 966 758 966 553 l 1175 758 q 1108 332 1175 506 q 889 0 1040 158 l 696 0 l 606 261 l 503 0 l 282 0 m 876 979 l 876 920 l 821 803 l 783 803 l 750 872 l 646 872 l 612 803 l 575 803 l 542 872 l 437 872 l 404 803 l 367 803 l 313 920 l 313 979 l 876 979 z \"},\"Ҁ\":{\"ha\":940,\"x_min\":81,\"x_max\":892,\"o\":\"m 582 -14 q 210 118 338 -14 q 81 494 81 249 q 141 765 81 648 q 314 943 201 881 q 581 1006 427 1006 q 892 936 733 1006 l 823 765 q 699 811 762 791 q 575 831 636 831 q 370 742 443 831 q 297 493 297 653 q 578 161 297 161 q 678 168 617 161 q 791 186 739 174 l 791 -334 l 582 -334 l 582 -14 z \"},\"ҁ\":{\"ha\":728,\"x_min\":62,\"x_max\":684,\"o\":\"m 408 -11 q 150 99 237 2 q 62 375 62 197 q 154 675 62 577 q 441 772 245 772 q 684 718 566 772 l 624 561 q 436 606 507 606 q 312 548 351 606 q 273 376 273 491 q 317 212 273 271 q 441 154 361 154 q 615 179 526 154 l 615 -334 l 408 -334 l 408 -11 z \"},\"҂\":{\"ha\":846,\"x_min\":71,\"x_max\":777,\"o\":\"m 399 293 l 591 180 l 543 97 l 350 208 l 228 -4 l 140 46 l 262 260 l 71 371 l 118 454 l 313 343 l 447 578 l 254 689 l 302 774 l 496 663 l 619 875 l 705 825 l 582 611 l 777 500 l 726 416 l 534 528 l 399 293 z \"},\"҃\":{\"ha\":774,\"x_min\":122,\"x_max\":654,\"o\":\"m 268 842 q 245 795 264 812 q 195 778 227 778 q 139 802 157 778 q 122 864 122 826 q 196 943 122 943 l 507 943 q 581 1007 514 1007 q 654 929 654 1007 q 636 866 654 890 q 579 842 618 842 l 268 842 z \"},\"҄\":{\"ha\":802,\"x_min\":165,\"x_max\":703,\"o\":\"m 175 974 q 273 986 228 974 q 358 1014 318 999 q 437 1042 399 1029 q 514 1055 475 1055 q 623 1037 585 1055 q 681 979 660 1019 q 703 873 703 939 l 703 840 l 579 840 q 557 898 572 880 q 511 916 543 916 q 466 907 491 916 q 391 879 441 899 q 176 842 300 842 l 165 842 l 165 974 l 175 974 z \"},\"҅\":{\"ha\":802,\"x_min\":313,\"x_max\":524,\"o\":\"m 422 1101 q 497 1082 471 1101 q 524 1026 524 1062 q 511 999 524 1008 q 483 984 498 990 q 455 973 468 979 q 443 954 443 967 q 466 913 443 932 q 522 885 489 893 l 522 827 q 375 877 437 831 q 313 989 313 924 q 341 1071 313 1041 q 422 1101 370 1101 z \"},\"҆\":{\"ha\":802,\"x_min\":311,\"x_max\":522,\"o\":\"m 522 989 q 460 878 522 925 q 313 827 399 831 l 313 885 q 369 912 345 892 q 392 954 392 932 q 379 973 392 967 q 352 984 367 979 q 324 999 336 990 q 311 1026 311 1008 q 338 1082 311 1062 q 412 1101 364 1101 q 494 1071 465 1101 q 522 989 522 1041 z \"},\"҈\":{\"ha\":1373,\"x_min\":28,\"x_max\":1346,\"o\":\"m 679 966 q 780 932 742 966 q 823 835 819 898 l 770 835 q 746 880 766 865 q 679 895 726 895 q 609 881 626 895 q 589 835 592 867 l 538 835 q 679 966 545 966 m 679 -85 q 780 -119 741 -85 q 823 -216 819 -154 l 770 -216 q 746 -172 766 -186 q 679 -157 726 -157 q 609 -171 626 -157 q 589 -216 592 -184 l 538 -216 q 575 -120 541 -156 q 679 -85 609 -85 m 1072 104 q 1174 70 1135 104 q 1217 -28 1213 35 l 1162 -28 q 1139 17 1159 3 q 1072 32 1118 32 q 1002 19 1019 32 q 982 -28 985 5 l 930 -28 q 968 69 934 33 q 1072 104 1002 104 m 290 104 q 392 70 353 104 q 435 -28 431 35 l 380 -28 q 357 17 377 3 q 290 32 336 32 q 220 19 237 32 q 200 -28 203 5 l 149 -28 q 186 69 152 33 q 290 104 220 104 m 1072 774 q 1174 739 1135 774 q 1217 642 1213 705 l 1162 642 q 1139 687 1159 672 q 1072 701 1118 701 q 1002 688 1019 701 q 982 642 985 675 l 930 642 q 968 738 934 703 q 1072 774 1002 774 m 290 774 q 392 739 353 774 q 435 642 431 705 l 380 642 q 357 687 377 672 q 290 701 336 701 q 220 688 237 701 q 200 642 203 675 l 149 642 q 186 738 152 703 q 290 774 220 774 m 1202 443 q 1303 408 1264 443 q 1346 311 1342 372 l 1292 311 q 1268 356 1289 341 q 1202 371 1248 371 q 1132 357 1149 371 q 1111 311 1114 344 l 1060 311 q 1202 443 1067 443 m 170 443 q 271 408 232 443 q 314 311 310 374 l 260 311 q 236 356 256 342 q 170 371 216 371 q 100 358 117 371 q 79 311 83 345 l 28 311 q 65 408 31 372 q 170 443 100 443 z \"},\"҉\":{\"ha\":1328,\"x_min\":28,\"x_max\":1300,\"o\":\"m 739 -33 q 704 -143 728 -78 q 656 -261 680 -208 l 590 -261 q 637 -24 626 -111 l 732 -24 l 739 -33 m 590 783 q 628 899 603 831 q 673 1011 652 967 l 739 1011 q 692 774 704 862 l 597 774 l 590 783 m 1072 449 q 1188 411 1120 436 q 1300 366 1256 387 l 1300 300 q 1063 347 1150 336 l 1063 441 l 1072 449 m 256 300 q 146 335 211 311 q 28 383 81 359 l 28 449 q 265 401 178 413 l 265 307 l 256 300 m 1120 804 l 1166 758 q 965 624 1046 684 l 899 690 l 900 701 q 1010 758 945 728 q 1120 804 1074 787 m 208 -83 l 161 -37 q 363 97 281 37 l 429 31 l 428 20 q 208 -83 323 -41 m 220 815 l 265 863 q 400 661 349 728 l 334 595 l 322 596 q 220 815 267 691 m 1107 -96 l 1061 -143 q 996 -43 1040 -109 q 926 58 952 23 l 993 125 l 1004 123 q 1061 11 1031 77 q 1107 -96 1092 -55 z \"},\"Ҋ\":{\"ha\":1272,\"x_min\":125,\"x_max\":1244,\"o\":\"m 125 991 l 314 991 l 314 513 l 311 385 l 304 239 l 309 239 l 766 991 l 1018 991 l 1018 180 l 1244 180 l 1124 -289 l 890 -289 l 1018 0 l 831 0 l 831 476 q 843 760 831 572 l 838 760 l 378 0 l 125 0 l 125 991 m 900 1314 q 804 1129 887 1187 q 566 1071 722 1071 q 328 1126 405 1071 q 241 1314 251 1182 l 427 1314 q 461 1216 431 1244 q 570 1187 492 1187 q 671 1218 637 1187 q 713 1314 705 1249 l 900 1314 m 1143 0 z \"},\"ҋ\":{\"ha\":1114,\"x_min\":109,\"x_max\":1095,\"o\":\"m 309 758 l 309 458 q 293 227 309 411 l 643 758 l 892 758 l 892 151 l 1095 151 l 996 -272 l 799 -272 l 892 0 l 692 0 l 692 302 q 705 530 692 383 l 357 0 l 109 0 l 109 758 l 309 758 m 831 1084 q 734 899 817 956 q 496 842 652 842 q 318 867 387 842 q 214 943 249 892 q 172 1084 179 994 l 357 1084 q 393 985 363 1011 q 500 958 423 958 q 604 990 570 958 q 643 1084 637 1023 l 831 1084 m 1000 0 z \"},\"Ҍ\":{\"ha\":856,\"x_min\":32,\"x_max\":823,\"o\":\"m 335 889 l 538 889 l 538 717 l 335 717 l 335 611 l 418 611 q 718 532 612 611 q 823 310 823 454 q 414 0 823 0 l 125 0 l 125 717 l 32 717 l 32 889 l 125 889 l 125 991 l 335 991 l 335 889 m 335 172 l 406 172 q 562 207 512 172 q 611 310 611 241 q 561 409 611 378 q 389 439 511 439 l 335 439 l 335 172 z \"},\"ҍ\":{\"ha\":852,\"x_min\":3,\"x_max\":804,\"o\":\"m 3 904 l 109 904 l 109 1055 l 315 1055 l 315 904 l 571 904 l 571 770 l 315 770 l 315 465 l 461 465 q 720 410 636 465 q 804 241 804 354 q 469 0 804 0 l 109 0 l 109 770 l 3 770 l 3 904 m 597 239 q 562 302 597 283 q 457 322 527 322 l 315 322 l 315 143 l 460 143 q 597 239 597 143 z \"},\"Ҏ\":{\"ha\":872,\"x_min\":125,\"x_max\":810,\"o\":\"m 810 682 q 778 527 810 595 q 682 416 745 458 l 742 332 l 639 256 l 561 367 q 425 353 503 353 l 335 353 l 335 0 l 125 0 l 125 991 l 441 991 q 716 914 622 991 q 810 682 810 836 m 335 525 l 433 525 l 449 526 l 410 582 l 514 657 l 570 578 q 597 675 597 614 q 557 784 597 749 q 431 819 517 819 l 335 819 l 335 525 z \"},\"ҏ\":{\"ha\":879,\"x_min\":109,\"x_max\":817,\"o\":\"m 525 -14 q 315 83 391 -14 l 304 83 q 315 -26 315 -12 l 315 -334 l 109 -334 l 109 758 l 277 758 l 306 660 l 317 660 q 408 744 353 716 q 530 772 463 772 q 741 669 665 772 q 817 380 817 565 q 718 66 817 175 l 782 -17 l 675 -97 l 602 -3 q 525 -14 566 -14 m 464 607 q 352 560 387 607 q 315 404 317 513 l 315 382 q 352 207 315 260 q 467 154 388 154 l 478 154 l 490 155 l 421 241 l 534 325 l 590 257 q 606 383 606 310 q 571 551 606 495 q 464 607 537 607 z \"},\"Ғ\":{\"ha\":777,\"x_min\":32,\"x_max\":749,\"o\":\"m 749 991 l 749 819 l 335 819 l 335 576 l 607 576 l 607 404 l 335 404 l 335 0 l 125 0 l 125 404 l 32 404 l 32 576 l 125 576 l 125 991 l 749 991 z \"},\"ғ\":{\"ha\":682,\"x_min\":3,\"x_max\":650,\"o\":\"m 650 758 l 650 590 l 302 590 l 302 443 l 528 443 l 528 283 l 302 283 l 302 0 l 96 0 l 96 283 l 3 283 l 3 443 l 96 443 l 96 758 l 650 758 z \"},\"Ҕ\":{\"ha\":1019,\"x_min\":125,\"x_max\":950,\"o\":\"m 421 364 q 335 355 385 364 l 335 0 l 125 0 l 125 991 l 749 991 l 749 819 l 335 819 l 335 547 q 509 555 408 555 q 743 498 640 555 q 898 337 846 440 q 950 96 950 235 q 903 -137 950 -37 q 771 -293 856 -238 q 582 -347 686 -347 q 460 -340 507 -347 q 363 -315 413 -332 l 363 -131 q 541 -163 450 -163 q 690 -93 635 -163 q 745 96 745 -24 q 667 296 745 229 q 421 364 589 364 z \"},\"ҕ\":{\"ha\":836,\"x_min\":109,\"x_max\":787,\"o\":\"m 787 46 q 746 -163 787 -75 q 629 -295 705 -250 q 453 -340 553 -340 q 279 -306 357 -340 l 279 -127 q 351 -154 310 -144 q 425 -164 392 -164 q 546 -109 504 -164 q 589 49 589 -54 q 375 256 589 256 q 315 252 347 256 l 315 0 l 109 0 l 109 758 l 663 758 l 663 590 l 315 590 l 315 427 q 416 435 366 435 q 609 387 524 435 q 741 252 694 340 q 787 46 787 163 z \"},\"Җ\":{\"ha\":1429,\"x_min\":0,\"x_max\":1401,\"o\":\"m 353 515 l 20 991 l 236 991 l 557 511 l 557 991 l 753 991 l 753 511 l 1074 991 l 1291 991 l 957 515 l 1186 180 l 1401 180 l 1401 -289 l 1198 -289 l 1198 0 l 1084 0 l 753 503 l 753 0 l 557 0 l 557 503 l 225 0 l 0 0 l 353 515 m 1310 0 z \"},\"җ\":{\"ha\":1308,\"x_min\":0,\"x_max\":1275,\"o\":\"m 510 390 l 510 758 l 703 758 l 703 390 l 972 758 l 1186 758 l 907 395 l 1095 151 l 1275 151 l 1275 -272 l 1089 -272 l 1089 0 l 991 0 l 703 385 l 703 0 l 510 0 l 510 385 l 221 0 l 0 0 l 306 395 l 26 758 l 240 758 l 510 390 m 1213 0 z \"},\"Ҙ\":{\"ha\":900,\"x_min\":64,\"x_max\":840,\"o\":\"m 810 760 q 742 602 810 664 q 558 522 674 539 l 558 518 q 767 443 694 505 q 840 282 840 381 q 729 66 840 145 q 422 -14 618 -14 q 72 40 204 -14 l 72 216 q 221 169 136 186 q 382 151 307 151 q 632 297 632 151 q 552 398 632 363 q 314 433 471 433 l 221 433 l 221 597 l 304 597 q 534 627 462 597 q 606 726 606 657 q 561 807 606 777 q 425 838 515 838 q 155 757 286 838 l 64 897 q 243 980 149 954 q 454 1006 338 1006 q 713 938 616 1006 q 810 760 810 870 m 420 -154 q 393 -82 420 -119 q 319 0 367 -45 l 441 0 q 517 -66 494 -41 q 551 -119 539 -92 q 563 -178 563 -146 q 516 -291 563 -248 q 393 -334 469 -334 q 288 -318 343 -334 l 288 -197 q 366 -210 328 -210 q 405 -196 389 -210 q 420 -154 420 -182 z \"},\"ҙ\":{\"ha\":771,\"x_min\":53,\"x_max\":718,\"o\":\"m 297 467 q 464 486 414 467 q 513 546 513 505 q 477 601 513 583 q 358 619 441 619 q 240 606 306 619 q 119 571 174 593 l 58 715 q 215 759 139 746 q 385 772 291 772 q 612 718 526 772 q 697 571 697 664 q 546 404 697 443 l 546 397 q 679 332 639 374 q 718 221 718 290 q 673 98 718 152 q 544 16 629 45 q 345 -14 459 -14 q 53 33 155 -14 l 53 204 q 181 161 111 177 q 315 146 250 146 q 467 169 416 146 q 517 233 517 191 q 464 301 517 279 q 301 323 411 323 l 221 323 l 221 467 l 297 467 m 346 -154 q 319 -82 346 -119 q 245 0 293 -45 l 367 0 q 443 -66 420 -41 q 477 -119 465 -92 q 489 -178 489 -146 q 442 -291 489 -248 q 319 -334 395 -334 q 214 -318 269 -334 l 214 -197 q 292 -210 254 -210 q 331 -196 315 -210 q 346 -154 346 -182 z \"},\"Қ\":{\"ha\":1050,\"x_min\":125,\"x_max\":1022,\"o\":\"m 800 180 l 1022 180 l 1022 -289 l 819 -289 l 819 0 l 694 0 l 335 503 l 335 0 l 125 0 l 125 991 l 335 991 l 335 511 l 690 991 l 914 991 l 553 515 l 800 180 m 933 0 z \"},\"қ\":{\"ha\":924,\"x_min\":109,\"x_max\":904,\"o\":\"m 606 758 l 833 758 l 533 395 l 734 151 l 904 151 l 904 -272 l 718 -272 l 718 0 l 625 0 l 315 385 l 315 0 l 109 0 l 109 758 l 315 758 l 315 390 l 606 758 m 860 0 z \"},\"Ҝ\":{\"ha\":922,\"x_min\":125,\"x_max\":922,\"o\":\"m 419 415 l 335 354 l 335 0 l 125 0 l 125 991 l 335 991 l 335 538 l 418 654 l 419 656 l 419 896 l 510 896 l 510 770 l 686 991 l 920 991 l 574 553 l 922 0 l 684 0 l 510 279 l 510 129 l 419 129 l 419 415 z \"},\"ҝ\":{\"ha\":832,\"x_min\":109,\"x_max\":832,\"o\":\"m 109 758 l 301 758 l 301 390 l 368 473 l 368 688 l 467 688 l 467 600 l 591 758 l 806 758 l 505 395 l 832 0 l 611 0 l 465 180 l 465 61 l 367 61 l 367 302 l 301 385 l 301 0 l 109 0 l 109 758 z \"},\"Ҟ\":{\"ha\":893,\"x_min\":3,\"x_max\":893,\"o\":\"m 3 900 l 96 900 l 96 991 l 306 991 l 306 900 l 399 900 l 399 728 l 306 728 l 306 538 l 389 654 l 657 991 l 890 991 l 545 553 l 893 0 l 654 0 l 395 418 l 306 354 l 306 0 l 96 0 l 96 728 l 3 728 l 3 900 z \"},\"ҟ\":{\"ha\":861,\"x_min\":3,\"x_max\":861,\"o\":\"m 3 946 l 109 946 l 109 1055 l 315 1055 l 315 946 l 529 946 l 529 811 l 315 811 l 315 585 l 304 412 l 307 412 l 397 528 l 610 758 l 843 758 l 542 429 l 861 0 l 623 0 l 404 307 l 315 236 l 315 0 l 109 0 l 109 811 l 3 811 l 3 946 z \"},\"Ҡ\":{\"ha\":1018,\"x_min\":0,\"x_max\":1018,\"o\":\"m 0 991 l 431 991 l 431 538 l 514 654 l 782 991 l 1015 991 l 669 553 l 1018 0 l 779 0 l 519 418 l 431 354 l 431 0 l 221 0 l 221 817 l 0 817 l 0 991 m 96 0 z \"},\"ҡ\":{\"ha\":965,\"x_min\":0,\"x_max\":965,\"o\":\"m 0 758 l 435 758 l 435 390 l 725 758 l 939 758 l 639 395 l 965 0 l 745 0 l 435 385 l 435 0 l 241 0 l 241 603 l 0 603 l 0 758 m 133 0 z \"},\"Ң\":{\"ha\":1168,\"x_min\":125,\"x_max\":1140,\"o\":\"m 937 180 l 1140 180 l 1140 -289 l 937 -289 l 937 0 l 728 0 l 728 428 l 335 428 l 335 0 l 125 0 l 125 991 l 335 991 l 335 603 l 728 603 l 728 991 l 937 991 l 937 180 m 1063 0 z \"},\"ң\":{\"ha\":1032,\"x_min\":109,\"x_max\":999,\"o\":\"m 315 758 l 315 467 l 604 467 l 604 758 l 811 758 l 811 151 l 999 151 l 999 -272 l 812 -272 l 812 0 l 604 0 l 604 313 l 315 313 l 315 0 l 109 0 l 109 758 l 315 758 m 920 0 z \"},\"Ҥ\":{\"ha\":1158,\"x_min\":125,\"x_max\":1158,\"o\":\"m 1158 817 l 937 817 l 937 0 l 728 0 l 728 428 l 335 428 l 335 0 l 125 0 l 125 991 l 335 991 l 335 603 l 728 603 l 728 991 l 1158 991 l 1158 817 m 1063 0 z \"},\"ҥ\":{\"ha\":1053,\"x_min\":109,\"x_max\":1053,\"o\":\"m 315 758 l 315 467 l 604 467 l 604 758 l 1053 758 l 1053 603 l 811 603 l 811 0 l 604 0 l 604 313 l 315 313 l 315 0 l 109 0 l 109 758 l 315 758 m 920 0 z \"},\"Ҧ\":{\"ha\":1563,\"x_min\":125,\"x_max\":1493,\"o\":\"m 882 545 q 1072 555 960 555 q 1296 497 1198 555 q 1444 337 1394 439 q 1493 96 1493 235 q 1446 -137 1493 -37 q 1314 -293 1399 -238 q 1125 -347 1229 -347 q 1005 -340 1051 -347 q 905 -315 960 -334 l 905 -131 q 1083 -163 993 -163 q 1230 -91 1172 -163 q 1287 96 1287 -18 q 1215 296 1287 229 q 987 364 1143 364 q 882 350 948 364 l 882 0 l 672 0 l 672 817 l 335 817 l 335 0 l 125 0 l 125 991 l 882 991 l 882 545 z \"},\"ҧ\":{\"ha\":1235,\"x_min\":109,\"x_max\":1186,\"o\":\"m 1186 46 q 1145 -162 1186 -75 q 1028 -295 1104 -249 q 851 -340 952 -340 q 677 -306 755 -340 l 677 -127 q 749 -154 708 -144 q 823 -164 790 -164 q 944 -109 901 -164 q 987 49 987 -54 q 935 203 987 150 q 781 256 882 256 l 777 256 l 777 0 l 570 0 l 570 603 l 315 603 l 315 0 l 109 0 l 109 758 l 777 758 l 777 432 l 831 435 q 1015 387 933 435 q 1141 251 1097 339 q 1186 46 1186 163 z \"},\"Ҩ\":{\"ha\":1079,\"x_min\":81,\"x_max\":1038,\"o\":\"m 1007 460 q 974 279 1007 363 q 864 119 941 195 q 940 109 895 109 q 1038 123 991 109 l 1038 -40 q 917 -57 996 -57 q 701 9 800 -57 q 532 -14 631 -14 q 201 119 321 -14 q 81 484 81 251 q 191 874 81 742 q 517 1007 301 1007 q 604 999 555 1007 q 685 978 654 990 l 632 815 q 517 835 570 835 q 293 490 293 835 q 361 249 293 334 q 549 164 429 164 q 570 167 566 164 q 501 301 527 218 q 475 468 475 383 q 542 693 475 616 q 739 770 610 770 q 937 688 866 770 q 1007 460 1007 606 m 819 454 q 743 612 819 612 q 685 571 706 612 q 664 457 664 529 q 683 315 664 374 q 728 222 702 256 q 794 323 769 260 q 819 454 819 386 z \"},\"ҩ\":{\"ha\":911,\"x_min\":62,\"x_max\":864,\"o\":\"m 844 345 q 815 201 844 264 q 733 103 786 138 q 781 98 752 98 q 864 110 821 98 l 864 -33 q 758 -49 815 -49 q 572 9 659 -49 q 415 -14 506 -14 q 158 92 254 -14 q 62 376 62 197 q 155 668 62 564 q 416 772 248 772 q 486 765 445 772 q 559 745 527 758 l 514 590 q 416 607 454 607 q 306 551 341 607 q 271 370 271 494 q 308 210 271 267 q 419 153 346 153 q 444 155 436 153 q 406 253 416 209 q 396 349 396 296 q 452 522 396 462 q 621 582 509 582 q 784 519 724 582 q 844 345 844 456 m 681 345 q 666 408 681 383 q 621 432 651 432 q 559 343 559 432 q 611 199 559 258 q 681 345 681 242 z \"},\"Ҫ\":{\"ha\":885,\"x_min\":81,\"x_max\":836,\"o\":\"m 546 831 q 362 742 427 831 q 297 493 297 652 q 546 161 297 161 q 799 214 650 161 l 799 37 q 526 -14 677 -14 q 195 118 310 -14 q 81 494 81 249 q 137 765 81 649 q 299 944 193 882 q 546 1006 404 1006 q 836 936 690 1006 l 768 765 q 656 811 713 791 q 546 831 600 831 m 525 -154 q 498 -82 525 -119 q 425 0 472 -45 l 546 0 q 622 -66 600 -41 q 656 -119 644 -92 q 668 -178 668 -146 q 621 -291 668 -248 q 498 -334 574 -334 q 393 -318 448 -334 l 393 -197 q 471 -210 433 -210 q 510 -196 494 -210 q 525 -154 525 -182 z \"},\"ҫ\":{\"ha\":714,\"x_min\":62,\"x_max\":671,\"o\":\"m 416 -14 q 62 375 62 -14 q 159 670 62 568 q 435 772 255 772 q 671 721 566 772 l 610 561 q 519 593 561 581 q 435 606 477 606 q 273 376 273 606 q 435 154 273 154 q 545 170 494 154 q 647 220 596 186 l 647 43 q 546 -1 597 11 q 416 -14 494 -14 m 421 -154 q 395 -82 421 -119 q 321 0 368 -45 l 442 0 q 518 -66 496 -41 q 552 -119 541 -92 q 564 -178 564 -146 q 517 -291 564 -248 q 395 -334 471 -334 q 289 -318 345 -334 l 289 -197 q 367 -210 330 -210 q 406 -196 391 -210 q 421 -154 421 -182 z \"},\"Ҭ\":{\"ha\":804,\"x_min\":28,\"x_max\":777,\"o\":\"m 507 180 l 710 180 l 710 -289 l 507 -289 l 507 0 l 297 0 l 297 817 l 28 817 l 28 991 l 777 991 l 777 817 l 507 817 l 507 180 z \"},\"ҭ\":{\"ha\":764,\"x_min\":32,\"x_max\":736,\"o\":\"m 736 758 l 736 603 l 488 603 l 488 151 l 673 151 l 673 -272 l 488 -272 l 488 0 l 281 0 l 281 603 l 32 603 l 32 758 l 736 758 z \"},\"Ү\":{\"ha\":867,\"x_min\":0,\"x_max\":867,\"o\":\"m 433 583 l 640 991 l 867 991 l 538 386 l 538 0 l 329 0 l 329 379 l 0 991 l 228 991 l 433 583 z \"},\"ү\":{\"ha\":798,\"x_min\":0,\"x_max\":798,\"o\":\"m 503 -334 l 294 -334 l 294 0 l 0 758 l 228 758 l 347 416 q 386 270 365 367 l 395 229 l 403 229 q 450 416 427 351 l 571 758 l 798 758 l 503 0 l 503 -334 z \"},\"Ұ\":{\"ha\":867,\"x_min\":0,\"x_max\":867,\"o\":\"m 433 583 l 640 991 l 867 991 l 538 386 l 538 358 l 754 358 l 754 183 l 538 183 l 538 0 l 329 0 l 329 183 l 113 183 l 113 358 l 329 358 l 329 379 l 0 991 l 228 991 l 433 583 z \"},\"ұ\":{\"ha\":798,\"x_min\":0,\"x_max\":798,\"o\":\"m 700 0 l 700 -155 l 503 -155 l 503 -334 l 294 -334 l 294 -155 l 97 -155 l 97 0 l 294 0 l 0 758 l 228 758 l 347 416 q 386 270 365 367 l 395 229 l 403 229 q 450 416 427 351 l 571 758 l 798 758 l 503 0 l 700 0 z \"},\"Ҳ\":{\"ha\":1032,\"x_min\":0,\"x_max\":1004,\"o\":\"m 806 180 l 1004 180 l 1004 -289 l 802 -289 l 802 0 l 686 0 l 456 375 l 225 0 l 0 0 l 329 511 l 21 991 l 253 991 l 467 635 l 676 991 l 903 991 l 591 500 l 806 180 m 926 0 z \"},\"ҳ\":{\"ha\":889,\"x_min\":7,\"x_max\":869,\"o\":\"m 264 387 l 20 758 l 254 758 l 401 517 l 550 758 l 785 758 l 538 387 l 694 151 l 869 151 l 869 -272 l 684 -272 l 684 0 l 561 0 l 401 260 l 241 0 l 7 0 l 264 387 m 796 0 m 803 0 z \"},\"Ҵ\":{\"ha\":1292,\"x_min\":28,\"x_max\":1264,\"o\":\"m 277 0 l 277 817 l 28 817 l 28 991 l 762 991 l 762 817 l 486 817 l 486 175 l 851 175 l 851 991 l 1061 991 l 1061 180 l 1264 180 l 1264 -289 l 1061 -289 l 1061 0 l 277 0 z \"},\"ҵ\":{\"ha\":1099,\"x_min\":32,\"x_max\":1079,\"o\":\"m 611 758 l 611 603 l 411 603 l 411 155 l 686 155 l 686 758 l 893 758 l 893 151 l 1079 151 l 1079 -272 l 893 -272 l 893 0 l 204 0 l 204 603 l 32 603 l 32 758 l 611 758 z \"},\"Ҷ\":{\"ha\":1117,\"x_min\":74,\"x_max\":1089,\"o\":\"m 886 180 l 1089 180 l 1089 -289 l 886 -289 l 886 0 l 676 0 l 676 383 q 502 335 572 348 q 370 322 433 322 q 151 390 228 322 q 74 582 74 458 l 74 991 l 283 991 l 283 642 q 317 533 283 570 q 429 497 350 497 q 540 508 485 497 q 676 547 595 519 l 676 991 l 886 991 l 886 180 m 1011 0 z \"},\"ҷ\":{\"ha\":1008,\"x_min\":83,\"x_max\":989,\"o\":\"m 290 758 l 290 481 q 382 382 290 382 q 493 395 441 382 q 596 431 544 409 l 596 758 l 803 758 l 803 151 l 989 151 l 989 -272 l 803 -272 l 803 0 l 596 0 l 596 301 q 463 248 524 263 q 343 232 401 232 q 151 295 219 232 q 83 476 83 359 l 83 758 l 290 758 m 911 0 z \"},\"Ҹ\":{\"ha\":1011,\"x_min\":74,\"x_max\":886,\"o\":\"m 424 323 l 397 322 l 370 322 q 151 390 228 322 q 74 582 74 458 l 74 991 l 283 991 l 283 642 q 317 533 283 567 q 424 497 350 498 l 424 720 l 514 720 l 514 504 q 676 547 574 513 l 676 991 l 886 991 l 886 0 l 676 0 l 676 383 q 514 336 589 353 l 514 117 l 424 117 l 424 323 z \"},\"ҹ\":{\"ha\":911,\"x_min\":83,\"x_max\":803,\"o\":\"m 395 235 q 343 232 378 232 q 151 295 219 232 q 83 476 83 359 l 83 758 l 290 758 l 290 481 q 382 382 290 382 l 395 382 l 395 555 l 479 555 l 479 392 q 596 431 532 403 l 596 758 l 803 758 l 803 0 l 596 0 l 596 301 q 479 252 525 264 l 479 87 l 395 87 l 395 235 z \"},\"Һ\":{\"ha\":1011,\"x_min\":125,\"x_max\":937,\"o\":\"m 125 991 l 335 991 l 335 608 q 507 656 435 643 q 642 669 580 669 q 859 602 781 669 q 937 410 937 534 l 937 0 l 728 0 l 728 350 q 694 458 728 422 q 582 494 661 494 q 472 484 528 494 q 335 444 415 473 l 335 0 l 125 0 l 125 991 z \"},\"һ\":{\"ha\":925,\"x_min\":109,\"x_max\":828,\"o\":\"m 621 0 l 621 285 q 529 376 621 376 q 315 328 431 376 l 315 0 l 109 0 l 109 758 l 315 758 l 315 457 q 448 511 387 495 q 568 526 509 526 q 760 463 692 526 q 828 282 828 399 l 828 0 l 621 0 z \"},\"Ҽ\":{\"ha\":1317,\"x_min\":0,\"x_max\":1206,\"o\":\"m 761 161 q 967 193 854 161 q 1154 271 1080 224 l 1154 82 q 973 9 1069 31 q 760 -14 876 -14 q 414 102 544 -14 q 265 428 285 218 l 222 428 q 56 475 112 428 q 0 604 0 522 q 36 743 0 683 l 195 743 q 183 707 189 732 q 176 663 176 683 q 241 603 176 603 l 269 603 q 415 901 294 795 q 734 1007 536 1007 q 1088 873 970 1007 q 1206 476 1206 739 l 1206 428 l 482 428 q 562 229 491 297 q 761 161 633 161 m 734 832 q 560 771 627 832 q 485 603 493 711 l 987 603 q 926 777 987 722 q 734 832 864 832 z \"},\"ҽ\":{\"ha\":993,\"x_min\":0,\"x_max\":933,\"o\":\"m 227 465 q 343 693 249 614 q 586 772 437 772 q 842 681 750 772 q 933 428 933 590 l 933 328 l 429 328 q 483 190 433 239 q 625 140 534 140 q 761 155 697 140 q 890 200 824 170 l 890 40 q 773 0 838 14 q 618 -14 709 -14 q 339 75 442 -14 q 222 328 235 163 q 0 479 0 328 q 28 591 0 545 l 167 591 q 150 518 150 554 q 215 465 150 465 l 227 465 m 587 625 q 481 586 524 625 q 433 465 439 547 l 739 465 q 697 583 738 541 q 587 625 657 625 z \"},\"Ҿ\":{\"ha\":1317,\"x_min\":0,\"x_max\":1206,\"o\":\"m 648 -5 q 382 133 481 22 q 265 428 283 245 l 222 428 q 56 475 112 428 q 0 604 0 522 q 36 743 0 683 l 195 743 q 183 707 189 732 q 176 663 176 683 q 241 603 176 603 l 269 603 q 415 901 294 795 q 734 1007 536 1007 q 1088 873 970 1007 q 1206 476 1206 739 l 1206 428 l 482 428 q 562 229 491 297 q 761 161 633 161 q 967 193 854 161 q 1154 271 1080 224 l 1154 82 q 1008 18 1080 39 q 850 -9 935 -3 l 850 -289 l 648 -289 l 648 -5 m 734 832 q 560 771 627 832 q 485 603 493 711 l 987 603 q 926 777 987 722 q 734 832 864 832 z \"},\"ҿ\":{\"ha\":993,\"x_min\":0,\"x_max\":933,\"o\":\"m 497 -1 q 303 110 374 26 q 222 328 233 194 q 0 479 0 328 q 28 591 0 545 l 167 591 q 150 518 150 554 q 215 465 150 465 l 227 465 q 343 693 249 614 q 586 772 437 772 q 842 681 750 772 q 933 428 933 590 l 933 328 l 429 328 q 483 190 433 239 q 625 140 534 140 q 761 155 697 140 q 890 200 824 170 l 890 40 q 684 -11 804 -3 l 684 -272 l 497 -272 l 497 -1 m 587 625 q 481 586 524 625 q 433 465 439 547 l 739 465 q 697 583 738 541 q 587 625 657 625 z \"},\"Ӂ\":{\"ha\":1310,\"x_min\":0,\"x_max\":1310,\"o\":\"m 353 515 l 20 991 l 236 991 l 557 511 l 557 991 l 753 991 l 753 511 l 1074 991 l 1291 991 l 957 515 l 1310 0 l 1084 0 l 753 503 l 753 0 l 557 0 l 557 503 l 225 0 l 0 0 l 353 515 m 982 1314 q 886 1129 969 1187 q 648 1071 804 1071 q 410 1126 487 1071 q 323 1314 333 1182 l 509 1314 q 544 1216 513 1244 q 652 1187 574 1187 q 754 1218 720 1187 q 795 1314 787 1249 l 982 1314 z \"},\"ӂ\":{\"ha\":1213,\"x_min\":0,\"x_max\":1213,\"o\":\"m 510 390 l 510 758 l 703 758 l 703 390 l 972 758 l 1186 758 l 907 395 l 1213 0 l 991 0 l 703 385 l 703 0 l 510 0 l 510 385 l 221 0 l 0 0 l 306 395 l 26 758 l 240 758 l 510 390 m 935 1084 q 839 900 922 958 q 600 842 756 842 q 362 897 439 842 q 276 1084 286 953 l 461 1084 q 496 986 466 1015 q 604 958 526 958 q 706 989 673 958 q 747 1084 740 1020 l 935 1084 z \"},\"Ӄ\":{\"ha\":1055,\"x_min\":125,\"x_max\":986,\"o\":\"m 461 364 q 335 347 410 364 l 335 0 l 125 0 l 125 991 l 335 991 l 335 514 l 433 654 l 700 991 l 933 991 l 542 525 l 545 525 q 783 472 680 525 q 936 323 886 419 q 986 96 986 227 q 939 -137 986 -37 q 807 -293 892 -238 q 618 -347 722 -347 q 496 -340 543 -347 q 399 -315 449 -332 l 399 -131 q 576 -163 486 -163 q 727 -93 673 -163 q 781 96 781 -24 q 704 296 781 228 q 461 364 627 364 z \"},\"ӄ\":{\"ha\":918,\"x_min\":109,\"x_max\":863,\"o\":\"m 863 46 q 822 -162 863 -75 q 705 -295 781 -249 q 528 -340 629 -340 q 354 -306 431 -340 l 354 -127 q 426 -154 385 -144 q 500 -164 467 -164 q 621 -108 578 -164 q 664 49 664 -52 q 610 202 664 149 q 453 256 557 256 q 378 249 419 256 q 315 233 336 241 l 315 0 l 109 0 l 109 758 l 315 758 l 315 424 l 610 758 l 843 758 l 522 419 q 770 320 677 419 q 863 46 863 220 z \"},\"Ӆ\":{\"ha\":1164,\"x_min\":11,\"x_max\":1136,\"o\":\"m 909 0 l 700 0 l 700 817 l 457 817 l 446 726 q 372 239 404 379 q 278 42 340 99 q 111 -14 216 -15 q 11 1 54 -14 l 11 174 q 85 160 50 160 q 142 193 121 160 q 181 315 163 226 q 231 607 200 404 q 283 991 262 810 l 909 991 l 909 180 l 1136 180 l 1015 -289 l 782 -289 l 909 0 m 1035 0 z \"},\"ӆ\":{\"ha\":1010,\"x_min\":0,\"x_max\":990,\"o\":\"m 787 151 l 990 151 l 892 -272 l 694 -272 l 787 0 l 581 0 l 581 603 l 390 603 q 337 223 368 349 q 254 42 306 98 q 118 -14 202 -14 q 0 8 46 -14 l 0 174 q 66 160 33 160 q 131 216 105 160 q 178 401 157 271 q 214 758 199 531 l 787 758 l 787 151 m 896 0 z \"},\"Ӈ\":{\"ha\":1063,\"x_min\":125,\"x_max\":937,\"o\":\"m 937 61 q 892 -153 937 -59 q 763 -297 846 -246 q 570 -347 679 -347 q 350 -315 440 -347 l 350 -131 q 446 -156 401 -149 q 546 -163 490 -163 q 680 -97 631 -163 q 728 85 728 -32 l 728 428 l 335 428 l 335 0 l 125 0 l 125 991 l 335 991 l 335 603 l 728 603 l 728 991 l 937 991 l 937 61 z \"},\"ӈ\":{\"ha\":920,\"x_min\":109,\"x_max\":811,\"o\":\"m 315 313 l 315 0 l 109 0 l 109 758 l 315 758 l 315 467 l 604 467 l 604 758 l 811 758 l 811 16 q 722 -246 811 -152 q 475 -340 632 -340 q 383 -332 423 -340 q 300 -302 343 -324 l 300 -125 q 453 -164 376 -164 q 564 -114 526 -164 q 604 32 602 -64 l 604 313 l 315 313 z \"},\"Ӊ\":{\"ha\":1192,\"x_min\":125,\"x_max\":1164,\"o\":\"m 937 180 l 1164 180 l 1043 -289 l 810 -289 l 937 0 l 728 0 l 728 428 l 335 428 l 335 0 l 125 0 l 125 991 l 335 991 l 335 603 l 728 603 l 728 991 l 937 991 l 937 180 m 1063 0 z \"},\"ӊ\":{\"ha\":1034,\"x_min\":109,\"x_max\":1014,\"o\":\"m 315 758 l 315 467 l 604 467 l 604 758 l 811 758 l 811 151 l 1014 151 l 916 -272 l 718 -272 l 811 0 l 604 0 l 604 313 l 315 313 l 315 0 l 109 0 l 109 758 l 315 758 m 920 0 z \"},\"Ӌ\":{\"ha\":1011,\"x_min\":74,\"x_max\":886,\"o\":\"m 886 0 l 711 0 l 711 -289 l 509 -289 l 509 180 l 676 180 l 676 383 q 502 335 572 348 q 370 322 433 322 q 151 390 228 322 q 74 582 74 458 l 74 991 l 283 991 l 283 642 q 317 533 283 570 q 429 497 350 497 q 540 508 485 497 q 676 547 595 519 l 676 991 l 886 991 l 886 0 z \"},\"ӌ\":{\"ha\":911,\"x_min\":83,\"x_max\":803,\"o\":\"m 290 758 l 290 481 q 382 382 290 382 q 493 395 441 382 q 596 431 544 409 l 596 758 l 803 758 l 803 0 l 627 0 l 627 -272 l 440 -272 l 440 151 l 596 151 l 596 301 q 463 248 524 263 q 343 232 401 232 q 151 295 219 232 q 83 476 83 359 l 83 758 l 290 758 z \"},\"Ӎ\":{\"ha\":1439,\"x_min\":125,\"x_max\":1411,\"o\":\"m 545 0 l 306 778 l 300 778 q 313 461 313 541 l 313 0 l 125 0 l 125 991 l 411 991 l 646 233 l 650 233 l 899 991 l 1185 991 l 1185 180 l 1411 180 l 1291 -289 l 1057 -289 l 1185 0 l 989 0 l 989 469 q 990 546 989 503 q 999 777 991 589 l 993 777 l 737 0 l 545 0 m 1310 0 z \"},\"ӎ\":{\"ha\":1286,\"x_min\":109,\"x_max\":1267,\"o\":\"m 1064 151 l 1267 151 l 1168 -272 l 971 -272 l 1064 0 l 871 0 l 871 597 l 860 555 q 794 339 823 412 l 660 0 l 513 0 l 376 342 q 314 551 347 416 l 301 597 l 301 0 l 109 0 l 109 758 l 393 758 l 524 435 q 561 315 544 382 q 585 199 578 247 q 620 345 607 300 q 647 427 632 389 q 782 758 662 464 l 1064 758 l 1064 151 m 1173 0 z \"},\"Ӑ\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 808 1314 q 713 1129 795 1187 q 474 1071 630 1071 q 236 1126 313 1071 q 150 1314 159 1182 l 335 1314 q 370 1216 340 1244 q 478 1187 400 1187 q 580 1218 547 1187 q 621 1314 614 1249 l 808 1314 z \"},\"ӑ\":{\"ha\":839,\"x_min\":58,\"x_max\":757,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 757 1084 q 661 900 744 958 q 422 842 578 842 q 185 897 262 842 q 98 1084 108 953 l 283 1084 q 318 986 288 1015 q 427 958 349 958 q 529 989 495 958 q 570 1084 562 1020 l 757 1084 z \"},\"Ӓ\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 248 1182 q 273 1250 248 1226 q 342 1274 298 1274 q 412 1249 387 1274 q 437 1182 437 1223 q 412 1117 437 1141 q 342 1092 386 1092 q 273 1116 298 1092 q 248 1182 248 1139 m 521 1182 q 548 1252 521 1230 q 616 1274 576 1274 q 687 1249 661 1274 q 713 1182 713 1225 q 686 1116 713 1141 q 616 1092 660 1092 q 548 1114 576 1092 q 521 1182 521 1136 z \"},\"ӓ\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 186 953 q 211 1021 186 997 q 280 1044 237 1044 q 350 1019 325 1044 q 376 953 376 994 q 350 887 376 912 q 280 863 324 863 q 211 886 237 863 q 186 953 186 910 m 459 953 q 487 1022 459 1000 q 555 1044 514 1044 q 625 1020 599 1044 q 651 953 651 996 q 625 887 651 911 q 555 863 598 863 q 487 885 514 863 q 459 953 459 907 z \"},\"Ӕ\":{\"ha\":1322,\"x_min\":0,\"x_max\":1240,\"o\":\"m 1240 0 l 648 0 l 648 236 l 315 236 l 214 0 l 0 0 l 444 991 l 1240 991 l 1240 819 l 859 819 l 859 602 l 1215 602 l 1215 429 l 859 429 l 859 174 l 1240 174 l 1240 0 m 392 412 l 648 412 l 648 812 l 562 812 l 392 412 z \"},\"ӕ\":{\"ha\":1274,\"x_min\":58,\"x_max\":1214,\"o\":\"m 901 -14 q 732 21 808 -14 q 607 126 656 55 q 474 17 541 47 q 300 -14 407 -14 q 124 51 191 -14 q 58 227 58 115 q 140 405 58 347 q 386 468 222 462 l 515 472 l 515 529 q 485 598 515 576 q 403 621 455 621 q 196 568 308 621 l 129 705 q 415 774 257 774 q 647 685 569 774 q 750 750 692 728 q 890 772 809 772 q 1127 679 1040 772 q 1214 428 1214 586 l 1214 328 l 724 328 q 776 190 727 239 q 913 140 825 140 q 1171 200 1046 140 l 1171 40 q 1055 0 1117 14 q 901 -14 992 -14 m 515 351 l 439 349 q 313 316 355 346 q 271 225 271 287 q 366 138 271 138 q 475 179 434 138 q 515 289 515 220 l 515 351 m 886 625 q 728 465 739 625 l 1019 465 q 982 583 1018 541 q 886 625 946 625 z \"},\"Ӗ\":{\"ha\":778,\"x_min\":80,\"x_max\":739,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 739 1314 q 643 1129 726 1187 q 404 1071 560 1071 q 166 1126 243 1071 q 80 1314 90 1182 l 265 1314 q 300 1216 270 1244 q 408 1187 330 1187 q 510 1218 477 1187 q 551 1314 544 1249 l 739 1314 z \"},\"ӗ\":{\"ha\":821,\"x_min\":62,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 749 1084 q 653 900 736 958 q 414 842 570 842 q 177 897 254 842 q 90 1084 100 953 l 275 1084 q 310 986 280 1015 q 418 958 340 958 q 520 989 487 958 q 562 1084 554 1020 l 749 1084 z \"},\"Ә\":{\"ha\":1135,\"x_min\":111,\"x_max\":1054,\"o\":\"m 555 832 q 347 801 455 832 q 163 722 239 770 l 163 904 q 352 984 257 960 q 557 1007 446 1007 q 923 871 791 1007 q 1054 494 1054 734 q 930 120 1054 254 q 582 -14 807 -14 q 230 119 349 -14 q 111 517 111 252 l 111 566 l 835 566 q 754 764 826 696 q 555 832 683 832 m 582 161 q 759 223 692 161 q 832 390 825 285 l 329 390 q 390 216 329 271 q 582 161 451 161 z \"},\"ә\":{\"ha\":835,\"x_min\":62,\"x_max\":775,\"o\":\"m 408 134 q 515 174 475 134 q 562 293 555 214 l 257 293 q 298 176 258 218 q 408 134 337 134 m 378 772 q 670 671 565 772 q 775 385 775 570 q 679 91 775 195 q 410 -14 583 -14 q 154 77 246 -14 q 62 330 62 168 l 62 431 l 567 431 q 513 568 564 519 q 371 618 462 618 q 241 605 304 618 q 106 558 178 592 l 106 718 q 230 760 165 748 q 378 772 294 772 z \"},\"Ӛ\":{\"ha\":1135,\"x_min\":111,\"x_max\":1054,\"o\":\"m 555 832 q 347 801 455 832 q 163 722 239 770 l 163 904 q 352 984 257 960 q 557 1007 446 1007 q 923 871 791 1007 q 1054 494 1054 734 q 930 120 1054 254 q 582 -14 807 -14 q 230 119 349 -14 q 111 517 111 252 l 111 566 l 835 566 q 754 764 826 696 q 555 832 683 832 m 582 161 q 759 223 692 161 q 832 390 825 285 l 329 390 q 390 216 329 271 q 582 161 451 161 m 351 1182 q 376 1250 351 1226 q 445 1274 401 1274 q 515 1249 490 1274 q 541 1182 541 1223 q 515 1117 541 1141 q 445 1092 489 1092 q 376 1116 401 1092 q 351 1182 351 1139 m 624 1182 q 651 1252 624 1230 q 720 1274 679 1274 q 790 1249 764 1274 q 816 1182 816 1225 q 789 1116 816 1141 q 720 1092 763 1092 q 651 1114 679 1092 q 624 1182 624 1136 z \"},\"ӛ\":{\"ha\":835,\"x_min\":62,\"x_max\":775,\"o\":\"m 408 134 q 515 174 475 134 q 562 293 555 214 l 257 293 q 298 176 258 218 q 408 134 337 134 m 378 772 q 670 671 565 772 q 775 385 775 570 q 679 91 775 195 q 410 -14 583 -14 q 154 77 246 -14 q 62 330 62 168 l 62 431 l 567 431 q 513 568 564 519 q 371 618 462 618 q 241 605 304 618 q 106 558 178 592 l 106 718 q 230 760 165 748 q 378 772 294 772 m 189 953 q 214 1021 189 997 q 283 1044 239 1044 q 353 1019 328 1044 q 378 953 378 994 q 353 887 378 912 q 283 863 327 863 q 214 886 239 863 q 189 953 189 910 m 462 953 q 489 1022 462 1000 q 557 1044 517 1044 q 628 1020 602 1044 q 654 953 654 996 q 627 887 654 911 q 557 863 601 863 q 489 885 517 863 q 462 953 462 907 z \"},\"Ӝ\":{\"ha\":1310,\"x_min\":0,\"x_max\":1310,\"o\":\"m 353 515 l 20 991 l 236 991 l 557 511 l 557 991 l 753 991 l 753 511 l 1074 991 l 1291 991 l 957 515 l 1310 0 l 1084 0 l 753 503 l 753 0 l 557 0 l 557 503 l 225 0 l 0 0 l 353 515 m 422 1182 q 448 1250 422 1226 q 517 1274 473 1274 q 587 1249 562 1274 q 612 1182 612 1223 q 587 1117 612 1141 q 517 1092 561 1092 q 448 1116 473 1092 q 422 1182 422 1139 m 696 1182 q 723 1252 696 1230 q 791 1274 751 1274 q 862 1249 836 1274 q 888 1182 888 1225 q 861 1116 888 1141 q 791 1092 835 1092 q 723 1114 751 1092 q 696 1182 696 1136 z \"},\"ӝ\":{\"ha\":1213,\"x_min\":0,\"x_max\":1213,\"o\":\"m 510 390 l 510 758 l 703 758 l 703 390 l 972 758 l 1186 758 l 907 395 l 1213 0 l 991 0 l 703 385 l 703 0 l 510 0 l 510 385 l 221 0 l 0 0 l 306 395 l 26 758 l 240 758 l 510 390 m 374 953 q 399 1021 374 997 q 468 1044 425 1044 q 538 1019 513 1044 q 564 953 564 994 q 538 887 564 912 q 468 863 512 863 q 399 886 425 863 q 374 953 374 910 m 647 953 q 674 1022 647 1000 q 743 1044 702 1044 q 813 1020 787 1044 q 839 953 839 996 q 812 887 839 911 q 743 863 786 863 q 674 885 702 863 q 647 953 647 907 z \"},\"Ӟ\":{\"ha\":900,\"x_min\":64,\"x_max\":840,\"o\":\"m 810 760 q 742 602 810 664 q 558 522 674 539 l 558 518 q 767 443 694 505 q 840 282 840 381 q 729 66 840 145 q 422 -14 618 -14 q 72 40 204 -14 l 72 216 q 221 169 136 186 q 382 151 307 151 q 632 297 632 151 q 552 398 632 363 q 314 433 471 433 l 221 433 l 221 597 l 304 597 q 534 627 462 597 q 606 726 606 657 q 561 807 606 777 q 425 838 515 838 q 155 757 286 838 l 64 897 q 243 980 149 954 q 454 1006 338 1006 q 713 938 616 1006 q 810 760 810 870 m 220 1182 q 245 1250 220 1226 q 314 1274 271 1274 q 384 1249 359 1274 q 410 1182 410 1223 q 384 1117 410 1141 q 314 1092 358 1092 q 245 1116 271 1092 q 220 1182 220 1139 m 493 1182 q 520 1252 493 1230 q 589 1274 548 1274 q 659 1249 633 1274 q 685 1182 685 1225 q 659 1116 685 1141 q 589 1092 632 1092 q 520 1114 548 1092 q 493 1182 493 1136 z \"},\"ӟ\":{\"ha\":771,\"x_min\":53,\"x_max\":718,\"o\":\"m 297 467 q 464 486 414 467 q 513 546 513 505 q 477 601 513 583 q 358 619 441 619 q 240 606 306 619 q 119 571 174 593 l 58 715 q 215 759 139 746 q 385 772 291 772 q 612 718 526 772 q 697 571 697 664 q 546 404 697 443 l 546 397 q 679 332 639 374 q 718 221 718 290 q 673 98 718 152 q 544 16 629 45 q 345 -14 459 -14 q 53 33 155 -14 l 53 204 q 181 161 111 177 q 315 146 250 146 q 467 169 416 146 q 517 233 517 191 q 464 301 517 279 q 301 323 411 323 l 221 323 l 221 467 l 297 467 m 155 953 q 181 1021 155 997 q 250 1044 206 1044 q 320 1019 294 1044 q 345 953 345 994 q 319 887 345 912 q 250 863 294 863 q 181 886 206 863 q 155 953 155 910 m 429 953 q 456 1022 429 1000 q 524 1044 484 1044 q 594 1020 568 1044 q 621 953 621 996 q 594 887 621 911 q 524 863 568 863 q 456 885 484 863 q 429 953 429 907 z \"},\"Ӡ\":{\"ha\":821,\"x_min\":39,\"x_max\":766,\"o\":\"m 192 582 l 436 818 l 72 818 l 72 991 l 722 991 l 722 857 l 429 578 q 680 496 593 571 q 766 289 766 422 q 656 67 766 148 q 345 -14 546 -14 q 39 40 169 -14 l 39 218 q 181 171 102 189 q 332 153 261 153 q 501 188 445 153 q 557 301 557 224 q 486 402 557 370 q 275 435 416 435 l 192 435 l 192 582 z \"},\"ӡ\":{\"ha\":807,\"x_min\":39,\"x_max\":753,\"o\":\"m 192 340 l 467 600 l 66 600 l 66 758 l 722 758 l 722 624 l 422 343 q 668 239 583 326 q 753 1 753 153 q 704 -177 753 -101 q 563 -293 656 -252 q 339 -334 470 -334 q 39 -279 169 -334 l 39 -102 q 178 -150 101 -132 q 323 -167 255 -167 q 487 -121 431 -167 q 543 11 543 -75 q 475 149 543 104 q 272 193 406 193 l 192 193 l 192 340 z \"},\"Ӣ\":{\"ha\":1143,\"x_min\":125,\"x_max\":1018,\"o\":\"m 125 991 l 314 991 l 314 513 l 311 385 l 304 239 l 309 239 l 766 991 l 1018 991 l 1018 0 l 831 0 l 831 476 q 843 760 831 572 l 838 760 l 378 0 l 125 0 l 125 991 m 340 1214 l 800 1214 l 800 1071 l 340 1071 l 340 1214 z \"},\"ӣ\":{\"ha\":1000,\"x_min\":109,\"x_max\":892,\"o\":\"m 309 758 l 309 458 q 293 227 309 411 l 643 758 l 892 758 l 892 0 l 692 0 l 692 302 q 705 530 692 383 l 357 0 l 109 0 l 109 758 l 309 758 m 271 985 l 731 985 l 731 842 l 271 842 l 271 985 z \"},\"Ӥ\":{\"ha\":1143,\"x_min\":125,\"x_max\":1018,\"o\":\"m 125 991 l 314 991 l 314 513 l 311 385 l 304 239 l 309 239 l 766 991 l 1018 991 l 1018 0 l 831 0 l 831 476 q 843 760 831 572 l 838 760 l 378 0 l 125 0 l 125 991 m 339 1182 q 365 1250 339 1226 q 433 1274 390 1274 q 504 1249 478 1274 q 529 1182 529 1223 q 503 1117 529 1141 q 433 1092 477 1092 q 365 1116 390 1092 q 339 1182 339 1139 m 612 1182 q 640 1252 612 1230 q 708 1274 667 1274 q 778 1249 752 1274 q 804 1182 804 1225 q 778 1116 804 1141 q 708 1092 751 1092 q 640 1114 667 1092 q 612 1182 612 1136 z \"},\"ӥ\":{\"ha\":1000,\"x_min\":109,\"x_max\":892,\"o\":\"m 309 758 l 309 458 q 293 227 309 411 l 643 758 l 892 758 l 892 0 l 692 0 l 692 302 q 705 530 692 383 l 357 0 l 109 0 l 109 758 l 309 758 m 269 953 q 294 1021 269 997 q 363 1044 319 1044 q 433 1019 408 1044 q 458 953 458 994 q 433 887 458 912 q 363 863 407 863 q 294 886 319 863 q 269 953 269 910 m 542 953 q 569 1022 542 1000 q 637 1044 597 1044 q 708 1020 682 1044 q 734 953 734 996 q 707 887 734 911 q 637 863 681 863 q 569 885 597 863 q 542 953 542 907 z \"},\"Ӧ\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 321 1182 q 347 1250 321 1226 q 416 1274 372 1274 q 486 1249 460 1274 q 511 1182 511 1223 q 486 1117 511 1141 q 416 1092 460 1092 q 347 1116 372 1092 q 321 1182 321 1139 m 595 1182 q 622 1252 595 1230 q 690 1274 650 1274 q 761 1249 734 1274 q 787 1182 787 1225 q 760 1116 787 1141 q 690 1092 734 1092 q 622 1114 650 1092 q 595 1182 595 1136 z \"},\"ӧ\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 199 953 q 224 1021 199 997 q 293 1044 250 1044 q 363 1019 338 1044 q 389 953 389 994 q 363 887 389 912 q 293 863 337 863 q 224 886 250 863 q 199 953 199 910 m 472 953 q 499 1022 472 1000 q 568 1044 527 1044 q 638 1020 612 1044 q 664 953 664 996 q 637 887 664 911 q 568 863 611 863 q 499 885 527 863 q 472 953 472 907 z \"},\"Ө\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 553 163 q 727 228 663 163 q 804 421 791 293 l 300 421 q 375 231 313 299 q 553 163 437 163 m 554 832 q 384 773 447 832 q 302 596 321 714 l 802 596 q 723 771 785 711 q 554 832 661 832 z \"},\"ө\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 431 153 q 534 192 496 153 q 582 310 572 231 l 277 310 q 324 192 287 231 q 431 153 361 153 m 429 606 q 325 567 363 606 q 277 453 287 529 l 582 453 q 535 567 572 529 q 429 606 498 606 z \"},\"Ӫ\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 553 163 q 727 228 663 163 q 804 421 791 293 l 300 421 q 375 231 313 299 q 553 163 437 163 m 554 832 q 384 773 447 832 q 302 596 321 714 l 802 596 q 723 771 785 711 q 554 832 661 832 m 323 1182 q 348 1250 323 1226 q 417 1274 374 1274 q 487 1249 462 1274 q 513 1182 513 1223 q 487 1117 513 1141 q 417 1092 461 1092 q 348 1116 374 1092 q 323 1182 323 1139 m 596 1182 q 624 1252 596 1230 q 692 1274 651 1274 q 762 1249 736 1274 q 788 1182 788 1225 q 762 1116 788 1141 q 692 1092 735 1092 q 624 1114 651 1092 q 596 1182 596 1136 z \"},\"ӫ\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 431 153 q 534 192 496 153 q 582 310 572 231 l 277 310 q 324 192 287 231 q 431 153 361 153 m 429 606 q 325 567 363 606 q 277 453 287 529 l 582 453 q 535 567 572 529 q 429 606 498 606 m 197 953 q 223 1021 197 997 q 292 1044 248 1044 q 362 1019 336 1044 q 387 953 387 994 q 361 887 387 912 q 292 863 336 863 q 223 886 248 863 q 197 953 197 910 m 471 953 q 498 1022 471 1000 q 566 1044 526 1044 q 636 1020 610 1044 q 663 953 663 996 q 636 887 663 911 q 566 863 610 863 q 498 885 526 863 q 471 953 471 907 z \"},\"Ӭ\":{\"ha\":921,\"x_min\":49,\"x_max\":840,\"o\":\"m 375 831 q 243 812 308 831 q 115 766 178 793 l 49 936 q 379 1006 206 1006 q 720 870 600 1006 q 840 494 840 735 q 716 118 840 249 q 359 -14 593 -14 q 66 37 199 -14 l 66 214 q 347 161 231 161 q 545 224 477 161 q 619 414 613 288 l 189 414 l 189 586 l 618 586 q 549 766 614 701 q 375 831 484 831 m 213 1182 q 238 1250 213 1226 q 307 1274 264 1274 q 377 1249 352 1274 q 403 1182 403 1223 q 377 1117 403 1141 q 307 1092 351 1092 q 238 1116 264 1092 q 213 1182 213 1139 m 486 1182 q 514 1252 486 1230 q 582 1274 541 1274 q 652 1249 626 1274 q 678 1182 678 1225 q 652 1116 678 1141 q 582 1092 625 1092 q 514 1114 541 1092 q 486 1182 486 1136 z \"},\"ӭ\":{\"ha\":711,\"x_min\":50,\"x_max\":648,\"o\":\"m 283 -14 q 50 33 141 -14 l 50 195 q 272 140 168 140 q 387 184 347 140 q 435 314 428 227 l 149 314 l 149 452 l 435 452 q 393 577 429 535 q 289 619 357 619 q 113 576 208 619 l 54 718 q 169 757 105 742 q 297 772 233 772 q 562 676 475 772 q 648 387 648 580 q 556 88 648 189 q 283 -14 465 -14 m 118 953 q 143 1021 118 997 q 212 1044 169 1044 q 282 1019 257 1044 q 308 953 308 994 q 282 887 308 912 q 212 863 256 863 q 143 886 169 863 q 118 953 118 910 m 391 953 q 419 1022 391 1000 q 487 1044 446 1044 q 557 1020 531 1044 q 583 953 583 996 q 557 887 583 911 q 487 863 530 863 q 419 885 446 863 q 391 953 391 907 z \"},\"Ӯ\":{\"ha\":907,\"x_min\":0,\"x_max\":907,\"o\":\"m 907 991 l 600 290 q 492 100 543 158 q 372 15 441 43 q 204 -14 303 -14 q 46 7 119 -14 l 46 187 q 195 163 106 163 q 286 189 251 163 q 343 279 320 215 l 0 991 l 222 991 l 467 439 l 473 439 l 486 473 l 690 991 l 907 991 m 225 1214 l 685 1214 l 685 1071 l 225 1071 l 225 1214 z \"},\"ӯ\":{\"ha\":790,\"x_min\":0,\"x_max\":790,\"o\":\"m 0 758 l 227 758 l 370 332 q 395 200 388 276 l 399 200 q 428 332 406 270 l 568 758 l 790 758 l 469 -97 q 343 -275 425 -216 q 153 -334 262 -334 q 47 -322 99 -334 l 47 -158 q 129 -167 85 -167 q 225 -133 184 -167 q 289 -32 266 -100 l 301 5 l 0 758 m 168 985 l 627 985 l 627 842 l 168 842 l 168 985 z \"},\"Ӱ\":{\"ha\":907,\"x_min\":0,\"x_max\":907,\"o\":\"m 907 991 l 600 290 q 492 100 543 158 q 372 15 441 43 q 204 -14 303 -14 q 46 7 119 -14 l 46 187 q 195 163 106 163 q 286 189 251 163 q 343 279 320 215 l 0 991 l 222 991 l 467 439 l 473 439 l 486 473 l 690 991 l 907 991 m 222 1182 q 248 1250 222 1226 q 317 1274 273 1274 q 387 1249 361 1274 q 412 1182 412 1223 q 387 1117 412 1141 q 317 1092 361 1092 q 248 1116 273 1092 q 222 1182 222 1139 m 496 1182 q 523 1252 496 1230 q 591 1274 551 1274 q 662 1249 635 1274 q 688 1182 688 1225 q 661 1116 688 1141 q 591 1092 635 1092 q 523 1114 551 1092 q 496 1182 496 1136 z \"},\"ӱ\":{\"ha\":790,\"x_min\":0,\"x_max\":790,\"o\":\"m 0 758 l 227 758 l 370 332 q 395 200 388 276 l 399 200 q 428 332 406 270 l 568 758 l 790 758 l 469 -97 q 343 -275 425 -216 q 153 -334 262 -334 q 47 -322 99 -334 l 47 -158 q 129 -167 85 -167 q 225 -133 184 -167 q 289 -32 266 -100 l 301 5 l 0 758 m 165 953 q 190 1021 165 997 q 259 1044 216 1044 q 329 1019 304 1044 q 355 953 355 994 q 329 887 355 912 q 259 863 303 863 q 190 886 216 863 q 165 953 165 910 m 438 953 q 466 1022 438 1000 q 534 1044 493 1044 q 604 1020 578 1044 q 630 953 630 996 q 604 887 630 911 q 534 863 577 863 q 466 885 493 863 q 438 953 438 907 z \"},\"Ӳ\":{\"ha\":907,\"x_min\":0,\"x_max\":907,\"o\":\"m 907 991 l 600 290 q 492 100 543 158 q 372 15 441 43 q 204 -14 303 -14 q 46 7 119 -14 l 46 187 q 195 163 106 163 q 286 189 251 163 q 343 279 320 215 l 0 991 l 222 991 l 467 439 l 473 439 l 486 473 l 690 991 l 907 991 m 231 1071 l 231 1089 q 310 1206 273 1147 q 362 1293 348 1265 l 566 1293 l 566 1279 q 467 1175 545 1243 q 340 1071 390 1107 l 231 1071 m 500 1071 l 500 1089 q 632 1293 594 1219 l 836 1293 l 836 1279 q 751 1188 819 1250 q 610 1071 683 1126 l 500 1071 z \"},\"ӳ\":{\"ha\":790,\"x_min\":0,\"x_max\":790,\"o\":\"m 0 758 l 227 758 l 370 332 q 395 200 388 276 l 399 200 q 428 332 406 270 l 568 758 l 790 758 l 469 -97 q 343 -275 425 -216 q 153 -334 262 -334 q 47 -322 99 -334 l 47 -158 q 129 -167 85 -167 q 225 -133 184 -167 q 289 -32 266 -100 l 301 5 l 0 758 m 161 842 l 161 860 q 241 977 203 918 q 293 1064 279 1036 l 497 1064 l 497 1050 q 398 946 475 1014 q 271 842 321 878 l 161 842 m 431 842 l 431 860 q 563 1064 525 990 l 767 1064 l 767 1050 q 682 959 750 1021 q 541 842 614 897 l 431 842 z \"},\"Ӵ\":{\"ha\":1011,\"x_min\":74,\"x_max\":886,\"o\":\"m 886 0 l 676 0 l 676 383 q 502 335 572 348 q 370 322 433 322 q 151 390 228 322 q 74 582 74 458 l 74 991 l 283 991 l 283 642 q 317 533 283 570 q 429 497 350 497 q 540 508 485 497 q 676 547 595 519 l 676 991 l 886 991 l 886 0 m 248 1182 q 273 1250 248 1226 q 342 1274 298 1274 q 412 1249 387 1274 q 437 1182 437 1223 q 412 1117 437 1141 q 342 1092 386 1092 q 273 1116 298 1092 q 248 1182 248 1139 m 521 1182 q 548 1252 521 1230 q 616 1274 576 1274 q 687 1249 661 1274 q 713 1182 713 1225 q 686 1116 713 1141 q 616 1092 660 1092 q 548 1114 576 1092 q 521 1182 521 1136 z \"},\"ӵ\":{\"ha\":911,\"x_min\":83,\"x_max\":803,\"o\":\"m 290 758 l 290 481 q 382 382 290 382 q 493 395 441 382 q 596 431 544 409 l 596 758 l 803 758 l 803 0 l 596 0 l 596 301 q 463 248 524 263 q 343 232 401 232 q 151 295 219 232 q 83 476 83 359 l 83 758 l 290 758 m 213 953 q 238 1021 213 997 q 307 1044 264 1044 q 377 1019 352 1044 q 403 953 403 994 q 377 887 403 912 q 307 863 351 863 q 238 886 264 863 q 213 953 213 910 m 486 953 q 514 1022 486 1000 q 582 1044 541 1044 q 652 1020 626 1044 q 678 953 678 996 q 652 887 678 911 q 582 863 625 863 q 514 885 541 863 q 486 953 486 907 z \"},\"Ӷ\":{\"ha\":779,\"x_min\":125,\"x_max\":751,\"o\":\"m 751 991 l 751 818 l 335 818 l 335 180 l 538 180 l 538 -289 l 335 -289 l 335 0 l 125 0 l 125 991 l 751 991 z \"},\"ӷ\":{\"ha\":664,\"x_min\":109,\"x_max\":632,\"o\":\"m 632 758 l 632 603 l 315 603 l 315 151 l 501 151 l 501 -272 l 315 -272 l 315 0 l 109 0 l 109 758 l 632 758 z \"},\"Ӹ\":{\"ha\":1258,\"x_min\":125,\"x_max\":1133,\"o\":\"m 803 310 q 700 78 803 155 q 396 0 597 0 l 125 0 l 125 991 l 335 991 l 335 611 l 403 611 q 698 532 593 611 q 803 310 803 453 m 335 172 l 390 172 q 542 207 494 172 q 590 310 590 241 q 544 409 590 379 q 380 439 497 439 l 335 439 l 335 172 m 1133 0 l 924 0 l 924 991 l 1133 991 l 1133 0 m 399 1182 q 424 1250 399 1226 q 493 1274 450 1274 q 563 1249 538 1274 q 589 1182 589 1223 q 563 1117 589 1141 q 493 1092 537 1092 q 424 1116 450 1092 q 399 1182 399 1139 m 672 1182 q 700 1252 672 1230 q 768 1274 727 1274 q 838 1249 812 1274 q 864 1182 864 1225 q 838 1116 864 1141 q 768 1092 811 1092 q 700 1114 727 1092 q 672 1182 672 1136 z \"},\"ӹ\":{\"ha\":1181,\"x_min\":109,\"x_max\":1072,\"o\":\"m 315 465 l 415 465 q 672 410 589 465 q 755 241 755 354 q 672 61 755 121 q 422 0 589 0 l 109 0 l 109 758 l 315 758 l 315 465 m 549 239 q 513 302 549 283 q 408 322 478 322 l 315 322 l 315 143 l 411 143 q 549 239 549 143 m 1072 0 l 865 0 l 865 758 l 1072 758 l 1072 0 m 359 953 q 384 1021 359 997 q 453 1044 410 1044 q 523 1019 498 1044 q 549 953 549 994 q 523 887 549 912 q 453 863 497 863 q 384 886 410 863 q 359 953 359 910 m 632 953 q 660 1022 632 1000 q 728 1044 687 1044 q 798 1020 772 1044 q 824 953 824 996 q 798 887 824 911 q 728 863 771 863 q 660 885 687 863 q 632 953 632 907 z \"},\"Ӻ\":{\"ha\":777,\"x_min\":32,\"x_max\":749,\"o\":\"m 749 991 l 749 819 l 335 819 l 335 576 l 607 576 l 607 404 l 335 404 l 335 0 l 125 0 l 125 404 l 32 404 l 32 576 l 125 576 l 125 991 l 749 991 m 296 -336 q 171 -319 229 -336 l 171 -157 q 252 -170 211 -170 q 335 -54 335 -170 l 335 205 l 535 205 l 535 -85 q 473 -271 535 -205 q 296 -336 411 -336 z \"},\"ӻ\":{\"ha\":682,\"x_min\":3,\"x_max\":650,\"o\":\"m 650 758 l 650 590 l 302 590 l 302 443 l 528 443 l 528 283 l 302 283 l 302 0 l 96 0 l 96 283 l 3 283 l 3 443 l 96 443 l 96 758 l 650 758 m 264 -336 q 138 -319 196 -336 l 138 -157 q 219 -170 178 -170 q 302 -54 302 -170 l 302 178 l 503 178 l 503 -85 q 440 -271 503 -205 q 264 -336 378 -336 z \"},\"Ӽ\":{\"ha\":1017,\"x_min\":0,\"x_max\":989,\"o\":\"m 926 0 l 686 0 l 456 375 l 225 0 l 0 0 l 329 511 l 21 991 l 253 991 l 467 635 l 676 991 l 903 991 l 591 500 l 926 0 m 750 -336 q 625 -319 682 -336 l 625 -157 q 705 -170 665 -170 q 789 -54 789 -170 l 789 205 l 989 205 l 989 -85 q 927 -271 989 -205 q 750 -336 865 -336 z \"},\"ӽ\":{\"ha\":896,\"x_min\":7,\"x_max\":876,\"o\":\"m 264 387 l 20 758 l 254 758 l 401 517 l 550 758 l 785 758 l 538 387 l 796 0 l 561 0 l 401 260 l 241 0 l 7 0 l 264 387 m 637 -336 q 512 -319 570 -336 l 512 -157 q 593 -170 552 -170 q 676 -54 676 -170 l 676 178 l 876 178 l 876 -85 q 814 -271 876 -205 q 637 -336 752 -336 z \"},\"Ӿ\":{\"ha\":926,\"x_min\":0,\"x_max\":926,\"o\":\"m 77 591 l 278 591 l 21 991 l 253 991 l 467 635 l 676 991 l 903 991 l 650 591 l 850 591 l 850 419 l 646 419 l 926 0 l 686 0 l 456 375 l 225 0 l 0 0 l 269 419 l 77 419 l 77 591 z \"},\"ӿ\":{\"ha\":803,\"x_min\":7,\"x_max\":796,\"o\":\"m 69 461 l 215 461 l 20 758 l 254 758 l 401 517 l 550 758 l 785 758 l 586 461 l 733 461 l 733 306 l 591 306 l 796 0 l 561 0 l 401 260 l 241 0 l 7 0 l 210 306 l 69 306 l 69 461 z \"},\"Ԁ\":{\"ha\":886,\"x_min\":62,\"x_max\":761,\"o\":\"m 62 310 q 168 532 62 454 q 468 611 274 611 l 551 611 l 551 991 l 761 991 l 761 0 l 472 0 q 62 310 62 0 m 551 439 l 497 439 q 325 409 375 439 q 275 310 275 378 q 325 207 275 241 q 481 172 374 172 l 551 172 l 551 439 z \"},\"ԁ\":{\"ha\":879,\"x_min\":62,\"x_max\":771,\"o\":\"m 349 -14 q 139 90 215 -14 q 62 378 62 194 q 140 668 62 564 q 354 772 218 772 q 572 661 497 772 l 579 661 q 564 812 564 746 l 564 1055 l 771 1055 l 771 0 l 612 0 l 572 98 l 564 98 q 349 -14 493 -14 m 421 151 q 537 197 500 151 q 578 354 574 243 l 578 376 q 540 551 578 498 q 418 604 503 604 q 310 546 349 604 q 272 375 272 487 q 311 207 272 263 q 421 151 349 151 z \"},\"Ԃ\":{\"ha\":1286,\"x_min\":62,\"x_max\":1168,\"o\":\"m 62 297 q 163 527 62 444 q 446 611 264 611 l 524 611 l 524 991 l 733 991 l 733 249 q 762 182 735 204 q 847 160 789 160 q 935 195 908 160 q 961 306 961 229 l 961 575 l 1168 575 l 1168 258 q 1086 56 1168 126 q 844 -14 1005 -14 q 706 13 771 -14 q 614 81 640 39 q 526 13 585 38 q 382 -12 467 -12 q 143 67 224 -12 q 62 297 62 147 m 524 439 l 475 439 q 322 403 368 439 q 275 294 275 368 q 307 195 275 229 q 400 160 338 160 q 490 182 457 160 q 524 244 524 204 l 524 439 z \"},\"ԃ\":{\"ha\":1282,\"x_min\":62,\"x_max\":1178,\"o\":\"m 411 -14 q 153 87 243 -14 q 62 378 62 187 q 136 667 62 562 q 342 772 210 772 q 551 661 479 772 l 558 661 q 548 735 553 687 q 543 812 543 784 l 543 1055 l 750 1055 l 750 258 q 777 184 750 208 q 864 160 804 160 q 948 195 923 160 q 974 306 974 229 l 974 475 l 1178 475 l 1178 258 q 1098 56 1178 125 q 861 -14 1019 -14 q 728 7 780 -14 q 635 79 677 28 q 537 14 604 42 q 411 -14 471 -14 m 410 151 q 519 198 485 151 q 557 354 554 244 l 557 376 q 521 552 557 500 q 408 604 485 604 q 272 375 272 604 q 305 207 272 263 q 410 151 338 151 z \"},\"Ԅ\":{\"ha\":1268,\"x_min\":17,\"x_max\":1150,\"o\":\"m 686 770 q 630 612 686 677 q 472 522 574 547 l 472 518 q 654 445 592 503 q 715 289 715 387 q 744 190 715 220 q 829 160 772 160 q 917 195 890 160 q 943 306 943 229 l 943 575 l 1150 575 l 1150 258 q 1069 56 1150 125 q 829 -14 987 -14 q 588 64 671 -14 q 505 289 505 141 q 439 398 505 361 q 248 435 373 435 l 132 435 l 132 582 l 248 582 q 481 724 481 582 q 445 806 481 777 q 332 836 408 836 q 122 768 226 836 l 17 908 q 347 1006 153 1006 q 595 942 503 1006 q 686 770 686 879 z \"},\"ԅ\":{\"ha\":1208,\"x_min\":39,\"x_max\":1104,\"o\":\"m 273 467 q 426 486 380 467 q 472 546 472 505 q 438 601 472 583 q 326 619 404 619 q 214 607 274 619 q 100 571 153 594 l 39 715 q 193 760 120 747 q 355 772 266 772 q 575 718 493 772 q 657 571 657 664 q 515 404 657 443 l 515 397 q 676 243 676 371 q 790 160 676 160 q 874 195 849 160 q 900 306 900 229 l 900 475 l 1104 475 l 1104 258 q 1024 56 1104 125 q 790 -14 945 -14 q 555 38 640 -14 q 469 186 469 90 q 420 289 469 254 q 278 323 370 323 l 174 323 l 174 467 l 273 467 z \"},\"Ԇ\":{\"ha\":974,\"x_min\":17,\"x_max\":946,\"o\":\"m 714 770 q 658 612 714 677 q 500 522 602 547 l 500 518 q 682 445 620 503 q 743 289 743 387 l 743 180 l 946 180 l 946 -289 l 743 -289 l 743 0 l 533 0 l 533 289 q 462 398 533 361 q 256 435 391 435 l 132 435 l 132 582 l 256 582 q 509 724 509 582 q 347 836 509 836 q 122 768 234 836 l 17 908 q 361 1006 159 1006 q 619 942 524 1006 q 714 770 714 879 z \"},\"ԇ\":{\"ha\":918,\"x_min\":53,\"x_max\":899,\"o\":\"m 294 467 q 458 486 410 467 q 507 546 507 505 q 471 601 507 583 q 353 619 435 619 q 234 606 300 619 q 114 571 168 593 l 53 715 q 210 759 134 746 q 379 772 286 772 q 606 718 521 772 q 692 571 692 664 q 550 404 692 443 l 550 397 q 675 332 637 374 q 713 221 713 290 l 713 151 l 899 151 l 899 -272 l 713 -272 l 713 0 l 511 0 l 511 221 q 459 299 511 274 q 298 323 408 323 l 187 323 l 187 467 l 294 467 z \"},\"Ԉ\":{\"ha\":1435,\"x_min\":11,\"x_max\":1317,\"o\":\"m 882 254 q 910 183 883 205 q 996 160 937 160 q 1083 195 1057 160 q 1109 306 1109 229 l 1109 575 l 1317 575 l 1317 258 q 1236 56 1317 125 q 996 -14 1154 -14 q 754 54 836 -14 q 672 254 672 122 l 672 817 l 457 817 l 446 726 q 372 239 404 379 q 278 42 340 99 q 111 -14 216 -15 q 11 1 54 -14 l 11 174 q 85 160 50 160 q 142 193 121 160 q 181 315 163 226 q 231 607 200 404 q 283 991 262 810 l 882 991 l 882 254 z \"},\"ԉ\":{\"ha\":1299,\"x_min\":0,\"x_max\":1194,\"o\":\"m 766 256 q 793 183 766 205 q 880 160 821 160 q 965 195 939 160 q 990 306 990 229 l 990 475 l 1194 475 l 1194 258 q 1115 56 1194 125 q 880 -14 1035 -14 q 640 54 721 -14 q 559 256 559 122 l 559 603 l 390 603 q 337 223 368 349 q 254 42 306 98 q 118 -14 202 -14 q 0 8 46 -14 l 0 174 q 66 160 33 160 q 131 216 105 160 q 178 401 157 271 q 214 758 199 531 l 766 758 l 766 256 z \"},\"Ԋ\":{\"ha\":1449,\"x_min\":125,\"x_max\":1331,\"o\":\"m 909 258 q 934 184 909 208 q 1017 160 959 160 q 1099 195 1074 160 q 1124 306 1124 229 l 1124 575 l 1331 575 l 1331 258 q 1251 56 1331 125 q 1017 -14 1171 -14 q 781 54 861 -14 q 700 253 701 122 l 700 428 l 335 428 l 335 0 l 125 0 l 125 991 l 335 991 l 335 603 l 700 603 l 700 991 l 909 991 l 909 258 z \"},\"ԋ\":{\"ha\":1322,\"x_min\":109,\"x_max\":1218,\"o\":\"m 315 758 l 315 467 l 590 467 l 590 758 l 798 758 l 798 254 q 825 183 799 205 q 907 160 852 160 q 989 195 964 160 q 1014 306 1014 229 l 1014 475 l 1218 475 l 1218 258 q 1139 55 1218 124 q 907 -14 1060 -14 q 671 55 750 -14 q 590 254 591 123 l 590 313 l 315 313 l 315 0 l 109 0 l 109 758 l 315 758 z \"},\"Ԍ\":{\"ha\":1111,\"x_min\":81,\"x_max\":1031,\"o\":\"m 557 557 l 1031 557 l 1031 473 q 917 109 1031 231 q 582 -14 802 -14 q 211 120 340 -14 q 81 497 81 254 q 140 768 81 652 q 312 944 199 883 q 579 1006 425 1006 q 921 933 766 1006 l 848 764 q 706 817 771 802 q 571 831 642 831 q 370 741 443 831 q 297 493 297 652 q 371 248 297 334 q 587 161 444 161 q 751 218 692 161 q 810 377 810 275 l 810 382 l 557 382 l 557 557 z \"},\"ԍ\":{\"ha\":921,\"x_min\":62,\"x_max\":859,\"o\":\"m 449 450 l 859 450 l 859 387 q 465 -14 859 -14 q 168 87 274 -14 q 62 374 62 189 q 173 669 62 566 q 486 772 283 772 q 772 714 640 772 l 710 555 q 598 592 659 579 q 488 606 536 606 q 325 549 377 606 q 272 371 272 492 q 460 150 272 150 q 597 189 547 150 q 647 296 647 229 l 449 296 l 449 450 z \"},\"Ԏ\":{\"ha\":1053,\"x_min\":28,\"x_max\":935,\"o\":\"m 507 258 q 533 184 507 208 q 616 160 558 160 q 702 195 676 160 q 728 306 728 229 l 728 575 l 935 575 l 935 258 q 854 56 935 125 q 618 -14 774 -14 q 378 55 458 -14 q 297 253 297 124 l 297 817 l 28 817 l 28 991 l 777 991 l 777 817 l 507 817 l 507 258 z \"},\"ԏ\":{\"ha\":1019,\"x_min\":32,\"x_max\":916,\"o\":\"m 736 758 l 736 603 l 488 603 l 488 258 q 515 184 488 208 q 602 160 542 160 q 686 195 660 160 q 711 306 711 229 l 711 475 l 916 475 l 916 258 q 836 56 916 125 q 602 -14 756 -14 q 363 54 444 -14 q 281 254 282 121 l 281 603 l 32 603 l 32 758 l 736 758 z \"},\"Ԑ\":{\"ha\":900,\"x_min\":60,\"x_max\":836,\"o\":\"m 90 760 q 137 887 90 831 q 269 975 184 944 q 461 1006 353 1006 q 668 983 581 1006 q 836 907 756 960 l 745 751 q 475 832 614 832 q 339 805 385 832 q 294 726 294 777 q 367 627 294 657 q 596 597 439 597 l 679 597 l 679 433 l 586 433 q 348 398 427 433 q 268 297 268 363 q 324 194 268 227 q 496 161 380 161 q 672 178 583 161 q 828 227 762 195 l 828 40 q 479 -14 697 -14 q 172 66 283 -14 q 60 282 60 145 q 129 443 60 381 q 322 518 198 505 l 322 522 q 152 602 214 539 q 90 760 90 665 z \"},\"ԑ\":{\"ha\":772,\"x_min\":53,\"x_max\":720,\"o\":\"m 570 467 l 570 323 l 456 323 q 307 300 357 323 q 257 228 257 277 q 431 146 257 146 q 582 161 506 146 q 718 204 659 177 l 718 39 q 424 -14 602 -14 q 148 42 243 -14 q 53 210 53 98 q 96 328 53 282 q 237 392 140 373 l 237 399 q 93 574 93 432 q 180 721 93 669 q 427 772 267 772 q 580 758 502 772 q 720 715 658 743 l 664 571 q 432 619 549 619 q 278 549 278 619 q 323 485 278 504 q 465 467 368 467 l 570 467 z \"},\"Ԓ\":{\"ha\":1136,\"x_min\":11,\"x_max\":1108,\"o\":\"m 909 0 l 700 0 l 700 817 l 457 817 l 446 726 q 372 239 404 379 q 278 42 340 99 q 111 -14 216 -15 q 11 1 54 -14 l 11 174 q 85 160 50 160 q 142 193 121 160 q 181 315 163 226 q 231 607 200 404 q 283 991 262 810 l 909 991 l 909 0 m 869 -336 q 744 -319 802 -336 l 744 -157 q 825 -170 784 -170 q 908 -54 908 -170 l 908 205 l 1108 205 l 1108 -85 q 1046 -271 1108 -205 q 869 -336 984 -336 z \"},\"ԓ\":{\"ha\":1006,\"x_min\":0,\"x_max\":986,\"o\":\"m 787 0 l 581 0 l 581 603 l 390 603 q 337 223 368 349 q 254 42 306 98 q 118 -14 202 -14 q 0 8 46 -14 l 0 174 q 66 160 33 160 q 131 216 105 160 q 178 401 157 271 q 214 758 199 531 l 787 758 l 787 0 m 747 -336 q 622 -319 680 -336 l 622 -157 q 703 -170 662 -170 q 786 -54 786 -170 l 786 178 l 986 178 l 986 -85 q 924 -271 986 -205 q 747 -336 862 -336 z \"},\"Ạ\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 367 -191 q 479 -89 367 -89 q 592 -191 592 -89 q 564 -265 592 -239 q 479 -292 535 -292 q 367 -191 367 -292 z \"},\"ạ\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 282 -191 q 395 -89 282 -89 q 507 -191 507 -89 q 479 -265 507 -239 q 395 -292 450 -292 q 282 -191 282 -292 z \"},\"Ả\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 653 1238 q 543 1104 653 1132 l 536 1056 l 418 1056 l 403 1156 q 472 1181 454 1164 q 490 1223 490 1198 q 476 1257 490 1245 q 439 1268 462 1268 q 345 1253 395 1268 l 345 1367 q 400 1378 365 1373 q 464 1382 436 1382 q 606 1344 559 1382 q 653 1238 653 1307 z \"},\"ả\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 593 1008 q 484 875 593 903 l 477 827 l 359 827 l 343 926 q 412 952 394 935 q 431 994 431 969 q 416 1027 431 1016 q 379 1039 402 1039 q 285 1023 335 1039 l 285 1137 q 341 1148 305 1144 q 404 1153 376 1153 q 546 1115 499 1153 q 593 1008 593 1078 z \"},\"Ấ\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 732 1071 l 623 1071 q 479 1183 547 1122 q 336 1071 402 1115 l 227 1071 l 227 1089 q 372 1279 302 1177 l 586 1279 q 668 1168 622 1226 q 732 1089 713 1110 l 732 1071 m 672 1221 q 766 1357 730 1282 l 929 1357 l 929 1343 q 775 1203 884 1282 l 672 1203 l 672 1221 z \"},\"ấ\":{\"ha\":839,\"x_min\":58,\"x_max\":867,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 670 842 l 560 842 q 417 954 484 892 q 274 842 340 886 l 164 842 l 164 860 q 310 1050 240 948 l 524 1050 q 605 939 559 997 q 670 860 651 881 l 670 842 m 610 991 q 703 1128 667 1053 l 867 1128 l 867 1114 q 713 974 821 1053 l 610 974 l 610 991 z \"},\"Ầ\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 227 1089 q 372 1279 302 1177 l 587 1279 q 663 1175 620 1230 q 732 1089 705 1119 l 732 1071 l 623 1071 q 479 1183 557 1115 q 336 1071 408 1118 l 227 1071 l 227 1089 m 286 1203 l 184 1203 q 29 1343 73 1284 l 29 1357 l 193 1357 q 286 1221 230 1281 l 286 1203 z \"},\"ầ\":{\"ha\":839,\"x_min\":-31,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 167 860 q 313 1050 243 948 l 527 1050 q 603 945 560 1001 q 673 860 646 890 l 673 842 l 563 842 q 420 954 497 886 q 277 842 348 889 l 167 842 l 167 860 m 227 974 l 124 974 q -31 1114 13 1055 l -31 1128 l 134 1128 q 227 991 170 1052 l 227 974 z \"},\"Ẩ\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 868 1336 q 783 1242 868 1259 l 779 1200 l 693 1200 l 686 1279 q 746 1291 724 1280 q 768 1321 768 1301 q 756 1345 768 1335 q 714 1356 743 1356 q 665 1349 690 1356 l 665 1435 q 728 1439 680 1439 q 830 1415 791 1439 q 868 1336 868 1390 m 732 1071 l 623 1071 q 479 1183 547 1122 q 336 1071 402 1115 l 227 1071 l 227 1089 q 372 1279 302 1177 l 586 1279 q 668 1168 622 1226 q 732 1089 713 1110 l 732 1071 z \"},\"ẩ\":{\"ha\":839,\"x_min\":58,\"x_max\":808,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 808 1107 q 724 1013 808 1029 l 720 971 l 633 971 l 627 1050 q 686 1062 664 1051 q 709 1092 709 1072 q 696 1116 709 1106 q 654 1126 684 1126 q 606 1120 631 1126 l 606 1206 q 668 1210 621 1210 q 770 1185 732 1210 q 808 1107 808 1161 m 673 842 l 563 842 q 420 954 487 892 q 277 842 342 886 l 167 842 l 167 860 q 313 1050 243 948 l 526 1050 q 608 939 562 997 q 673 860 654 881 l 673 842 z \"},\"Ẫ\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 578 1292 q 528 1300 553 1292 q 478 1319 503 1309 q 431 1338 454 1329 q 389 1346 408 1346 q 348 1335 362 1346 q 324 1291 333 1324 l 248 1291 q 290 1410 254 1366 q 382 1454 326 1454 q 434 1445 408 1454 q 484 1426 460 1436 q 531 1407 509 1416 q 571 1398 553 1398 q 613 1411 599 1398 q 636 1455 627 1423 l 713 1455 q 669 1334 705 1377 q 578 1292 633 1292 m 732 1071 l 636 1071 q 479 1174 541 1119 q 322 1071 423 1124 l 227 1071 l 227 1089 q 387 1265 342 1200 l 572 1265 q 648 1174 605 1219 q 732 1089 692 1129 l 732 1071 z \"},\"ẫ\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 518 1063 q 468 1071 494 1063 q 418 1090 443 1080 q 371 1108 394 1100 q 330 1117 349 1117 q 288 1106 302 1117 q 264 1061 273 1095 l 188 1061 q 230 1181 194 1137 q 323 1225 267 1225 q 374 1216 348 1225 q 425 1197 400 1207 q 471 1178 449 1187 q 511 1169 494 1169 q 553 1181 539 1169 q 576 1226 567 1194 l 653 1226 q 609 1105 645 1147 q 518 1063 573 1063 m 673 842 l 576 842 q 420 945 481 890 q 262 842 363 895 l 167 842 l 167 860 q 327 1036 282 971 l 513 1036 q 589 945 545 989 q 673 860 632 900 l 673 842 z \"},\"Ậ\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 637 1071 q 479 1190 531 1134 q 323 1071 426 1135 l 186 1071 l 186 1089 q 359 1293 314 1217 l 602 1293 q 674 1197 623 1258 q 775 1089 726 1137 l 775 1071 l 637 1071 m 367 -191 q 479 -89 367 -89 q 592 -191 592 -89 q 564 -265 592 -239 q 479 -292 535 -292 q 367 -191 367 -292 z \"},\"ậ\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 574 841 q 416 960 468 904 q 260 841 363 905 l 123 841 l 123 859 q 296 1063 251 987 l 538 1063 q 611 967 559 1028 q 712 859 663 907 l 712 841 l 574 841 m 290 -191 q 403 -89 290 -89 q 515 -191 515 -89 q 487 -265 515 -239 q 403 -292 458 -292 q 290 -191 290 -292 z \"},\"Ắ\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 412 1265 q 492 1402 460 1337 l 642 1402 l 642 1388 q 501 1247 579 1313 l 412 1247 l 412 1265 m 726 1300 q 653 1132 719 1193 q 478 1071 587 1071 q 303 1129 366 1071 q 235 1300 240 1187 l 336 1300 q 381 1213 342 1241 q 479 1185 420 1185 q 578 1217 539 1185 q 623 1300 616 1249 l 726 1300 z \"},\"ắ\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 350 1036 q 429 1173 397 1107 l 579 1173 l 579 1158 q 439 1018 517 1084 l 350 1018 l 350 1036 m 664 1071 q 590 903 656 964 q 416 842 524 842 q 241 900 304 842 q 172 1071 178 958 l 274 1071 q 318 984 279 1012 q 417 956 357 956 q 515 987 477 956 q 560 1071 554 1019 l 664 1071 z \"},\"Ằ\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 547 1247 l 458 1247 q 318 1388 387 1305 l 318 1402 l 468 1402 q 547 1265 500 1337 l 547 1247 m 338 1300 q 382 1217 343 1249 q 481 1185 420 1185 q 581 1214 543 1185 q 624 1300 618 1244 l 725 1300 q 656 1129 719 1187 q 482 1071 593 1071 q 307 1132 373 1071 q 233 1300 241 1192 l 338 1300 z \"},\"ằ\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 485 1018 l 396 1018 q 256 1158 324 1076 l 256 1173 l 406 1173 q 485 1036 437 1107 l 485 1018 m 275 1071 q 319 988 281 1020 q 418 956 358 956 q 518 985 480 956 q 562 1071 556 1015 l 663 1071 q 594 900 656 958 q 420 842 531 842 q 244 902 311 842 q 171 1071 178 963 l 275 1071 z \"},\"Ẳ\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 581 1357 q 564 1300 581 1322 q 510 1265 547 1278 l 506 1238 l 433 1238 l 427 1312 q 474 1326 461 1318 q 488 1352 488 1335 q 448 1379 488 1379 q 392 1374 412 1379 l 392 1444 q 454 1449 407 1449 q 547 1426 513 1449 q 581 1357 581 1403 m 338 1300 q 382 1217 343 1249 q 481 1185 420 1185 q 581 1214 543 1185 q 624 1300 618 1244 l 725 1300 q 656 1129 719 1187 q 482 1071 593 1071 q 307 1132 373 1071 q 233 1300 241 1192 l 338 1300 z \"},\"ẳ\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 519 1128 q 503 1070 519 1093 q 449 1036 486 1048 l 445 1008 l 372 1008 l 366 1083 q 413 1097 400 1089 q 427 1122 427 1105 q 387 1150 427 1150 q 331 1145 351 1150 l 331 1215 q 393 1219 346 1219 q 486 1197 452 1219 q 519 1128 519 1174 m 277 1071 q 321 988 282 1020 q 420 956 359 956 q 519 985 481 956 q 563 1071 557 1015 l 664 1071 q 595 900 658 958 q 421 842 532 842 q 246 902 312 842 q 172 1071 180 963 l 277 1071 z \"},\"Ẵ\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 338 1272 q 378 1208 342 1232 q 481 1185 414 1185 q 624 1272 614 1185 l 725 1272 q 656 1122 719 1173 q 482 1071 594 1071 q 306 1125 372 1071 q 233 1272 241 1179 l 338 1272 m 585 1305 q 535 1314 560 1305 q 485 1333 509 1322 q 438 1351 460 1343 q 396 1360 415 1360 q 353 1348 367 1360 q 331 1304 340 1335 l 254 1304 q 294 1413 260 1372 q 389 1454 327 1454 q 440 1445 414 1454 q 491 1426 467 1436 q 538 1407 515 1416 q 578 1398 560 1398 q 620 1411 606 1398 q 643 1455 633 1423 l 720 1455 q 677 1343 712 1381 q 585 1305 642 1305 z \"},\"ẵ\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 277 1043 q 317 979 281 1003 q 420 956 353 956 q 563 1043 553 956 l 664 1043 q 595 893 658 944 q 421 842 533 842 q 245 896 311 842 q 172 1043 180 949 l 277 1043 m 524 1076 q 474 1085 499 1076 q 424 1103 448 1093 q 377 1122 399 1114 q 335 1131 354 1131 q 292 1118 306 1131 q 270 1075 279 1106 l 193 1075 q 233 1184 199 1143 q 328 1225 266 1225 q 379 1216 353 1225 q 430 1197 406 1207 q 477 1178 454 1187 q 517 1169 499 1169 q 558 1181 545 1169 q 582 1226 572 1194 l 659 1226 q 616 1114 651 1152 q 524 1076 581 1076 z \"},\"Ặ\":{\"ha\":958,\"x_min\":0,\"x_max\":958,\"o\":\"m 732 0 l 660 236 l 298 236 l 227 0 l 0 0 l 350 996 l 607 996 l 958 0 l 732 0 m 610 412 q 497 775 510 733 q 479 842 485 817 q 351 412 457 755 l 610 412 m 746 1300 q 663 1133 738 1196 q 476 1071 589 1071 q 288 1133 358 1071 q 212 1300 218 1194 l 328 1300 q 346 1250 330 1268 q 391 1223 362 1232 q 477 1215 420 1215 q 628 1300 617 1215 l 746 1300 m 367 -191 q 479 -89 367 -89 q 592 -191 592 -89 q 564 -265 592 -239 q 479 -292 535 -292 q 367 -191 367 -292 z \"},\"ặ\":{\"ha\":839,\"x_min\":58,\"x_max\":734,\"o\":\"m 590 0 l 550 103 l 545 103 q 437 12 492 37 q 293 -14 382 -14 q 121 49 184 -14 q 58 227 58 111 q 143 405 58 347 q 397 468 227 462 l 529 472 l 529 505 q 411 621 529 621 q 197 566 320 621 l 129 705 q 419 774 260 774 q 653 707 572 774 q 734 505 734 641 l 734 0 l 590 0 m 529 351 l 449 349 q 315 316 359 346 q 271 225 271 286 q 371 138 271 138 q 486 179 443 138 q 529 289 529 220 l 529 351 m 283 -191 q 396 -89 283 -89 q 509 -191 509 -89 q 480 -265 509 -239 q 396 -292 452 -292 q 283 -191 283 -292 m 684 1071 q 602 904 676 966 q 414 842 527 842 q 226 903 296 842 q 151 1071 156 965 l 266 1071 q 284 1021 269 1039 q 329 994 300 1002 q 416 986 358 986 q 566 1071 555 986 l 684 1071 z \"},\"Ẹ\":{\"ha\":778,\"x_min\":125,\"x_max\":696,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 296 -191 q 408 -89 296 -89 q 521 -191 521 -89 q 492 -265 521 -239 q 408 -292 464 -292 q 296 -191 296 -292 z \"},\"ẹ\":{\"ha\":821,\"x_min\":62,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 297 -191 q 410 -89 297 -89 q 522 -191 522 -89 q 494 -265 522 -239 q 410 -292 465 -292 q 297 -191 297 -292 z \"},\"Ẻ\":{\"ha\":778,\"x_min\":125,\"x_max\":696,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 589 1238 q 479 1104 589 1132 l 473 1056 l 355 1056 l 339 1156 q 408 1181 390 1164 q 427 1223 427 1198 q 412 1257 427 1245 q 375 1268 398 1268 q 281 1253 331 1268 l 281 1367 q 337 1378 301 1373 q 400 1382 372 1382 q 542 1344 495 1382 q 589 1238 589 1307 z \"},\"ẻ\":{\"ha\":821,\"x_min\":62,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 604 1008 q 494 875 604 903 l 488 827 l 370 827 l 354 926 q 423 952 405 935 q 441 994 441 969 q 427 1027 441 1016 q 390 1039 413 1039 q 296 1023 346 1039 l 296 1137 q 352 1148 316 1144 q 415 1153 387 1153 q 557 1115 510 1153 q 604 1008 604 1078 z \"},\"Ẽ\":{\"ha\":778,\"x_min\":125,\"x_max\":696,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 298 1142 q 258 1124 277 1142 q 230 1069 239 1106 l 129 1069 q 185 1223 136 1168 q 313 1279 233 1279 q 368 1268 341 1279 q 421 1243 395 1257 q 472 1219 447 1230 q 522 1208 497 1208 q 562 1226 543 1208 q 590 1280 581 1244 l 691 1280 q 634 1126 684 1182 q 507 1071 585 1071 q 452 1082 479 1071 q 399 1106 425 1093 q 348 1131 373 1120 q 298 1142 323 1142 z \"},\"ẽ\":{\"ha\":821,\"x_min\":62,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 307 913 q 266 895 286 913 q 238 840 247 877 l 137 840 q 193 994 144 939 q 321 1050 241 1050 q 376 1039 349 1050 q 429 1014 403 1027 q 480 990 455 1001 q 530 979 505 979 q 570 997 551 979 q 598 1051 589 1015 l 699 1051 q 643 897 692 953 q 515 842 593 842 q 460 853 487 842 q 407 877 433 864 q 356 902 381 890 q 307 913 331 913 z \"},\"Ế\":{\"ha\":778,\"x_min\":125,\"x_max\":861,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 664 1071 l 554 1071 q 411 1183 478 1122 q 268 1071 334 1115 l 158 1071 l 158 1089 q 304 1279 234 1177 l 517 1279 q 599 1168 553 1226 q 664 1089 645 1110 l 664 1071 m 604 1221 q 697 1357 661 1282 l 861 1357 l 861 1343 q 707 1203 815 1282 l 604 1203 l 604 1221 z \"},\"ế\":{\"ha\":821,\"x_min\":62,\"x_max\":871,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 674 842 l 564 842 q 421 954 488 892 q 278 842 344 886 l 168 842 l 168 860 q 314 1050 244 948 l 528 1050 q 609 939 564 997 q 674 860 655 881 l 674 842 m 614 991 q 707 1128 671 1053 l 871 1128 l 871 1114 q 717 974 825 1053 l 614 974 l 614 991 z \"},\"Ề\":{\"ha\":778,\"x_min\":-35,\"x_max\":696,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 163 1089 q 309 1279 239 1177 l 523 1279 q 599 1175 556 1230 q 669 1089 642 1119 l 669 1071 l 559 1071 q 416 1183 493 1115 q 273 1071 344 1118 l 163 1071 l 163 1089 m 222 1203 l 120 1203 q -35 1343 9 1284 l -35 1357 l 130 1357 q 222 1221 166 1281 l 222 1203 z \"},\"ề\":{\"ha\":821,\"x_min\":-22,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 175 860 q 321 1050 251 948 l 535 1050 q 611 945 568 1001 q 681 860 654 890 l 681 842 l 571 842 q 428 954 505 886 q 285 842 356 889 l 175 842 l 175 860 m 235 974 l 132 974 q -22 1114 21 1055 l -22 1128 l 142 1128 q 235 991 178 1052 l 235 974 z \"},\"Ể\":{\"ha\":778,\"x_min\":125,\"x_max\":800,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 800 1336 q 715 1242 800 1259 l 711 1200 l 625 1200 l 618 1279 q 677 1291 655 1280 q 700 1321 700 1301 q 687 1345 700 1335 q 646 1356 675 1356 q 597 1349 622 1356 l 597 1435 q 659 1439 612 1439 q 761 1415 723 1439 q 800 1336 800 1390 m 664 1071 l 554 1071 q 411 1183 478 1122 q 268 1071 334 1115 l 158 1071 l 158 1089 q 304 1279 234 1177 l 517 1279 q 599 1168 553 1226 q 664 1089 645 1110 l 664 1071 z \"},\"ể\":{\"ha\":821,\"x_min\":62,\"x_max\":810,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 810 1107 q 725 1013 810 1029 l 721 971 l 635 971 l 628 1050 q 688 1062 665 1051 q 710 1092 710 1072 q 697 1116 710 1106 q 656 1126 685 1126 q 607 1120 632 1126 l 607 1206 q 669 1210 622 1210 q 771 1185 733 1210 q 810 1107 810 1161 m 674 842 l 564 842 q 421 954 488 892 q 278 842 344 886 l 168 842 l 168 860 q 314 1050 244 948 l 528 1050 q 609 939 564 997 q 674 860 655 881 l 674 842 z \"},\"Ễ\":{\"ha\":778,\"x_min\":125,\"x_max\":696,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 512 1292 q 462 1300 488 1292 q 412 1319 437 1309 q 365 1338 388 1329 q 323 1346 342 1346 q 282 1335 296 1346 q 258 1291 267 1324 l 182 1291 q 224 1410 188 1366 q 317 1454 260 1454 q 368 1445 342 1454 q 418 1426 394 1436 q 465 1407 443 1416 q 505 1398 488 1398 q 547 1411 533 1398 q 570 1455 561 1423 l 647 1455 q 603 1334 639 1377 q 512 1292 567 1292 m 667 1071 l 570 1071 q 414 1174 475 1119 q 256 1071 357 1124 l 161 1071 l 161 1089 q 321 1265 276 1200 l 507 1265 q 583 1174 539 1219 q 667 1089 626 1129 l 667 1071 z \"},\"ễ\":{\"ha\":821,\"x_min\":62,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 522 1063 q 472 1071 498 1063 q 422 1090 447 1080 q 375 1108 398 1100 q 334 1117 353 1117 q 292 1106 307 1117 q 269 1061 277 1095 l 192 1061 q 234 1181 198 1137 q 327 1225 271 1225 q 378 1216 352 1225 q 429 1197 404 1207 q 475 1178 453 1187 q 515 1169 498 1169 q 557 1181 543 1169 q 581 1226 571 1194 l 657 1226 q 613 1105 649 1147 q 522 1063 577 1063 m 677 842 l 581 842 q 424 945 485 890 q 267 842 368 895 l 171 842 l 171 860 q 331 1036 286 971 l 517 1036 q 593 945 549 989 q 677 860 636 900 l 677 842 z \"},\"Ệ\":{\"ha\":778,\"x_min\":116,\"x_max\":705,\"o\":\"m 696 0 l 125 0 l 125 991 l 696 991 l 696 819 l 335 819 l 335 602 l 671 602 l 671 429 l 335 429 l 335 174 l 696 174 l 696 0 m 568 1071 q 409 1190 461 1134 q 254 1071 356 1135 l 116 1071 l 116 1089 q 290 1293 244 1217 l 532 1293 q 605 1197 553 1258 q 705 1089 656 1137 l 705 1071 l 568 1071 m 296 -191 q 408 -89 296 -89 q 521 -191 521 -89 q 492 -265 521 -239 q 408 -292 464 -292 q 296 -191 296 -292 z \"},\"ệ\":{\"ha\":821,\"x_min\":62,\"x_max\":761,\"o\":\"m 422 625 q 319 584 357 625 q 277 465 282 542 l 567 465 q 527 584 566 542 q 422 625 488 625 m 452 -14 q 165 87 269 -14 q 62 374 62 189 q 158 668 62 564 q 421 772 253 772 q 671 681 582 772 q 761 428 761 589 l 761 328 l 272 328 q 324 190 275 239 q 461 140 373 140 q 591 155 530 140 q 718 200 652 169 l 718 40 q 602 0 664 13 q 452 -14 541 -14 m 569 842 q 410 961 463 905 q 255 842 357 906 l 117 842 l 117 860 q 291 1064 245 988 l 533 1064 q 606 968 554 1029 q 707 860 658 907 l 707 842 l 569 842 m 297 -189 q 410 -87 297 -87 q 522 -189 522 -87 q 494 -264 522 -237 q 410 -290 465 -290 q 297 -189 297 -290 z \"},\"ỉ\":{\"ha\":424,\"x_min\":79,\"x_max\":388,\"o\":\"m 315 0 l 109 0 l 109 758 l 315 758 l 315 0 m 388 1008 q 278 875 388 903 l 271 827 l 153 827 l 138 926 q 207 952 189 935 q 225 994 225 969 q 211 1027 225 1016 q 174 1039 197 1039 q 79 1023 130 1039 l 79 1137 q 135 1148 100 1144 q 199 1153 171 1153 q 341 1115 294 1153 q 388 1008 388 1078 z \"},\"ị\":{\"ha\":424,\"x_min\":98,\"x_max\":325,\"o\":\"m 100 954 q 212 1055 100 1055 q 325 954 325 1055 q 297 879 325 906 q 212 852 269 852 q 100 954 100 852 m 315 0 l 109 0 l 109 758 l 315 758 l 315 0 m 98 -191 q 211 -89 98 -89 q 323 -191 323 -89 q 295 -265 323 -239 q 211 -292 267 -292 q 98 -191 98 -292 z \"},\"Ọ\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 440 -191 q 553 -89 440 -89 q 665 -191 665 -89 q 637 -265 665 -239 q 553 -292 608 -292 q 440 -191 440 -292 z \"},\"ọ\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 315 -191 q 428 -89 315 -89 q 541 -191 541 -89 q 512 -265 541 -239 q 428 -292 484 -292 q 315 -191 315 -292 z \"},\"Ỏ\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 728 1238 q 618 1104 728 1132 l 611 1056 l 493 1056 l 477 1156 q 547 1181 528 1164 q 565 1223 565 1198 q 551 1257 565 1245 q 513 1268 536 1268 q 419 1253 469 1268 l 419 1367 q 475 1378 439 1373 q 538 1382 511 1382 q 681 1344 633 1382 q 728 1238 728 1307 z \"},\"ỏ\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 604 1008 q 494 875 604 903 l 488 827 l 370 827 l 354 926 q 423 952 405 935 q 441 994 441 969 q 427 1027 441 1016 q 390 1039 413 1039 q 296 1023 346 1039 l 296 1137 q 352 1148 316 1144 q 415 1153 387 1153 q 557 1115 510 1153 q 604 1008 604 1078 z \"},\"Ố\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 800 1071 l 690 1071 q 547 1183 614 1122 q 404 1071 470 1115 l 294 1071 l 294 1089 q 440 1279 370 1177 l 654 1279 q 735 1168 690 1226 q 800 1089 781 1110 l 800 1071 m 740 1221 q 833 1357 798 1282 l 997 1357 l 997 1343 q 843 1203 951 1282 l 740 1203 l 740 1221 z \"},\"ố\":{\"ha\":860,\"x_min\":62,\"x_max\":875,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 678 842 l 568 842 q 425 954 492 892 q 282 842 348 886 l 172 842 l 172 860 q 318 1050 248 948 l 532 1050 q 613 939 568 997 q 678 860 659 881 l 678 842 m 618 991 q 711 1128 675 1053 l 875 1128 l 875 1114 q 721 974 829 1053 l 618 974 l 618 991 z \"},\"Ồ\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 297 1089 q 443 1279 373 1177 l 657 1279 q 733 1175 690 1230 q 803 1089 776 1119 l 803 1071 l 693 1071 q 550 1183 627 1115 q 407 1071 478 1118 l 297 1071 l 297 1089 m 357 1203 l 254 1203 q 100 1343 143 1284 l 100 1357 l 264 1357 q 357 1221 300 1281 l 357 1203 z \"},\"ồ\":{\"ha\":860,\"x_min\":-22,\"x_max\":798,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 175 860 q 321 1050 251 948 l 535 1050 q 611 945 568 1001 q 681 860 654 890 l 681 842 l 571 842 q 428 954 505 886 q 285 842 356 889 l 175 842 l 175 860 m 235 974 l 132 974 q -22 1114 21 1055 l -22 1128 l 142 1128 q 235 991 178 1052 l 235 974 z \"},\"Ổ\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 936 1336 q 851 1242 936 1259 l 847 1200 l 761 1200 l 754 1279 q 814 1291 791 1280 q 836 1321 836 1301 q 824 1345 836 1335 q 782 1356 811 1356 q 733 1349 758 1356 l 733 1435 q 795 1439 748 1439 q 898 1415 859 1439 q 936 1336 936 1390 m 800 1071 l 690 1071 q 547 1183 614 1122 q 404 1071 470 1115 l 294 1071 l 294 1089 q 440 1279 370 1177 l 654 1279 q 735 1168 690 1226 q 800 1089 781 1110 l 800 1071 z \"},\"ổ\":{\"ha\":860,\"x_min\":62,\"x_max\":814,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 814 1107 q 729 1013 814 1029 l 725 971 l 639 971 l 632 1050 q 692 1062 669 1051 q 714 1092 714 1072 q 702 1116 714 1106 q 660 1126 689 1126 q 611 1120 636 1126 l 611 1206 q 673 1210 626 1210 q 775 1185 737 1210 q 814 1107 814 1161 m 678 842 l 568 842 q 425 954 492 892 q 282 842 348 886 l 172 842 l 172 860 q 318 1050 248 948 l 532 1050 q 613 939 568 997 q 678 860 659 881 l 678 842 z \"},\"Ỗ\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 650 1292 q 600 1300 625 1292 q 550 1319 574 1309 q 503 1338 526 1329 q 461 1346 480 1346 q 419 1335 434 1346 q 396 1291 405 1324 l 319 1291 q 362 1410 326 1366 q 454 1454 398 1454 q 506 1445 479 1454 q 556 1426 532 1436 q 603 1407 581 1416 q 643 1398 625 1398 q 685 1411 671 1398 q 708 1455 699 1423 l 785 1455 q 741 1334 777 1377 q 650 1292 705 1292 m 804 1071 l 708 1071 q 551 1174 612 1119 q 394 1071 495 1124 l 298 1071 l 298 1089 q 458 1265 414 1200 l 644 1265 q 720 1174 677 1219 q 804 1089 764 1129 l 804 1071 z \"},\"ỗ\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 529 1063 q 479 1071 505 1063 q 429 1090 454 1080 q 382 1108 405 1100 q 340 1117 359 1117 q 299 1106 313 1117 q 275 1061 284 1095 l 199 1061 q 241 1181 205 1137 q 334 1225 277 1225 q 385 1216 359 1225 q 435 1197 411 1207 q 482 1178 460 1187 q 522 1169 505 1169 q 564 1181 550 1169 q 587 1226 578 1194 l 664 1226 q 620 1105 656 1147 q 529 1063 584 1063 m 684 842 l 587 842 q 431 945 492 890 q 273 842 374 895 l 178 842 l 178 860 q 338 1036 293 971 l 524 1036 q 600 945 556 989 q 684 860 643 900 l 684 842 z \"},\"Ộ\":{\"ha\":1105,\"x_min\":81,\"x_max\":1025,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 877 81 746 q 554 1007 326 1007 q 904 876 783 1007 q 1025 497 1025 744 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 440 -191 q 553 -89 440 -89 q 665 -191 665 -89 q 637 -265 665 -239 q 553 -292 608 -292 q 440 -191 440 -292 m 709 1071 q 550 1190 602 1134 q 395 1071 497 1135 l 257 1071 l 257 1089 q 431 1293 385 1217 l 673 1293 q 746 1197 694 1258 q 846 1089 798 1137 l 846 1071 l 709 1071 z \"},\"ộ\":{\"ha\":860,\"x_min\":62,\"x_max\":798,\"o\":\"m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 625 725 541 772 q 753 589 708 677 q 798 380 798 500 m 318 -191 q 431 -89 318 -89 q 543 -191 543 -89 q 515 -265 543 -239 q 431 -292 486 -292 q 318 -191 318 -292 m 586 842 q 427 961 479 905 q 272 842 374 906 l 134 842 l 134 860 q 308 1064 262 988 l 550 1064 q 623 968 571 1029 q 724 860 675 907 l 724 842 l 586 842 z \"},\"Ớ\":{\"ha\":1146,\"x_min\":81,\"x_max\":1187,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 876 81 745 q 555 1007 326 1007 q 911 869 790 1007 q 974 1055 974 911 l 1178 1055 l 1187 1040 q 1115 852 1163 920 q 983 750 1067 784 q 1025 497 1025 642 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 1105 0 m 416 1071 l 416 1089 q 575 1293 532 1225 l 807 1293 l 807 1279 q 687 1174 772 1244 q 553 1071 602 1105 l 416 1071 z \"},\"ớ\":{\"ha\":943,\"x_min\":62,\"x_max\":1007,\"o\":\"m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 576 749 508 772 q 692 679 644 726 q 793 872 793 709 l 997 872 l 1007 857 q 959 713 989 766 q 882 624 930 660 q 762 570 833 587 q 798 380 798 485 m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 860 0 m 310 842 l 310 860 q 469 1064 427 996 l 701 1064 l 701 1050 q 581 945 666 1015 q 448 842 496 876 l 310 842 z \"},\"Ờ\":{\"ha\":1146,\"x_min\":81,\"x_max\":1187,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 876 81 745 q 555 1007 326 1007 q 911 869 790 1007 q 974 1055 974 911 l 1178 1055 l 1187 1040 q 1115 852 1163 920 q 983 750 1067 784 q 1025 497 1025 642 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 1105 0 m 547 1071 q 422 1167 505 1101 q 293 1279 339 1234 l 293 1293 l 525 1293 q 684 1089 568 1225 l 684 1071 l 547 1071 z \"},\"ờ\":{\"ha\":943,\"x_min\":62,\"x_max\":1007,\"o\":\"m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 576 749 508 772 q 692 679 644 726 q 793 872 793 709 l 997 872 l 1007 857 q 959 713 989 766 q 882 624 930 660 q 762 570 833 587 q 798 380 798 485 m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 860 0 m 418 842 q 292 938 375 871 q 163 1050 210 1005 l 163 1064 l 395 1064 q 555 860 438 996 l 555 842 l 418 842 z \"},\"Ở\":{\"ha\":1146,\"x_min\":81,\"x_max\":1187,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 876 81 745 q 555 1007 326 1007 q 911 869 790 1007 q 974 1055 974 911 l 1178 1055 l 1187 1040 q 1115 852 1163 920 q 983 750 1067 784 q 1025 497 1025 642 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 1105 0 m 742 1238 q 632 1104 742 1132 l 625 1056 l 507 1056 l 492 1156 q 561 1181 543 1164 q 579 1223 579 1198 q 565 1257 579 1245 q 528 1268 551 1268 q 433 1253 484 1268 l 433 1367 q 489 1378 454 1373 q 553 1382 525 1382 q 695 1344 648 1382 q 742 1238 742 1307 z \"},\"ở\":{\"ha\":943,\"x_min\":62,\"x_max\":1007,\"o\":\"m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 576 749 508 772 q 692 679 644 726 q 793 872 793 709 l 997 872 l 1007 857 q 959 713 989 766 q 882 624 930 660 q 762 570 833 587 q 798 380 798 485 m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 860 0 m 612 1008 q 503 875 612 903 l 496 827 l 378 827 l 362 926 q 431 952 413 935 q 450 994 450 969 q 435 1027 450 1016 q 398 1039 421 1039 q 304 1023 354 1039 l 304 1137 q 360 1148 324 1144 q 423 1153 395 1153 q 565 1115 518 1153 q 612 1008 612 1078 z \"},\"Ỡ\":{\"ha\":1146,\"x_min\":81,\"x_max\":1187,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 876 81 745 q 555 1007 326 1007 q 911 869 790 1007 q 974 1055 974 911 l 1178 1055 l 1187 1040 q 1115 852 1163 920 q 983 750 1067 784 q 1025 497 1025 642 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 1105 0 m 448 1142 q 407 1124 427 1142 q 379 1069 388 1106 l 278 1069 q 334 1223 286 1168 q 463 1279 382 1279 q 517 1268 490 1279 q 570 1243 544 1257 q 621 1219 596 1230 q 671 1208 646 1208 q 711 1226 692 1208 q 739 1280 730 1244 l 840 1280 q 784 1126 833 1182 q 656 1071 734 1071 q 601 1082 628 1071 q 548 1106 574 1093 q 497 1131 522 1120 q 448 1142 472 1142 z \"},\"ỡ\":{\"ha\":943,\"x_min\":62,\"x_max\":1007,\"o\":\"m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 576 749 508 772 q 692 679 644 726 q 793 872 793 709 l 997 872 l 1007 857 q 959 713 989 766 q 882 624 930 660 q 762 570 833 587 q 798 380 798 485 m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 860 0 m 323 913 q 283 895 302 913 q 255 840 264 877 l 154 840 q 210 994 161 939 q 338 1050 258 1050 q 393 1039 366 1050 q 446 1014 420 1027 q 497 990 472 1001 q 547 979 522 979 q 587 997 568 979 q 615 1051 606 1015 l 716 1051 q 660 897 709 953 q 532 842 610 842 q 477 853 504 842 q 424 877 450 864 q 373 902 398 890 q 323 913 348 913 z \"},\"Ợ\":{\"ha\":1146,\"x_min\":81,\"x_max\":1187,\"o\":\"m 1025 497 q 903 119 1025 251 q 553 -14 781 -14 q 203 119 325 -14 q 81 498 81 251 q 203 876 81 745 q 555 1007 326 1007 q 911 869 790 1007 q 974 1055 974 911 l 1178 1055 l 1187 1040 q 1115 852 1163 920 q 983 750 1067 784 q 1025 497 1025 642 m 301 497 q 364 247 301 331 q 553 163 427 163 q 804 497 804 163 q 554 832 804 832 q 365 748 429 832 q 301 497 301 663 m 1105 0 m 441 -191 q 554 -89 441 -89 q 667 -191 667 -89 q 638 -265 667 -239 q 554 -292 610 -292 q 441 -191 441 -292 z \"},\"ợ\":{\"ha\":943,\"x_min\":62,\"x_max\":1007,\"o\":\"m 798 380 q 700 91 798 195 q 428 -14 602 -14 q 235 34 319 -14 q 107 172 152 82 q 62 380 62 261 q 159 669 62 566 q 432 772 256 772 q 576 749 508 772 q 692 679 644 726 q 793 872 793 709 l 997 872 l 1007 857 q 959 713 989 766 q 882 624 930 660 q 762 570 833 587 q 798 380 798 485 m 273 380 q 310 210 273 268 q 431 153 347 153 q 550 210 513 153 q 586 380 586 267 q 549 549 586 493 q 429 606 513 606 q 310 550 347 606 q 273 380 273 494 m 860 0 m 319 -191 q 432 -89 319 -89 q 545 -191 545 -89 q 516 -265 545 -239 q 432 -292 488 -292 q 319 -191 319 -292 z \"},\"Ụ\":{\"ha\":1050,\"x_min\":118,\"x_max\":932,\"o\":\"m 932 991 l 932 350 q 883 157 932 240 q 741 31 833 75 q 521 -14 648 -14 q 224 84 330 -14 q 118 353 118 182 l 118 991 l 328 991 l 328 385 q 374 216 328 270 q 526 163 420 163 q 676 217 629 163 q 722 386 722 271 l 722 991 l 932 991 m 412 -191 q 525 -89 412 -89 q 637 -191 637 -89 q 609 -265 637 -239 q 525 -292 581 -292 q 412 -191 412 -292 z \"},\"ụ\":{\"ha\":913,\"x_min\":104,\"x_max\":804,\"o\":\"m 646 0 l 618 97 l 607 97 q 513 15 574 44 q 374 -14 452 -14 q 172 58 240 -14 q 104 264 104 130 l 104 758 l 311 758 l 311 315 q 340 192 311 233 q 433 151 370 151 q 559 209 520 151 q 597 401 597 267 l 597 758 l 804 758 l 804 0 l 646 0 m 342 -191 q 454 -89 342 -89 q 567 -191 567 -89 q 538 -265 567 -239 q 454 -292 510 -292 q 342 -191 342 -292 z \"},\"Ủ\":{\"ha\":1050,\"x_min\":118,\"x_max\":932,\"o\":\"m 932 991 l 932 350 q 883 157 932 240 q 741 31 833 75 q 521 -14 648 -14 q 224 84 330 -14 q 118 353 118 182 l 118 991 l 328 991 l 328 385 q 374 216 328 270 q 526 163 420 163 q 676 217 629 163 q 722 386 722 271 l 722 991 l 932 991 m 693 1238 q 583 1104 693 1132 l 576 1056 l 458 1056 l 443 1156 q 512 1181 494 1164 q 530 1223 530 1198 q 516 1257 530 1245 q 479 1268 502 1268 q 385 1253 435 1268 l 385 1367 q 440 1378 405 1373 q 504 1382 476 1382 q 646 1344 599 1382 q 693 1238 693 1307 z \"},\"ủ\":{\"ha\":913,\"x_min\":104,\"x_max\":804,\"o\":\"m 646 0 l 618 97 l 607 97 q 513 15 574 44 q 374 -14 452 -14 q 172 58 240 -14 q 104 264 104 130 l 104 758 l 311 758 l 311 315 q 340 192 311 233 q 433 151 370 151 q 559 209 520 151 q 597 401 597 267 l 597 758 l 804 758 l 804 0 l 646 0 m 624 1008 q 514 875 624 903 l 507 827 l 389 827 l 374 926 q 443 952 425 935 q 461 994 461 969 q 447 1027 461 1016 q 410 1039 433 1039 q 315 1023 366 1039 l 315 1137 q 371 1148 336 1144 q 435 1153 407 1153 q 577 1115 530 1153 q 624 1008 624 1078 z \"},\"Ứ\":{\"ha\":1229,\"x_min\":118,\"x_max\":1243,\"o\":\"m 932 991 l 932 864 q 1006 932 982 882 q 1029 1055 1029 983 l 1234 1055 l 1243 1040 q 1185 879 1221 936 q 1087 788 1149 823 q 932 739 1025 753 l 932 350 q 883 157 932 240 q 741 31 833 75 q 521 -14 648 -14 q 224 84 330 -14 q 118 353 118 182 l 118 991 l 328 991 l 328 368 q 375 213 328 262 q 526 163 423 163 q 676 215 629 163 q 722 370 722 267 l 722 991 l 932 991 m 1050 0 m 414 1071 l 414 1089 q 574 1293 531 1225 l 806 1293 l 806 1279 q 685 1174 770 1244 q 552 1071 600 1105 l 414 1071 z \"},\"ứ\":{\"ha\":1055,\"x_min\":104,\"x_max\":1120,\"o\":\"m 646 0 l 618 97 l 606 97 q 512 16 573 45 q 374 -14 452 -14 q 172 58 240 -14 q 104 264 104 130 l 104 758 l 311 758 l 311 315 q 340 192 311 233 q 433 151 370 151 q 559 209 520 151 q 597 401 597 267 l 597 758 l 804 758 l 804 679 q 879 744 852 694 q 905 872 905 793 l 1109 872 l 1120 857 q 1061 694 1098 751 q 963 603 1025 637 q 804 554 901 568 l 804 0 l 646 0 m 913 0 m 340 842 l 340 860 q 500 1064 457 996 l 732 1064 l 732 1050 q 611 945 696 1015 q 478 842 526 876 l 340 842 z \"},\"Ừ\":{\"ha\":1229,\"x_min\":118,\"x_max\":1243,\"o\":\"m 932 991 l 932 864 q 1006 932 982 882 q 1029 1055 1029 983 l 1234 1055 l 1243 1040 q 1185 879 1221 936 q 1087 788 1149 823 q 932 739 1025 753 l 932 350 q 883 157 932 240 q 741 31 833 75 q 521 -14 648 -14 q 224 84 330 -14 q 118 353 118 182 l 118 991 l 328 991 l 328 368 q 375 213 328 262 q 526 163 423 163 q 676 215 629 163 q 722 370 722 267 l 722 991 l 932 991 m 1050 0 m 493 1071 q 368 1167 450 1101 q 239 1279 285 1234 l 239 1293 l 471 1293 q 630 1089 513 1225 l 630 1071 l 493 1071 z \"},\"ừ\":{\"ha\":1055,\"x_min\":104,\"x_max\":1120,\"o\":\"m 646 0 l 618 97 l 606 97 q 512 16 573 45 q 374 -14 452 -14 q 172 58 240 -14 q 104 264 104 130 l 104 758 l 311 758 l 311 315 q 340 192 311 233 q 433 151 370 151 q 559 209 520 151 q 597 401 597 267 l 597 758 l 804 758 l 804 679 q 879 744 852 694 q 905 872 905 793 l 1109 872 l 1120 857 q 1061 694 1098 751 q 963 603 1025 637 q 804 554 901 568 l 804 0 l 646 0 m 913 0 m 416 842 q 291 938 374 871 q 162 1050 208 1005 l 162 1064 l 394 1064 q 553 860 437 996 l 553 842 l 416 842 z \"},\"Ử\":{\"ha\":1229,\"x_min\":118,\"x_max\":1243,\"o\":\"m 932 991 l 932 864 q 1006 932 982 882 q 1029 1055 1029 983 l 1234 1055 l 1243 1040 q 1185 879 1221 936 q 1087 788 1149 823 q 932 739 1025 753 l 932 350 q 883 157 932 240 q 741 31 833 75 q 521 -14 648 -14 q 224 84 330 -14 q 118 353 118 182 l 118 991 l 328 991 l 328 368 q 375 213 328 262 q 526 163 423 163 q 676 215 629 163 q 722 370 722 267 l 722 991 l 932 991 m 1050 0 m 697 1238 q 587 1104 697 1132 l 581 1056 l 463 1056 l 447 1156 q 516 1181 498 1164 q 534 1223 534 1198 q 520 1257 534 1245 q 483 1268 506 1268 q 389 1253 439 1268 l 389 1367 q 445 1378 409 1373 q 508 1382 480 1382 q 650 1344 603 1382 q 697 1238 697 1307 z \"},\"ử\":{\"ha\":1055,\"x_min\":104,\"x_max\":1120,\"o\":\"m 646 0 l 618 97 l 606 97 q 512 16 573 45 q 374 -14 452 -14 q 172 58 240 -14 q 104 264 104 130 l 104 758 l 311 758 l 311 315 q 340 192 311 233 q 433 151 370 151 q 559 209 520 151 q 597 401 597 267 l 597 758 l 804 758 l 804 679 q 879 744 852 694 q 905 872 905 793 l 1109 872 l 1120 857 q 1061 694 1098 751 q 963 603 1025 637 q 804 554 901 568 l 804 0 l 646 0 m 913 0 m 628 1008 q 518 875 628 903 l 511 827 l 393 827 l 378 926 q 447 952 429 935 q 465 994 465 969 q 451 1027 465 1016 q 414 1039 437 1039 q 319 1023 370 1039 l 319 1137 q 375 1148 340 1144 q 439 1153 411 1153 q 581 1115 534 1153 q 628 1008 628 1078 z \"},\"Ữ\":{\"ha\":1229,\"x_min\":118,\"x_max\":1243,\"o\":\"m 932 991 l 932 864 q 1006 932 982 882 q 1029 1055 1029 983 l 1234 1055 l 1243 1040 q 1185 879 1221 936 q 1087 788 1149 823 q 932 739 1025 753 l 932 350 q 883 157 932 240 q 741 31 833 75 q 521 -14 648 -14 q 224 84 330 -14 q 118 353 118 182 l 118 991 l 328 991 l 328 368 q 375 213 328 262 q 526 163 423 163 q 676 215 629 163 q 722 370 722 267 l 722 991 l 932 991 m 1050 0 m 414 1142 q 374 1124 393 1142 q 346 1069 355 1106 l 245 1069 q 301 1223 252 1168 q 429 1279 349 1279 q 484 1268 457 1279 q 537 1243 511 1257 q 588 1219 563 1230 q 637 1208 613 1208 q 678 1226 659 1208 q 706 1280 697 1244 l 807 1280 q 750 1126 800 1182 q 623 1071 701 1071 q 568 1082 595 1071 q 515 1106 541 1093 q 464 1131 489 1120 q 414 1142 439 1142 z \"},\"ữ\":{\"ha\":1055,\"x_min\":104,\"x_max\":1120,\"o\":\"m 646 0 l 618 97 l 606 97 q 512 16 573 45 q 374 -14 452 -14 q 172 58 240 -14 q 104 264 104 130 l 104 758 l 311 758 l 311 315 q 340 192 311 233 q 433 151 370 151 q 559 209 520 151 q 597 401 597 267 l 597 758 l 804 758 l 804 679 q 879 744 852 694 q 905 872 905 793 l 1109 872 l 1120 857 q 1061 694 1098 751 q 963 603 1025 637 q 804 554 901 568 l 804 0 l 646 0 m 913 0 m 345 913 q 304 895 323 913 q 276 840 285 877 l 175 840 q 231 994 182 939 q 359 1050 279 1050 q 414 1039 387 1050 q 467 1014 441 1027 q 518 990 493 1001 q 568 979 543 979 q 608 997 589 979 q 636 1051 627 1015 l 737 1051 q 681 897 730 953 q 553 842 631 842 q 498 853 525 842 q 445 877 471 864 q 394 902 419 890 q 345 913 369 913 z \"},\"Ự\":{\"ha\":1229,\"x_min\":118,\"x_max\":1243,\"o\":\"m 932 991 l 932 864 q 1006 932 982 882 q 1029 1055 1029 983 l 1234 1055 l 1243 1040 q 1185 879 1221 936 q 1087 788 1149 823 q 932 739 1025 753 l 932 350 q 883 157 932 240 q 741 31 833 75 q 521 -14 648 -14 q 224 84 330 -14 q 118 353 118 182 l 118 991 l 328 991 l 328 368 q 375 213 328 262 q 526 163 423 163 q 676 215 629 163 q 722 370 722 267 l 722 991 l 932 991 m 1050 0 m 406 -191 q 518 -89 406 -89 q 631 -191 631 -89 q 602 -265 631 -239 q 518 -292 574 -292 q 406 -191 406 -292 z \"},\"ự\":{\"ha\":1055,\"x_min\":104,\"x_max\":1120,\"o\":\"m 646 0 l 618 97 l 606 97 q 512 16 573 45 q 374 -14 452 -14 q 172 58 240 -14 q 104 264 104 130 l 104 758 l 311 758 l 311 315 q 340 192 311 233 q 433 151 370 151 q 559 209 520 151 q 597 401 597 267 l 597 758 l 804 758 l 804 679 q 879 744 852 694 q 905 872 905 793 l 1109 872 l 1120 857 q 1061 694 1098 751 q 963 603 1025 637 q 804 554 901 568 l 804 0 l 646 0 m 913 0 m 336 -191 q 449 -89 336 -89 q 562 -191 562 -89 q 533 -265 562 -239 q 449 -292 505 -292 q 336 -191 336 -292 z \"},\"Ỵ\":{\"ha\":867,\"x_min\":0,\"x_max\":867,\"o\":\"m 433 583 l 640 991 l 867 991 l 538 386 l 538 0 l 329 0 l 329 379 l 0 991 l 228 991 l 433 583 m 319 -191 q 432 -89 319 -89 q 545 -191 545 -89 q 516 -265 545 -239 q 432 -292 488 -292 q 319 -191 319 -292 z \"},\"ỵ\":{\"ha\":790,\"x_min\":0,\"x_max\":790,\"o\":\"m 0 758 l 227 758 l 370 332 q 395 200 388 276 l 399 200 q 428 332 406 270 l 568 758 l 790 758 l 469 -97 q 343 -275 425 -216 q 153 -334 262 -334 q 47 -322 99 -334 l 47 -158 q 129 -167 85 -167 q 225 -133 184 -167 q 289 -32 266 -100 l 301 5 l 0 758 m 553 -191 q 665 -89 553 -89 q 778 -191 778 -89 q 749 -265 778 -239 q 665 -292 721 -292 q 553 -191 553 -292 z \"},\"Ỷ\":{\"ha\":867,\"x_min\":0,\"x_max\":867,\"o\":\"m 433 583 l 640 991 l 867 991 l 538 386 l 538 0 l 329 0 l 329 379 l 0 991 l 228 991 l 433 583 m 603 1238 q 493 1104 603 1132 l 486 1056 l 368 1056 l 353 1156 q 422 1181 404 1164 q 440 1223 440 1198 q 426 1257 440 1245 q 389 1268 412 1268 q 294 1253 345 1268 l 294 1367 q 350 1378 315 1373 q 414 1382 386 1382 q 556 1344 509 1382 q 603 1238 603 1307 z \"},\"ỷ\":{\"ha\":790,\"x_min\":0,\"x_max\":790,\"o\":\"m 0 758 l 227 758 l 370 332 q 395 200 388 276 l 399 200 q 428 332 406 270 l 568 758 l 790 758 l 469 -97 q 343 -275 425 -216 q 153 -334 262 -334 q 47 -322 99 -334 l 47 -158 q 129 -167 85 -167 q 225 -133 184 -167 q 289 -32 266 -100 l 301 5 l 0 758 m 566 1008 q 456 875 566 903 l 449 827 l 331 827 l 315 926 q 385 952 366 935 q 403 994 403 969 q 389 1027 403 1016 q 351 1039 374 1039 q 257 1023 307 1039 l 257 1137 q 313 1148 277 1144 q 376 1153 349 1153 q 518 1115 471 1153 q 566 1008 566 1078 z \"},\"Ỹ\":{\"ha\":867,\"x_min\":0,\"x_max\":867,\"o\":\"m 433 583 l 640 991 l 867 991 l 538 386 l 538 0 l 329 0 l 329 379 l 0 991 l 228 991 l 433 583 m 322 1142 q 282 1124 301 1142 q 254 1069 262 1106 l 153 1069 q 209 1223 160 1168 q 337 1279 257 1279 q 392 1268 365 1279 q 445 1243 418 1257 q 496 1219 471 1230 q 545 1208 521 1208 q 586 1226 566 1208 q 614 1280 605 1244 l 715 1280 q 658 1126 707 1182 q 530 1071 609 1071 q 476 1082 503 1071 q 423 1106 449 1093 q 372 1131 397 1120 q 322 1142 347 1142 z \"},\"ỹ\":{\"ha\":790,\"x_min\":0,\"x_max\":790,\"o\":\"m 0 758 l 227 758 l 370 332 q 395 200 388 276 l 399 200 q 428 332 406 270 l 568 758 l 790 758 l 469 -97 q 343 -275 425 -216 q 153 -334 262 -334 q 47 -322 99 -334 l 47 -158 q 129 -167 85 -167 q 225 -133 184 -167 q 289 -32 266 -100 l 301 5 l 0 758 m 288 913 q 248 895 267 913 q 220 840 229 877 l 119 840 q 175 994 126 939 q 303 1050 223 1050 q 358 1039 331 1050 q 411 1014 385 1027 q 462 990 437 1001 q 511 979 487 979 q 552 997 532 979 q 580 1051 571 1015 l 681 1051 q 624 897 673 953 q 496 842 575 842 q 442 853 469 842 q 389 877 415 864 q 338 902 363 890 q 288 913 313 913 z \"},\"₫\":{\"ha\":901,\"x_min\":62,\"x_max\":876,\"o\":\"m 342 -14 q 137 84 212 -14 q 62 357 62 182 q 130 639 62 548 q 349 730 197 730 q 479 702 422 730 q 572 619 536 673 l 579 619 q 564 777 564 708 l 564 811 l 350 811 l 350 946 l 564 946 l 564 1055 l 771 1055 l 771 946 l 876 946 l 876 811 l 771 811 l 771 0 l 603 0 l 559 98 l 551 98 q 342 -14 481 -14 m 429 151 q 539 193 504 151 q 578 336 575 235 l 578 355 q 544 518 578 475 q 419 562 509 562 q 316 515 344 562 q 288 354 288 469 q 321 202 288 253 q 429 151 355 151 m 721 -220 l 144 -220 l 144 -125 l 721 -125 l 721 -220 z \"},\"̏\":{\"ha\":0,\"x_min\":-782,\"x_max\":-191,\"o\":\"m -300 842 q -416 944 -342 875 q -513 1050 -490 1013 l -513 1064 l -309 1064 q -252 957 -286 1015 q -191 860 -218 898 l -191 842 l -300 842 m -570 842 q -690 948 -619 880 q -782 1050 -761 1016 l -782 1064 l -578 1064 q -522 957 -555 1015 q -460 860 -488 898 l -460 842 l -570 842 z \"},\"ﬀ\":{\"ha\":1075,\"x_min\":28,\"x_max\":1138,\"o\":\"m 528 603 l 349 603 l 349 0 l 142 0 l 142 603 l 28 603 l 28 703 l 142 758 l 142 814 q 205 1003 142 943 q 410 1063 269 1063 q 600 1031 517 1063 l 547 879 q 432 899 485 899 q 368 872 388 899 q 349 806 349 846 l 349 758 l 528 758 l 528 603 m 1065 603 l 886 603 l 886 0 l 680 0 l 680 603 l 566 603 l 566 703 l 680 758 l 680 814 q 743 1003 680 943 q 947 1063 807 1063 q 1138 1031 1055 1063 l 1085 879 q 970 899 1023 899 q 906 872 926 899 q 886 806 886 846 l 886 758 l 1065 758 l 1065 603 z \"},\"℠\":{\"ha\":1021,\"x_min\":56,\"x_max\":958,\"o\":\"m 364 642 q 317 535 364 574 q 191 497 270 497 q 56 526 115 497 l 56 624 q 193 587 134 587 q 240 601 224 587 q 256 637 256 614 q 244 669 256 656 q 207 694 232 682 q 109 750 134 730 q 72 797 85 770 q 58 859 58 823 q 102 960 58 922 q 222 999 145 999 q 363 964 287 999 l 328 879 q 269 903 290 897 q 222 908 249 908 q 182 897 197 908 q 167 863 167 886 q 181 827 167 842 q 245 787 195 812 q 340 721 317 753 q 364 642 364 690 m 629 503 l 517 861 l 513 861 l 515 786 l 515 503 l 404 503 l 404 991 l 572 991 l 681 646 l 796 991 l 958 991 l 958 503 l 844 503 l 844 779 l 847 861 l 843 861 l 725 503 l 629 503 z \"},\"Ţ\":{\"ha\":804,\"x_min\":28,\"x_max\":777,\"o\":\"m 507 0 l 297 0 l 297 817 l 28 817 l 28 991 l 777 991 l 777 817 l 507 817 l 507 0 m 563 -170 q 512 -295 563 -256 q 353 -334 460 -334 q 254 -319 300 -334 l 254 -205 q 303 -215 273 -210 q 351 -220 334 -220 q 400 -178 400 -220 q 288 -104 400 -121 l 340 0 l 471 0 l 453 -41 q 533 -92 503 -58 q 563 -170 563 -126 z \"},\"ţ\":{\"ha\":603,\"x_min\":32,\"x_max\":558,\"o\":\"m 428 151 q 558 175 482 151 l 558 21 q 368 -14 481 -14 q 188 49 244 -14 q 131 237 131 112 l 131 603 l 32 603 l 32 690 l 146 760 l 205 920 l 338 920 l 338 758 l 550 758 l 550 603 l 338 603 l 338 237 q 362 172 338 193 q 428 151 387 151 m 502 -170 q 451 -295 502 -256 q 292 -334 399 -334 q 193 -319 239 -334 l 193 -205 q 242 -215 212 -210 q 290 -220 273 -220 q 339 -178 339 -220 q 227 -104 339 -121 l 279 0 l 410 0 l 392 -41 q 472 -92 442 -58 q 502 -170 502 -126 z \"},\"I\":{\"ha\":460,\"x_min\":125,\"x_max\":335,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 0 l 125 0 z \"},\"Ì\":{\"ha\":460,\"x_min\":-39,\"x_max\":352,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 0 l 125 0 m 215 1071 q 90 1167 172 1101 q -39 1279 7 1234 l -39 1293 l 193 1293 q 352 1089 235 1225 l 352 1071 l 215 1071 z \"},\"Í\":{\"ha\":460,\"x_min\":113,\"x_max\":505,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 0 l 125 0 m 113 1071 l 113 1089 q 273 1293 230 1225 l 505 1293 l 505 1279 q 384 1174 469 1244 q 251 1071 299 1105 l 113 1071 z \"},\"Î\":{\"ha\":460,\"x_min\":-65,\"x_max\":524,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 0 l 125 0 m 387 1071 q 228 1190 280 1134 q 73 1071 175 1135 l -65 1071 l -65 1089 q 109 1293 63 1217 l 351 1293 q 424 1197 372 1258 q 524 1089 475 1137 l 524 1071 l 387 1071 z \"},\"Ï\":{\"ha\":460,\"x_min\":-2,\"x_max\":463,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 0 l 125 0 m -2 1182 q 23 1250 -2 1226 q 92 1274 49 1274 q 162 1249 137 1274 q 188 1182 188 1223 q 162 1117 188 1141 q 92 1092 136 1092 q 23 1116 49 1092 q -2 1182 -2 1139 m 271 1182 q 299 1252 271 1230 q 367 1274 326 1274 q 437 1249 411 1274 q 463 1182 463 1225 q 437 1116 463 1141 q 367 1092 410 1092 q 299 1114 326 1092 q 271 1182 271 1136 z \"},\"Ĩ\":{\"ha\":460,\"x_min\":-51,\"x_max\":511,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 0 l 125 0 m 119 1142 q 78 1124 98 1142 q 50 1069 59 1106 l -51 1069 q 5 1223 -43 1168 q 134 1279 54 1279 q 188 1268 161 1279 q 241 1243 215 1257 q 292 1219 267 1230 q 342 1208 317 1208 q 382 1226 363 1208 q 410 1280 401 1244 l 511 1280 q 455 1126 504 1182 q 327 1071 406 1071 q 272 1082 299 1071 q 219 1106 245 1093 q 168 1131 193 1120 q 119 1142 143 1142 z \"},\"Ī\":{\"ha\":460,\"x_min\":2,\"x_max\":462,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 0 l 125 0 m 2 1214 l 462 1214 l 462 1071 l 2 1071 l 2 1214 z \"},\"Ĭ\":{\"ha\":460,\"x_min\":-36,\"x_max\":498,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 0 l 125 0 m 498 1300 q 415 1133 490 1196 q 228 1071 340 1071 q 40 1133 110 1071 q -36 1300 -31 1194 l 79 1300 q 98 1250 82 1268 q 143 1223 114 1232 q 229 1215 172 1215 q 380 1300 369 1215 l 498 1300 z \"},\"Į\":{\"ha\":460,\"x_min\":75,\"x_max\":350,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 0 l 125 0 m 218 -154 q 233 -196 218 -182 q 272 -210 248 -210 q 350 -197 309 -210 l 350 -318 q 244 -334 294 -334 q 121 -291 168 -334 q 75 -178 75 -248 q 100 -92 75 -132 q 197 0 126 -52 l 318 0 q 244 -82 271 -45 q 218 -154 218 -119 z \"},\"İ\":{\"ha\":460,\"x_min\":117,\"x_max\":342,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 0 l 125 0 m 117 1183 q 229 1284 117 1284 q 342 1183 342 1284 q 314 1108 342 1135 q 229 1082 286 1082 q 117 1183 117 1082 z \"},\"Ĳ\":{\"ha\":1000,\"x_min\":125,\"x_max\":876,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 0 l 125 0 m 562 -292 q 437 -277 490 -292 l 437 -102 q 536 -115 492 -115 q 635 -72 606 -115 q 665 62 665 -29 l 665 991 l 876 991 l 876 64 q 796 -201 876 -110 q 562 -292 717 -292 z \"},\"Ί\":{\"ha\":711,\"x_min\":-67,\"x_max\":506,\"o\":\"m 296 0 l 296 991 l 506 991 l 506 0 l 296 0 m -67 791 q -37 903 -55 828 q -12 1034 -19 977 l 180 1034 l 180 1018 q 54 770 127 892 l -67 770 l -67 791 z \"},\"Ι\":{\"ha\":460,\"x_min\":125,\"x_max\":335,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 0 l 125 0 z \"},\"Ϊ\":{\"ha\":460,\"x_min\":-2,\"x_max\":463,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 0 l 125 0 m -2 1182 q 23 1250 -2 1226 q 92 1274 49 1274 q 162 1249 137 1274 q 188 1182 188 1223 q 162 1117 188 1141 q 92 1092 136 1092 q 23 1116 49 1092 q -2 1182 -2 1139 m 271 1182 q 299 1252 271 1230 q 367 1274 326 1274 q 437 1249 411 1274 q 463 1182 463 1225 q 437 1116 463 1141 q 367 1092 410 1092 q 299 1114 326 1092 q 271 1182 271 1136 z \"},\"І\":{\"ha\":460,\"x_min\":125,\"x_max\":335,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 0 l 125 0 z \"},\"Ї\":{\"ha\":460,\"x_min\":-2,\"x_max\":463,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 0 l 125 0 m -2 1182 q 23 1250 -2 1226 q 92 1274 49 1274 q 162 1249 137 1274 q 188 1182 188 1223 q 162 1117 188 1141 q 92 1092 136 1092 q 23 1116 49 1092 q -2 1182 -2 1139 m 271 1182 q 299 1252 271 1230 q 367 1274 326 1274 q 437 1249 411 1274 q 463 1182 463 1225 q 437 1116 463 1141 q 367 1092 410 1092 q 299 1114 326 1092 q 271 1182 271 1136 z \"},\"Ӏ\":{\"ha\":460,\"x_min\":125,\"x_max\":335,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 0 l 125 0 z \"},\"ӏ\":{\"ha\":460,\"x_min\":125,\"x_max\":335,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 0 l 125 0 z \"},\"Ỉ\":{\"ha\":460,\"x_min\":94,\"x_max\":403,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 0 l 125 0 m 403 1238 q 293 1104 403 1132 l 286 1056 l 168 1056 l 153 1156 q 222 1181 203 1164 q 240 1223 240 1198 q 226 1257 240 1245 q 189 1268 212 1268 q 94 1253 144 1268 l 94 1367 q 150 1378 115 1373 q 214 1382 186 1382 q 356 1344 309 1382 q 403 1238 403 1307 z \"},\"Ị\":{\"ha\":460,\"x_min\":117,\"x_max\":342,\"o\":\"m 125 0 l 125 991 l 335 991 l 335 0 l 125 0 m 117 -191 q 229 -89 117 -89 q 342 -191 342 -89 q 313 -265 342 -239 q 229 -292 285 -292 q 117 -191 117 -292 z \"}},\"familyName\":\"Open Sans\",\"ascender\":1485,\"descender\":-407,\"underlinePosition\":-104,\"underlineThickness\":69,\"boundingBox\":{\"yMin\":-407,\"xMin\":-860,\"yMax\":1485,\"xMax\":1832},\"resolution\":1000,\"original_font_information\":{\"format\":0,\"copyright\":\"Digitized data copyright © 2010-2011, Google Corporation.\",\"fontFamily\":\"Open Sans\",\"fontSubfamily\":\"Bold\",\"uniqueID\":\"1.10;1ASC;OpenSans-Bold\",\"fullName\":\"Open Sans Bold\",\"version\":\"Version 1.10\",\"postScriptName\":\"OpenSans-Bold\",\"trademark\":\"Open Sans is a trademark of Google and may be registered in certain jurisdictions.\",\"manufacturer\":\"Ascender Corporation\",\"manufacturerURL\":\"http://www.ascendercorp.com/\",\"designerURL\":\"http://www.ascendercorp.com/typedesigners.html\",\"licence\":\"Licensed under the Apache License, Version 2.0\",\"licenceURL\":\"http://www.apache.org/licenses/LICENSE-2.0\"},\"cssFontWeight\":\"bold\",\"cssFontStyle\":\"normal\"}");

/***/ }),

/***/ "./src/Open_Sans_Bold_Italic.json":
/*!****************************************!*\
  !*** ./src/Open_Sans_Bold_Italic.json ***!
  \****************************************/
/*! exports provided: glyphs, familyName, ascender, descender, underlinePosition, underlineThickness, boundingBox, resolution, original_font_information, cssFontWeight, cssFontStyle, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"glyphs\":{\"0\":{\"ha\":765,\"x_min\":45,\"x_max\":753,\"o\":\"m 753 686 q 638 177 753 368 q 318 -14 524 -14 q 114 69 184 -14 q 45 317 45 152 q 102 681 45 518 q 256 925 159 844 q 482 1007 354 1007 q 753 686 753 1007 m 464 838 q 362 767 410 838 q 283 562 315 696 q 250 313 250 428 q 269 195 250 235 q 335 155 288 155 q 437 227 390 155 q 516 431 484 299 q 547 693 547 564 q 527 803 547 768 q 464 838 506 838 z \"},\"1\":{\"ha\":765,\"x_min\":123,\"x_max\":676,\"o\":\"m 467 0 l 260 0 l 382 562 q 433 757 406 665 q 392 725 427 751 q 214 610 356 699 l 123 755 l 507 991 l 676 991 l 467 0 z \"},\"2\":{\"ha\":765,\"x_min\":-33,\"x_max\":745,\"o\":\"m 619 0 l -33 0 l -4 144 l 319 432 q 488 605 441 540 q 534 726 534 669 q 507 804 534 777 q 432 831 479 831 q 340 808 387 831 q 224 728 293 785 l 125 865 q 296 974 214 941 q 465 1006 377 1006 q 669 939 594 1006 q 745 764 745 873 q 717 627 745 691 q 634 500 689 564 q 453 334 578 436 l 271 183 l 271 176 l 656 176 l 619 0 z \"},\"3\":{\"ha\":765,\"x_min\":9,\"x_max\":749,\"o\":\"m 749 779 q 685 602 749 673 q 507 510 621 530 l 507 507 q 642 435 596 490 q 688 298 688 380 q 637 137 688 208 q 494 26 587 66 q 272 -14 400 -14 q 9 40 110 -14 l 9 221 q 133 170 66 187 q 262 153 199 153 q 427 196 370 153 q 485 315 485 239 q 310 432 485 432 l 216 432 l 248 582 l 297 582 q 475 624 410 582 q 541 741 541 666 q 511 811 541 786 q 429 836 482 836 q 235 768 338 836 l 149 907 q 306 984 233 962 q 473 1006 380 1006 q 675 944 602 1006 q 749 779 749 883 z \"},\"4\":{\"ha\":765,\"x_min\":-17,\"x_max\":749,\"o\":\"m 697 205 l 582 205 l 539 0 l 340 0 l 383 205 l -17 205 l 16 364 l 538 991 l 749 991 l 616 368 l 732 368 l 697 205 m 418 368 l 457 536 q 484 648 465 576 q 513 743 503 720 l 509 743 q 419 621 485 701 l 207 368 l 418 368 z \"},\"5\":{\"ha\":765,\"x_min\":18,\"x_max\":765,\"o\":\"m 422 625 q 618 555 547 625 q 690 361 690 486 q 642 163 690 248 q 500 32 593 78 q 277 -14 408 -14 q 129 2 197 -14 q 18 41 60 18 l 18 224 q 257 157 136 157 q 420 205 361 157 q 479 336 479 253 q 440 432 479 400 q 328 464 401 464 q 183 441 258 464 l 113 494 l 253 991 l 765 991 l 728 814 l 396 814 l 336 615 q 422 625 385 625 z \"},\"6\":{\"ha\":765,\"x_min\":60,\"x_max\":782,\"o\":\"m 60 318 q 101 586 60 455 q 215 813 142 718 q 389 958 287 909 q 631 1007 490 1007 q 782 989 715 1007 l 747 822 q 618 839 690 839 q 405 766 486 839 q 279 532 324 692 l 282 532 q 493 644 360 644 q 657 578 600 644 q 715 393 715 513 q 667 181 715 279 q 538 35 619 83 q 350 -14 457 -14 q 133 73 206 -14 q 60 318 60 159 m 359 154 q 469 218 427 154 q 511 378 511 281 q 489 455 511 426 q 419 484 466 484 q 341 459 378 484 q 282 395 304 435 q 260 286 260 354 q 287 189 260 224 q 359 154 314 154 z \"},\"7\":{\"ha\":765,\"x_min\":53,\"x_max\":825,\"o\":\"m 53 0 l 553 815 l 126 815 l 164 991 l 825 991 l 798 860 l 288 0 l 53 0 z \"},\"8\":{\"ha\":765,\"x_min\":37,\"x_max\":764,\"o\":\"m 489 1007 q 635 979 572 1007 q 731 899 698 950 q 764 781 764 847 q 709 622 764 690 q 553 519 654 555 q 700 272 700 424 q 657 124 700 189 q 534 22 614 58 q 349 -14 454 -14 q 120 54 203 -14 q 37 237 37 122 q 273 526 37 439 q 161 729 161 616 q 201 873 161 810 q 315 972 240 937 q 489 1007 389 1007 m 395 436 q 277 363 316 406 q 239 260 239 321 q 273 173 239 205 q 364 140 307 140 q 464 177 427 140 q 501 271 501 213 q 476 360 501 320 q 395 436 452 399 m 471 854 q 389 823 419 854 q 358 742 358 791 q 441 606 358 652 q 567 755 567 654 q 540 828 567 802 q 471 854 513 854 z \"},\"9\":{\"ha\":765,\"x_min\":58,\"x_max\":741,\"o\":\"m 741 679 q 673 317 741 489 q 494 66 606 146 q 221 -14 382 -14 q 58 8 134 -14 l 58 182 q 212 154 134 154 q 353 187 294 154 q 451 281 412 220 q 518 456 490 342 l 515 456 q 315 349 440 349 q 144 419 205 349 q 83 612 83 489 q 133 820 83 725 q 266 961 182 914 q 460 1007 349 1007 q 669 924 597 1007 q 741 679 741 840 m 437 839 q 359 810 393 839 q 306 733 325 782 q 288 629 288 684 q 313 540 288 570 q 385 510 338 510 q 460 535 425 510 q 516 603 495 559 q 536 710 536 646 q 512 803 536 767 q 437 839 488 839 z \"},\" \":{\"ha\":361,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\"!\":{\"ha\":397,\"x_min\":17,\"x_max\":439,\"o\":\"m 265 329 l 102 329 l 208 991 l 439 991 l 265 329 m 17 78 q 53 176 17 139 q 155 212 90 212 q 229 186 201 212 q 257 114 257 161 q 220 18 257 55 q 122 -18 182 -18 q 45 7 73 -18 q 17 78 17 33 z \"},\"\\\"\":{\"ha\":629,\"x_min\":136,\"x_max\":647,\"o\":\"m 372 991 l 269 633 l 136 633 l 184 991 l 372 991 m 647 991 l 545 633 l 410 633 l 460 991 l 647 991 z \"},\"#\":{\"ha\":897,\"x_min\":28,\"x_max\":904,\"o\":\"m 703 574 l 656 416 l 831 416 l 818 277 l 616 277 l 538 0 l 389 0 l 468 277 l 336 277 l 258 0 l 113 0 l 189 277 l 28 277 l 40 416 l 228 416 l 275 574 l 104 574 l 117 715 l 313 715 l 393 991 l 541 991 l 461 715 l 596 715 l 675 991 l 821 991 l 742 715 l 904 715 l 892 574 l 703 574 m 375 416 l 509 416 l 555 574 l 422 574 l 375 416 z \"},\"$\":{\"ha\":765,\"x_min\":35,\"x_max\":760,\"o\":\"m 701 336 q 616 139 701 212 q 367 54 531 66 l 340 -81 l 245 -81 l 275 56 q 35 114 134 64 l 35 294 q 309 215 169 222 l 357 433 q 193 536 246 475 q 140 681 140 597 q 227 870 140 798 q 464 953 313 943 l 488 1055 l 582 1055 l 559 953 q 760 892 672 938 l 688 734 q 524 785 598 779 l 481 582 q 613 514 570 547 q 679 438 656 481 q 701 336 701 394 m 403 218 q 472 249 446 224 q 498 315 498 273 q 482 367 498 347 q 441 396 465 387 l 403 218 m 429 785 q 364 757 387 780 q 340 693 340 734 q 395 618 340 640 l 429 785 z \"},\"%\":{\"ha\":1189,\"x_min\":78,\"x_max\":1139,\"o\":\"m 351 864 q 276 777 309 864 q 244 589 244 690 q 282 524 244 524 q 358 612 326 524 q 390 799 390 701 q 351 864 390 864 m 557 790 q 519 580 557 677 q 416 433 481 482 q 269 383 352 383 q 126 440 175 383 q 78 600 78 496 q 116 811 78 715 q 216 957 153 908 q 363 1006 279 1006 q 506 951 456 1006 q 557 790 557 897 m 1054 991 l 319 0 l 157 0 l 895 991 l 1054 991 m 933 468 q 882 430 907 468 q 842 326 858 392 q 827 193 827 259 q 864 127 827 127 q 916 165 892 127 q 957 270 941 202 q 972 403 972 337 q 933 468 972 468 m 1139 400 q 1102 188 1139 287 q 1002 38 1065 88 q 856 -12 938 -12 q 709 41 758 -12 q 660 192 660 94 q 696 411 660 312 q 796 559 732 509 q 945 610 861 610 q 1088 556 1038 610 q 1139 400 1139 503 z \"},\"&\":{\"ha\":983,\"x_min\":46,\"x_max\":970,\"o\":\"m 899 0 l 661 0 l 612 66 q 339 -14 494 -14 q 122 53 197 -14 q 46 243 46 119 q 99 411 46 341 q 285 547 153 481 q 233 722 233 635 q 313 931 233 854 q 528 1007 393 1007 q 708 951 642 1007 q 774 799 774 895 q 526 510 774 609 l 659 332 q 713 414 688 370 q 766 532 738 458 l 970 532 q 760 195 880 319 l 899 0 m 367 422 q 283 352 307 388 q 260 262 260 315 q 291 189 260 218 q 370 160 321 160 q 519 200 448 160 l 367 422 m 449 624 q 554 699 526 664 q 583 775 583 734 q 563 831 583 814 q 515 848 543 848 q 446 817 471 848 q 421 736 421 785 q 429 673 421 705 q 449 624 437 642 z \"},\"'\":{\"ha\":354,\"x_min\":136,\"x_max\":372,\"o\":\"m 372 991 l 269 633 l 136 633 l 184 991 l 372 991 z \"},\"(\":{\"ha\":471,\"x_min\":50,\"x_max\":570,\"o\":\"m 50 191 q 133 615 50 420 q 392 991 216 810 l 570 991 q 314 603 397 803 q 231 183 231 402 q 310 -220 231 -26 l 151 -220 q 50 191 50 -39 z \"},\")\":{\"ha\":471,\"x_min\":-100,\"x_max\":419,\"o\":\"m 419 582 q 335 154 419 350 q 78 -220 251 -41 l -100 -220 q 239 589 239 150 q 160 991 239 797 l 318 991 q 419 582 419 812 z \"},\"*\":{\"ha\":757,\"x_min\":117,\"x_max\":786,\"o\":\"m 600 1032 l 524 793 l 786 812 l 774 640 l 545 669 l 653 441 l 486 392 l 425 621 l 292 432 l 151 543 l 338 711 l 117 774 l 175 935 l 404 817 l 427 1067 l 600 1032 z \"},\"+\":{\"ha\":765,\"x_min\":74,\"x_max\":720,\"o\":\"m 322 415 l 74 415 l 74 564 l 322 564 l 322 814 l 471 814 l 471 564 l 720 564 l 720 415 l 471 415 l 471 168 l 322 168 l 322 415 z \"},\",\":{\"ha\":386,\"x_min\":-69,\"x_max\":261,\"o\":\"m 256 161 l 261 146 q 83 -179 181 -27 l -69 -179 q 62 161 -19 -66 l 256 161 z \"},\"-\":{\"ha\":447,\"x_min\":28,\"x_max\":419,\"o\":\"m 28 288 l 64 457 l 419 457 l 383 288 l 28 288 z \"},\".\":{\"ha\":396,\"x_min\":17,\"x_max\":257,\"o\":\"m 17 78 q 53 176 17 139 q 155 212 90 212 q 229 186 201 212 q 257 114 257 161 q 220 18 257 55 q 122 -18 182 -18 q 45 7 73 -18 q 17 78 17 33 z \"},\"/\":{\"ha\":585,\"x_min\":-61,\"x_max\":688,\"o\":\"m 688 991 l 139 0 l -61 0 l 488 991 l 688 991 z \"},\":\":{\"ha\":396,\"x_min\":17,\"x_max\":380,\"o\":\"m 140 637 q 178 736 140 700 q 279 772 216 772 q 353 746 326 772 q 380 673 380 720 q 343 578 380 615 q 245 542 307 542 q 169 567 197 542 q 140 637 140 591 m 17 78 q 53 176 17 139 q 155 212 90 212 q 229 186 201 212 q 257 114 257 161 q 220 18 257 55 q 122 -18 182 -18 q 45 7 73 -18 q 17 78 17 33 z \"},\";\":{\"ha\":396,\"x_min\":-69,\"x_max\":380,\"o\":\"m 261 146 q 83 -179 181 -27 l -69 -179 q 62 161 -19 -66 l 256 161 l 261 146 m 140 637 q 178 736 140 700 q 279 772 216 772 q 353 746 326 772 q 380 673 380 720 q 343 578 380 615 q 245 542 307 542 q 169 567 197 542 q 140 637 140 591 z \"},\"<\":{\"ha\":765,\"x_min\":74,\"x_max\":720,\"o\":\"m 720 138 l 74 435 l 74 532 l 720 868 l 720 705 l 283 490 l 720 300 l 720 138 z \"},\"=\":{\"ha\":765,\"x_min\":74,\"x_max\":720,\"o\":\"m 74 547 l 74 694 l 720 694 l 720 547 l 74 547 m 74 283 l 74 432 l 720 432 l 720 283 l 74 283 z \"},\">\":{\"ha\":765,\"x_min\":74,\"x_max\":720,\"o\":\"m 74 300 l 510 490 l 74 705 l 74 868 l 720 532 l 720 435 l 74 138 l 74 300 z \"},\"?\":{\"ha\":637,\"x_min\":113,\"x_max\":682,\"o\":\"m 176 329 l 186 382 q 236 502 199 452 q 353 607 273 552 q 459 693 437 664 q 482 758 482 722 q 392 839 482 839 q 320 828 358 839 q 183 771 281 817 l 121 921 q 422 1006 277 1006 q 612 946 543 1006 q 682 781 682 887 q 663 679 682 724 q 607 596 644 634 q 478 496 570 557 q 413 446 435 467 q 377 402 391 426 q 351 329 363 379 l 176 329 m 113 78 q 150 176 113 140 q 252 212 187 212 q 325 186 298 212 q 353 114 353 161 q 315 18 353 55 q 218 -18 278 -18 q 140 7 168 -18 q 113 78 113 33 z \"},\"@\":{\"ha\":1189,\"x_min\":62,\"x_max\":1175,\"o\":\"m 1175 570 q 1132 352 1175 452 q 1011 195 1088 252 q 839 139 935 139 q 741 165 779 139 q 692 239 703 191 l 688 239 q 611 163 654 186 q 511 139 568 139 q 377 193 425 139 q 329 349 329 247 q 375 536 329 448 q 502 675 420 624 q 684 726 583 726 q 905 689 809 726 l 833 404 q 821 352 826 374 q 815 309 815 330 q 854 262 815 262 q 939 306 899 262 q 1001 422 978 349 q 1025 567 1025 494 q 941 788 1025 711 q 697 864 857 864 q 449 800 559 864 q 276 620 338 736 q 214 354 214 503 q 304 96 214 189 q 559 3 395 3 q 708 16 639 3 q 859 61 778 30 l 859 -65 q 543 -126 703 -126 q 287 -68 396 -126 q 120 96 178 -10 q 62 339 62 201 q 144 676 62 528 q 377 908 226 824 q 714 991 528 991 q 1053 881 930 991 q 1175 570 1175 770 m 675 603 q 576 568 619 603 q 508 475 533 533 q 484 357 484 417 q 500 288 484 313 q 547 262 517 262 q 692 446 643 262 l 730 596 q 675 603 706 603 z \"},\"A\":{\"ha\":872,\"x_min\":-83,\"x_max\":789,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 z \"},\"B\":{\"ha\":861,\"x_min\":36,\"x_max\":848,\"o\":\"m 534 991 q 769 936 690 991 q 848 771 848 881 q 792 603 848 669 q 632 515 736 537 l 632 511 q 740 446 700 494 q 781 323 781 398 q 677 84 781 168 q 390 0 573 0 l 36 0 l 245 991 l 534 991 m 370 599 l 471 599 q 594 632 553 599 q 635 726 635 665 q 519 819 635 819 l 416 819 l 370 599 m 279 174 l 401 174 q 526 213 481 174 q 571 322 571 252 q 447 432 571 432 l 335 432 l 279 174 z \"},\"C\":{\"ha\":850,\"x_min\":83,\"x_max\":905,\"o\":\"m 614 832 q 453 777 524 832 q 338 615 381 722 q 294 386 294 509 q 341 218 294 273 q 489 163 387 163 q 718 215 588 163 l 718 39 q 447 -14 583 -14 q 179 88 275 -14 q 83 375 83 189 q 154 702 83 553 q 342 929 224 852 q 614 1007 460 1007 q 764 992 699 1007 q 905 936 830 977 l 825 766 q 707 819 753 806 q 614 832 660 832 z \"},\"D\":{\"ha\":940,\"x_min\":36,\"x_max\":897,\"o\":\"m 897 616 q 831 287 897 427 q 638 73 764 146 q 342 0 513 0 l 36 0 l 245 991 l 514 991 q 797 895 697 991 q 897 616 897 798 m 351 174 q 526 225 452 174 q 643 377 601 277 q 685 606 685 477 q 636 765 685 710 q 494 819 587 819 l 416 819 l 279 174 l 351 174 z \"},\"E\":{\"ha\":753,\"x_min\":36,\"x_max\":800,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 z \"},\"F\":{\"ha\":737,\"x_min\":36,\"x_max\":798,\"o\":\"m 243 0 l 36 0 l 245 991 l 798 991 l 761 819 l 416 819 l 363 564 l 684 564 l 646 392 l 325 392 l 243 0 z \"},\"G\":{\"ha\":958,\"x_min\":83,\"x_max\":942,\"o\":\"m 511 557 l 893 557 l 783 40 q 615 -2 692 9 q 450 -14 537 -14 q 179 86 275 -14 q 83 372 83 186 q 156 701 83 554 q 360 927 229 848 q 664 1007 492 1007 q 942 940 812 1007 l 864 770 q 764 813 814 797 q 654 829 713 829 q 469 773 551 829 q 341 613 387 717 q 294 389 294 509 q 343 217 294 272 q 494 163 393 163 q 610 179 546 163 l 654 382 l 473 382 l 511 557 z \"},\"H\":{\"ha\":972,\"x_min\":36,\"x_max\":979,\"o\":\"m 770 0 l 562 0 l 653 428 l 334 428 l 243 0 l 36 0 l 245 991 l 453 991 l 371 603 l 690 603 l 772 991 l 979 991 l 770 0 z \"},\"J\":{\"ha\":460,\"x_min\":-218,\"x_max\":468,\"o\":\"m -92 -292 q -218 -273 -155 -292 l -218 -102 q -107 -115 -159 -115 q 2 -74 -40 -115 q 62 56 43 -33 l 261 991 l 468 991 l 262 26 q 143 -216 227 -140 q -92 -292 60 -292 z \"},\"K\":{\"ha\":851,\"x_min\":36,\"x_max\":979,\"o\":\"m 774 0 l 545 0 l 401 401 l 317 354 l 243 0 l 36 0 l 245 991 l 453 991 l 350 515 l 457 654 l 734 991 l 979 991 l 576 517 l 774 0 z \"},\"L\":{\"ha\":720,\"x_min\":36,\"x_max\":627,\"o\":\"m 36 0 l 245 991 l 453 991 l 279 174 l 627 174 l 590 0 l 36 0 z \"},\"M\":{\"ha\":1222,\"x_min\":36,\"x_max\":1229,\"o\":\"m 568 250 l 942 991 l 1229 991 l 1019 0 l 829 0 l 928 469 q 999 768 964 637 l 996 768 l 610 0 l 419 0 l 378 768 l 375 768 q 349 612 368 709 q 222 0 331 515 l 36 0 l 245 991 l 519 991 l 566 250 l 568 250 z \"},\"N\":{\"ha\":1048,\"x_min\":36,\"x_max\":1055,\"o\":\"m 846 0 l 614 0 l 372 750 l 368 750 l 366 728 q 321 467 344 582 l 222 0 l 36 0 l 245 991 l 488 991 l 718 261 l 721 261 q 747 408 729 313 q 869 991 766 504 l 1055 991 l 846 0 z \"},\"O\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 z \"},\"P\":{\"ha\":806,\"x_min\":36,\"x_max\":807,\"o\":\"m 354 525 l 392 525 q 544 572 488 525 q 599 697 599 618 q 467 819 599 819 l 416 819 l 354 525 m 807 703 q 692 446 807 539 q 375 353 577 353 l 317 353 l 243 0 l 36 0 l 245 991 l 475 991 q 723 919 639 991 q 807 703 807 847 z \"},\"Q\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 888 259 971 422 q 661 31 805 97 l 833 -236 l 590 -236 l 469 -14 l 452 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 z \"},\"R\":{\"ha\":846,\"x_min\":36,\"x_max\":811,\"o\":\"m 359 551 l 412 551 q 551 590 501 551 q 600 708 600 629 q 568 791 600 764 q 467 819 536 819 l 416 819 l 359 551 m 323 380 l 243 0 l 36 0 l 245 991 l 489 991 q 730 922 650 991 q 811 720 811 853 q 755 535 811 612 q 593 421 699 458 l 770 0 l 545 0 l 404 380 l 323 380 z \"},\"S\":{\"ha\":736,\"x_min\":28,\"x_max\":753,\"o\":\"m 642 293 q 541 69 642 151 q 269 -14 441 -14 q 28 47 119 -14 l 28 233 q 271 160 159 160 q 389 189 347 160 q 432 268 432 218 q 423 319 432 297 q 397 360 414 341 q 313 429 380 379 q 181 562 219 496 q 143 704 143 628 q 185 860 143 791 q 305 967 227 929 q 484 1006 382 1006 q 753 939 631 1006 l 679 781 q 484 831 573 831 q 391 800 427 831 q 355 720 355 770 q 378 647 355 678 q 478 566 400 616 q 601 446 560 511 q 642 293 642 380 z \"},\"T\":{\"ha\":737,\"x_min\":114,\"x_max\":836,\"o\":\"m 387 0 l 180 0 l 353 817 l 114 817 l 151 991 l 836 991 l 799 817 l 559 817 l 387 0 z \"},\"U\":{\"ha\":960,\"x_min\":96,\"x_max\":972,\"o\":\"m 972 991 l 836 350 q 688 78 798 170 q 404 -14 579 -14 q 178 63 260 -14 q 96 272 96 140 q 106 366 96 321 l 239 991 l 446 991 l 314 368 q 302 283 302 318 q 431 163 302 163 q 563 215 514 163 q 633 370 612 267 l 765 991 l 972 991 z \"},\"V\":{\"ha\":819,\"x_min\":125,\"x_max\":945,\"o\":\"m 363 203 q 437 395 416 353 l 730 991 l 945 991 l 437 0 l 211 0 l 125 991 l 325 991 l 359 395 q 362 304 362 364 q 358 203 361 235 l 363 203 z \"},\"W\":{\"ha\":1242,\"x_min\":125,\"x_max\":1372,\"o\":\"m 682 690 q 604 488 651 591 l 385 0 l 155 0 l 125 991 l 319 991 l 323 450 q 321 333 323 415 q 314 215 318 251 l 318 215 q 363 337 333 258 q 404 436 394 416 l 654 991 l 838 991 l 852 399 q 846 215 852 300 l 850 215 q 939 452 879 302 l 1162 991 l 1372 991 l 933 0 l 699 0 l 684 489 l 682 583 q 685 690 682 643 l 682 690 z \"},\"X\":{\"ha\":842,\"x_min\":-79,\"x_max\":950,\"o\":\"m 762 0 l 538 0 l 421 368 l 153 0 l -79 0 l 311 518 l 150 991 l 367 991 l 471 640 l 717 991 l 950 991 l 581 500 l 762 0 z \"},\"Y\":{\"ha\":783,\"x_min\":126,\"x_max\":911,\"o\":\"m 425 590 l 679 991 l 911 991 l 492 379 l 411 0 l 205 0 l 286 379 l 126 991 l 338 991 l 425 590 z \"},\"Z\":{\"ha\":745,\"x_min\":-41,\"x_max\":814,\"o\":\"m 624 0 l -41 0 l -16 136 l 511 818 l 143 818 l 179 991 l 814 991 l 786 854 l 256 174 l 660 174 l 624 0 z \"},\"[\":{\"ha\":460,\"x_min\":-25,\"x_max\":554,\"o\":\"m 296 -220 l -25 -220 l 233 991 l 554 991 l 524 848 l 378 848 l 180 -77 l 326 -77 l 296 -220 z \"},\"\\\\\":{\"ha\":585,\"x_min\":150,\"x_max\":478,\"o\":\"m 326 991 l 478 0 l 297 0 l 150 991 l 326 991 z \"},\"]\":{\"ha\":460,\"x_min\":-93,\"x_max\":485,\"o\":\"m -62 -77 l 82 -77 l 279 848 l 134 848 l 164 991 l 485 991 l 227 -220 l -93 -220 l -62 -77 z \"},\"^\":{\"ha\":733,\"x_min\":14,\"x_max\":721,\"o\":\"m 14 353 l 433 997 l 533 997 l 721 353 l 570 353 l 452 782 l 179 353 l 14 353 z \"},\"_\":{\"ha\":555,\"x_min\":-126,\"x_max\":452,\"o\":\"m 431 -220 l -126 -220 l -106 -125 l 452 -125 l 431 -220 z \"},\"`\":{\"ha\":770,\"x_min\":345,\"x_max\":633,\"o\":\"m 633 842 l 509 842 q 415 946 460 888 q 345 1050 369 1003 l 345 1064 l 555 1064 q 633 859 580 964 l 633 842 z \"},\"a\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 z \"},\"b\":{\"ha\":827,\"x_min\":25,\"x_max\":765,\"o\":\"m 551 772 q 708 699 650 772 q 765 497 765 626 q 719 248 765 368 q 592 57 673 127 q 414 -14 511 -14 q 227 97 282 -14 l 221 97 l 182 0 l 25 0 l 249 1055 l 453 1055 l 411 860 q 354 657 383 736 l 359 657 q 456 748 412 724 q 551 772 500 772 m 469 607 q 381 563 423 607 q 312 440 339 519 q 285 271 285 362 q 310 184 285 216 q 379 151 335 151 q 466 198 425 151 q 533 327 507 245 q 558 488 558 408 q 469 607 558 607 z \"},\"c\":{\"ha\":671,\"x_min\":61,\"x_max\":685,\"o\":\"m 343 -14 q 134 59 207 -14 q 61 265 61 132 q 112 527 61 409 q 254 708 162 644 q 463 772 345 772 q 685 724 586 772 l 623 568 q 551 595 586 584 q 471 607 515 607 q 367 564 413 607 q 294 445 320 520 q 268 282 268 369 q 299 184 268 217 q 385 151 330 151 q 480 167 436 151 q 571 207 524 183 l 571 40 q 343 -14 468 -14 z \"},\"d\":{\"ha\":825,\"x_min\":61,\"x_max\":864,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 262 61 132 q 110 516 61 395 q 237 705 158 637 q 412 772 317 772 q 508 747 468 772 q 585 661 549 722 l 590 661 l 591 680 q 608 812 595 755 l 660 1055 l 864 1055 l 640 0 l 485 0 l 494 98 l 492 98 q 391 13 444 39 q 275 -14 338 -14 m 361 151 q 448 198 406 151 q 516 321 490 244 q 542 488 542 399 q 516 574 542 542 q 447 607 491 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 361 151 268 151 z \"},\"e\":{\"ha\":774,\"x_min\":61,\"x_max\":739,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 z \"},\"f\":{\"ha\":518,\"x_min\":-149,\"x_max\":669,\"o\":\"m -31 -334 q -149 -317 -101 -334 l -149 -153 q -71 -167 -107 -167 q 2 -140 -29 -167 q 46 -52 33 -113 l 184 603 l 74 603 l 94 701 l 218 758 l 231 815 q 325 1003 258 944 q 510 1063 391 1063 q 669 1029 599 1063 l 615 878 q 525 899 568 899 q 463 871 486 899 q 431 800 439 844 l 422 758 l 571 758 l 538 603 l 389 603 l 243 -82 q -31 -334 191 -334 z \"},\"g\":{\"ha\":751,\"x_min\":-78,\"x_max\":804,\"o\":\"m 804 757 l 781 644 l 663 616 q 673 536 673 581 q 591 327 673 404 q 368 250 509 250 q 301 257 328 250 q 244 204 244 239 q 264 171 244 181 q 325 155 285 161 l 418 143 q 579 86 528 129 q 629 -39 629 43 q 524 -258 629 -182 q 221 -334 418 -334 q 1 -282 80 -334 q -78 -142 -78 -231 q -32 -23 -78 -73 q 114 60 15 27 q 64 150 64 92 q 94 233 64 198 q 193 300 124 268 q 128 376 149 333 q 107 479 107 418 q 192 693 107 614 q 424 772 277 772 q 536 757 480 772 l 804 757 m 248 -4 q 139 -43 176 -14 q 102 -117 102 -72 q 233 -195 102 -195 q 388 -164 336 -195 q 440 -78 440 -134 q 418 -37 440 -52 q 325 -14 396 -23 l 248 -4 m 416 643 q 332 591 364 643 q 300 461 300 539 q 370 380 300 380 q 452 432 420 380 q 484 564 484 484 q 416 643 484 643 z \"},\"h\":{\"ha\":839,\"x_min\":25,\"x_max\":768,\"o\":\"m 663 0 l 458 0 l 551 443 q 562 524 562 489 q 489 607 562 607 q 376 530 427 607 q 296 314 325 452 l 229 0 l 25 0 l 249 1055 l 453 1055 q 412 867 427 932 q 354 657 398 801 l 359 657 q 453 741 401 709 q 572 772 505 772 q 717 716 666 772 q 768 554 768 659 q 753 432 768 505 l 663 0 z \"},\"i\":{\"ha\":412,\"x_min\":25,\"x_max\":443,\"o\":\"m 218 936 q 251 1025 218 995 q 342 1055 283 1055 q 417 1034 391 1055 q 443 974 443 1013 q 413 886 443 920 q 321 852 383 852 q 218 936 218 852 m 229 0 l 25 0 l 186 758 l 390 758 l 229 0 z \"},\"j\":{\"ha\":412,\"x_min\":-179,\"x_max\":444,\"o\":\"m -61 -334 q -179 -317 -132 -334 l -179 -153 q -102 -167 -138 -167 q 16 -52 -9 -167 l 187 758 l 392 758 l 212 -82 q -61 -334 160 -334 m 220 936 q 252 1025 220 995 q 343 1055 284 1055 q 418 1034 393 1055 q 444 974 444 1013 q 414 886 444 920 q 322 852 385 852 q 220 936 220 852 z \"},\"k\":{\"ha\":789,\"x_min\":25,\"x_max\":857,\"o\":\"m 624 758 l 857 758 l 519 416 l 713 0 l 485 0 l 361 285 l 279 236 l 229 0 l 25 0 l 249 1055 l 453 1055 l 353 585 q 333 505 347 557 l 314 436 l 317 436 l 624 758 z \"},\"l\":{\"ha\":412,\"x_min\":25,\"x_max\":453,\"o\":\"m 229 0 l 25 0 l 249 1055 l 453 1055 l 229 0 z \"},\"m\":{\"ha\":1257,\"x_min\":25,\"x_max\":1186,\"o\":\"m 572 772 q 750 618 721 772 l 754 618 q 863 732 800 692 q 997 772 926 772 q 1138 715 1089 772 q 1186 554 1186 657 q 1171 432 1186 503 l 1080 0 l 876 0 l 970 443 q 981 524 981 489 q 914 607 981 607 q 801 531 852 607 q 721 315 751 455 l 656 0 l 452 0 l 545 443 q 555 524 555 489 q 489 607 555 607 q 376 530 427 607 q 296 314 325 452 l 229 0 l 25 0 l 186 758 l 342 758 l 328 618 l 332 618 q 572 772 431 772 z \"},\"n\":{\"ha\":839,\"x_min\":25,\"x_max\":768,\"o\":\"m 663 0 l 458 0 l 551 443 q 562 524 562 489 q 489 607 562 607 q 376 530 427 607 q 296 314 325 452 l 229 0 l 25 0 l 186 758 l 342 758 l 328 618 l 332 618 q 572 772 431 772 q 717 716 666 772 q 768 554 768 659 q 753 432 768 505 l 663 0 z \"},\"o\":{\"ha\":812,\"x_min\":61,\"x_max\":751,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 z \"},\"p\":{\"ha\":827,\"x_min\":-46,\"x_max\":765,\"o\":\"m 551 772 q 708 700 650 772 q 765 496 765 627 q 719 247 765 366 q 591 57 672 127 q 414 -14 511 -14 q 317 12 357 -14 q 241 97 276 37 l 236 97 q 207 -103 228 -11 l 158 -334 l -46 -334 l 186 758 l 342 758 l 330 643 l 336 643 q 551 772 430 772 m 469 607 q 380 561 423 607 q 311 439 337 515 q 285 271 285 363 q 310 184 285 216 q 379 151 335 151 q 466 198 425 151 q 533 327 507 245 q 558 488 558 408 q 469 607 558 607 z \"},\"q\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 265 -14 q 159 19 205 -14 q 87 113 113 51 q 61 261 61 174 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 516 747 471 772 q 600 661 561 722 l 606 661 l 644 758 l 802 758 l 570 -334 l 366 -334 q 415 -105 397 -186 q 472 102 433 -24 l 467 102 q 370 12 418 38 q 265 -14 321 -14 m 363 151 q 449 199 406 151 q 517 321 492 246 q 542 488 542 397 q 516 574 542 542 q 447 607 491 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 293 181 268 211 q 363 151 317 151 z \"},\"r\":{\"ha\":585,\"x_min\":25,\"x_max\":636,\"o\":\"m 571 772 q 636 765 611 772 l 591 568 q 524 579 561 579 q 386 517 445 579 q 301 339 326 455 l 229 0 l 25 0 l 186 758 l 342 758 l 328 618 l 332 618 q 571 772 431 772 z \"},\"s\":{\"ha\":657,\"x_min\":16,\"x_max\":629,\"o\":\"m 562 250 q 478 55 562 123 q 243 -14 393 -14 q 116 -3 170 -14 q 16 31 62 7 l 16 199 q 232 138 122 138 q 321 160 286 138 q 355 220 355 182 q 330 272 355 249 q 241 330 305 295 q 127 422 159 376 q 94 530 94 468 q 169 709 94 646 q 383 772 244 772 q 629 708 519 772 l 562 562 q 387 619 467 619 q 325 602 349 619 q 301 555 301 585 q 323 509 301 529 q 404 458 345 489 q 525 366 488 416 q 562 250 562 315 z \"},\"t\":{\"ha\":570,\"x_min\":64,\"x_max\":596,\"o\":\"m 349 151 q 458 175 393 151 l 458 22 q 278 -14 383 -14 q 129 29 176 -14 q 81 161 81 72 q 89 237 81 195 l 167 603 l 64 603 l 83 703 l 216 760 l 306 920 l 437 920 l 404 758 l 596 758 l 562 603 l 371 603 l 293 237 q 289 201 289 217 q 349 151 289 151 z \"},\"u\":{\"ha\":839,\"x_min\":75,\"x_max\":815,\"o\":\"m 178 758 l 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 125 42 174 -14 q 75 204 75 98 q 92 349 75 267 l 178 758 z \"},\"v\":{\"ha\":711,\"x_min\":69,\"x_max\":791,\"o\":\"m 309 204 q 371 355 346 308 l 572 758 l 791 758 l 382 0 l 163 0 l 69 758 l 269 758 l 300 361 q 304 204 304 271 l 309 204 z \"},\"w\":{\"ha\":1095,\"x_min\":85,\"x_max\":1165,\"o\":\"m 581 583 q 497 367 538 463 l 339 0 l 119 0 l 85 758 l 275 758 l 278 422 l 275 309 l 271 193 l 273 193 q 283 221 277 207 q 317 314 288 236 q 349 395 347 392 l 505 758 l 728 758 l 728 395 q 721 193 728 298 l 725 193 l 744 248 q 808 422 793 389 l 957 758 l 1165 758 l 806 0 l 582 0 l 578 353 q 585 583 578 458 l 581 583 z \"},\"x\":{\"ha\":737,\"x_min\":-68,\"x_max\":806,\"o\":\"m 257 389 l 104 758 l 322 758 l 400 532 l 566 758 l 806 758 l 489 378 l 654 0 l 433 0 l 349 232 l 170 0 l -68 0 l 257 389 z \"},\"y\":{\"ha\":721,\"x_min\":-96,\"x_max\":793,\"o\":\"m 69 758 l 269 758 l 307 407 q 317 208 317 324 l 321 208 q 351 289 334 243 q 395 393 367 336 l 571 758 l 793 758 l 332 -109 q 4 -334 212 -334 q -96 -321 -57 -334 l -96 -158 q -17 -167 -50 -167 q 83 -134 40 -167 q 163 -33 126 -102 l 180 0 l 69 758 z \"},\"z\":{\"ha\":632,\"x_min\":-32,\"x_max\":656,\"o\":\"m 507 0 l -32 0 l -8 122 l 382 600 l 113 600 l 147 758 l 656 758 l 627 623 l 243 158 l 541 158 l 507 0 z \"},\"{\":{\"ha\":493,\"x_min\":-5,\"x_max\":589,\"o\":\"m 136 216 q -5 311 136 311 l 25 467 q 156 495 108 467 q 218 589 203 523 l 260 782 q 349 944 286 897 q 532 991 412 991 l 589 991 l 555 839 q 467 815 494 838 q 429 743 439 793 l 385 542 q 197 382 354 401 l 197 376 q 283 320 255 359 q 311 229 311 282 q 301 153 311 199 l 277 32 q 272 -3 272 13 q 295 -53 272 -39 q 357 -66 317 -66 l 357 -220 l 321 -220 q 149 -177 208 -220 q 90 -52 90 -134 q 100 33 90 -13 l 126 158 q 136 216 136 205 z \"},\"|\":{\"ha\":765,\"x_min\":309,\"x_max\":457,\"o\":\"m 309 1051 l 457 1051 l 457 -315 l 309 -315 l 309 1051 z \"},\"}\":{\"ha\":493,\"x_min\":-68,\"x_max\":500,\"o\":\"m 174 991 q 404 823 404 991 q 395 739 404 785 l 368 614 q 358 555 358 567 q 500 461 358 461 l 469 306 q 339 277 387 306 q 277 183 291 249 l 235 -9 q 146 -172 210 -125 q -37 -220 83 -220 l -68 -220 l -68 -66 q 25 -42 -5 -64 q 65 29 55 -20 l 110 231 q 174 343 127 306 q 297 390 222 380 l 297 396 q 183 543 183 431 q 193 619 183 572 l 218 741 q 222 775 222 761 q 198 825 222 812 q 123 839 173 839 l 151 991 l 174 991 z \"},\"~\":{\"ha\":765,\"x_min\":74,\"x_max\":720,\"o\":\"m 232 456 q 153 433 195 456 q 74 374 111 411 l 74 530 q 248 604 142 604 q 327 595 291 604 q 421 561 363 585 q 496 533 465 543 q 561 524 528 524 q 637 544 595 524 q 720 606 678 565 l 720 449 q 546 375 650 375 q 472 383 506 375 q 372 418 438 391 q 286 450 312 444 q 232 456 260 456 z \"},\" \":{\"ha\":361,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\"¡\":{\"ha\":397,\"x_min\":-50,\"x_max\":372,\"o\":\"m 123 411 l 288 411 l 180 -252 l -50 -252 l 123 411 m 372 663 q 335 564 372 600 q 233 528 297 528 q 160 553 187 528 q 132 627 132 579 q 169 721 132 684 q 267 758 205 758 q 344 733 316 758 q 372 663 372 708 z \"},\"¢\":{\"ha\":765,\"x_min\":111,\"x_max\":734,\"o\":\"m 390 -14 l 262 -14 l 296 129 q 158 221 205 153 q 111 396 111 289 q 154 637 111 527 q 274 815 196 747 q 456 899 353 883 l 478 1006 l 606 1006 l 582 899 q 734 854 662 889 l 672 699 q 601 726 636 714 q 521 737 566 737 q 374 640 431 737 q 318 412 318 543 q 349 315 318 347 q 435 282 379 282 q 530 298 486 282 q 621 338 574 314 l 621 171 q 418 117 528 123 l 390 -14 z \"},\"£\":{\"ha\":765,\"x_min\":-8,\"x_max\":842,\"o\":\"m 591 1007 q 842 949 724 1007 l 765 791 q 604 838 669 838 q 521 811 553 838 q 475 721 488 784 l 443 566 l 646 566 l 615 416 l 412 416 l 400 359 q 258 176 372 227 l 703 176 l 665 0 l -8 0 l 25 167 q 191 346 158 199 l 205 416 l 75 416 l 106 566 l 236 566 l 269 733 q 379 937 297 867 q 591 1007 461 1007 z \"},\"¤\":{\"ha\":765,\"x_min\":78,\"x_max\":718,\"o\":\"m 129 490 q 165 624 129 559 l 78 710 l 178 810 l 264 724 q 397 760 326 760 q 530 722 469 760 l 616 810 l 718 713 l 631 625 q 667 490 667 565 q 631 355 667 418 l 715 271 l 616 172 l 530 257 q 397 222 466 222 q 262 257 319 222 l 178 174 l 79 272 l 165 357 q 129 490 129 420 m 269 490 q 306 400 269 438 q 397 363 343 363 q 490 400 452 363 q 528 490 528 437 q 489 582 528 545 q 397 619 451 619 q 307 581 345 619 q 269 490 269 543 z \"},\"¥\":{\"ha\":765,\"x_min\":60,\"x_max\":875,\"o\":\"m 412 591 l 664 991 l 875 991 l 532 485 l 669 485 l 643 364 l 472 364 l 453 271 l 624 271 l 599 150 l 428 150 l 396 0 l 199 0 l 231 150 l 60 150 l 85 271 l 256 271 l 275 364 l 104 364 l 131 485 l 264 485 l 134 991 l 335 991 l 412 591 z \"},\"¦\":{\"ha\":765,\"x_min\":309,\"x_max\":457,\"o\":\"m 309 1051 l 457 1051 l 457 498 l 309 498 l 309 1051 m 309 237 l 457 237 l 457 -315 l 309 -315 l 309 237 z \"},\"§\":{\"ha\":675,\"x_min\":14,\"x_max\":697,\"o\":\"m 102 515 q 134 626 102 576 q 239 722 166 676 q 191 780 210 745 q 172 852 172 814 q 252 1011 172 954 q 464 1069 331 1069 q 697 1010 581 1069 l 642 879 q 450 936 542 936 q 353 864 353 936 q 380 812 353 835 q 467 764 408 790 q 631 558 631 692 q 500 353 631 431 q 543 295 526 329 q 561 221 561 260 q 475 49 561 112 q 241 -14 390 -14 q 14 37 103 -14 l 14 189 q 248 118 130 118 q 346 142 315 118 q 376 204 376 165 q 354 253 376 231 q 268 307 332 276 q 145 396 189 346 q 102 515 102 446 m 343 656 q 288 608 309 639 q 267 541 267 577 q 296 475 267 504 q 393 415 326 446 q 445 468 427 436 q 463 533 463 500 q 343 656 463 607 z \"},\"¨\":{\"ha\":770,\"x_min\":269,\"x_max\":742,\"o\":\"m 269 937 q 298 1017 269 990 q 379 1044 327 1044 q 469 971 469 1044 q 443 892 469 922 q 361 863 416 863 q 269 937 269 863 m 542 937 q 570 1017 542 990 q 652 1044 599 1044 q 719 1025 696 1044 q 742 971 742 1006 q 715 892 742 922 q 633 863 688 863 q 542 937 542 863 z \"},\"©\":{\"ha\":1156,\"x_min\":85,\"x_max\":1104,\"o\":\"m 632 685 q 522 635 557 685 q 486 490 486 586 q 524 353 486 399 q 632 306 562 306 q 706 316 661 306 q 790 346 750 327 l 790 216 q 612 178 701 178 q 404 261 479 178 q 329 489 329 344 q 409 727 329 642 q 629 812 488 812 q 822 764 726 812 l 771 646 q 632 685 694 685 m 85 496 q 153 750 85 631 q 339 937 220 869 q 595 1006 458 1006 q 848 939 730 1006 q 1035 752 966 871 q 1104 496 1104 632 q 1037 243 1104 361 q 852 56 970 125 q 595 -14 734 -14 q 336 57 454 -14 q 151 244 217 127 q 85 496 85 361 m 180 496 q 236 289 180 385 q 388 138 291 193 q 595 82 484 82 q 804 138 708 82 q 954 290 899 195 q 1008 496 1008 385 q 954 702 1008 606 q 803 853 899 797 q 595 909 707 909 q 387 853 484 909 q 235 702 290 798 q 180 496 180 606 z \"},\"ª\":{\"ha\":524,\"x_min\":103,\"x_max\":595,\"o\":\"m 250 510 q 142 557 180 510 q 103 692 103 605 q 134 846 103 771 q 218 962 165 922 q 338 1003 270 1003 q 460 933 419 1003 l 464 933 l 490 994 l 595 994 l 488 518 l 383 518 l 389 581 l 387 581 q 250 510 333 510 m 300 612 q 357 641 330 612 q 401 722 383 669 q 419 827 419 775 q 359 899 419 899 q 276 833 310 899 q 241 688 241 768 q 300 612 241 612 z \"},\"«\":{\"ha\":781,\"x_min\":49,\"x_max\":781,\"o\":\"m 49 386 l 321 700 l 450 595 l 261 368 l 353 131 l 186 61 l 49 374 l 49 386 m 379 386 l 652 700 l 781 595 l 591 368 l 684 131 l 517 61 l 379 374 l 379 386 z \"},\"¬\":{\"ha\":765,\"x_min\":74,\"x_max\":720,\"o\":\"m 720 168 l 571 168 l 571 415 l 74 415 l 74 564 l 720 564 l 720 168 z \"},\"­\":{\"ha\":447,\"x_min\":28,\"x_max\":419,\"o\":\"m 28 288 l 64 457 l 419 457 l 383 288 l 28 288 z \"},\"®\":{\"ha\":1156,\"x_min\":85,\"x_max\":1104,\"o\":\"m 839 610 q 809 508 839 551 q 721 443 779 465 l 854 199 l 682 199 l 589 400 l 543 400 l 543 199 l 387 199 l 387 791 l 596 791 q 776 746 713 791 q 839 610 839 700 m 543 514 l 578 514 q 654 535 627 514 q 682 597 682 556 q 658 657 682 637 q 579 677 634 677 l 543 677 l 543 514 m 85 496 q 153 750 85 631 q 339 937 220 869 q 595 1006 458 1006 q 848 939 730 1006 q 1035 752 966 871 q 1104 496 1104 632 q 1037 243 1104 361 q 852 56 970 125 q 595 -14 734 -14 q 336 57 454 -14 q 151 244 217 127 q 85 496 85 361 m 180 496 q 236 289 180 385 q 388 138 291 193 q 595 82 484 82 q 804 138 708 82 q 954 290 899 195 q 1008 496 1008 385 q 954 702 1008 606 q 803 853 899 797 q 595 909 707 909 q 387 853 484 909 q 235 702 290 798 q 180 496 180 606 z \"},\"¯\":{\"ha\":694,\"x_min\":-4,\"x_max\":729,\"o\":\"m 699 1055 l -4 1055 l 26 1192 l 729 1192 l 699 1055 z \"},\"°\":{\"ha\":595,\"x_min\":111,\"x_max\":581,\"o\":\"m 111 771 q 143 889 111 834 q 229 975 174 943 q 346 1006 284 1006 q 464 974 409 1006 q 549 888 518 942 q 581 771 581 833 q 549 654 581 708 q 464 569 518 600 q 346 538 410 538 q 229 568 283 538 q 143 653 174 599 q 111 771 111 707 m 240 771 q 271 697 240 728 q 346 667 302 667 q 421 698 391 667 q 452 771 452 729 q 421 846 452 814 q 346 878 390 878 q 271 845 302 878 q 240 771 240 813 z \"},\"±\":{\"ha\":765,\"x_min\":74,\"x_max\":720,\"o\":\"m 322 457 l 74 457 l 74 606 l 322 606 l 322 856 l 471 856 l 471 606 l 720 606 l 720 457 l 471 457 l 471 210 l 322 210 l 322 457 m 74 0 l 74 149 l 720 149 l 720 0 l 74 0 z \"},\"²\":{\"ha\":526,\"x_min\":40,\"x_max\":550,\"o\":\"m 479 397 l 40 397 l 64 510 l 249 659 q 345 741 324 720 q 375 781 365 762 q 385 819 385 800 q 367 861 385 848 q 326 875 350 875 q 199 819 268 875 l 131 926 q 237 985 181 965 q 367 1006 292 1006 q 500 963 450 1006 q 550 854 550 920 q 535 771 550 807 q 488 701 520 735 q 359 597 455 667 l 272 533 l 507 533 l 479 397 z \"},\"³\":{\"ha\":526,\"x_min\":62,\"x_max\":551,\"o\":\"m 551 861 q 517 763 551 802 q 404 703 482 723 l 404 700 q 509 581 509 677 q 436 439 509 492 q 243 386 363 386 q 144 396 192 386 q 62 424 96 407 l 62 554 q 235 505 147 505 q 319 526 286 505 q 353 586 353 547 q 335 628 353 611 q 275 646 317 646 l 189 646 l 212 754 l 273 754 q 363 773 330 754 q 396 831 396 792 q 378 871 396 858 q 330 885 361 885 q 203 840 272 885 l 147 942 q 359 1004 243 1004 q 499 967 448 1004 q 551 861 551 929 z \"},\"´\":{\"ha\":770,\"x_min\":328,\"x_max\":705,\"o\":\"m 328 859 q 478 1064 381 918 l 705 1064 l 705 1053 q 601 949 674 1015 q 469 842 528 884 l 328 842 l 328 859 z \"},\"µ\":{\"ha\":847,\"x_min\":-46,\"x_max\":823,\"o\":\"m 288 236 q 309 173 288 195 q 363 151 330 151 q 473 223 424 151 q 553 440 522 296 l 619 758 l 823 758 l 663 0 l 507 0 l 519 119 l 515 119 q 335 -14 436 -14 q 274 0 300 -14 q 235 32 248 13 l 231 32 q 216 -62 225 -13 q 160 -334 207 -112 l -46 -334 l 186 758 l 390 758 l 298 321 q 288 236 288 273 z \"},\"¶\":{\"ha\":909,\"x_min\":100,\"x_max\":815,\"o\":\"m 815 -176 l 705 -176 l 705 920 l 593 920 l 593 -176 l 484 -176 l 484 379 q 385 367 441 367 q 169 452 238 367 q 100 707 100 536 q 173 968 100 880 q 406 1055 245 1055 l 815 1055 l 815 -176 z \"},\"·\":{\"ha\":396,\"x_min\":89,\"x_max\":329,\"o\":\"m 89 471 q 125 569 89 532 q 227 606 161 606 q 301 580 273 606 q 329 507 329 554 q 292 412 329 448 q 194 375 254 375 q 117 400 144 375 q 89 471 89 426 z \"},\"¸\":{\"ha\":285,\"x_min\":-140,\"x_max\":178,\"o\":\"m 178 -170 q 121 -291 178 -248 q -37 -334 65 -334 q -140 -318 -96 -334 l -140 -204 q -56 -220 -98 -220 q 14 -164 14 -220 q -7 -126 14 -141 q -82 -104 -28 -111 l -17 0 l 109 0 l 82 -49 q 178 -170 178 -82 z \"},\"¹\":{\"ha\":526,\"x_min\":87,\"x_max\":498,\"o\":\"m 358 991 l 498 991 l 372 397 l 205 397 l 262 667 q 300 807 279 741 q 245 766 289 797 l 157 711 l 87 823 l 358 991 z \"},\"º\":{\"ha\":511,\"x_min\":110,\"x_max\":549,\"o\":\"m 549 810 q 516 652 549 723 q 426 546 483 581 q 293 510 369 510 q 156 561 202 510 q 110 704 110 612 q 180 920 110 838 q 368 1003 251 1003 q 502 953 456 1003 q 549 810 549 903 m 354 892 q 281 831 311 892 q 252 696 252 770 q 306 621 252 621 q 377 679 349 621 q 406 819 406 736 q 354 892 406 892 z \"},\"»\":{\"ha\":781,\"x_min\":0,\"x_max\":732,\"o\":\"m 732 363 l 460 49 l 330 154 l 519 380 l 428 618 l 595 688 l 732 375 l 732 363 m 401 363 l 129 49 l 0 154 l 189 380 l 97 618 l 264 688 l 401 375 l 401 363 z \"},\"¼\":{\"ha\":1223,\"x_min\":66,\"x_max\":1092,\"o\":\"m 1017 991 l 282 0 l 120 0 l 857 991 l 1017 991 m 336 991 l 477 991 l 351 397 l 184 397 l 241 667 q 278 807 257 741 q 224 766 267 797 l 135 711 l 66 823 l 336 991 m 1067 103 l 986 103 l 964 1 l 803 1 l 825 103 l 572 103 l 593 221 l 916 599 l 1092 599 l 1010 217 l 1090 217 l 1067 103 m 849 217 l 888 374 l 903 424 q 874 385 895 410 q 731 217 854 359 l 849 217 z \"},\"½\":{\"ha\":1223,\"x_min\":66,\"x_max\":1147,\"o\":\"m 1077 1 l 637 1 l 661 113 l 846 262 q 942 345 922 323 q 972 385 962 366 q 982 422 982 404 q 965 465 982 451 q 924 478 947 478 q 796 422 865 478 l 728 530 q 834 589 779 568 q 964 609 890 609 q 1098 566 1048 609 q 1147 458 1147 524 q 1133 374 1147 410 q 1085 304 1118 338 q 957 201 1053 270 l 869 136 l 1105 136 l 1077 1 m 336 991 l 477 991 l 351 397 l 184 397 l 241 667 q 278 807 257 741 q 224 766 267 797 l 135 711 l 66 823 l 336 991 m 1017 991 l 282 0 l 120 0 l 857 991 l 1017 991 z \"},\"¾\":{\"ha\":1223,\"x_min\":90,\"x_max\":1133,\"o\":\"m 1107 991 l 372 0 l 210 0 l 947 991 l 1107 991 m 1108 103 l 1027 103 l 1006 1 l 844 1 l 867 103 l 614 103 l 635 221 l 957 599 l 1133 599 l 1051 217 l 1132 217 l 1108 103 m 890 217 l 930 374 l 945 424 q 916 385 936 410 q 772 217 895 359 l 890 217 m 579 861 q 545 763 579 802 q 432 703 510 723 l 432 700 q 536 581 536 677 q 464 439 536 492 q 271 386 391 386 q 172 396 220 386 q 90 424 124 407 l 90 554 q 262 505 175 505 q 347 526 314 505 q 380 586 380 547 q 363 628 380 611 q 303 646 345 646 l 217 646 l 240 754 l 301 754 q 391 773 358 754 q 424 831 424 792 q 406 871 424 858 q 358 885 389 885 q 231 840 300 885 l 175 942 q 387 1004 271 1004 q 527 967 475 1004 q 579 861 579 929 z \"},\"¿\":{\"ha\":637,\"x_min\":-46,\"x_max\":524,\"o\":\"m 460 411 l 450 358 q 398 236 437 287 q 283 134 359 185 q 177 48 201 77 q 154 -18 154 19 q 244 -98 154 -98 q 316 -87 278 -98 q 453 -31 355 -77 l 515 -180 q 214 -265 366 -265 q 24 -206 94 -265 q -46 -40 -46 -146 q -27 61 -46 16 q 30 145 -7 106 q 158 244 67 184 q 245 316 221 286 q 279 389 269 347 l 285 411 l 460 411 m 524 663 q 486 564 524 600 q 385 528 448 528 q 311 553 338 528 q 283 627 283 579 q 320 722 283 685 q 418 758 357 758 q 495 733 467 758 q 524 663 524 708 z \"},\"À\":{\"ha\":872,\"x_min\":-83,\"x_max\":789,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 654 1071 l 530 1071 q 436 1175 481 1118 q 366 1279 390 1232 l 366 1293 l 576 1293 q 654 1088 601 1193 l 654 1071 z \"},\"Á\":{\"ha\":872,\"x_min\":-83,\"x_max\":876,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 498 1088 q 649 1293 552 1147 l 876 1293 l 876 1282 q 772 1178 845 1244 q 640 1071 699 1113 l 498 1071 l 498 1088 z \"},\"Â\":{\"ha\":872,\"x_min\":-83,\"x_max\":838,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 838 1071 l 703 1071 q 593 1185 661 1107 q 436 1071 522 1125 l 289 1071 l 289 1088 q 393 1187 332 1126 q 489 1293 454 1249 l 718 1293 q 768 1197 733 1257 q 838 1088 804 1137 l 838 1071 z \"},\"Ã\":{\"ha\":872,\"x_min\":-83,\"x_max\":872,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 677 1071 q 619 1082 644 1071 q 572 1106 593 1093 q 530 1131 550 1120 q 488 1142 510 1142 q 450 1123 467 1142 q 424 1069 433 1104 l 304 1069 q 494 1279 344 1279 q 554 1268 528 1279 q 602 1243 580 1257 q 644 1219 625 1230 q 685 1208 664 1208 q 724 1226 708 1208 q 755 1280 741 1243 l 872 1280 q 677 1071 827 1071 z \"},\"Ä\":{\"ha\":872,\"x_min\":-83,\"x_max\":823,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 350 1166 q 379 1246 350 1219 q 460 1274 408 1274 q 550 1200 550 1274 q 524 1121 550 1151 q 441 1092 497 1092 q 350 1166 350 1092 m 623 1166 q 651 1246 623 1219 q 732 1274 680 1274 q 800 1255 777 1274 q 823 1200 823 1236 q 796 1121 823 1151 q 714 1092 769 1092 q 623 1166 623 1092 z \"},\"Å\":{\"ha\":872,\"x_min\":-83,\"x_max\":789,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 737 1063 q 690 945 737 990 q 565 900 642 900 q 444 943 490 900 q 397 1061 397 986 q 443 1179 397 1135 q 565 1222 490 1222 q 688 1178 640 1222 q 737 1063 737 1134 m 631 1061 q 612 1109 631 1092 q 565 1126 593 1126 q 518 1109 536 1126 q 500 1061 500 1092 q 516 1013 500 1031 q 565 996 532 996 q 612 1013 593 996 q 631 1061 631 1031 z \"},\"Æ\":{\"ha\":1243,\"x_min\":-83,\"x_max\":1291,\"o\":\"m 1080 0 l 526 0 l 576 236 l 288 236 l 139 0 l -83 0 l 542 991 l 1291 991 l 1254 819 l 907 819 l 861 602 l 1185 602 l 1147 429 l 823 429 l 770 174 l 1117 174 l 1080 0 m 614 412 l 700 819 l 646 819 l 399 412 l 614 412 z \"},\"Ç\":{\"ha\":850,\"x_min\":83,\"x_max\":905,\"o\":\"m 614 832 q 453 777 524 832 q 338 615 381 722 q 294 386 294 509 q 341 218 294 273 q 489 163 387 163 q 718 215 588 163 l 718 39 q 447 -14 583 -14 q 179 88 275 -14 q 83 375 83 189 q 154 702 83 553 q 342 929 224 852 q 614 1007 460 1007 q 764 992 699 1007 q 905 936 830 977 l 825 766 q 707 819 753 806 q 614 832 660 832 m 559 -170 q 503 -291 559 -248 q 345 -334 447 -334 q 241 -318 286 -334 l 241 -204 q 326 -220 284 -220 q 395 -164 395 -220 q 374 -126 395 -141 q 300 -104 353 -111 l 365 0 l 490 0 l 464 -49 q 559 -170 559 -82 z \"},\"È\":{\"ha\":753,\"x_min\":36,\"x_max\":800,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 614 1071 l 490 1071 q 396 1175 441 1118 q 326 1279 350 1232 l 326 1293 l 536 1293 q 614 1088 561 1193 l 614 1071 z \"},\"É\":{\"ha\":753,\"x_min\":36,\"x_max\":800,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 412 1088 q 563 1293 466 1147 l 790 1293 l 790 1282 q 686 1178 759 1244 q 554 1071 612 1113 l 412 1071 l 412 1088 z \"},\"Ê\":{\"ha\":753,\"x_min\":36,\"x_max\":800,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 798 1071 l 664 1071 q 554 1185 621 1107 q 397 1071 483 1125 l 250 1071 l 250 1088 q 353 1187 292 1126 q 450 1293 414 1249 l 679 1293 q 729 1197 694 1257 q 798 1088 764 1137 l 798 1071 z \"},\"Ë\":{\"ha\":753,\"x_min\":36,\"x_max\":800,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 297 1166 q 326 1246 297 1219 q 407 1274 355 1274 q 497 1200 497 1274 q 471 1121 497 1151 q 389 1092 444 1092 q 297 1166 297 1092 m 570 1166 q 598 1246 570 1219 q 680 1274 627 1274 q 747 1255 724 1274 q 770 1200 770 1236 q 743 1121 770 1151 q 661 1092 716 1092 q 570 1166 570 1092 z \"},\"Ð\":{\"ha\":940,\"x_min\":25,\"x_max\":897,\"o\":\"m 897 616 q 831 287 897 427 q 638 73 764 146 q 342 0 513 0 l 36 0 l 121 404 l 25 404 l 62 576 l 157 576 l 245 991 l 514 991 q 797 895 697 991 q 897 616 897 798 m 351 174 q 526 225 452 174 q 643 377 601 277 q 685 606 685 477 q 636 765 685 710 q 494 819 587 819 l 416 819 l 366 576 l 526 576 l 489 404 l 328 404 l 279 174 l 351 174 z \"},\"Ñ\":{\"ha\":1048,\"x_min\":36,\"x_max\":1055,\"o\":\"m 846 0 l 614 0 l 372 750 l 368 750 l 366 728 q 321 467 344 582 l 222 0 l 36 0 l 245 991 l 488 991 l 718 261 l 721 261 q 747 408 729 313 q 869 991 766 504 l 1055 991 l 846 0 m 755 1071 q 697 1082 722 1071 q 650 1106 671 1093 q 608 1131 628 1120 q 566 1142 588 1142 q 528 1123 545 1142 q 502 1069 511 1104 l 382 1069 q 572 1279 422 1279 q 632 1268 606 1279 q 680 1243 658 1257 q 722 1219 703 1230 q 763 1208 742 1208 q 802 1226 786 1208 q 833 1280 819 1243 l 950 1280 q 755 1071 905 1071 z \"},\"Ò\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 714 1071 l 589 1071 q 495 1175 541 1118 q 425 1279 450 1232 l 425 1293 l 636 1293 q 714 1088 661 1193 l 714 1071 z \"},\"Ó\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 511 1088 q 661 1293 564 1147 l 888 1293 l 888 1282 q 784 1178 857 1244 q 652 1071 711 1113 l 511 1071 l 511 1088 z \"},\"Ô\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 887 1071 l 753 1071 q 643 1185 710 1107 q 486 1071 572 1125 l 338 1071 l 338 1088 q 442 1187 381 1126 q 538 1293 503 1249 l 768 1293 q 818 1197 783 1257 q 887 1088 853 1137 l 887 1071 z \"},\"Õ\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 726 1071 q 668 1082 693 1071 q 621 1106 642 1093 q 579 1131 599 1120 q 536 1142 559 1142 q 499 1123 515 1142 q 473 1069 482 1104 l 353 1069 q 543 1279 393 1279 q 603 1268 576 1279 q 651 1243 629 1257 q 693 1219 673 1230 q 734 1208 713 1208 q 773 1226 757 1208 q 804 1280 789 1243 l 921 1280 q 726 1071 876 1071 z \"},\"Ö\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 397 1166 q 426 1246 397 1219 q 507 1274 454 1274 q 597 1200 597 1274 q 570 1121 597 1151 q 488 1092 544 1092 q 397 1166 397 1092 m 669 1166 q 698 1246 669 1219 q 779 1274 726 1274 q 846 1255 823 1274 q 869 1200 869 1236 q 843 1121 869 1151 q 761 1092 816 1092 q 669 1166 669 1092 z \"},\"×\":{\"ha\":765,\"x_min\":87,\"x_max\":705,\"o\":\"m 290 490 l 87 694 l 191 799 l 395 596 l 602 799 l 705 697 l 498 490 l 703 285 l 602 182 l 395 386 l 191 183 l 89 286 l 290 490 z \"},\"Ø\":{\"ha\":1014,\"x_min\":68,\"x_max\":989,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 245 35 330 -14 l 172 -58 l 68 20 l 150 122 q 83 364 83 216 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 815 956 732 1007 l 886 1044 l 989 965 l 909 867 q 971 636 971 776 m 590 836 q 435 774 505 836 q 326 603 365 712 q 288 364 288 494 q 293 296 288 342 l 697 807 q 590 836 650 836 m 768 631 l 765 685 l 366 183 q 469 158 406 158 q 623 218 553 158 q 730 386 692 279 q 768 631 768 494 z \"},\"Ù\":{\"ha\":960,\"x_min\":96,\"x_max\":972,\"o\":\"m 972 991 l 836 350 q 688 78 798 170 q 404 -14 579 -14 q 178 63 260 -14 q 96 272 96 140 q 106 366 96 321 l 239 991 l 446 991 l 314 368 q 302 283 302 318 q 431 163 302 163 q 563 215 514 163 q 633 370 612 267 l 765 991 l 972 991 m 680 1071 l 555 1071 q 461 1175 507 1118 q 391 1279 415 1232 l 391 1293 l 602 1293 q 680 1088 626 1193 l 680 1071 z \"},\"Ú\":{\"ha\":960,\"x_min\":96,\"x_max\":972,\"o\":\"m 972 991 l 836 350 q 688 78 798 170 q 404 -14 579 -14 q 178 63 260 -14 q 96 272 96 140 q 106 366 96 321 l 239 991 l 446 991 l 314 368 q 302 283 302 318 q 431 163 302 163 q 563 215 514 163 q 633 370 612 267 l 765 991 l 972 991 m 513 1088 q 664 1293 567 1147 l 891 1293 l 891 1282 q 787 1178 860 1244 q 655 1071 713 1113 l 513 1071 l 513 1088 z \"},\"Û\":{\"ha\":960,\"x_min\":96,\"x_max\":972,\"o\":\"m 972 991 l 836 350 q 688 78 798 170 q 404 -14 579 -14 q 178 63 260 -14 q 96 272 96 140 q 106 366 96 321 l 239 991 l 446 991 l 314 368 q 302 283 302 318 q 431 163 302 163 q 563 215 514 163 q 633 370 612 267 l 765 991 l 972 991 m 871 1071 l 736 1071 q 627 1185 694 1107 q 469 1071 555 1125 l 322 1071 l 322 1088 q 426 1187 365 1126 q 522 1293 487 1249 l 751 1293 q 802 1197 766 1257 q 871 1088 837 1137 l 871 1071 z \"},\"Ü\":{\"ha\":960,\"x_min\":96,\"x_max\":972,\"o\":\"m 972 991 l 836 350 q 688 78 798 170 q 404 -14 579 -14 q 178 63 260 -14 q 96 272 96 140 q 106 366 96 321 l 239 991 l 446 991 l 314 368 q 302 283 302 318 q 431 163 302 163 q 563 215 514 163 q 633 370 612 267 l 765 991 l 972 991 m 383 1166 q 412 1246 383 1219 q 493 1274 441 1274 q 583 1200 583 1274 q 557 1121 583 1151 q 475 1092 530 1092 q 383 1166 383 1092 m 656 1166 q 684 1246 656 1219 q 766 1274 713 1274 q 833 1255 810 1274 q 856 1200 856 1236 q 829 1121 856 1151 q 747 1092 802 1092 q 656 1166 656 1092 z \"},\"Ý\":{\"ha\":783,\"x_min\":126,\"x_max\":911,\"o\":\"m 425 590 l 679 991 l 911 991 l 492 379 l 411 0 l 205 0 l 286 379 l 126 991 l 338 991 l 425 590 m 411 1088 q 562 1293 465 1147 l 789 1293 l 789 1282 q 684 1178 758 1244 q 553 1071 611 1113 l 411 1071 l 411 1088 z \"},\"Þ\":{\"ha\":806,\"x_min\":36,\"x_max\":775,\"o\":\"m 775 547 q 660 291 775 382 q 343 199 544 199 l 285 199 l 243 0 l 36 0 l 245 991 l 453 991 l 419 836 l 443 836 q 691 764 607 836 q 775 547 775 692 m 322 371 l 359 371 q 510 416 454 371 q 567 542 567 461 q 435 664 567 664 l 385 664 l 322 371 z \"},\"ß\":{\"ha\":916,\"x_min\":-176,\"x_max\":882,\"o\":\"m 574 1063 q 798 1002 715 1063 q 882 839 882 941 q 848 709 882 762 q 728 606 815 656 q 663 559 678 577 q 647 522 647 541 q 662 489 647 507 q 715 441 677 471 q 813 339 788 385 q 839 237 839 294 q 755 54 839 122 q 526 -14 671 -14 q 325 28 399 -14 l 325 191 q 500 138 412 138 q 600 160 568 138 q 632 218 632 182 q 614 269 632 245 q 541 335 596 293 q 453 423 477 384 q 429 509 429 463 q 460 607 429 566 q 570 693 490 648 q 641 745 614 718 q 667 810 667 771 q 640 877 667 852 q 555 901 613 901 q 450 866 490 901 q 392 750 409 831 l 220 -77 q 120 -272 191 -211 q -68 -334 50 -334 q -176 -317 -129 -334 l -176 -153 q -98 -167 -135 -167 q 17 -46 -8 -167 l 189 772 q 313 994 221 924 q 574 1063 404 1063 z \"},\"à\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 589 842 l 465 842 q 371 946 416 888 q 300 1050 325 1003 l 300 1064 l 511 1064 q 589 859 536 964 l 589 842 z \"},\"á\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 406 859 q 556 1064 459 918 l 783 1064 l 783 1053 q 679 949 752 1015 q 547 842 606 884 l 406 842 l 406 859 z \"},\"â\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 760 841 l 625 841 q 515 955 583 877 q 358 841 444 895 l 211 841 l 211 858 q 315 958 254 897 q 411 1063 376 1019 l 640 1063 q 690 967 655 1027 q 760 858 726 907 l 760 841 z \"},\"ã\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 600 842 q 541 853 566 842 q 494 877 515 864 q 452 902 472 890 q 410 913 432 913 q 372 894 389 913 q 346 840 355 875 l 226 840 q 416 1050 266 1050 q 476 1039 450 1050 q 524 1014 502 1027 q 566 990 547 1001 q 607 979 586 979 q 646 997 630 979 q 677 1051 663 1014 l 794 1051 q 600 842 749 842 z \"},\"ä\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 269 937 q 298 1017 269 990 q 379 1044 327 1044 q 469 971 469 1044 q 443 892 469 922 q 361 863 416 863 q 269 937 269 863 m 542 937 q 570 1017 542 990 q 652 1044 599 1044 q 719 1025 696 1044 q 742 971 742 1006 q 715 892 742 922 q 633 863 688 863 q 542 937 542 863 z \"},\"å\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 694 1003 q 646 885 694 930 q 522 840 599 840 q 400 883 447 840 q 353 1002 353 926 q 400 1119 353 1076 q 522 1162 446 1162 q 645 1118 596 1162 q 694 1003 694 1074 m 587 1002 q 569 1049 587 1032 q 522 1067 550 1067 q 475 1049 493 1067 q 456 1002 456 1032 q 473 954 456 971 q 522 936 489 936 q 569 954 550 936 q 587 1002 587 971 z \"},\"æ\":{\"ha\":1211,\"x_min\":61,\"x_max\":1177,\"o\":\"m 818 -14 q 696 5 744 -14 q 616 64 648 23 l 606 0 l 478 0 l 488 98 l 484 98 q 384 13 435 39 q 271 -14 333 -14 q 116 60 172 -14 q 61 261 61 134 q 107 516 61 397 q 233 704 154 635 q 408 772 312 772 q 517 746 473 772 q 595 661 561 720 l 599 661 l 637 758 l 765 758 l 753 697 q 834 751 783 730 q 949 772 886 772 q 1116 716 1055 772 q 1177 566 1177 659 q 1063 370 1177 439 q 741 301 950 301 l 705 301 l 704 288 l 704 275 q 742 175 704 210 q 850 140 779 140 q 953 156 895 140 q 1063 199 1011 172 l 1063 45 q 818 -14 941 -14 m 351 151 q 442 197 400 151 q 509 322 484 243 q 534 488 534 401 q 512 574 534 542 q 443 607 490 607 q 356 560 397 607 q 292 434 315 513 q 268 271 268 355 q 290 182 268 214 q 351 151 312 151 m 909 625 q 797 571 850 625 q 728 439 744 517 l 758 439 q 922 472 863 439 q 981 561 981 505 q 909 625 981 625 z \"},\"ç\":{\"ha\":671,\"x_min\":61,\"x_max\":685,\"o\":\"m 343 -14 q 134 59 207 -14 q 61 265 61 132 q 112 527 61 409 q 254 708 162 644 q 463 772 345 772 q 685 724 586 772 l 623 568 q 551 595 586 584 q 471 607 515 607 q 367 564 413 607 q 294 445 320 520 q 268 282 268 369 q 299 184 268 217 q 385 151 330 151 q 480 167 436 151 q 571 207 524 183 l 571 40 q 343 -14 468 -14 m 443 -170 q 387 -291 443 -248 q 228 -334 330 -334 q 125 -318 170 -334 l 125 -204 q 210 -220 168 -220 q 279 -164 279 -220 q 258 -126 279 -141 q 183 -104 237 -111 l 248 0 l 374 0 l 347 -49 q 443 -170 443 -82 z \"},\"è\":{\"ha\":774,\"x_min\":61,\"x_max\":739,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 576 842 l 451 842 q 357 946 403 888 q 287 1050 311 1003 l 287 1064 l 498 1064 q 576 859 522 964 l 576 842 z \"},\"é\":{\"ha\":774,\"x_min\":61,\"x_max\":739,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 358 859 q 509 1064 412 918 l 736 1064 l 736 1053 q 631 949 705 1015 q 500 842 558 884 l 358 842 l 358 859 z \"},\"ê\":{\"ha\":774,\"x_min\":61,\"x_max\":747,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 747 842 l 612 842 q 503 956 570 878 q 345 842 431 896 l 198 842 l 198 859 q 302 958 241 897 q 398 1064 363 1019 l 627 1064 q 677 967 642 1027 q 747 859 713 907 l 747 842 z \"},\"ë\":{\"ha\":774,\"x_min\":61,\"x_max\":739,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 248 937 q 276 1017 248 990 q 357 1044 305 1044 q 448 971 448 1044 q 421 892 448 922 q 339 863 395 863 q 248 937 248 863 m 520 937 q 549 1017 520 990 q 630 1044 577 1044 q 697 1025 674 1044 q 720 971 720 1006 q 693 892 720 922 q 612 863 667 863 q 520 937 520 863 z \"},\"ì\":{\"ha\":412,\"x_min\":25,\"x_max\":393,\"o\":\"m 229 0 l 25 0 l 186 758 l 390 758 l 229 0 m 393 842 l 268 842 q 174 946 220 888 q 104 1050 128 1003 l 104 1064 l 315 1064 q 393 859 339 964 l 393 842 z \"},\"í\":{\"ha\":412,\"x_min\":25,\"x_max\":575,\"o\":\"m 229 0 l 25 0 l 186 758 l 390 758 l 229 0 m 197 859 q 348 1064 251 918 l 575 1064 l 575 1053 q 471 949 544 1015 q 339 842 397 884 l 197 842 l 197 859 z \"},\"î\":{\"ha\":412,\"x_min\":24,\"x_max\":573,\"o\":\"m 229 0 l 25 0 l 186 758 l 390 758 l 229 0 m 573 842 l 439 842 q 329 956 396 878 q 172 842 258 896 l 24 842 l 24 859 q 128 958 67 897 q 224 1064 189 1019 l 454 1064 q 504 967 469 1027 q 573 859 539 907 l 573 842 z \"},\"ï\":{\"ha\":412,\"x_min\":25,\"x_max\":558,\"o\":\"m 229 0 l 25 0 l 186 758 l 390 758 l 229 0 m 85 937 q 114 1017 85 990 q 195 1044 143 1044 q 286 971 286 1044 q 259 892 286 922 q 177 863 233 863 q 85 937 85 863 m 358 937 q 387 1017 358 990 q 468 1044 415 1044 q 535 1025 512 1044 q 558 971 558 1006 q 531 892 558 922 q 450 863 505 863 q 358 937 358 863 z \"},\"ð\":{\"ha\":802,\"x_min\":49,\"x_max\":785,\"o\":\"m 419 888 q 335 942 396 911 l 415 1068 q 572 974 506 1027 l 733 1063 l 785 960 l 654 888 q 731 728 709 815 q 753 539 753 642 q 706 246 753 370 q 568 54 659 121 q 349 -14 477 -14 q 125 61 202 -14 q 49 275 49 136 q 93 479 49 387 q 215 623 136 572 q 395 675 294 675 q 497 654 451 675 q 575 590 544 633 l 579 590 q 500 800 566 734 l 343 711 l 283 811 l 419 888 m 358 139 q 441 177 403 139 q 502 277 479 214 q 524 408 524 340 q 497 491 524 460 q 424 522 471 522 q 336 486 374 522 q 276 389 297 450 q 254 256 254 328 q 281 170 254 201 q 358 139 307 139 z \"},\"ñ\":{\"ha\":839,\"x_min\":25,\"x_max\":811,\"o\":\"m 663 0 l 458 0 l 551 443 q 562 524 562 489 q 489 607 562 607 q 376 530 427 607 q 296 314 325 452 l 229 0 l 25 0 l 186 758 l 342 758 l 328 618 l 332 618 q 572 772 431 772 q 717 716 666 772 q 768 554 768 659 q 753 432 768 505 l 663 0 m 616 842 q 558 853 583 842 q 511 877 532 864 q 469 902 489 890 q 427 913 449 913 q 389 894 406 913 q 363 840 372 875 l 243 840 q 433 1050 283 1050 q 493 1039 467 1050 q 541 1014 519 1027 q 583 990 564 1001 q 624 979 603 979 q 663 997 647 979 q 694 1051 680 1014 l 811 1051 q 616 842 766 842 z \"},\"ò\":{\"ha\":812,\"x_min\":61,\"x_max\":751,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 573 842 l 448 842 q 354 946 400 888 q 284 1050 309 1003 l 284 1064 l 495 1064 q 573 859 519 964 l 573 842 z \"},\"ó\":{\"ha\":812,\"x_min\":61,\"x_max\":765,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 387 859 q 538 1064 441 918 l 765 1064 l 765 1053 q 661 949 734 1015 q 529 842 587 884 l 387 842 l 387 859 z \"},\"ô\":{\"ha\":812,\"x_min\":61,\"x_max\":752,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 752 842 l 618 842 q 508 956 575 878 q 351 842 437 896 l 203 842 l 203 859 q 307 958 246 897 q 404 1064 368 1019 l 633 1064 q 683 967 648 1027 q 752 859 718 907 l 752 842 z \"},\"õ\":{\"ha\":812,\"x_min\":61,\"x_max\":781,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 587 842 q 528 853 553 842 q 481 877 503 864 q 439 902 459 890 q 397 913 419 913 q 359 894 376 913 q 333 840 342 875 l 213 840 q 404 1050 253 1050 q 463 1039 437 1050 q 511 1014 489 1027 q 553 990 534 1001 q 594 979 573 979 q 633 997 617 979 q 665 1051 650 1014 l 781 1051 q 587 842 736 842 z \"},\"ö\":{\"ha\":812,\"x_min\":61,\"x_max\":751,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 262 937 q 291 1017 262 990 q 372 1044 319 1044 q 462 971 462 1044 q 435 892 462 922 q 353 863 409 863 q 262 937 262 863 m 534 937 q 563 1017 534 990 q 644 1044 591 1044 q 711 1025 688 1044 q 734 971 734 1006 q 708 892 734 922 q 626 863 681 863 q 534 937 534 863 z \"},\"÷\":{\"ha\":765,\"x_min\":74,\"x_max\":720,\"o\":\"m 74 415 l 74 564 l 720 564 l 720 415 l 74 415 m 301 253 q 326 330 301 304 q 396 355 351 355 q 466 329 441 355 q 490 253 490 302 q 465 178 490 205 q 396 150 440 150 q 327 176 352 150 q 301 253 301 203 m 301 726 q 326 803 301 777 q 396 829 351 829 q 466 802 441 829 q 490 726 490 774 q 465 651 490 679 q 396 624 440 624 q 327 650 352 624 q 301 726 301 677 z \"},\"ø\":{\"ha\":812,\"x_min\":29,\"x_max\":764,\"o\":\"m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 199 22 268 -14 l 125 -69 l 29 4 l 110 104 q 61 278 61 177 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 618 734 553 772 l 665 794 l 764 720 l 707 648 q 751 472 751 576 m 449 612 q 351 570 394 612 q 284 455 308 528 q 261 297 261 382 l 261 289 l 509 596 q 449 612 485 612 m 368 146 q 499 236 446 146 q 553 452 553 326 l 553 463 l 310 161 q 334 151 317 156 q 368 146 351 146 z \"},\"ù\":{\"ha\":839,\"x_min\":75,\"x_max\":815,\"o\":\"m 178 758 l 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 125 42 174 -14 q 75 204 75 98 q 92 349 75 267 l 178 758 m 573 842 l 448 842 q 354 946 400 888 q 284 1050 309 1003 l 284 1064 l 495 1064 q 573 859 519 964 l 573 842 z \"},\"ú\":{\"ha\":839,\"x_min\":75,\"x_max\":815,\"o\":\"m 178 758 l 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 125 42 174 -14 q 75 204 75 98 q 92 349 75 267 l 178 758 m 414 859 q 564 1064 467 918 l 791 1064 l 791 1053 q 687 949 760 1015 q 555 842 614 884 l 414 842 l 414 859 z \"},\"û\":{\"ha\":839,\"x_min\":75,\"x_max\":815,\"o\":\"m 178 758 l 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 125 42 174 -14 q 75 204 75 98 q 92 349 75 267 l 178 758 m 775 842 l 641 842 q 531 956 598 878 q 374 842 460 896 l 227 842 l 227 859 q 330 958 269 897 q 427 1064 391 1019 l 656 1064 q 706 967 671 1027 q 775 859 741 907 l 775 842 z \"},\"ü\":{\"ha\":839,\"x_min\":75,\"x_max\":815,\"o\":\"m 178 758 l 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 125 42 174 -14 q 75 204 75 98 q 92 349 75 267 l 178 758 m 279 937 q 308 1017 279 990 q 389 1044 336 1044 q 479 971 479 1044 q 452 892 479 922 q 370 863 426 863 q 279 937 279 863 m 551 937 q 580 1017 551 990 q 661 1044 608 1044 q 728 1025 705 1044 q 751 971 751 1006 q 725 892 751 922 q 643 863 698 863 q 551 937 551 863 z \"},\"ý\":{\"ha\":721,\"x_min\":-96,\"x_max\":793,\"o\":\"m 69 758 l 269 758 l 307 407 q 317 208 317 324 l 321 208 q 351 289 334 243 q 395 393 367 336 l 571 758 l 793 758 l 332 -109 q 4 -334 212 -334 q -96 -321 -57 -334 l -96 -158 q -17 -167 -50 -167 q 83 -134 40 -167 q 163 -33 126 -102 l 180 0 l 69 758 m 337 859 q 488 1064 391 918 l 715 1064 l 715 1053 q 610 949 684 1015 q 479 842 537 884 l 337 842 l 337 859 z \"},\"þ\":{\"ha\":827,\"x_min\":-46,\"x_max\":765,\"o\":\"m 551 772 q 709 700 653 772 q 765 496 765 628 q 718 237 765 361 q 595 50 671 114 q 425 -14 518 -14 q 241 97 304 -14 l 236 97 q 207 -103 228 -11 l 158 -334 l -46 -334 l 249 1055 l 453 1055 l 408 847 q 354 657 389 758 l 359 657 q 551 772 448 772 m 463 607 q 374 563 414 607 q 310 438 334 519 q 285 271 285 357 q 308 184 285 216 q 379 151 330 151 q 467 195 426 151 q 533 320 507 239 q 558 488 558 400 q 533 577 558 547 q 463 607 507 607 z \"},\"ÿ\":{\"ha\":721,\"x_min\":-96,\"x_max\":793,\"o\":\"m 69 758 l 269 758 l 307 407 q 317 208 317 324 l 321 208 q 351 289 334 243 q 395 393 367 336 l 571 758 l 793 758 l 332 -109 q 4 -334 212 -334 q -96 -321 -57 -334 l -96 -158 q -17 -167 -50 -167 q 83 -134 40 -167 q 163 -33 126 -102 l 180 0 l 69 758 m 210 937 q 239 1017 210 990 q 320 1044 268 1044 q 410 971 410 1044 q 384 892 410 922 q 302 863 357 863 q 210 937 210 863 m 483 937 q 511 1017 483 990 q 593 1044 540 1044 q 660 1025 637 1044 q 683 971 683 1006 q 656 892 683 922 q 574 863 629 863 q 483 937 483 863 z \"},\"Ā\":{\"ha\":872,\"x_min\":-83,\"x_max\":811,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 391 1214 l 811 1214 l 781 1071 l 361 1071 l 391 1214 z \"},\"ā\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 315 985 l 735 985 l 705 842 l 285 842 l 315 985 z \"},\"Ă\":{\"ha\":872,\"x_min\":-83,\"x_max\":840,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 840 1300 q 574 1071 803 1071 q 412 1120 470 1071 q 354 1255 354 1170 q 358 1300 354 1281 l 476 1300 q 501 1236 476 1256 q 581 1215 526 1215 q 667 1234 633 1215 q 712 1300 701 1252 l 840 1300 z \"},\"ă\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 766 1071 q 500 842 729 842 q 338 891 396 842 q 280 1026 280 941 q 284 1071 280 1052 l 402 1071 q 427 1006 402 1027 q 507 986 452 986 q 593 1004 559 986 q 638 1071 627 1023 l 766 1071 z \"},\"Ą\":{\"ha\":872,\"x_min\":-83,\"x_max\":789,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 722 0 q 617 -100 642 -65 q 593 -170 593 -136 q 604 -199 593 -189 q 633 -210 614 -210 q 703 -197 663 -210 l 703 -317 q 591 -334 646 -334 q 482 -297 522 -334 q 441 -201 441 -261 q 474 -99 441 -146 q 587 0 506 -52 l 722 0 z \"},\"ą\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 620 0 q 515 -100 539 -65 q 490 -170 490 -136 q 501 -199 490 -189 q 531 -210 512 -210 q 600 -197 561 -210 l 600 -317 q 489 -334 543 -334 q 379 -297 420 -334 q 339 -201 339 -261 q 371 -99 339 -146 q 485 0 404 -52 l 620 0 z \"},\"Ć\":{\"ha\":850,\"x_min\":83,\"x_max\":905,\"o\":\"m 614 832 q 453 777 524 832 q 338 615 381 722 q 294 386 294 509 q 341 218 294 273 q 489 163 387 163 q 718 215 588 163 l 718 39 q 447 -14 583 -14 q 179 88 275 -14 q 83 375 83 189 q 154 702 83 553 q 342 929 224 852 q 614 1007 460 1007 q 764 992 699 1007 q 905 936 830 977 l 825 766 q 707 819 753 806 q 614 832 660 832 m 498 1088 q 649 1293 552 1147 l 876 1293 l 876 1282 q 772 1178 845 1244 q 640 1071 699 1113 l 498 1071 l 498 1088 z \"},\"ć\":{\"ha\":671,\"x_min\":61,\"x_max\":724,\"o\":\"m 343 -14 q 134 59 207 -14 q 61 265 61 132 q 112 527 61 409 q 254 708 162 644 q 463 772 345 772 q 685 724 586 772 l 623 568 q 551 595 586 584 q 471 607 515 607 q 367 564 413 607 q 294 445 320 520 q 268 282 268 369 q 299 184 268 217 q 385 151 330 151 q 480 167 436 151 q 571 207 524 183 l 571 40 q 343 -14 468 -14 m 346 859 q 496 1064 399 918 l 724 1064 l 724 1053 q 619 949 692 1015 q 488 842 546 884 l 346 842 l 346 859 z \"},\"Ĉ\":{\"ha\":850,\"x_min\":83,\"x_max\":905,\"o\":\"m 614 832 q 453 777 524 832 q 338 615 381 722 q 294 386 294 509 q 341 218 294 273 q 489 163 387 163 q 718 215 588 163 l 718 39 q 447 -14 583 -14 q 179 88 275 -14 q 83 375 83 189 q 154 702 83 553 q 342 929 224 852 q 614 1007 460 1007 q 764 992 699 1007 q 905 936 830 977 l 825 766 q 707 819 753 806 q 614 832 660 832 m 876 1071 l 742 1071 q 632 1185 699 1107 q 475 1071 561 1125 l 328 1071 l 328 1088 q 431 1187 370 1126 q 528 1293 492 1249 l 757 1293 q 807 1197 772 1257 q 876 1088 842 1137 l 876 1071 z \"},\"ĉ\":{\"ha\":671,\"x_min\":61,\"x_max\":720,\"o\":\"m 343 -14 q 134 59 207 -14 q 61 265 61 132 q 112 527 61 409 q 254 708 162 644 q 463 772 345 772 q 685 724 586 772 l 623 568 q 551 595 586 584 q 471 607 515 607 q 367 564 413 607 q 294 445 320 520 q 268 282 268 369 q 299 184 268 217 q 385 151 330 151 q 480 167 436 151 q 571 207 524 183 l 571 40 q 343 -14 468 -14 m 720 842 l 586 842 q 476 956 543 878 q 319 842 405 896 l 172 842 l 172 859 q 275 958 214 897 q 372 1064 336 1019 l 601 1064 q 651 967 616 1027 q 720 859 686 907 l 720 842 z \"},\"Ċ\":{\"ha\":850,\"x_min\":83,\"x_max\":905,\"o\":\"m 614 832 q 453 777 524 832 q 338 615 381 722 q 294 386 294 509 q 341 218 294 273 q 489 163 387 163 q 718 215 588 163 l 718 39 q 447 -14 583 -14 q 179 88 275 -14 q 83 375 83 189 q 154 702 83 553 q 342 929 224 852 q 614 1007 460 1007 q 764 992 699 1007 q 905 936 830 977 l 825 766 q 707 819 753 806 q 614 832 660 832 m 526 1165 q 558 1254 526 1224 q 649 1284 590 1284 q 724 1263 699 1284 q 750 1203 750 1242 q 720 1115 750 1149 q 628 1082 690 1082 q 526 1165 526 1082 z \"},\"ċ\":{\"ha\":671,\"x_min\":61,\"x_max\":685,\"o\":\"m 343 -14 q 134 59 207 -14 q 61 265 61 132 q 112 527 61 409 q 254 708 162 644 q 463 772 345 772 q 685 724 586 772 l 623 568 q 551 595 586 584 q 471 607 515 607 q 367 564 413 607 q 294 445 320 520 q 268 282 268 369 q 299 184 268 217 q 385 151 330 151 q 480 167 436 151 q 571 207 524 183 l 571 40 q 343 -14 468 -14 m 360 936 q 392 1025 360 995 q 484 1055 425 1055 q 559 1034 533 1055 q 585 974 585 1013 q 555 886 585 920 q 463 852 525 852 q 360 936 360 852 z \"},\"Č\":{\"ha\":850,\"x_min\":83,\"x_max\":905,\"o\":\"m 614 832 q 453 777 524 832 q 338 615 381 722 q 294 386 294 509 q 341 218 294 273 q 489 163 387 163 q 718 215 588 163 l 718 39 q 447 -14 583 -14 q 179 88 275 -14 q 83 375 83 189 q 154 702 83 553 q 342 929 224 852 q 614 1007 460 1007 q 764 992 699 1007 q 905 936 830 977 l 825 766 q 707 819 753 806 q 614 832 660 832 m 349 1293 l 483 1293 q 593 1179 526 1257 q 750 1293 671 1243 l 897 1293 l 897 1276 q 697 1071 753 1142 l 468 1071 q 418 1167 453 1107 q 349 1276 382 1227 l 349 1293 z \"},\"č\":{\"ha\":671,\"x_min\":61,\"x_max\":758,\"o\":\"m 343 -14 q 134 59 207 -14 q 61 265 61 132 q 112 527 61 409 q 254 708 162 644 q 463 772 345 772 q 685 724 586 772 l 623 568 q 551 595 586 584 q 471 607 515 607 q 367 564 413 607 q 294 445 320 520 q 268 282 268 369 q 299 184 268 217 q 385 151 330 151 q 480 167 436 151 q 571 207 524 183 l 571 40 q 343 -14 468 -14 m 209 1064 l 343 1064 q 453 950 386 1028 q 610 1064 531 1014 l 758 1064 l 758 1047 q 557 842 614 913 l 328 842 q 278 938 313 878 q 209 1047 243 998 l 209 1064 z \"},\"Ď\":{\"ha\":940,\"x_min\":36,\"x_max\":897,\"o\":\"m 897 616 q 831 287 897 427 q 638 73 764 146 q 342 0 513 0 l 36 0 l 245 991 l 514 991 q 797 895 697 991 q 897 616 897 798 m 351 174 q 526 225 452 174 q 643 377 601 277 q 685 606 685 477 q 636 765 685 710 q 494 819 587 819 l 416 819 l 279 174 l 351 174 m 318 1293 l 452 1293 q 562 1179 495 1257 q 720 1293 640 1243 l 867 1293 l 867 1276 q 667 1071 723 1142 l 437 1071 q 387 1167 422 1107 q 318 1276 352 1227 l 318 1293 z \"},\"ď\":{\"ha\":825,\"x_min\":61,\"x_max\":1158,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 262 61 132 q 110 516 61 395 q 237 705 158 637 q 412 772 317 772 q 508 747 468 772 q 585 661 549 722 l 590 661 l 591 680 q 608 812 595 755 l 660 1055 l 864 1055 l 640 0 l 485 0 l 494 98 l 492 98 q 391 13 444 39 q 275 -14 338 -14 m 361 151 q 448 198 406 151 q 516 321 490 244 q 542 488 542 399 q 516 574 542 542 q 447 607 491 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 361 151 268 151 m 882 851 q 966 1055 939 972 l 1158 1055 l 1158 1042 q 1093 942 1138 1003 q 1004 833 1048 880 l 882 833 l 882 851 z \"},\"Đ\":{\"ha\":940,\"x_min\":25,\"x_max\":897,\"o\":\"m 897 616 q 831 287 897 427 q 638 73 764 146 q 342 0 513 0 l 36 0 l 121 404 l 25 404 l 62 576 l 157 576 l 245 991 l 514 991 q 797 895 697 991 q 897 616 897 798 m 351 174 q 526 225 452 174 q 643 377 601 277 q 685 606 685 477 q 636 765 685 710 q 494 819 587 819 l 416 819 l 366 576 l 526 576 l 489 404 l 328 404 l 279 174 l 351 174 z \"},\"đ\":{\"ha\":825,\"x_min\":61,\"x_max\":945,\"o\":\"m 404 730 q 506 707 464 730 q 579 629 549 684 l 585 629 q 588 684 585 648 q 608 811 592 721 l 408 811 l 436 946 l 636 946 l 660 1055 l 864 1055 l 840 946 l 945 946 l 917 811 l 811 811 l 640 0 l 485 0 l 494 98 l 492 98 q 390 12 439 37 q 282 -14 340 -14 q 120 58 179 -14 q 61 262 61 130 q 109 498 61 385 q 233 671 156 612 q 404 730 309 730 m 364 151 q 450 192 410 151 q 515 308 489 232 q 541 457 541 384 q 518 536 541 506 q 447 566 496 566 q 357 524 399 566 q 292 414 316 483 q 268 271 268 346 q 294 181 268 211 q 364 151 319 151 z \"},\"Ē\":{\"ha\":753,\"x_min\":36,\"x_max\":800,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 350 1214 l 770 1214 l 739 1071 l 319 1071 l 350 1214 z \"},\"ē\":{\"ha\":774,\"x_min\":61,\"x_max\":739,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 298 985 l 718 985 l 688 842 l 268 842 l 298 985 z \"},\"Ĕ\":{\"ha\":753,\"x_min\":36,\"x_max\":800,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 799 1300 q 532 1071 762 1071 q 371 1120 429 1071 q 313 1255 313 1170 q 317 1300 313 1281 l 435 1300 q 459 1236 435 1256 q 539 1215 484 1215 q 626 1234 592 1215 q 671 1300 659 1252 l 799 1300 z \"},\"ĕ\":{\"ha\":774,\"x_min\":61,\"x_max\":762,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 762 1071 q 495 842 724 842 q 333 891 391 842 q 275 1026 275 941 q 279 1071 275 1052 l 397 1071 q 422 1006 397 1027 q 502 986 447 986 q 588 1004 555 986 q 633 1071 622 1023 l 762 1071 z \"},\"Ė\":{\"ha\":753,\"x_min\":36,\"x_max\":800,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 422 1145 q 455 1235 422 1204 q 546 1265 487 1265 q 621 1244 595 1265 q 647 1183 647 1223 q 617 1096 647 1129 q 525 1062 587 1062 q 422 1145 422 1062 z \"},\"ė\":{\"ha\":774,\"x_min\":61,\"x_max\":739,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 388 936 q 420 1025 388 995 q 511 1055 452 1055 q 587 1034 561 1055 q 612 974 612 1013 q 583 886 612 920 q 490 852 553 852 q 388 936 388 852 z \"},\"Ę\":{\"ha\":753,\"x_min\":36,\"x_max\":800,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 524 0 q 418 -100 443 -65 q 394 -170 394 -136 q 405 -199 394 -189 q 435 -210 416 -210 q 504 -197 465 -210 l 504 -317 q 393 -334 447 -334 q 283 -297 323 -334 q 243 -201 243 -261 q 275 -99 243 -146 q 389 0 307 -52 l 524 0 z \"},\"ę\":{\"ha\":774,\"x_min\":61,\"x_max\":739,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 469 14 q 363 -87 388 -52 q 339 -156 339 -122 q 350 -185 339 -175 q 380 -196 361 -196 q 449 -184 410 -196 l 449 -303 q 338 -320 392 -320 q 228 -284 269 -320 q 188 -188 188 -248 q 220 -85 188 -132 q 334 14 252 -39 l 469 14 z \"},\"Ě\":{\"ha\":753,\"x_min\":36,\"x_max\":835,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 286 1293 l 420 1293 q 530 1179 463 1257 q 688 1293 608 1243 l 835 1293 l 835 1276 q 635 1071 691 1142 l 406 1071 q 355 1167 391 1107 q 286 1276 320 1227 l 286 1293 z \"},\"ě\":{\"ha\":774,\"x_min\":61,\"x_max\":795,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 247 1064 l 381 1064 q 491 950 424 1028 q 648 1064 569 1014 l 795 1064 l 795 1047 q 595 842 652 913 l 366 842 q 316 938 351 878 q 247 1047 281 998 l 247 1064 z \"},\"Ĝ\":{\"ha\":958,\"x_min\":83,\"x_max\":942,\"o\":\"m 511 557 l 893 557 l 783 40 q 615 -2 692 9 q 450 -14 537 -14 q 179 86 275 -14 q 83 372 83 186 q 156 701 83 554 q 360 927 229 848 q 664 1007 492 1007 q 942 940 812 1007 l 864 770 q 764 813 814 797 q 654 829 713 829 q 469 773 551 829 q 341 613 387 717 q 294 389 294 509 q 343 217 294 272 q 494 163 393 163 q 610 179 546 163 l 654 382 l 473 382 l 511 557 m 887 1071 l 753 1071 q 643 1185 710 1107 q 486 1071 572 1125 l 338 1071 l 338 1088 q 442 1187 381 1126 q 538 1293 503 1249 l 768 1293 q 818 1197 783 1257 q 887 1088 853 1137 l 887 1071 z \"},\"ĝ\":{\"ha\":751,\"x_min\":-78,\"x_max\":807,\"o\":\"m 804 757 l 781 644 l 663 616 q 673 536 673 581 q 591 327 673 404 q 368 250 509 250 q 301 257 328 250 q 244 204 244 239 q 264 171 244 181 q 325 155 285 161 l 418 143 q 579 86 528 129 q 629 -39 629 43 q 524 -258 629 -182 q 221 -334 418 -334 q 1 -282 80 -334 q -78 -142 -78 -231 q -32 -23 -78 -73 q 114 60 15 27 q 64 150 64 92 q 94 233 64 198 q 193 300 124 268 q 128 376 149 333 q 107 479 107 418 q 192 693 107 614 q 424 772 277 772 q 536 757 480 772 l 804 757 m 248 -4 q 139 -43 176 -14 q 102 -117 102 -72 q 233 -195 102 -195 q 388 -164 336 -195 q 440 -78 440 -134 q 418 -37 440 -52 q 325 -14 396 -23 l 248 -4 m 416 643 q 332 591 364 643 q 300 461 300 539 q 370 380 300 380 q 452 432 420 380 q 484 564 484 484 q 416 643 484 643 m 807 842 l 673 842 q 563 956 630 878 q 406 842 492 896 l 258 842 l 258 859 q 362 958 301 897 q 458 1064 423 1019 l 688 1064 q 738 967 703 1027 q 807 859 773 907 l 807 842 z \"},\"Ğ\":{\"ha\":958,\"x_min\":83,\"x_max\":942,\"o\":\"m 511 557 l 893 557 l 783 40 q 615 -2 692 9 q 450 -14 537 -14 q 179 86 275 -14 q 83 372 83 186 q 156 701 83 554 q 360 927 229 848 q 664 1007 492 1007 q 942 940 812 1007 l 864 770 q 764 813 814 797 q 654 829 713 829 q 469 773 551 829 q 341 613 387 717 q 294 389 294 509 q 343 217 294 272 q 494 163 393 163 q 610 179 546 163 l 654 382 l 473 382 l 511 557 m 884 1300 q 617 1071 846 1071 q 455 1120 513 1071 q 397 1255 397 1170 q 401 1300 397 1281 l 519 1300 q 544 1236 519 1256 q 624 1215 569 1215 q 710 1234 677 1215 q 755 1300 744 1252 l 884 1300 z \"},\"ğ\":{\"ha\":751,\"x_min\":-78,\"x_max\":804,\"o\":\"m 804 757 l 781 644 l 663 616 q 673 536 673 581 q 591 327 673 404 q 368 250 509 250 q 301 257 328 250 q 244 204 244 239 q 264 171 244 181 q 325 155 285 161 l 418 143 q 579 86 528 129 q 629 -39 629 43 q 524 -258 629 -182 q 221 -334 418 -334 q 1 -282 80 -334 q -78 -142 -78 -231 q -32 -23 -78 -73 q 114 60 15 27 q 64 150 64 92 q 94 233 64 198 q 193 300 124 268 q 128 376 149 333 q 107 479 107 418 q 192 693 107 614 q 424 772 277 772 q 536 757 480 772 l 804 757 m 248 -4 q 139 -43 176 -14 q 102 -117 102 -72 q 233 -195 102 -195 q 388 -164 336 -195 q 440 -78 440 -134 q 418 -37 440 -52 q 325 -14 396 -23 l 248 -4 m 416 643 q 332 591 364 643 q 300 461 300 539 q 370 380 300 380 q 452 432 420 380 q 484 564 484 484 q 416 643 484 643 m 779 1071 q 513 842 742 842 q 351 891 409 842 q 293 1026 293 941 q 297 1071 293 1052 l 415 1071 q 440 1006 415 1027 q 519 986 465 986 q 606 1004 572 986 q 651 1071 640 1023 l 779 1071 z \"},\"Ġ\":{\"ha\":958,\"x_min\":83,\"x_max\":942,\"o\":\"m 511 557 l 893 557 l 783 40 q 615 -2 692 9 q 450 -14 537 -14 q 179 86 275 -14 q 83 372 83 186 q 156 701 83 554 q 360 927 229 848 q 664 1007 492 1007 q 942 940 812 1007 l 864 770 q 764 813 814 797 q 654 829 713 829 q 469 773 551 829 q 341 613 387 717 q 294 389 294 509 q 343 217 294 272 q 494 163 393 163 q 610 179 546 163 l 654 382 l 473 382 l 511 557 m 527 1165 q 559 1254 527 1224 q 650 1284 591 1284 q 726 1263 700 1284 q 751 1203 751 1242 q 722 1115 751 1149 q 629 1082 692 1082 q 527 1165 527 1082 z \"},\"ġ\":{\"ha\":751,\"x_min\":-78,\"x_max\":804,\"o\":\"m 804 757 l 781 644 l 663 616 q 673 536 673 581 q 591 327 673 404 q 368 250 509 250 q 301 257 328 250 q 244 204 244 239 q 264 171 244 181 q 325 155 285 161 l 418 143 q 579 86 528 129 q 629 -39 629 43 q 524 -258 629 -182 q 221 -334 418 -334 q 1 -282 80 -334 q -78 -142 -78 -231 q -32 -23 -78 -73 q 114 60 15 27 q 64 150 64 92 q 94 233 64 198 q 193 300 124 268 q 128 376 149 333 q 107 479 107 418 q 192 693 107 614 q 424 772 277 772 q 536 757 480 772 l 804 757 m 248 -4 q 139 -43 176 -14 q 102 -117 102 -72 q 233 -195 102 -195 q 388 -164 336 -195 q 440 -78 440 -134 q 418 -37 440 -52 q 325 -14 396 -23 l 248 -4 m 416 643 q 332 591 364 643 q 300 461 300 539 q 370 380 300 380 q 452 432 420 380 q 484 564 484 484 q 416 643 484 643 m 416 936 q 448 1025 416 995 q 539 1055 480 1055 q 614 1034 589 1055 q 640 974 640 1013 q 610 886 640 920 q 518 852 581 852 q 416 936 416 852 z \"},\"Ģ\":{\"ha\":958,\"x_min\":83,\"x_max\":942,\"o\":\"m 511 557 l 893 557 l 783 40 q 615 -2 692 9 q 450 -14 537 -14 q 179 86 275 -14 q 83 372 83 186 q 156 701 83 554 q 360 927 229 848 q 664 1007 492 1007 q 942 940 812 1007 l 864 770 q 764 813 814 797 q 654 829 713 829 q 469 773 551 829 q 341 613 387 717 q 294 389 294 509 q 343 217 294 272 q 494 163 393 163 q 610 179 546 163 l 654 382 l 473 382 l 511 557 m 274 -289 q 318 -189 291 -254 q 359 -85 346 -123 l 550 -85 l 550 -98 q 485 -198 528 -140 q 396 -307 443 -255 l 274 -307 l 274 -289 z \"},\"ģ\":{\"ha\":751,\"x_min\":-78,\"x_max\":804,\"o\":\"m 804 757 l 781 644 l 663 616 q 673 536 673 581 q 591 327 673 404 q 368 250 509 250 q 301 257 328 250 q 244 204 244 239 q 264 171 244 181 q 325 155 285 161 l 418 143 q 579 86 528 129 q 629 -39 629 43 q 524 -258 629 -182 q 221 -334 418 -334 q 1 -282 80 -334 q -78 -142 -78 -231 q -32 -23 -78 -73 q 114 60 15 27 q 64 150 64 92 q 94 233 64 198 q 193 300 124 268 q 128 376 149 333 q 107 479 107 418 q 192 693 107 614 q 424 772 277 772 q 536 757 480 772 l 804 757 m 248 -4 q 139 -43 176 -14 q 102 -117 102 -72 q 233 -195 102 -195 q 388 -164 336 -195 q 440 -78 440 -134 q 418 -37 440 -52 q 325 -14 396 -23 l 248 -4 m 416 643 q 332 591 364 643 q 300 461 300 539 q 370 380 300 380 q 452 432 420 380 q 484 564 484 484 q 416 643 484 643 m 675 1046 q 632 950 662 1019 q 591 842 603 882 l 399 842 l 399 856 q 464 955 420 896 q 553 1064 507 1014 l 675 1064 l 675 1046 z \"},\"Ĥ\":{\"ha\":972,\"x_min\":36,\"x_max\":979,\"o\":\"m 770 0 l 562 0 l 653 428 l 334 428 l 243 0 l 36 0 l 245 991 l 453 991 l 371 603 l 690 603 l 772 991 l 979 991 l 770 0 m 884 1071 l 750 1071 q 640 1185 707 1107 q 483 1071 569 1125 l 336 1071 l 336 1088 q 439 1187 378 1126 q 536 1293 500 1249 l 765 1293 q 815 1197 780 1257 q 884 1088 850 1137 l 884 1071 z \"},\"ĥ\":{\"ha\":839,\"x_min\":25,\"x_max\":812,\"o\":\"m 663 0 l 458 0 l 551 443 q 562 524 562 489 q 489 607 562 607 q 376 530 427 607 q 296 314 325 452 l 229 0 l 25 0 l 249 1055 l 453 1055 q 412 867 427 932 q 354 657 398 801 l 359 657 q 453 741 401 709 q 572 772 505 772 q 717 716 666 772 q 768 554 768 659 q 753 432 768 505 l 663 0 m 812 1108 l 678 1108 q 568 1222 635 1144 q 411 1108 497 1162 l 264 1108 l 264 1125 q 368 1225 307 1164 q 464 1331 429 1286 l 693 1331 q 743 1234 708 1294 q 812 1125 779 1174 l 812 1108 z \"},\"Ħ\":{\"ha\":972,\"x_min\":36,\"x_max\":1072,\"o\":\"m 951 860 l 1072 860 l 1044 725 l 922 725 l 770 0 l 562 0 l 653 428 l 334 428 l 243 0 l 36 0 l 189 725 l 69 725 l 97 860 l 218 860 l 245 991 l 453 991 l 425 860 l 745 860 l 772 991 l 979 991 l 951 860 m 690 603 l 715 725 l 396 725 l 371 603 l 690 603 z \"},\"ħ\":{\"ha\":839,\"x_min\":25,\"x_max\":760,\"o\":\"m 663 0 l 458 0 l 543 401 q 554 482 554 448 q 482 566 554 566 q 368 487 419 566 q 288 272 317 409 l 229 0 l 25 0 l 197 811 l 87 811 l 117 946 l 225 946 l 249 1055 l 453 1055 l 431 946 l 633 946 l 604 811 l 401 811 q 347 615 376 700 l 353 615 q 445 699 395 668 q 564 730 496 730 q 709 673 659 730 q 760 513 760 616 q 745 390 760 459 l 663 0 z \"},\"ĩ\":{\"ha\":412,\"x_min\":25,\"x_max\":605,\"o\":\"m 229 0 l 25 0 l 186 758 l 390 758 l 229 0 m 410 842 q 352 853 377 842 q 304 877 326 864 q 263 902 283 890 q 220 913 243 913 q 183 894 199 913 q 157 840 166 875 l 37 840 q 227 1050 77 1050 q 287 1039 260 1050 q 335 1014 313 1027 q 377 990 357 1001 q 418 979 397 979 q 457 997 441 979 q 488 1051 473 1014 l 605 1051 q 410 842 560 842 z \"},\"ī\":{\"ha\":412,\"x_min\":25,\"x_max\":537,\"o\":\"m 229 0 l 25 0 l 186 758 l 390 758 l 229 0 m 117 985 l 537 985 l 507 842 l 87 842 l 117 985 z \"},\"ĭ\":{\"ha\":412,\"x_min\":25,\"x_max\":577,\"o\":\"m 229 0 l 25 0 l 186 758 l 390 758 l 229 0 m 577 1071 q 311 842 540 842 q 149 891 207 842 q 91 1026 91 941 q 95 1071 91 1052 l 213 1071 q 238 1006 213 1027 q 317 986 262 986 q 404 1004 370 986 q 449 1071 437 1023 l 577 1071 z \"},\"į\":{\"ha\":412,\"x_min\":-52,\"x_max\":443,\"o\":\"m 218 936 q 251 1025 218 995 q 342 1055 283 1055 q 417 1034 391 1055 q 443 974 443 1013 q 413 886 443 920 q 321 852 383 852 q 218 936 218 852 m 229 0 l 25 0 l 186 758 l 390 758 l 229 0 m 229 0 q 124 -100 149 -65 q 100 -170 100 -136 q 111 -199 100 -189 q 140 -210 121 -210 q 210 -197 170 -210 l 210 -317 q 98 -334 153 -334 q -11 -297 29 -334 q -52 -201 -52 -261 q -19 -99 -52 -146 q 94 0 13 -52 l 229 0 z \"},\"ı\":{\"ha\":412,\"x_min\":25,\"x_max\":390,\"o\":\"m 229 0 l 25 0 l 186 758 l 390 758 l 229 0 z \"},\"ĳ\":{\"ha\":825,\"x_min\":25,\"x_max\":857,\"o\":\"m 218 936 q 251 1025 218 995 q 342 1055 283 1055 q 417 1034 391 1055 q 443 974 443 1013 q 413 886 443 920 q 321 852 383 852 q 218 936 218 852 m 229 0 l 25 0 l 186 758 l 390 758 l 229 0 m 351 -334 q 233 -317 281 -334 l 233 -153 q 311 -167 275 -167 q 428 -52 404 -167 l 600 758 l 804 758 l 625 -82 q 351 -334 572 -334 m 632 936 q 664 1025 632 995 q 755 1055 696 1055 q 831 1034 805 1055 q 857 974 857 1013 q 827 886 857 920 q 734 852 797 852 q 632 936 632 852 z \"},\"Ĵ\":{\"ha\":460,\"x_min\":-218,\"x_max\":644,\"o\":\"m -92 -292 q -218 -273 -155 -292 l -218 -102 q -107 -115 -159 -115 q 2 -74 -40 -115 q 62 56 43 -33 l 261 991 l 468 991 l 262 26 q 143 -216 227 -140 q -92 -292 60 -292 m 644 1071 l 509 1071 q 399 1185 467 1107 q 242 1071 328 1125 l 95 1071 l 95 1088 q 199 1187 138 1126 q 295 1293 260 1249 l 524 1293 q 574 1197 539 1257 q 644 1088 610 1137 l 644 1071 z \"},\"ĵ\":{\"ha\":412,\"x_min\":-178,\"x_max\":567,\"o\":\"m -60 -334 q -178 -317 -130 -334 l -178 -153 q -100 -167 -136 -167 q -27 -140 -58 -167 q 17 -52 4 -113 l 189 758 l 393 758 l 214 -82 q -60 -334 161 -334 m 567 842 l 433 842 q 323 956 390 878 q 165 842 252 896 l 18 842 l 18 859 q 122 958 61 897 q 218 1064 183 1019 l 448 1064 q 498 967 463 1027 q 567 859 533 907 l 567 842 z \"},\"Ķ\":{\"ha\":851,\"x_min\":36,\"x_max\":979,\"o\":\"m 774 0 l 545 0 l 401 401 l 317 354 l 243 0 l 36 0 l 245 991 l 453 991 l 350 515 l 457 654 l 734 991 l 979 991 l 576 517 l 774 0 m 205 -289 q 250 -189 222 -254 q 290 -85 277 -123 l 481 -85 l 481 -98 q 417 -198 459 -140 q 328 -307 374 -255 l 205 -307 l 205 -289 z \"},\"ķ\":{\"ha\":789,\"x_min\":25,\"x_max\":857,\"o\":\"m 624 758 l 857 758 l 519 416 l 713 0 l 485 0 l 361 285 l 279 236 l 229 0 l 25 0 l 249 1055 l 453 1055 l 353 585 q 333 505 347 557 l 314 436 l 317 436 l 624 758 m 167 -289 q 211 -189 184 -254 q 252 -85 239 -123 l 443 -85 l 443 -98 q 378 -198 420 -140 q 289 -307 336 -255 l 167 -307 l 167 -289 z \"},\"ĸ\":{\"ha\":789,\"x_min\":25,\"x_max\":857,\"o\":\"m 624 758 l 857 758 l 519 416 l 713 0 l 485 0 l 361 285 l 279 236 l 229 0 l 25 0 l 186 758 l 390 758 q 331 501 342 542 q 311 432 320 460 l 314 432 l 624 758 z \"},\"Ĺ\":{\"ha\":720,\"x_min\":36,\"x_max\":652,\"o\":\"m 36 0 l 245 991 l 453 991 l 279 174 l 627 174 l 590 0 l 36 0 m 274 1088 q 425 1293 328 1147 l 652 1293 l 652 1282 q 547 1178 621 1244 q 416 1071 474 1113 l 274 1071 l 274 1088 z \"},\"ĺ\":{\"ha\":412,\"x_min\":25,\"x_max\":638,\"o\":\"m 229 0 l 25 0 l 249 1055 l 453 1055 l 229 0 m 260 1126 q 411 1332 314 1186 l 638 1332 l 638 1320 q 534 1217 607 1282 q 402 1109 460 1152 l 260 1109 l 260 1126 z \"},\"Ļ\":{\"ha\":720,\"x_min\":36,\"x_max\":627,\"o\":\"m 36 0 l 245 991 l 453 991 l 279 174 l 627 174 l 590 0 l 36 0 m 128 -289 q 173 -189 145 -254 q 213 -85 200 -123 l 404 -85 l 404 -98 q 339 -198 382 -140 q 250 -307 297 -255 l 128 -307 l 128 -289 z \"},\"ļ\":{\"ha\":412,\"x_min\":-67,\"x_max\":453,\"o\":\"m 229 0 l 25 0 l 249 1055 l 453 1055 l 229 0 m -67 -289 q -23 -189 -50 -254 q 18 -85 5 -123 l 209 -85 l 209 -98 q 144 -198 186 -140 q 55 -307 102 -255 l -67 -307 l -67 -289 z \"},\"Ľ\":{\"ha\":720,\"x_min\":36,\"x_max\":807,\"o\":\"m 36 0 l 245 991 l 453 991 l 279 174 l 627 174 l 590 0 l 36 0 m 531 788 q 615 992 587 909 l 807 992 l 807 979 q 742 879 787 940 q 653 770 696 817 l 531 770 l 531 788 z \"},\"ľ\":{\"ha\":412,\"x_min\":25,\"x_max\":747,\"o\":\"m 229 0 l 25 0 l 249 1055 l 453 1055 l 229 0 m 471 851 q 555 1055 528 972 l 747 1055 l 747 1042 q 682 942 727 1003 q 593 833 637 880 l 471 833 l 471 851 z \"},\"Ŀ\":{\"ha\":720,\"x_min\":36,\"x_max\":696,\"o\":\"m 36 0 l 245 991 l 453 991 l 279 174 l 627 174 l 590 0 l 36 0 m 471 491 q 504 580 471 550 q 595 610 536 610 q 670 589 644 610 q 696 529 696 568 q 666 441 696 475 q 574 408 636 408 q 471 491 471 408 z \"},\"ŀ\":{\"ha\":603,\"x_min\":25,\"x_max\":639,\"o\":\"m 229 0 l 25 0 l 249 1055 l 453 1055 l 229 0 m 414 453 q 447 542 414 512 q 538 572 479 572 q 613 551 587 572 q 639 491 639 530 q 609 403 639 437 q 517 370 579 370 q 414 453 414 370 z \"},\"Ł\":{\"ha\":721,\"x_min\":0,\"x_max\":628,\"o\":\"m 39 0 l 109 326 l 69 306 l 0 443 l 150 524 l 249 991 l 454 991 l 382 648 l 478 701 l 550 564 l 339 450 l 281 174 l 628 174 l 591 0 l 39 0 z \"},\"ł\":{\"ha\":454,\"x_min\":0,\"x_max\":494,\"o\":\"m 379 635 l 422 660 l 494 522 l 338 437 l 244 0 l 43 0 l 110 317 l 69 294 l 0 432 l 151 514 l 267 1055 l 468 1055 l 379 635 z \"},\"Ń\":{\"ha\":1048,\"x_min\":36,\"x_max\":1055,\"o\":\"m 846 0 l 614 0 l 372 750 l 368 750 l 366 728 q 321 467 344 582 l 222 0 l 36 0 l 245 991 l 488 991 l 718 261 l 721 261 q 747 408 729 313 q 869 991 766 504 l 1055 991 l 846 0 m 581 1088 q 731 1293 634 1147 l 958 1293 l 958 1282 q 854 1178 927 1244 q 722 1071 781 1113 l 581 1071 l 581 1088 z \"},\"ń\":{\"ha\":839,\"x_min\":25,\"x_max\":783,\"o\":\"m 663 0 l 458 0 l 551 443 q 562 524 562 489 q 489 607 562 607 q 376 530 427 607 q 296 314 325 452 l 229 0 l 25 0 l 186 758 l 342 758 l 328 618 l 332 618 q 572 772 431 772 q 717 716 666 772 q 768 554 768 659 q 753 432 768 505 l 663 0 m 406 859 q 556 1064 459 918 l 783 1064 l 783 1053 q 679 949 752 1015 q 547 842 606 884 l 406 842 l 406 859 z \"},\"Ņ\":{\"ha\":1048,\"x_min\":36,\"x_max\":1055,\"o\":\"m 846 0 l 614 0 l 372 750 l 368 750 l 366 728 q 321 467 344 582 l 222 0 l 36 0 l 245 991 l 488 991 l 718 261 l 721 261 q 747 408 729 313 q 869 991 766 504 l 1055 991 l 846 0 m 258 -289 q 303 -189 275 -254 q 343 -85 330 -123 l 534 -85 l 534 -98 q 470 -198 512 -140 q 380 -307 427 -255 l 258 -307 l 258 -289 z \"},\"ņ\":{\"ha\":839,\"x_min\":25,\"x_max\":768,\"o\":\"m 663 0 l 458 0 l 551 443 q 562 524 562 489 q 489 607 562 607 q 376 530 427 607 q 296 314 325 452 l 229 0 l 25 0 l 186 758 l 342 758 l 328 618 l 332 618 q 572 772 431 772 q 717 716 666 772 q 768 554 768 659 q 753 432 768 505 l 663 0 m 161 -289 q 206 -189 178 -254 q 246 -85 233 -123 l 437 -85 l 437 -98 q 373 -198 415 -140 q 283 -307 330 -255 l 161 -307 l 161 -289 z \"},\"Ň\":{\"ha\":1048,\"x_min\":36,\"x_max\":1055,\"o\":\"m 846 0 l 614 0 l 372 750 l 368 750 l 366 728 q 321 467 344 582 l 222 0 l 36 0 l 245 991 l 488 991 l 718 261 l 721 261 q 747 408 729 313 q 869 991 766 504 l 1055 991 l 846 0 m 421 1293 l 555 1293 q 665 1179 598 1257 q 823 1293 743 1243 l 970 1293 l 970 1276 q 770 1071 826 1142 l 541 1071 q 490 1167 526 1107 q 421 1276 455 1227 l 421 1293 z \"},\"ň\":{\"ha\":839,\"x_min\":25,\"x_max\":808,\"o\":\"m 663 0 l 458 0 l 551 443 q 562 524 562 489 q 489 607 562 607 q 376 530 427 607 q 296 314 325 452 l 229 0 l 25 0 l 186 758 l 342 758 l 328 618 l 332 618 q 572 772 431 772 q 717 716 666 772 q 768 554 768 659 q 753 432 768 505 l 663 0 m 260 1064 l 394 1064 q 504 950 437 1028 q 661 1064 582 1014 l 808 1064 l 808 1047 q 608 842 665 913 l 379 842 q 329 938 364 878 q 260 1047 294 998 l 260 1064 z \"},\"ŉ\":{\"ha\":946,\"x_min\":1,\"x_max\":876,\"o\":\"m 770 0 l 566 0 l 659 443 q 669 524 669 489 q 596 607 669 607 q 483 530 534 607 q 403 314 432 452 l 336 0 l 132 0 l 293 758 l 449 758 l 435 618 l 439 618 q 680 772 538 772 q 824 716 773 772 q 876 554 876 659 q 860 432 876 505 l 770 0 m 326 991 l 332 977 q 154 652 262 823 l 1 652 q 133 991 61 791 l 326 991 z \"},\"Ŋ\":{\"ha\":1048,\"x_min\":36,\"x_max\":1055,\"o\":\"m 493 -292 q 364 -275 412 -292 l 364 -100 q 473 -115 422 -115 q 656 0 619 -115 l 372 750 l 368 750 l 366 728 q 321 467 344 582 l 222 0 l 36 0 l 245 991 l 469 991 l 728 323 l 732 323 q 781 593 760 500 l 869 991 l 1055 991 l 846 0 q 725 -219 814 -146 q 493 -292 635 -292 z \"},\"ŋ\":{\"ha\":839,\"x_min\":25,\"x_max\":768,\"o\":\"m 371 -334 q 253 -317 300 -334 l 253 -153 q 330 -167 294 -167 q 403 -139 372 -167 q 447 -52 435 -112 l 551 443 q 562 524 562 489 q 489 607 562 607 q 376 530 427 607 q 296 314 325 452 l 229 0 l 25 0 l 186 758 l 342 758 l 328 618 l 332 618 q 572 772 431 772 q 717 716 666 772 q 768 554 768 659 q 753 432 768 505 l 646 -79 q 550 -272 618 -210 q 371 -334 481 -334 z \"},\"Ō\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 453 1214 l 873 1214 l 842 1071 l 422 1071 l 453 1214 z \"},\"ō\":{\"ha\":812,\"x_min\":61,\"x_max\":751,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 301 985 l 721 985 l 690 842 l 271 842 l 301 985 z \"},\"Ŏ\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 897 1300 q 631 1071 860 1071 q 469 1120 527 1071 q 411 1255 411 1170 q 415 1300 411 1281 l 533 1300 q 558 1236 533 1256 q 637 1215 583 1215 q 724 1234 690 1215 q 769 1300 758 1252 l 897 1300 z \"},\"ŏ\":{\"ha\":812,\"x_min\":61,\"x_max\":753,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 753 1071 q 487 842 716 842 q 325 891 383 842 q 267 1026 267 941 q 271 1071 267 1052 l 389 1071 q 414 1006 389 1027 q 494 986 439 986 q 580 1004 547 986 q 625 1071 614 1023 l 753 1071 z \"},\"Ő\":{\"ha\":1014,\"x_min\":83,\"x_max\":1040,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 408 1088 q 564 1293 485 1175 l 771 1293 l 771 1282 q 668 1182 742 1246 q 528 1071 593 1118 l 408 1071 l 408 1088 m 677 1088 q 833 1293 754 1175 l 1040 1293 l 1040 1282 q 937 1182 1011 1246 q 798 1071 863 1118 l 677 1071 l 677 1088 z \"},\"ő\":{\"ha\":812,\"x_min\":61,\"x_max\":887,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 254 859 q 411 1064 332 945 l 618 1064 l 618 1053 q 514 952 589 1017 q 375 842 440 888 l 254 842 l 254 859 m 524 859 q 680 1064 601 945 l 887 1064 l 887 1053 q 784 952 858 1017 q 644 842 709 888 l 524 842 l 524 859 z \"},\"Œ\":{\"ha\":1251,\"x_min\":83,\"x_max\":1299,\"o\":\"m 1089 0 l 574 0 q 452 -14 511 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 750 991 703 1007 l 1299 991 l 1263 819 l 916 819 l 869 602 l 1193 602 l 1156 429 l 832 429 l 778 174 l 1125 174 l 1089 0 m 467 163 q 574 184 526 163 l 705 806 q 591 832 663 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 z \"},\"œ\":{\"ha\":1225,\"x_min\":61,\"x_max\":1190,\"o\":\"m 812 -14 q 671 13 734 -14 q 578 85 609 39 q 478 13 535 39 q 338 -14 421 -14 q 136 66 211 -14 q 61 281 61 145 q 108 539 61 427 q 243 711 155 650 q 453 772 332 772 q 665 664 595 772 q 936 772 770 772 q 1123 717 1056 772 q 1190 566 1190 662 q 1077 370 1190 439 q 754 301 964 301 l 720 301 l 718 287 l 718 273 q 753 176 718 212 q 852 140 787 140 q 960 153 911 140 q 1076 199 1008 166 l 1076 45 q 950 0 1013 14 q 812 -14 888 -14 m 437 606 q 351 565 389 606 q 290 445 313 524 q 267 281 267 366 q 291 186 267 219 q 366 153 316 153 q 487 244 439 153 q 534 472 534 335 q 509 571 534 537 q 437 606 484 606 m 924 625 q 811 572 864 625 q 742 439 759 519 l 772 439 q 936 472 878 439 q 994 561 994 505 q 924 625 994 625 z \"},\"Ŕ\":{\"ha\":846,\"x_min\":36,\"x_max\":815,\"o\":\"m 359 551 l 412 551 q 551 590 501 551 q 600 708 600 629 q 568 791 600 764 q 467 819 536 819 l 416 819 l 359 551 m 323 380 l 243 0 l 36 0 l 245 991 l 489 991 q 730 922 650 991 q 811 720 811 853 q 755 535 811 612 q 593 421 699 458 l 770 0 l 545 0 l 404 380 l 323 380 m 437 1088 q 588 1293 491 1147 l 815 1293 l 815 1282 q 711 1178 784 1244 q 579 1071 637 1113 l 437 1071 l 437 1088 z \"},\"ŕ\":{\"ha\":585,\"x_min\":25,\"x_max\":689,\"o\":\"m 571 772 q 636 765 611 772 l 591 568 q 524 579 561 579 q 386 517 445 579 q 301 339 326 455 l 229 0 l 25 0 l 186 758 l 342 758 l 328 618 l 332 618 q 571 772 431 772 m 311 859 q 462 1064 365 918 l 689 1064 l 689 1053 q 585 949 658 1015 q 453 842 511 884 l 311 842 l 311 859 z \"},\"Ŗ\":{\"ha\":846,\"x_min\":36,\"x_max\":811,\"o\":\"m 359 551 l 412 551 q 551 590 501 551 q 600 708 600 629 q 568 791 600 764 q 467 819 536 819 l 416 819 l 359 551 m 323 380 l 243 0 l 36 0 l 245 991 l 489 991 q 730 922 650 991 q 811 720 811 853 q 755 535 811 612 q 593 421 699 458 l 770 0 l 545 0 l 404 380 l 323 380 m 203 -289 q 247 -189 220 -254 q 288 -85 275 -123 l 479 -85 l 479 -98 q 414 -198 456 -140 q 325 -307 372 -255 l 203 -307 l 203 -289 z \"},\"ŗ\":{\"ha\":585,\"x_min\":-64,\"x_max\":636,\"o\":\"m 571 772 q 636 765 611 772 l 591 568 q 524 579 561 579 q 386 517 445 579 q 301 339 326 455 l 229 0 l 25 0 l 186 758 l 342 758 l 328 618 l 332 618 q 571 772 431 772 m -64 -289 q -20 -189 -47 -254 q 20 -85 7 -123 l 212 -85 l 212 -98 q 147 -198 189 -140 q 58 -307 104 -255 l -64 -307 l -64 -289 z \"},\"Ř\":{\"ha\":846,\"x_min\":36,\"x_max\":849,\"o\":\"m 359 551 l 412 551 q 551 590 501 551 q 600 708 600 629 q 568 791 600 764 q 467 819 536 819 l 416 819 l 359 551 m 323 380 l 243 0 l 36 0 l 245 991 l 489 991 q 730 922 650 991 q 811 720 811 853 q 755 535 811 612 q 593 421 699 458 l 770 0 l 545 0 l 404 380 l 323 380 m 300 1293 l 435 1293 q 545 1179 477 1257 q 702 1293 623 1243 l 849 1293 l 849 1276 q 649 1071 705 1142 l 420 1071 q 370 1167 405 1107 q 300 1276 334 1227 l 300 1293 z \"},\"ř\":{\"ha\":585,\"x_min\":25,\"x_max\":724,\"o\":\"m 571 772 q 636 765 611 772 l 591 568 q 524 579 561 579 q 386 517 445 579 q 301 339 326 455 l 229 0 l 25 0 l 186 758 l 342 758 l 328 618 l 332 618 q 571 772 431 772 m 176 1064 l 310 1064 q 420 950 353 1028 q 577 1064 498 1014 l 724 1064 l 724 1047 q 524 842 581 913 l 295 842 q 245 938 280 878 q 176 1047 210 998 l 176 1064 z \"},\"Ś\":{\"ha\":736,\"x_min\":28,\"x_max\":776,\"o\":\"m 642 293 q 541 69 642 151 q 269 -14 441 -14 q 28 47 119 -14 l 28 233 q 271 160 159 160 q 389 189 347 160 q 432 268 432 218 q 423 319 432 297 q 397 360 414 341 q 313 429 380 379 q 181 562 219 496 q 143 704 143 628 q 185 860 143 791 q 305 967 227 929 q 484 1006 382 1006 q 753 939 631 1006 l 679 781 q 484 831 573 831 q 391 800 427 831 q 355 720 355 770 q 378 647 355 678 q 478 566 400 616 q 601 446 560 511 q 642 293 642 380 m 398 1088 q 549 1293 452 1147 l 776 1293 l 776 1282 q 671 1178 745 1244 q 540 1071 598 1113 l 398 1071 l 398 1088 z \"},\"ś\":{\"ha\":657,\"x_min\":16,\"x_max\":678,\"o\":\"m 562 250 q 478 55 562 123 q 243 -14 393 -14 q 116 -3 170 -14 q 16 31 62 7 l 16 199 q 232 138 122 138 q 321 160 286 138 q 355 220 355 182 q 330 272 355 249 q 241 330 305 295 q 127 422 159 376 q 94 530 94 468 q 169 709 94 646 q 383 772 244 772 q 629 708 519 772 l 562 562 q 387 619 467 619 q 325 602 349 619 q 301 555 301 585 q 323 509 301 529 q 404 458 345 489 q 525 366 488 416 q 562 250 562 315 m 300 859 q 451 1064 354 918 l 678 1064 l 678 1053 q 574 949 647 1015 q 442 842 500 884 l 300 842 l 300 859 z \"},\"Ŝ\":{\"ha\":736,\"x_min\":28,\"x_max\":762,\"o\":\"m 642 293 q 541 69 642 151 q 269 -14 441 -14 q 28 47 119 -14 l 28 233 q 271 160 159 160 q 389 189 347 160 q 432 268 432 218 q 423 319 432 297 q 397 360 414 341 q 313 429 380 379 q 181 562 219 496 q 143 704 143 628 q 185 860 143 791 q 305 967 227 929 q 484 1006 382 1006 q 753 939 631 1006 l 679 781 q 484 831 573 831 q 391 800 427 831 q 355 720 355 770 q 378 647 355 678 q 478 566 400 616 q 601 446 560 511 q 642 293 642 380 m 762 1071 l 628 1071 q 518 1185 585 1107 q 361 1071 447 1125 l 214 1071 l 214 1088 q 317 1187 256 1126 q 414 1293 378 1249 l 643 1293 q 693 1197 658 1257 q 762 1088 728 1137 l 762 1071 z \"},\"ŝ\":{\"ha\":657,\"x_min\":16,\"x_max\":665,\"o\":\"m 562 250 q 478 55 562 123 q 243 -14 393 -14 q 116 -3 170 -14 q 16 31 62 7 l 16 199 q 232 138 122 138 q 321 160 286 138 q 355 220 355 182 q 330 272 355 249 q 241 330 305 295 q 127 422 159 376 q 94 530 94 468 q 169 709 94 646 q 383 772 244 772 q 629 708 519 772 l 562 562 q 387 619 467 619 q 325 602 349 619 q 301 555 301 585 q 323 509 301 529 q 404 458 345 489 q 525 366 488 416 q 562 250 562 315 m 665 842 l 530 842 q 420 956 488 878 q 263 842 349 896 l 116 842 l 116 859 q 220 958 159 897 q 316 1064 281 1019 l 545 1064 q 595 967 560 1027 q 665 859 631 907 l 665 842 z \"},\"Ş\":{\"ha\":736,\"x_min\":28,\"x_max\":753,\"o\":\"m 642 293 q 541 69 642 151 q 269 -14 441 -14 q 28 47 119 -14 l 28 233 q 271 160 159 160 q 389 189 347 160 q 432 268 432 218 q 423 319 432 297 q 397 360 414 341 q 313 429 380 379 q 181 562 219 496 q 143 704 143 628 q 185 860 143 791 q 305 967 227 929 q 484 1006 382 1006 q 753 939 631 1006 l 679 781 q 484 831 573 831 q 391 800 427 831 q 355 720 355 770 q 378 647 355 678 q 478 566 400 616 q 601 446 560 511 q 642 293 642 380 m 419 -170 q 363 -291 419 -248 q 204 -334 307 -334 q 101 -318 146 -334 l 101 -204 q 186 -220 144 -220 q 255 -164 255 -220 q 234 -126 255 -141 q 159 -104 213 -111 l 224 0 l 350 0 l 323 -49 q 419 -170 419 -82 z \"},\"ş\":{\"ha\":657,\"x_min\":16,\"x_max\":629,\"o\":\"m 562 250 q 478 55 562 123 q 243 -14 393 -14 q 116 -3 170 -14 q 16 31 62 7 l 16 199 q 232 138 122 138 q 321 160 286 138 q 355 220 355 182 q 330 272 355 249 q 241 330 305 295 q 127 422 159 376 q 94 530 94 468 q 169 709 94 646 q 383 772 244 772 q 629 708 519 772 l 562 562 q 387 619 467 619 q 325 602 349 619 q 301 555 301 585 q 323 509 301 529 q 404 458 345 489 q 525 366 488 416 q 562 250 562 315 m 383 -170 q 327 -291 383 -248 q 168 -334 271 -334 q 65 -318 110 -334 l 65 -204 q 150 -220 108 -220 q 219 -164 219 -220 q 198 -126 219 -141 q 123 -104 177 -111 l 189 0 l 314 0 l 288 -49 q 383 -170 383 -82 z \"},\"Š\":{\"ha\":736,\"x_min\":28,\"x_max\":794,\"o\":\"m 642 293 q 541 69 642 151 q 269 -14 441 -14 q 28 47 119 -14 l 28 233 q 271 160 159 160 q 389 189 347 160 q 432 268 432 218 q 423 319 432 297 q 397 360 414 341 q 313 429 380 379 q 181 562 219 496 q 143 704 143 628 q 185 860 143 791 q 305 967 227 929 q 484 1006 382 1006 q 753 939 631 1006 l 679 781 q 484 831 573 831 q 391 800 427 831 q 355 720 355 770 q 378 647 355 678 q 478 566 400 616 q 601 446 560 511 q 642 293 642 380 m 245 1293 l 380 1293 q 490 1179 422 1257 q 647 1293 568 1243 l 794 1293 l 794 1276 q 594 1071 650 1142 l 365 1071 q 315 1167 350 1107 q 245 1276 279 1227 l 245 1293 z \"},\"š\":{\"ha\":657,\"x_min\":16,\"x_max\":718,\"o\":\"m 562 250 q 478 55 562 123 q 243 -14 393 -14 q 116 -3 170 -14 q 16 31 62 7 l 16 199 q 232 138 122 138 q 321 160 286 138 q 355 220 355 182 q 330 272 355 249 q 241 330 305 295 q 127 422 159 376 q 94 530 94 468 q 169 709 94 646 q 383 772 244 772 q 629 708 519 772 l 562 562 q 387 619 467 619 q 325 602 349 619 q 301 555 301 585 q 323 509 301 529 q 404 458 345 489 q 525 366 488 416 q 562 250 562 315 m 169 1064 l 303 1064 q 413 950 346 1028 q 570 1064 491 1014 l 718 1064 l 718 1047 q 517 842 574 913 l 288 842 q 238 938 273 878 q 169 1047 203 998 l 169 1064 z \"},\"Ț\":{\"ha\":737,\"x_min\":86,\"x_max\":836,\"o\":\"m 387 0 l 180 0 l 353 817 l 114 817 l 151 991 l 836 991 l 799 817 l 559 817 l 387 0 m 86 -289 q 131 -189 103 -254 q 171 -85 158 -123 l 362 -85 l 362 -98 q 297 -198 340 -140 q 208 -307 255 -255 l 86 -307 l 86 -289 z \"},\"ț\":{\"ha\":570,\"x_min\":38,\"x_max\":596,\"o\":\"m 349 151 q 458 175 393 151 l 458 22 q 278 -14 383 -14 q 129 29 176 -14 q 81 161 81 72 q 89 237 81 195 l 167 603 l 64 603 l 83 703 l 216 760 l 306 920 l 437 920 l 404 758 l 596 758 l 562 603 l 371 603 l 293 237 q 289 201 289 217 q 349 151 289 151 m 38 -289 q 82 -189 55 -254 q 123 -85 110 -123 l 314 -85 l 314 -98 q 249 -198 292 -140 q 160 -307 207 -255 l 38 -307 l 38 -289 z \"},\"Ť\":{\"ha\":737,\"x_min\":114,\"x_max\":836,\"o\":\"m 387 0 l 180 0 l 353 817 l 114 817 l 151 991 l 836 991 l 799 817 l 559 817 l 387 0 m 269 1293 l 404 1293 q 513 1179 446 1257 q 671 1293 591 1243 l 818 1293 l 818 1276 q 618 1071 674 1142 l 389 1071 q 338 1167 374 1107 q 269 1276 303 1227 l 269 1293 z \"},\"ť\":{\"ha\":570,\"x_min\":64,\"x_max\":786,\"o\":\"m 349 151 q 458 175 393 151 l 458 22 q 278 -14 383 -14 q 129 29 176 -14 q 81 161 81 72 q 89 237 81 195 l 167 603 l 64 603 l 83 703 l 216 760 l 306 920 l 437 920 l 404 758 l 596 758 l 562 603 l 371 603 l 293 237 q 289 201 289 217 q 349 151 289 151 m 510 865 q 594 1069 566 985 l 786 1069 l 786 1055 q 721 955 766 1017 q 632 847 675 894 l 510 847 l 510 865 z \"},\"Ŧ\":{\"ha\":737,\"x_min\":113,\"x_max\":836,\"o\":\"m 509 576 l 668 576 l 631 404 l 472 404 l 387 0 l 180 0 l 265 404 l 113 404 l 150 576 l 301 576 l 353 817 l 114 817 l 151 991 l 836 991 l 799 817 l 559 817 l 509 576 z \"},\"ŧ\":{\"ha\":570,\"x_min\":21,\"x_max\":596,\"o\":\"m 349 151 q 458 175 393 151 l 458 22 q 278 -14 383 -14 q 129 29 176 -14 q 81 161 81 72 q 89 237 81 195 l 111 338 l 21 338 l 49 472 l 139 472 l 167 603 l 64 603 l 83 703 l 216 760 l 306 920 l 437 920 l 404 758 l 596 758 l 562 603 l 371 603 l 343 472 l 501 472 l 473 338 l 314 338 l 293 237 q 289 201 289 217 q 349 151 289 151 z \"},\"Ũ\":{\"ha\":960,\"x_min\":96,\"x_max\":972,\"o\":\"m 972 991 l 836 350 q 688 78 798 170 q 404 -14 579 -14 q 178 63 260 -14 q 96 272 96 140 q 106 366 96 321 l 239 991 l 446 991 l 314 368 q 302 283 302 318 q 431 163 302 163 q 563 215 514 163 q 633 370 612 267 l 765 991 l 972 991 m 726 1071 q 668 1082 693 1071 q 621 1106 642 1093 q 579 1131 599 1120 q 536 1142 559 1142 q 499 1123 515 1142 q 473 1069 482 1104 l 353 1069 q 543 1279 393 1279 q 603 1268 576 1279 q 651 1243 629 1257 q 693 1219 673 1230 q 734 1208 713 1208 q 773 1226 757 1208 q 804 1280 789 1243 l 921 1280 q 726 1071 876 1071 z \"},\"ũ\":{\"ha\":839,\"x_min\":75,\"x_max\":815,\"o\":\"m 178 758 l 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 125 42 174 -14 q 75 204 75 98 q 92 349 75 267 l 178 758 m 621 842 q 562 853 587 842 q 515 877 536 864 q 473 902 493 890 q 431 913 453 913 q 393 894 410 913 q 367 840 376 875 l 247 840 q 437 1050 287 1050 q 497 1039 471 1050 q 545 1014 523 1027 q 587 990 568 1001 q 628 979 607 979 q 667 997 651 979 q 699 1051 684 1014 l 815 1051 q 621 842 770 842 z \"},\"Ū\":{\"ha\":960,\"x_min\":96,\"x_max\":972,\"o\":\"m 972 991 l 836 350 q 688 78 798 170 q 404 -14 579 -14 q 178 63 260 -14 q 96 272 96 140 q 106 366 96 321 l 239 991 l 446 991 l 314 368 q 302 283 302 318 q 431 163 302 163 q 563 215 514 163 q 633 370 612 267 l 765 991 l 972 991 m 439 1214 l 859 1214 l 828 1071 l 408 1071 l 439 1214 z \"},\"ū\":{\"ha\":839,\"x_min\":75,\"x_max\":815,\"o\":\"m 178 758 l 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 125 42 174 -14 q 75 204 75 98 q 92 349 75 267 l 178 758 m 330 985 l 750 985 l 720 842 l 300 842 l 330 985 z \"},\"Ŭ\":{\"ha\":960,\"x_min\":96,\"x_max\":972,\"o\":\"m 972 991 l 836 350 q 688 78 798 170 q 404 -14 579 -14 q 178 63 260 -14 q 96 272 96 140 q 106 366 96 321 l 239 991 l 446 991 l 314 368 q 302 283 302 318 q 431 163 302 163 q 563 215 514 163 q 633 370 612 267 l 765 991 l 972 991 m 888 1300 q 621 1071 850 1071 q 459 1120 517 1071 q 401 1255 401 1170 q 406 1300 401 1281 l 524 1300 q 548 1236 524 1256 q 628 1215 573 1215 q 714 1234 681 1215 q 760 1300 748 1252 l 888 1300 z \"},\"ŭ\":{\"ha\":839,\"x_min\":75,\"x_max\":815,\"o\":\"m 178 758 l 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 125 42 174 -14 q 75 204 75 98 q 92 349 75 267 l 178 758 m 787 1071 q 521 842 750 842 q 359 891 417 842 q 301 1026 301 941 q 305 1071 301 1052 l 423 1071 q 448 1006 423 1027 q 528 986 473 986 q 614 1004 581 986 q 659 1071 648 1023 l 787 1071 z \"},\"Ů\":{\"ha\":960,\"x_min\":96,\"x_max\":972,\"o\":\"m 972 991 l 836 350 q 688 78 798 170 q 404 -14 579 -14 q 178 63 260 -14 q 96 272 96 140 q 106 366 96 321 l 239 991 l 446 991 l 314 368 q 302 283 302 318 q 431 163 302 163 q 563 215 514 163 q 633 370 612 267 l 765 991 l 972 991 m 810 1232 q 762 1115 810 1160 q 637 1069 715 1069 q 516 1113 563 1069 q 469 1231 469 1156 q 516 1348 469 1305 q 637 1392 562 1392 q 761 1348 712 1392 q 810 1232 810 1303 m 703 1231 q 685 1279 703 1261 q 637 1296 666 1296 q 591 1279 609 1296 q 572 1231 572 1261 q 589 1183 572 1200 q 637 1165 605 1165 q 685 1183 666 1165 q 703 1231 703 1200 z \"},\"ů\":{\"ha\":839,\"x_min\":75,\"x_max\":815,\"o\":\"m 178 758 l 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 125 42 174 -14 q 75 204 75 98 q 92 349 75 267 l 178 758 m 701 1003 q 654 885 701 930 q 529 840 606 840 q 408 883 454 840 q 361 1002 361 926 q 407 1119 361 1076 q 529 1162 454 1162 q 652 1118 604 1162 q 701 1003 701 1074 m 595 1002 q 576 1049 595 1032 q 529 1067 557 1067 q 482 1049 500 1067 q 464 1002 464 1032 q 480 954 464 971 q 529 936 496 936 q 576 954 557 936 q 595 1002 595 971 z \"},\"Ű\":{\"ha\":960,\"x_min\":96,\"x_max\":1038,\"o\":\"m 972 991 l 836 350 q 688 78 798 170 q 404 -14 579 -14 q 178 63 260 -14 q 96 272 96 140 q 106 366 96 321 l 239 991 l 446 991 l 314 368 q 302 283 302 318 q 431 163 302 163 q 563 215 514 163 q 633 370 612 267 l 765 991 l 972 991 m 406 1088 q 562 1293 483 1175 l 769 1293 l 769 1282 q 666 1182 740 1246 q 526 1071 591 1118 l 406 1071 l 406 1088 m 675 1088 q 831 1293 752 1175 l 1038 1293 l 1038 1282 q 935 1182 1009 1246 q 795 1071 861 1118 l 675 1071 l 675 1088 z \"},\"ű\":{\"ha\":839,\"x_min\":75,\"x_max\":924,\"o\":\"m 178 758 l 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 125 42 174 -14 q 75 204 75 98 q 92 349 75 267 l 178 758 m 291 859 q 448 1064 368 945 l 654 1064 l 654 1053 q 551 952 625 1017 q 412 842 477 888 l 291 842 l 291 859 m 560 859 q 717 1064 637 945 l 924 1064 l 924 1053 q 820 952 895 1017 q 681 842 746 888 l 560 842 l 560 859 z \"},\"Ų\":{\"ha\":960,\"x_min\":96,\"x_max\":972,\"o\":\"m 972 991 l 836 350 q 688 78 798 170 q 404 -14 579 -14 q 178 63 260 -14 q 96 272 96 140 q 106 366 96 321 l 239 991 l 446 991 l 314 368 q 302 283 302 318 q 431 163 302 163 q 563 215 514 163 q 633 370 612 267 l 765 991 l 972 991 m 585 0 q 480 -100 505 -65 q 456 -170 456 -136 q 467 -199 456 -189 q 496 -210 477 -210 q 566 -197 526 -210 l 566 -317 q 454 -334 509 -334 q 345 -297 385 -334 q 304 -201 304 -261 q 337 -99 304 -146 q 450 0 369 -52 l 585 0 z \"},\"ų\":{\"ha\":839,\"x_min\":75,\"x_max\":815,\"o\":\"m 178 758 l 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 125 42 174 -14 q 75 204 75 98 q 92 349 75 267 l 178 758 m 633 0 q 528 -100 553 -65 q 504 -170 504 -136 q 515 -199 504 -189 q 545 -210 526 -210 q 614 -197 574 -210 l 614 -317 q 503 -334 557 -334 q 393 -297 433 -334 q 353 -201 353 -261 q 385 -99 353 -146 q 498 0 417 -52 l 633 0 z \"},\"Ŵ\":{\"ha\":1242,\"x_min\":125,\"x_max\":1372,\"o\":\"m 682 690 q 604 488 651 591 l 385 0 l 155 0 l 125 991 l 319 991 l 323 450 q 321 333 323 415 q 314 215 318 251 l 318 215 q 363 337 333 258 q 404 436 394 416 l 654 991 l 838 991 l 852 399 q 846 215 852 300 l 850 215 q 939 452 879 302 l 1162 991 l 1372 991 l 933 0 l 699 0 l 684 489 l 682 583 q 685 690 682 643 l 682 690 m 1030 1071 l 896 1071 q 786 1185 853 1107 q 629 1071 715 1125 l 481 1071 l 481 1088 q 585 1187 524 1126 q 682 1293 646 1249 l 911 1293 q 961 1197 926 1257 q 1030 1088 996 1137 l 1030 1071 z \"},\"ŵ\":{\"ha\":1095,\"x_min\":85,\"x_max\":1165,\"o\":\"m 581 583 q 497 367 538 463 l 339 0 l 119 0 l 85 758 l 275 758 l 278 422 l 275 309 l 271 193 l 273 193 q 283 221 277 207 q 317 314 288 236 q 349 395 347 392 l 505 758 l 728 758 l 728 395 q 721 193 728 298 l 725 193 l 744 248 q 808 422 793 389 l 957 758 l 1165 758 l 806 0 l 582 0 l 578 353 q 585 583 578 458 l 581 583 m 896 842 l 762 842 q 652 956 719 878 q 494 842 581 896 l 347 842 l 347 859 q 451 958 390 897 q 547 1064 512 1019 l 777 1064 q 827 967 791 1027 q 896 859 862 907 l 896 842 z \"},\"Ŷ\":{\"ha\":783,\"x_min\":126,\"x_max\":911,\"o\":\"m 425 590 l 679 991 l 911 991 l 492 379 l 411 0 l 205 0 l 286 379 l 126 991 l 338 991 l 425 590 m 781 1071 l 646 1071 q 536 1185 604 1107 q 379 1071 465 1125 l 232 1071 l 232 1088 q 336 1187 275 1126 q 432 1293 397 1249 l 661 1293 q 711 1197 676 1257 q 781 1088 747 1137 l 781 1071 z \"},\"ŷ\":{\"ha\":721,\"x_min\":-96,\"x_max\":793,\"o\":\"m 69 758 l 269 758 l 307 407 q 317 208 317 324 l 321 208 q 351 289 334 243 q 395 393 367 336 l 571 758 l 793 758 l 332 -109 q 4 -334 212 -334 q -96 -321 -57 -334 l -96 -158 q -17 -167 -50 -167 q 83 -134 40 -167 q 163 -33 126 -102 l 180 0 l 69 758 m 701 842 l 566 842 q 456 956 524 878 q 299 842 385 896 l 152 842 l 152 859 q 256 958 195 897 q 352 1064 317 1019 l 581 1064 q 631 967 596 1027 q 701 859 667 907 l 701 842 z \"},\"Ÿ\":{\"ha\":783,\"x_min\":126,\"x_max\":911,\"o\":\"m 425 590 l 679 991 l 911 991 l 492 379 l 411 0 l 205 0 l 286 379 l 126 991 l 338 991 l 425 590 m 293 1166 q 322 1246 293 1219 q 403 1274 351 1274 q 493 1200 493 1274 q 467 1121 493 1151 q 385 1092 440 1092 q 293 1166 293 1092 m 566 1166 q 594 1246 566 1219 q 675 1274 623 1274 q 743 1255 720 1274 q 766 1200 766 1236 q 739 1121 766 1151 q 657 1092 712 1092 q 566 1166 566 1092 z \"},\"Ź\":{\"ha\":745,\"x_min\":-41,\"x_max\":814,\"o\":\"m 624 0 l -41 0 l -16 136 l 511 818 l 143 818 l 179 991 l 814 991 l 786 854 l 256 174 l 660 174 l 624 0 m 399 1088 q 550 1293 453 1147 l 777 1293 l 777 1282 q 673 1178 746 1244 q 541 1071 600 1113 l 399 1071 l 399 1088 z \"},\"ź\":{\"ha\":632,\"x_min\":-32,\"x_max\":701,\"o\":\"m 507 0 l -32 0 l -8 122 l 382 600 l 113 600 l 147 758 l 656 758 l 627 623 l 243 158 l 541 158 l 507 0 m 323 859 q 473 1064 376 918 l 701 1064 l 701 1053 q 596 949 669 1015 q 465 842 523 884 l 323 842 l 323 859 z \"},\"Ż\":{\"ha\":745,\"x_min\":-41,\"x_max\":814,\"o\":\"m 624 0 l -41 0 l -16 136 l 511 818 l 143 818 l 179 991 l 814 991 l 786 854 l 256 174 l 660 174 l 624 0 m 403 1165 q 435 1254 403 1224 q 526 1284 467 1284 q 602 1263 576 1284 q 627 1203 627 1242 q 597 1115 627 1149 q 505 1082 568 1082 q 403 1165 403 1082 z \"},\"ż\":{\"ha\":632,\"x_min\":-32,\"x_max\":656,\"o\":\"m 507 0 l -32 0 l -8 122 l 382 600 l 113 600 l 147 758 l 656 758 l 627 623 l 243 158 l 541 158 l 507 0 m 309 936 q 341 1025 309 995 q 432 1055 373 1055 q 507 1034 481 1055 q 533 974 533 1013 q 503 886 533 920 q 411 852 473 852 q 309 936 309 852 z \"},\"Ž\":{\"ha\":745,\"x_min\":-41,\"x_max\":814,\"o\":\"m 624 0 l -41 0 l -16 136 l 511 818 l 143 818 l 179 991 l 814 991 l 786 854 l 256 174 l 660 174 l 624 0 m 262 1293 l 397 1293 q 507 1179 439 1257 q 664 1293 585 1243 l 811 1293 l 811 1276 q 611 1071 667 1142 l 382 1071 q 332 1167 367 1107 q 262 1276 296 1227 l 262 1293 z \"},\"ž\":{\"ha\":632,\"x_min\":-32,\"x_max\":728,\"o\":\"m 507 0 l -32 0 l -8 122 l 382 600 l 113 600 l 147 758 l 656 758 l 627 623 l 243 158 l 541 158 l 507 0 m 180 1064 l 314 1064 q 424 950 357 1028 q 581 1064 502 1014 l 728 1064 l 728 1047 q 528 842 585 913 l 299 842 q 249 938 284 878 q 180 1047 214 998 l 180 1064 z \"},\"ſ\":{\"ha\":497,\"x_min\":-167,\"x_max\":652,\"o\":\"m -49 -334 q -167 -317 -119 -334 l -167 -153 q -89 -167 -125 -167 q 28 -52 3 -167 l 212 815 q 307 1004 241 945 q 492 1063 373 1063 q 652 1029 579 1063 l 597 878 q 507 899 551 899 q 445 871 469 899 q 412 800 422 844 l 225 -82 q -49 -334 173 -334 z \"},\"ƒ\":{\"ha\":765,\"x_min\":-21,\"x_max\":785,\"o\":\"m 97 -334 q -21 -317 26 -334 l -21 -153 q 57 -167 20 -167 q 174 -52 149 -167 l 300 546 l 186 546 l 205 647 l 334 701 l 346 758 q 440 946 374 887 q 625 1006 506 1006 q 785 972 714 1006 l 730 821 q 640 842 684 842 q 578 814 602 842 q 546 743 554 787 l 538 701 l 686 701 l 653 546 l 504 546 l 371 -82 q 97 -334 319 -334 z \"},\"Ǻ\":{\"ha\":872,\"x_min\":-83,\"x_max\":896,\"o\":\"m 736 991 q 684 869 736 916 l 789 0 l 587 0 l 567 224 l 249 224 l 134 0 l -83 0 l 412 913 q 396 990 396 945 q 442 1108 396 1065 q 564 1152 488 1152 q 687 1107 638 1152 q 736 991 736 1063 m 521 1198 q 590 1258 545 1217 q 664 1331 635 1299 l 896 1331 l 896 1324 q 790 1253 857 1291 q 667 1189 724 1215 l 521 1189 l 521 1198 m 629 990 q 611 1038 629 1021 q 564 1055 592 1055 q 517 1038 535 1055 q 498 990 498 1021 q 515 942 498 960 q 564 925 531 925 q 611 942 592 925 q 629 990 629 960 m 521 779 q 456 632 492 704 l 338 400 l 557 400 l 539 610 q 529 779 532 667 l 521 779 z \"},\"ǻ\":{\"ha\":818,\"x_min\":61,\"x_max\":836,\"o\":\"m 461 1198 q 533 1261 488 1219 q 604 1331 578 1302 l 836 1331 l 836 1324 q 730 1253 797 1291 q 607 1189 664 1215 l 461 1189 l 461 1198 m 675 975 q 627 858 675 903 q 503 812 580 812 q 381 856 427 812 q 335 974 335 900 q 381 1091 335 1047 q 503 1135 427 1135 q 626 1090 577 1135 q 675 975 675 1046 m 568 974 q 550 1022 568 1004 q 503 1039 531 1039 q 456 1022 474 1039 q 437 974 437 1004 q 454 926 437 943 q 503 908 470 908 q 550 926 531 908 q 568 974 568 943 m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 z \"},\"Ǽ\":{\"ha\":1243,\"x_min\":-83,\"x_max\":1291,\"o\":\"m 1080 0 l 526 0 l 576 236 l 288 236 l 139 0 l -83 0 l 542 991 l 1291 991 l 1254 819 l 907 819 l 861 602 l 1185 602 l 1147 429 l 823 429 l 770 174 l 1117 174 l 1080 0 m 614 412 l 700 819 l 646 819 l 399 412 l 614 412 m 765 1088 q 916 1293 819 1147 l 1143 1293 l 1143 1282 q 1038 1178 1112 1244 q 907 1071 965 1113 l 765 1071 l 765 1088 z \"},\"ǽ\":{\"ha\":1211,\"x_min\":61,\"x_max\":1177,\"o\":\"m 818 -14 q 696 5 744 -14 q 616 64 648 23 l 606 0 l 478 0 l 488 98 l 484 98 q 384 13 435 39 q 271 -14 333 -14 q 116 60 172 -14 q 61 261 61 134 q 107 516 61 397 q 233 704 154 635 q 408 772 312 772 q 517 746 473 772 q 595 661 561 720 l 599 661 l 637 758 l 765 758 l 753 697 q 834 751 783 730 q 949 772 886 772 q 1116 716 1055 772 q 1177 566 1177 659 q 1063 370 1177 439 q 741 301 950 301 l 705 301 l 704 288 l 704 275 q 742 175 704 210 q 850 140 779 140 q 953 156 895 140 q 1063 199 1011 172 l 1063 45 q 818 -14 941 -14 m 351 151 q 442 197 400 151 q 509 322 484 243 q 534 488 534 401 q 512 574 534 542 q 443 607 490 607 q 356 560 397 607 q 292 434 315 513 q 268 271 268 355 q 290 182 268 214 q 351 151 312 151 m 909 625 q 797 571 850 625 q 728 439 744 517 l 758 439 q 922 472 863 439 q 981 561 981 505 q 909 625 981 625 m 643 859 q 793 1064 696 918 l 1021 1064 l 1021 1053 q 916 949 989 1015 q 785 842 843 884 l 643 842 l 643 859 z \"},\"Ǿ\":{\"ha\":1014,\"x_min\":68,\"x_max\":989,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 245 35 330 -14 l 172 -58 l 68 20 l 150 122 q 83 364 83 216 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 815 956 732 1007 l 886 1044 l 989 965 l 909 867 q 971 636 971 776 m 590 836 q 435 774 505 836 q 326 603 365 712 q 288 364 288 494 q 293 296 288 342 l 697 807 q 590 836 650 836 m 768 631 l 765 685 l 366 183 q 469 158 406 158 q 623 218 553 158 q 730 386 692 279 q 768 631 768 494 m 511 1088 q 661 1293 564 1147 l 888 1293 l 888 1282 q 784 1178 857 1244 q 652 1071 711 1113 l 511 1071 l 511 1088 z \"},\"ǿ\":{\"ha\":812,\"x_min\":29,\"x_max\":764,\"o\":\"m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 199 22 268 -14 l 125 -69 l 29 4 l 110 104 q 61 278 61 177 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 618 734 553 772 l 665 794 l 764 720 l 707 648 q 751 472 751 576 m 449 612 q 351 570 394 612 q 284 455 308 528 q 261 297 261 382 l 261 289 l 509 596 q 449 612 485 612 m 368 146 q 499 236 446 146 q 553 452 553 326 l 553 463 l 310 161 q 334 151 317 156 q 368 146 351 146 m 376 859 q 527 1064 430 918 l 754 1064 l 754 1053 q 650 949 723 1015 q 518 842 576 884 l 376 842 l 376 859 z \"},\"Ș\":{\"ha\":736,\"x_min\":28,\"x_max\":753,\"o\":\"m 642 293 q 541 69 642 151 q 269 -14 441 -14 q 28 47 119 -14 l 28 233 q 271 160 159 160 q 389 189 347 160 q 432 268 432 218 q 423 319 432 297 q 397 360 414 341 q 313 429 380 379 q 181 562 219 496 q 143 704 143 628 q 185 860 143 791 q 305 967 227 929 q 484 1006 382 1006 q 753 939 631 1006 l 679 781 q 484 831 573 831 q 391 800 427 831 q 355 720 355 770 q 378 647 355 678 q 478 566 400 616 q 601 446 560 511 q 642 293 642 380 m 102 -289 q 146 -189 119 -254 q 186 -85 174 -123 l 378 -85 l 378 -98 q 313 -198 355 -140 q 224 -307 271 -255 l 102 -307 l 102 -289 z \"},\"ș\":{\"ha\":657,\"x_min\":16,\"x_max\":629,\"o\":\"m 562 250 q 478 55 562 123 q 243 -14 393 -14 q 116 -3 170 -14 q 16 31 62 7 l 16 199 q 232 138 122 138 q 321 160 286 138 q 355 220 355 182 q 330 272 355 249 q 241 330 305 295 q 127 422 159 376 q 94 530 94 468 q 169 709 94 646 q 383 772 244 772 q 629 708 519 772 l 562 562 q 387 619 467 619 q 325 602 349 619 q 301 555 301 585 q 323 509 301 529 q 404 458 345 489 q 525 366 488 416 q 562 250 562 315 m 73 -289 q 118 -189 90 -254 q 158 -85 145 -123 l 349 -85 l 349 -98 q 284 -198 327 -140 q 195 -307 242 -255 l 73 -307 l 73 -289 z \"},\"ˆ\":{\"ha\":770,\"x_min\":211,\"x_max\":760,\"o\":\"m 760 842 l 625 842 q 515 956 583 878 q 358 842 444 896 l 211 842 l 211 859 q 315 958 254 897 q 411 1064 376 1019 l 640 1064 q 690 967 655 1027 q 760 859 726 907 l 760 842 z \"},\"ˇ\":{\"ha\":770,\"x_min\":256,\"x_max\":804,\"o\":\"m 256 1064 l 390 1064 q 500 950 433 1028 q 657 1064 578 1014 l 804 1064 l 804 1047 q 604 842 661 913 l 375 842 q 325 938 360 878 q 256 1047 290 998 l 256 1064 z \"},\"ˉ\":{\"ha\":743,\"x_min\":261,\"x_max\":711,\"o\":\"m 292 985 l 711 985 l 681 842 l 261 842 l 292 985 z \"},\"˘\":{\"ha\":770,\"x_min\":292,\"x_max\":778,\"o\":\"m 778 1071 q 511 842 741 842 q 350 891 408 842 q 292 1026 292 941 q 296 1071 292 1052 l 414 1071 q 438 1006 414 1027 q 518 986 463 986 q 605 1004 571 986 q 650 1071 638 1023 l 778 1071 z \"},\"˙\":{\"ha\":412,\"x_min\":218,\"x_max\":443,\"o\":\"m 218 936 q 251 1025 218 995 q 342 1055 283 1055 q 417 1034 391 1055 q 443 974 443 1013 q 413 886 443 920 q 321 852 383 852 q 218 936 218 852 z \"},\"˚\":{\"ha\":802,\"x_min\":361,\"x_max\":701,\"o\":\"m 701 1003 q 654 885 701 930 q 529 840 606 840 q 408 883 454 840 q 361 1002 361 926 q 407 1119 361 1076 q 529 1162 454 1162 q 652 1118 604 1162 q 701 1003 701 1074 m 595 1002 q 576 1049 595 1032 q 529 1067 557 1067 q 482 1049 500 1067 q 464 1002 464 1032 q 480 954 464 971 q 529 936 496 936 q 576 954 557 936 q 595 1002 595 971 z \"},\"˛\":{\"ha\":286,\"x_min\":-117,\"x_max\":164,\"o\":\"m 164 0 q 59 -100 83 -65 q 35 -170 35 -136 q 45 -199 35 -189 q 75 -210 56 -210 q 144 -197 105 -210 l 144 -317 q 33 -334 87 -334 q -76 -297 -36 -334 q -117 -201 -117 -261 q -84 -99 -117 -146 q 29 0 -52 -52 l 164 0 z \"},\"˜\":{\"ha\":770,\"x_min\":214,\"x_max\":782,\"o\":\"m 587 842 q 529 853 554 842 q 481 877 503 864 q 440 902 460 890 q 397 913 420 913 q 360 894 376 913 q 334 840 343 875 l 214 840 q 404 1050 254 1050 q 464 1039 437 1050 q 512 1014 490 1027 q 554 990 534 1001 q 595 979 574 979 q 634 997 618 979 q 665 1051 650 1014 l 782 1051 q 587 842 737 842 z \"},\"˝\":{\"ha\":770,\"x_min\":189,\"x_max\":822,\"o\":\"m 189 859 q 346 1064 267 945 l 553 1064 l 553 1053 q 449 952 524 1017 q 310 842 375 888 l 189 842 l 189 859 m 458 859 q 615 1064 536 945 l 822 1064 l 822 1053 q 719 952 793 1017 q 579 842 644 888 l 458 842 l 458 859 z \"},\"΄\":{\"ha\":770,\"x_min\":383,\"x_max\":677,\"o\":\"m 383 863 q 485 1105 435 966 l 677 1105 l 677 1089 q 505 842 596 955 l 383 842 l 383 863 z \"},\"΅\":{\"ha\":770,\"x_min\":232,\"x_max\":786,\"o\":\"m 437 960 q 476 1050 452 988 q 518 1164 501 1113 l 694 1164 l 694 1150 q 533 942 633 1053 l 437 942 l 437 960 m 232 937 q 258 1017 232 990 q 330 1044 284 1044 q 392 1025 371 1044 q 412 971 412 1006 q 388 892 412 922 q 314 863 364 863 q 232 937 232 863 m 606 937 q 632 1017 606 990 q 704 1044 658 1044 q 765 1025 745 1044 q 786 971 786 1006 q 762 892 786 922 q 688 863 738 863 q 606 937 606 863 z \"},\"Ά\":{\"ha\":872,\"x_min\":-83,\"x_max\":789,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 50 791 q 152 1034 102 895 l 345 1034 l 345 1018 q 172 770 263 884 l 50 770 l 50 791 z \"},\"·\":{\"ha\":396,\"x_min\":89,\"x_max\":329,\"o\":\"m 89 471 q 125 569 89 532 q 227 606 161 606 q 301 580 273 606 q 329 507 329 554 q 292 412 329 448 q 194 375 254 375 q 117 400 144 375 q 89 471 89 426 z \"},\"Έ\":{\"ha\":875,\"x_min\":23,\"x_max\":900,\"o\":\"m 690 0 l 136 0 l 345 991 l 900 991 l 863 819 l 516 819 l 471 602 l 794 602 l 757 429 l 433 429 l 379 174 l 726 174 l 690 0 m 23 791 q 125 1034 75 895 l 317 1034 l 317 1018 q 145 770 236 884 l 23 770 l 23 791 z \"},\"Ή\":{\"ha\":1072,\"x_min\":23,\"x_max\":1079,\"o\":\"m 869 0 l 662 0 l 753 428 l 433 428 l 342 0 l 136 0 l 345 991 l 553 991 l 471 603 l 790 603 l 872 991 l 1079 991 l 869 0 m 23 791 q 125 1034 75 895 l 317 1034 l 317 1018 q 145 770 236 884 l 23 770 l 23 791 z \"},\"Ό\":{\"ha\":1095,\"x_min\":42,\"x_max\":1052,\"o\":\"m 1052 636 q 985 293 1052 444 q 801 64 918 141 q 532 -14 684 -14 q 261 86 359 -14 q 164 364 164 186 q 231 695 164 544 q 416 926 298 846 q 689 1007 534 1007 q 957 909 862 1007 q 1052 636 1052 812 m 672 832 q 522 770 590 832 q 414 600 453 708 q 375 364 375 491 q 420 214 375 264 q 547 163 465 163 q 697 222 629 163 q 802 389 764 281 q 840 631 840 496 q 796 780 840 727 q 672 832 752 832 m 42 791 q 144 1034 94 895 l 336 1034 l 336 1018 q 164 770 255 884 l 42 770 l 42 791 z \"},\"Ύ\":{\"ha\":994,\"x_min\":23,\"x_max\":1122,\"o\":\"m 636 590 l 890 991 l 1122 991 l 703 379 l 622 0 l 416 0 l 497 379 l 337 991 l 549 991 l 636 590 m 23 791 q 125 1034 75 895 l 317 1034 l 317 1018 q 145 770 236 884 l 23 770 l 23 791 z \"},\"Ώ\":{\"ha\":1109,\"x_min\":42,\"x_max\":1068,\"o\":\"m 682 832 q 547 789 607 832 q 449 662 487 747 q 412 482 412 578 q 437 308 412 378 q 517 187 463 238 l 477 0 l 63 0 l 99 176 l 352 176 q 243 302 283 219 q 203 488 203 385 q 266 760 203 639 q 440 944 329 881 q 697 1007 551 1007 q 969 913 871 1007 q 1068 654 1068 820 q 995 365 1068 488 q 785 176 922 243 l 1032 176 l 995 0 l 555 0 l 595 187 q 857 629 857 341 q 812 780 857 728 q 682 832 766 832 m 42 791 q 144 1034 94 895 l 336 1034 l 336 1018 q 164 770 255 884 l 42 770 l 42 791 z \"},\"ΐ\":{\"ha\":510,\"x_min\":48,\"x_max\":602,\"o\":\"m 334 151 q 443 175 378 151 l 443 22 q 262 -14 368 -14 q 114 29 162 -14 q 65 161 65 71 q 81 268 65 197 l 184 758 l 389 758 l 283 256 q 275 200 275 216 q 334 151 275 151 m 254 960 q 293 1050 268 988 q 334 1164 317 1113 l 511 1164 l 511 1150 q 349 942 450 1053 l 254 942 l 254 960 m 48 937 q 74 1017 48 990 q 146 1044 100 1044 q 208 1025 187 1044 q 229 971 229 1006 q 204 892 229 922 q 130 863 180 863 q 48 937 48 863 m 422 937 q 448 1017 422 990 q 520 1044 474 1044 q 582 1025 561 1044 q 602 971 602 1006 q 578 892 602 922 q 504 863 554 863 q 422 937 422 863 z \"},\"Α\":{\"ha\":872,\"x_min\":-83,\"x_max\":789,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 z \"},\"Β\":{\"ha\":861,\"x_min\":36,\"x_max\":848,\"o\":\"m 534 991 q 769 936 690 991 q 848 771 848 881 q 792 603 848 669 q 632 515 736 537 l 632 511 q 740 446 700 494 q 781 323 781 398 q 677 84 781 168 q 390 0 573 0 l 36 0 l 245 991 l 534 991 m 370 599 l 471 599 q 594 632 553 599 q 635 726 635 665 q 519 819 635 819 l 416 819 l 370 599 m 279 174 l 401 174 q 526 213 481 174 q 571 322 571 252 q 447 432 571 432 l 335 432 l 279 174 z \"},\"Γ\":{\"ha\":699,\"x_min\":36,\"x_max\":798,\"o\":\"m 240 0 l 36 0 l 245 991 l 798 991 l 761 819 l 414 819 l 240 0 z \"},\"Δ\":{\"ha\":840,\"x_min\":-36,\"x_max\":761,\"o\":\"m 427 996 l 665 996 l 761 118 l 734 0 l -36 0 l -12 122 l 427 996 m 510 796 q 471 700 499 759 l 216 175 l 567 175 l 515 689 q 510 796 510 754 z \"},\"Ε\":{\"ha\":753,\"x_min\":36,\"x_max\":800,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 z \"},\"Ζ\":{\"ha\":745,\"x_min\":-41,\"x_max\":814,\"o\":\"m 624 0 l -41 0 l -16 136 l 511 818 l 143 818 l 179 991 l 814 991 l 786 854 l 256 174 l 660 174 l 624 0 z \"},\"Η\":{\"ha\":972,\"x_min\":36,\"x_max\":979,\"o\":\"m 770 0 l 562 0 l 653 428 l 334 428 l 243 0 l 36 0 l 245 991 l 453 991 l 371 603 l 690 603 l 772 991 l 979 991 l 770 0 z \"},\"Θ\":{\"ha\":1031,\"x_min\":83,\"x_max\":987,\"o\":\"m 705 590 l 669 418 l 368 418 l 404 590 l 705 590 m 987 612 q 924 285 987 429 q 744 63 861 140 q 469 -14 626 -14 q 185 91 288 -14 q 83 376 83 195 q 152 707 83 560 q 339 931 220 854 q 612 1007 458 1007 q 889 903 791 1007 q 987 612 987 799 m 600 832 q 442 775 511 832 q 334 610 373 718 q 294 371 294 502 q 344 219 294 275 q 478 163 393 163 q 637 220 570 163 q 741 383 705 277 q 777 623 777 489 q 729 775 777 719 q 600 832 682 832 z \"},\"Κ\":{\"ha\":851,\"x_min\":36,\"x_max\":979,\"o\":\"m 774 0 l 545 0 l 401 401 l 317 354 l 243 0 l 36 0 l 245 991 l 453 991 l 350 515 l 457 654 l 734 991 l 979 991 l 576 517 l 774 0 z \"},\"Λ\":{\"ha\":833,\"x_min\":-83,\"x_max\":750,\"o\":\"m -83 0 l 424 996 l 656 996 l 750 0 l 550 0 l 510 567 q 504 796 504 644 l 484 743 q 424 597 452 656 l 134 0 l -83 0 z \"},\"Μ\":{\"ha\":1222,\"x_min\":36,\"x_max\":1229,\"o\":\"m 568 250 l 942 991 l 1229 991 l 1019 0 l 829 0 l 928 469 q 999 768 964 637 l 996 768 l 610 0 l 419 0 l 378 768 l 375 768 q 349 612 368 709 q 222 0 331 515 l 36 0 l 245 991 l 519 991 l 566 250 l 568 250 z \"},\"Ν\":{\"ha\":1048,\"x_min\":36,\"x_max\":1055,\"o\":\"m 846 0 l 614 0 l 372 750 l 368 750 l 366 728 q 321 467 344 582 l 222 0 l 36 0 l 245 991 l 488 991 l 718 261 l 721 261 q 747 408 729 313 q 869 991 766 504 l 1055 991 l 846 0 z \"},\"Ξ\":{\"ha\":724,\"x_min\":-29,\"x_max\":765,\"o\":\"m 178 602 l 631 602 l 593 429 l 140 429 l 178 602 m 207 991 l 765 991 l 729 819 l 171 819 l 207 991 m 618 174 l 582 0 l -29 0 l 5 174 l 618 174 z \"},\"Ο\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 z \"},\"Π\":{\"ha\":965,\"x_min\":36,\"x_max\":972,\"o\":\"m 762 0 l 555 0 l 729 817 l 416 817 l 243 0 l 36 0 l 245 991 l 972 991 l 762 0 z \"},\"Ρ\":{\"ha\":806,\"x_min\":36,\"x_max\":807,\"o\":\"m 354 525 l 392 525 q 544 572 488 525 q 599 697 599 618 q 467 819 599 819 l 416 819 l 354 525 m 807 703 q 692 446 807 539 q 375 353 577 353 l 317 353 l 243 0 l 36 0 l 245 991 l 475 991 q 723 919 639 991 q 807 703 807 847 z \"},\"Σ\":{\"ha\":754,\"x_min\":-29,\"x_max\":802,\"o\":\"m -29 0 l 4 164 l 372 507 l 154 833 l 187 991 l 802 991 l 765 819 l 386 819 l 602 493 l 262 174 l 667 174 l 631 0 l -29 0 z \"},\"Τ\":{\"ha\":737,\"x_min\":114,\"x_max\":836,\"o\":\"m 387 0 l 180 0 l 353 817 l 114 817 l 151 991 l 836 991 l 799 817 l 559 817 l 387 0 z \"},\"Υ\":{\"ha\":783,\"x_min\":126,\"x_max\":911,\"o\":\"m 425 590 l 679 991 l 911 991 l 492 379 l 411 0 l 205 0 l 286 379 l 126 991 l 338 991 l 425 590 z \"},\"Φ\":{\"ha\":1133,\"x_min\":83,\"x_max\":1090,\"o\":\"m 378 -14 l 411 138 q 238 184 311 145 q 124 297 164 224 q 83 468 83 370 q 210 767 83 659 q 570 884 336 875 l 595 1006 l 787 1006 l 762 884 q 1005 785 920 870 q 1090 557 1090 700 q 962 252 1090 362 q 604 139 833 142 l 571 -14 l 378 -14 m 639 301 q 821 377 758 309 q 884 557 884 444 q 844 674 884 631 q 728 720 804 717 l 639 301 m 534 720 q 355 647 420 713 q 290 467 290 581 q 330 347 290 391 q 446 301 370 304 l 534 720 z \"},\"Χ\":{\"ha\":842,\"x_min\":-79,\"x_max\":950,\"o\":\"m 762 0 l 538 0 l 421 368 l 153 0 l -79 0 l 311 518 l 150 991 l 367 991 l 471 640 l 717 991 l 950 991 l 581 500 l 762 0 z \"},\"Ψ\":{\"ha\":1133,\"x_min\":121,\"x_max\":1185,\"o\":\"m 656 294 l 642 294 l 579 0 l 386 0 l 450 294 l 440 294 q 205 365 290 294 q 121 559 121 435 q 136 693 121 620 l 200 991 l 400 991 l 332 667 q 322 587 322 621 q 360 493 322 521 q 473 465 397 465 l 485 465 l 596 991 l 789 991 l 677 465 l 689 465 q 840 512 789 465 q 914 664 891 559 l 983 991 l 1185 991 l 1109 640 q 656 294 1036 294 z \"},\"Ω\":{\"ha\":1006,\"x_min\":-41,\"x_max\":964,\"o\":\"m 578 832 q 443 789 503 832 q 345 662 382 747 q 307 482 307 578 q 333 308 307 378 q 412 187 359 238 l 372 0 l -41 0 l -5 176 l 248 176 q 139 302 179 219 q 98 488 98 385 q 161 760 98 639 q 336 944 224 881 q 593 1007 447 1007 q 865 913 766 1007 q 964 654 964 820 q 890 365 964 488 q 681 176 817 243 l 928 176 l 890 0 l 450 0 l 490 187 q 753 629 753 341 q 707 780 753 728 q 578 832 662 832 z \"},\"Ϋ\":{\"ha\":783,\"x_min\":126,\"x_max\":911,\"o\":\"m 425 590 l 679 991 l 911 991 l 492 379 l 411 0 l 205 0 l 286 379 l 126 991 l 338 991 l 425 590 m 293 1166 q 322 1246 293 1219 q 403 1274 351 1274 q 493 1200 493 1274 q 467 1121 493 1151 q 385 1092 440 1092 q 293 1166 293 1092 m 566 1166 q 594 1246 566 1219 q 675 1274 623 1274 q 743 1255 720 1274 q 766 1200 766 1236 q 739 1121 766 1151 q 657 1092 712 1092 q 566 1166 566 1092 z \"},\"ά\":{\"ha\":842,\"x_min\":61,\"x_max\":842,\"o\":\"m 602 656 q 634 713 614 684 q 669 758 654 743 l 842 758 q 780 620 811 702 q 730 457 748 538 l 685 240 q 681 204 681 220 q 722 160 681 160 q 766 168 747 160 l 766 7 q 654 -14 724 -14 q 488 98 518 -14 l 484 98 q 379 10 429 34 q 268 -14 330 -14 q 115 59 170 -14 q 61 261 61 131 q 106 523 61 405 q 234 706 152 640 q 418 772 316 772 q 520 746 478 772 q 597 656 563 720 l 602 656 m 358 151 q 450 199 410 151 q 512 338 489 247 q 534 488 534 429 q 513 574 534 542 q 447 607 491 607 q 358 561 399 607 q 292 438 317 515 q 268 281 268 362 q 290 182 268 214 q 358 151 312 151 m 429 863 q 531 1105 481 966 l 724 1105 l 724 1089 q 551 842 642 955 l 429 842 l 429 863 z \"},\"έ\":{\"ha\":713,\"x_min\":26,\"x_max\":726,\"o\":\"m 517 323 l 416 323 q 288 297 335 323 q 241 225 241 271 q 272 166 241 187 q 361 146 302 146 q 480 160 423 146 q 600 207 536 174 l 600 40 q 328 -14 492 -14 q 107 39 188 -14 q 26 186 26 92 q 249 397 26 361 l 249 401 q 165 461 195 422 q 136 547 136 499 q 220 713 136 654 q 453 772 303 772 q 726 714 619 772 l 664 564 q 554 607 602 595 q 458 619 507 619 q 357 597 393 619 q 322 534 322 576 q 355 483 322 499 q 456 467 388 467 l 547 467 l 517 323 m 381 863 q 483 1105 433 966 l 675 1105 l 675 1089 q 503 842 594 955 l 381 842 l 381 863 z \"},\"ή\":{\"ha\":839,\"x_min\":25,\"x_max\":768,\"o\":\"m 591 -334 l 387 -334 l 551 443 q 562 524 562 489 q 489 607 562 607 q 376 530 427 607 q 296 314 325 452 l 229 0 l 25 0 l 186 758 l 342 758 l 328 618 l 332 618 q 572 772 431 772 q 717 716 666 772 q 768 554 768 659 q 753 432 768 505 l 591 -334 m 428 863 q 530 1105 479 966 l 722 1105 l 722 1089 q 550 842 641 955 l 428 842 l 428 863 z \"},\"ί\":{\"ha\":510,\"x_min\":65,\"x_max\":520,\"o\":\"m 334 151 q 443 175 378 151 l 443 22 q 262 -14 368 -14 q 114 29 162 -14 q 65 161 65 71 q 81 268 65 197 l 184 758 l 389 758 l 283 256 q 275 200 275 216 q 334 151 275 151 m 226 863 q 328 1105 277 966 l 520 1105 l 520 1089 q 348 842 439 955 l 226 842 l 226 863 z \"},\"ΰ\":{\"ha\":856,\"x_min\":81,\"x_max\":794,\"o\":\"m 361 -14 q 153 54 224 -14 q 81 244 81 121 q 92 346 81 292 l 179 758 l 382 758 l 294 340 q 285 258 285 299 q 380 153 285 153 q 590 758 590 153 l 794 758 q 767 393 794 534 q 687 165 740 252 q 553 32 635 78 q 361 -14 471 -14 m 446 960 q 485 1050 460 988 q 526 1164 509 1113 l 703 1164 l 703 1150 q 541 942 642 1053 l 446 942 l 446 960 m 240 937 q 266 1017 240 990 q 338 1044 292 1044 q 400 1025 379 1044 q 420 971 420 1006 q 396 892 420 922 q 322 863 372 863 q 240 937 240 863 m 614 937 q 640 1017 614 990 q 712 1044 666 1044 q 773 1025 753 1044 q 794 971 794 1006 q 770 892 794 922 q 696 863 746 863 q 614 937 614 863 z \"},\"α\":{\"ha\":842,\"x_min\":61,\"x_max\":842,\"o\":\"m 602 656 q 634 713 614 684 q 669 758 654 743 l 842 758 q 780 620 811 702 q 730 457 748 538 l 685 240 q 681 204 681 220 q 722 160 681 160 q 766 168 747 160 l 766 7 q 654 -14 724 -14 q 488 98 518 -14 l 484 98 q 379 10 429 34 q 268 -14 330 -14 q 115 59 170 -14 q 61 261 61 131 q 106 523 61 405 q 234 706 152 640 q 418 772 316 772 q 520 746 478 772 q 597 656 563 720 l 602 656 m 358 151 q 450 199 410 151 q 512 338 489 247 q 534 488 534 429 q 513 574 534 542 q 447 607 491 607 q 358 561 399 607 q 292 438 317 515 q 268 281 268 362 q 290 182 268 214 q 358 151 312 151 z \"},\"β\":{\"ha\":861,\"x_min\":-45,\"x_max\":835,\"o\":\"m 545 1063 q 759 1000 683 1063 q 835 825 835 937 q 772 639 835 706 q 596 553 709 572 q 729 479 681 537 q 778 330 778 420 q 734 148 778 229 q 614 27 690 67 q 436 -14 538 -14 q 336 -2 382 -14 q 239 37 290 9 l 161 -334 l -45 -334 l 189 775 q 306 993 220 924 q 545 1063 392 1063 m 533 901 q 442 861 477 901 q 390 736 408 820 l 272 193 q 326 163 290 175 q 397 151 361 151 q 518 202 474 151 q 562 339 562 254 q 527 433 562 401 q 424 464 491 464 l 392 464 l 427 628 l 467 628 q 583 674 541 628 q 625 804 625 720 q 600 876 625 850 q 533 901 575 901 z \"},\"γ\":{\"ha\":711,\"x_min\":40,\"x_max\":791,\"o\":\"m 258 -334 l 40 -334 q 164 9 75 -159 l 69 758 l 269 758 q 295 431 286 545 q 302 205 304 317 l 306 205 q 331 269 316 233 q 362 337 347 304 q 572 758 377 369 l 791 758 l 418 72 q 315 -144 351 -51 q 258 -334 279 -237 z \"},\"δ\":{\"ha\":817,\"x_min\":37,\"x_max\":835,\"o\":\"m 359 628 q 257 821 257 713 q 338 998 257 933 q 558 1063 420 1063 q 701 1045 634 1063 q 835 986 768 1027 l 754 840 q 559 909 648 909 q 487 888 514 909 q 460 828 460 866 q 467 791 460 808 q 489 758 473 775 q 575 684 505 741 q 733 387 733 557 q 627 95 733 203 q 335 -14 522 -14 q 118 58 198 -14 q 37 253 37 130 q 121 490 37 391 q 359 628 205 589 m 358 153 q 472 217 427 153 q 518 382 518 281 q 449 536 518 481 q 308 435 363 507 q 253 273 253 362 q 279 184 253 216 q 358 153 305 153 z \"},\"ε\":{\"ha\":713,\"x_min\":26,\"x_max\":726,\"o\":\"m 517 323 l 416 323 q 288 297 335 323 q 241 225 241 271 q 272 166 241 187 q 361 146 302 146 q 480 160 423 146 q 600 207 536 174 l 600 40 q 328 -14 492 -14 q 107 39 188 -14 q 26 186 26 92 q 249 397 26 361 l 249 401 q 165 461 195 422 q 136 547 136 499 q 220 713 136 654 q 453 772 303 772 q 726 714 619 772 l 664 564 q 554 607 602 595 q 458 619 507 619 q 357 597 393 619 q 322 534 322 576 q 355 483 322 499 q 456 467 388 467 l 547 467 l 517 323 z \"},\"ζ\":{\"ha\":643,\"x_min\":61,\"x_max\":779,\"o\":\"m 61 297 q 103 496 61 403 q 229 680 146 589 q 500 913 313 770 q 378 904 447 904 l 216 904 l 250 1055 l 779 1055 l 753 932 q 461 678 562 779 q 314 494 360 577 q 268 326 268 410 q 297 238 268 275 q 389 174 326 202 q 493 113 460 140 q 543 53 526 86 q 559 -25 559 20 q 530 -141 559 -87 q 433 -257 500 -195 l 220 -257 q 327 -137 300 -176 q 353 -66 353 -97 q 334 -26 353 -43 q 260 17 315 -8 q 108 132 155 64 q 61 297 61 199 z \"},\"η\":{\"ha\":839,\"x_min\":25,\"x_max\":768,\"o\":\"m 591 -334 l 387 -334 l 551 443 q 562 524 562 489 q 489 607 562 607 q 376 530 427 607 q 296 314 325 452 l 229 0 l 25 0 l 186 758 l 342 758 l 328 618 l 332 618 q 572 772 431 772 q 717 716 666 772 q 768 554 768 659 q 753 432 768 505 l 591 -334 z \"},\"θ\":{\"ha\":812,\"x_min\":68,\"x_max\":789,\"o\":\"m 334 -14 q 136 65 203 -14 q 68 293 68 144 q 88 505 68 387 q 149 740 109 623 q 242 928 190 858 q 365 1034 294 998 q 529 1071 435 1071 q 723 991 658 1071 q 789 761 789 911 q 731 377 789 581 q 575 79 673 172 q 334 -14 476 -14 m 349 136 q 454 215 410 136 q 536 456 498 293 l 290 456 q 269 262 269 342 q 349 136 269 136 m 513 921 q 323 610 397 921 l 568 610 q 587 802 587 717 q 569 888 587 856 q 513 921 551 921 z \"},\"ι\":{\"ha\":510,\"x_min\":65,\"x_max\":443,\"o\":\"m 334 151 q 443 175 378 151 l 443 22 q 262 -14 368 -14 q 114 29 162 -14 q 65 161 65 71 q 81 268 65 197 l 184 758 l 389 758 l 283 256 q 275 200 275 216 q 334 151 275 151 z \"},\"κ\":{\"ha\":789,\"x_min\":25,\"x_max\":857,\"o\":\"m 624 758 l 857 758 l 519 416 l 713 0 l 485 0 l 361 285 l 279 236 l 229 0 l 25 0 l 186 758 l 390 758 q 331 501 342 542 q 311 432 320 460 l 314 432 l 624 758 z \"},\"λ\":{\"ha\":794,\"x_min\":-62,\"x_max\":732,\"o\":\"m 353 720 l 346 782 q 319 866 340 842 q 256 890 298 890 q 187 882 226 890 l 163 1048 q 293 1064 222 1064 q 462 1005 403 1064 q 539 817 522 945 l 608 297 q 636 190 618 219 q 686 160 653 160 q 732 167 708 160 l 732 8 q 603 -14 682 -14 q 484 31 525 -14 q 429 171 443 76 l 410 307 q 397 469 402 357 q 365 394 382 437 q 326 311 348 352 l 160 0 l -62 0 l 353 720 z \"},\"μ\":{\"ha\":847,\"x_min\":-46,\"x_max\":823,\"o\":\"m 288 236 q 309 173 288 195 q 363 151 330 151 q 473 223 424 151 q 553 440 522 296 l 619 758 l 823 758 l 663 0 l 507 0 l 519 119 l 515 119 q 335 -14 436 -14 q 274 0 300 -14 q 235 32 248 13 l 231 32 q 216 -62 225 -13 q 160 -334 207 -112 l -46 -334 l 186 758 l 390 758 l 298 321 q 288 236 288 273 z \"},\"ν\":{\"ha\":764,\"x_min\":69,\"x_max\":777,\"o\":\"m 69 758 l 269 758 l 311 340 q 318 184 318 275 q 467 426 408 291 q 568 758 526 560 l 777 758 q 633 335 732 516 q 366 0 534 153 l 164 0 l 69 758 z \"},\"ξ\":{\"ha\":643,\"x_min\":62,\"x_max\":733,\"o\":\"m 575 478 l 528 478 q 337 434 406 478 q 268 313 268 391 q 292 238 268 267 q 389 174 315 209 q 499 107 470 133 q 544 49 529 81 q 559 -25 559 17 q 530 -141 559 -87 q 433 -257 500 -195 l 220 -257 q 323 -139 296 -180 q 350 -66 350 -98 q 330 -23 350 -41 q 260 17 310 -6 q 110 127 157 64 q 62 278 62 191 q 309 557 62 493 l 309 561 q 207 615 243 576 q 171 708 171 654 q 223 834 171 784 q 390 913 276 884 q 225 904 264 904 l 189 904 l 222 1055 l 733 1055 l 703 913 l 686 913 q 523 891 595 913 q 415 829 451 869 q 379 732 379 788 q 419 649 379 677 q 536 621 458 621 l 606 621 l 575 478 z \"},\"ο\":{\"ha\":812,\"x_min\":61,\"x_max\":751,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 z \"},\"π\":{\"ha\":993,\"x_min\":64,\"x_max\":1018,\"o\":\"m 796 149 q 885 171 840 149 l 885 24 q 717 -14 817 -14 q 581 30 628 -14 q 533 155 533 73 q 537 197 533 174 q 618 603 541 221 l 432 603 l 304 0 l 97 0 l 227 603 l 64 603 l 83 703 l 216 758 l 1018 758 l 986 603 l 823 603 l 750 236 q 745 197 745 209 q 796 149 745 149 z \"},\"ρ\":{\"ha\":827,\"x_min\":-45,\"x_max\":765,\"o\":\"m 765 478 q 721 223 765 336 q 595 48 677 111 q 410 -14 514 -14 q 235 71 299 -14 q 218 -45 229 15 q 158 -334 207 -104 l -45 -334 l 110 400 q 186 622 141 547 q 304 735 232 697 q 484 772 377 772 q 690 694 616 772 q 765 478 765 616 m 471 607 q 376 554 412 607 q 317 390 340 500 l 279 211 q 380 151 313 151 q 467 195 427 151 q 532 323 507 239 q 558 481 558 407 q 536 574 558 541 q 471 607 513 607 z \"},\"ς\":{\"ha\":643,\"x_min\":61,\"x_max\":685,\"o\":\"m 268 330 q 294 240 268 276 q 389 174 321 204 q 493 113 460 140 q 543 53 526 86 q 559 -25 559 20 q 530 -141 559 -87 q 433 -257 500 -195 l 220 -257 q 323 -139 296 -180 q 350 -66 350 -98 q 329 -21 350 -39 q 260 20 308 -2 q 107 135 153 68 q 61 302 61 202 q 116 544 61 431 q 262 714 172 656 q 468 772 353 772 q 685 724 583 772 l 623 568 q 471 607 537 607 q 368 569 414 607 q 295 466 321 531 q 268 330 268 401 z \"},\"σ\":{\"ha\":859,\"x_min\":61,\"x_max\":908,\"o\":\"m 745 400 q 715 244 745 326 q 635 105 686 162 q 514 17 585 48 q 355 -14 444 -14 q 140 66 219 -14 q 61 288 61 146 q 115 537 61 431 q 273 701 170 644 q 517 758 376 758 l 908 758 l 876 607 l 684 607 q 727 523 709 576 q 745 400 745 470 m 498 607 q 375 566 427 607 q 294 453 322 526 q 267 292 267 381 q 368 153 267 153 q 496 241 447 153 q 546 463 546 330 q 518 607 546 538 l 498 607 z \"},\"τ\":{\"ha\":693,\"x_min\":64,\"x_max\":720,\"o\":\"m 437 151 q 547 175 481 151 l 547 22 q 367 -14 472 -14 q 218 29 267 -14 q 170 161 170 71 q 178 237 170 195 l 256 603 l 64 603 l 83 703 l 212 758 l 720 758 l 686 603 l 460 603 l 382 237 q 378 201 378 217 q 437 151 378 151 z \"},\"υ\":{\"ha\":856,\"x_min\":81,\"x_max\":794,\"o\":\"m 361 -14 q 153 54 224 -14 q 81 244 81 121 q 92 346 81 292 l 179 758 l 382 758 l 294 340 q 285 258 285 299 q 380 153 285 153 q 590 758 590 153 l 794 758 q 767 393 794 534 q 687 165 740 252 q 553 32 635 78 q 361 -14 471 -14 z \"},\"φ\":{\"ha\":1061,\"x_min\":61,\"x_max\":1000,\"o\":\"m 567 154 q 687 212 636 165 q 765 335 738 260 q 793 498 793 410 q 729 619 793 619 q 642 500 669 619 l 567 154 m 269 -334 l 340 -7 q 137 94 212 10 q 61 313 61 178 q 119 564 61 450 q 309 786 178 677 l 439 667 q 309 491 349 575 q 269 319 269 407 q 298 205 269 245 q 372 153 326 164 l 447 503 q 548 709 479 645 q 736 772 617 772 q 930 694 861 772 q 1000 481 1000 616 q 943 229 1000 339 q 779 57 886 119 q 532 -12 672 -6 l 467 -334 l 269 -334 z \"},\"χ\":{\"ha\":766,\"x_min\":-176,\"x_max\":854,\"o\":\"m 208 772 q 335 725 292 772 q 395 567 378 677 l 412 443 l 629 758 l 854 758 l 465 233 l 515 -81 q 538 -140 522 -120 q 587 -160 554 -160 q 657 -150 618 -160 l 657 -311 q 525 -334 591 -334 q 395 -287 439 -334 q 335 -131 351 -239 l 307 60 l 46 -334 l -176 -334 l 257 272 l 221 498 q 198 573 212 551 q 155 595 184 595 q 106 585 132 595 l 71 746 q 208 772 139 772 z \"},\"ψ\":{\"ha\":1122,\"x_min\":81,\"x_max\":1061,\"o\":\"m 794 1054 l 602 146 q 796 314 734 168 q 857 758 857 461 l 1061 758 q 1008 318 1061 476 q 846 77 956 159 q 567 -20 737 -5 l 500 -334 l 304 -334 l 371 -20 q 155 62 229 -5 q 81 244 81 129 q 92 346 81 292 l 179 758 l 382 758 l 294 340 q 285 258 285 299 q 316 176 285 206 q 406 143 347 146 l 599 1054 l 794 1054 z \"},\"ω\":{\"ha\":1139,\"x_min\":61,\"x_max\":1078,\"o\":\"m 297 -14 q 123 58 184 -14 q 61 258 61 130 q 228 758 61 493 l 433 758 q 304 508 352 639 q 257 264 257 376 q 334 147 257 147 q 410 187 381 147 q 457 317 438 227 l 500 517 l 693 517 q 651 322 665 389 q 637 225 637 256 q 705 147 637 147 q 795 200 754 147 q 860 354 836 254 q 885 564 885 454 q 864 758 885 666 l 1057 758 q 1078 579 1078 673 q 981 145 1078 304 q 710 -14 884 -14 q 524 123 562 -14 q 424 18 479 50 q 297 -14 369 -14 z \"},\"ϊ\":{\"ha\":510,\"x_min\":65,\"x_max\":574,\"o\":\"m 334 151 q 443 175 378 151 l 443 22 q 262 -14 368 -14 q 114 29 162 -14 q 65 161 65 71 q 81 268 65 197 l 184 758 l 389 758 l 283 256 q 275 200 275 216 q 334 151 275 151 m 102 937 q 131 1017 102 990 q 212 1044 159 1044 q 302 971 302 1044 q 275 892 302 922 q 193 863 249 863 q 102 937 102 863 m 374 937 q 403 1017 374 990 q 484 1044 431 1044 q 551 1025 528 1044 q 574 971 574 1006 q 548 892 574 922 q 466 863 521 863 q 374 937 374 863 z \"},\"ϋ\":{\"ha\":856,\"x_min\":81,\"x_max\":794,\"o\":\"m 361 -14 q 153 54 224 -14 q 81 244 81 121 q 92 346 81 292 l 179 758 l 382 758 l 294 340 q 285 258 285 299 q 380 153 285 153 q 590 758 590 153 l 794 758 q 767 393 794 534 q 687 165 740 252 q 553 32 635 78 q 361 -14 471 -14 m 272 937 q 301 1017 272 990 q 382 1044 330 1044 q 472 971 472 1044 q 446 892 472 922 q 363 863 419 863 q 272 937 272 863 m 545 937 q 573 1017 545 990 q 654 1044 602 1044 q 722 1025 699 1044 q 745 971 745 1006 q 718 892 745 922 q 636 863 691 863 q 545 937 545 863 z \"},\"ό\":{\"ha\":812,\"x_min\":61,\"x_max\":751,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 404 863 q 506 1105 456 966 l 699 1105 l 699 1089 q 526 842 617 955 l 404 842 l 404 863 z \"},\"ύ\":{\"ha\":856,\"x_min\":81,\"x_max\":794,\"o\":\"m 361 -14 q 153 54 224 -14 q 81 244 81 121 q 92 346 81 292 l 179 758 l 382 758 l 294 340 q 285 258 285 299 q 380 153 285 153 q 590 758 590 153 l 794 758 q 767 393 794 534 q 687 165 740 252 q 553 32 635 78 q 361 -14 471 -14 m 416 863 q 518 1105 468 966 l 711 1105 l 711 1089 q 538 842 629 955 l 416 842 l 416 863 z \"},\"ώ\":{\"ha\":1139,\"x_min\":61,\"x_max\":1078,\"o\":\"m 297 -14 q 123 58 184 -14 q 61 258 61 130 q 228 758 61 493 l 433 758 q 304 508 352 639 q 257 264 257 376 q 334 147 257 147 q 410 187 381 147 q 457 317 438 227 l 500 517 l 693 517 q 651 322 665 389 q 637 225 637 256 q 705 147 637 147 q 795 200 754 147 q 860 354 836 254 q 885 564 885 454 q 864 758 885 666 l 1057 758 q 1078 579 1078 673 q 981 145 1078 304 q 710 -14 884 -14 q 524 123 562 -14 q 424 18 479 50 q 297 -14 369 -14 m 570 863 q 672 1105 622 966 l 865 1105 l 865 1089 q 692 842 783 955 l 570 842 l 570 863 z \"},\"Ё\":{\"ha\":753,\"x_min\":36,\"x_max\":800,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 309 1166 q 338 1246 309 1219 q 419 1274 367 1274 q 509 1200 509 1274 q 483 1121 509 1151 q 401 1092 456 1092 q 309 1166 309 1092 m 582 1166 q 610 1246 582 1219 q 692 1274 639 1274 q 759 1255 736 1274 q 782 1200 782 1236 q 755 1121 782 1151 q 673 1092 728 1092 q 582 1166 582 1092 z \"},\"Ђ\":{\"ha\":1031,\"x_min\":114,\"x_max\":940,\"o\":\"m 632 -14 q 500 12 553 -14 l 500 184 q 600 158 554 158 q 675 184 650 158 q 714 267 701 210 q 730 348 726 324 q 732 379 733 372 q 710 439 732 420 q 642 457 689 457 l 484 457 l 386 0 l 179 0 l 353 817 l 114 817 l 151 991 l 829 991 l 791 817 l 559 817 l 521 632 l 685 632 q 873 573 806 632 q 940 408 940 514 q 938 359 940 382 q 918 242 936 337 q 867 94 901 148 q 780 14 834 39 q 632 -14 726 -12 z \"},\"Ѓ\":{\"ha\":699,\"x_min\":36,\"x_max\":798,\"o\":\"m 240 0 l 36 0 l 245 991 l 798 991 l 761 819 l 414 819 l 240 0 m 412 1088 q 563 1293 466 1147 l 790 1293 l 790 1282 q 686 1178 759 1244 q 554 1071 612 1113 l 412 1071 l 412 1088 z \"},\"Є\":{\"ha\":850,\"x_min\":83,\"x_max\":905,\"o\":\"m 614 832 q 440 767 515 832 q 328 586 366 703 l 689 586 l 653 414 l 296 414 l 294 393 l 294 372 q 489 163 294 163 q 718 215 588 163 l 718 39 q 447 -14 591 -14 q 179 88 275 -14 q 83 375 83 189 q 154 702 83 553 q 342 929 224 852 q 614 1007 460 1007 q 766 990 696 1007 q 905 936 835 974 l 825 766 q 725 813 777 794 q 614 832 673 832 z \"},\"Ѕ\":{\"ha\":736,\"x_min\":28,\"x_max\":753,\"o\":\"m 642 293 q 541 69 642 151 q 269 -14 441 -14 q 28 47 119 -14 l 28 233 q 271 160 159 160 q 389 189 347 160 q 432 268 432 218 q 423 319 432 297 q 397 360 414 341 q 313 429 380 379 q 181 562 219 496 q 143 704 143 628 q 185 860 143 791 q 305 967 227 929 q 484 1006 382 1006 q 753 939 631 1006 l 679 781 q 484 831 573 831 q 391 800 427 831 q 355 720 355 770 q 378 647 355 678 q 478 566 400 616 q 601 446 560 511 q 642 293 642 380 z \"},\"Ј\":{\"ha\":460,\"x_min\":-218,\"x_max\":468,\"o\":\"m -92 -292 q -218 -273 -155 -292 l -218 -102 q -107 -115 -159 -115 q 2 -74 -40 -115 q 62 56 43 -33 l 261 991 l 468 991 l 262 26 q 143 -216 227 -140 q -92 -292 60 -292 z \"},\"Љ\":{\"ha\":1331,\"x_min\":-41,\"x_max\":1258,\"o\":\"m 880 611 l 926 611 q 1173 541 1087 611 q 1258 340 1258 471 q 1151 88 1258 176 q 842 0 1044 0 l 545 0 l 717 817 l 545 817 q 435 425 491 600 q 330 158 380 251 q 219 26 280 66 q 56 -14 157 -14 q -41 3 1 -14 l -41 175 q 26 161 -5 161 q 99 183 71 161 q 155 252 127 204 q 217 399 182 299 q 297 651 253 499 q 389 991 340 803 l 961 991 l 880 611 m 787 172 l 868 172 q 1002 213 956 172 q 1048 334 1048 254 q 1016 411 1048 384 q 918 439 984 439 l 844 439 l 787 172 z \"},\"Њ\":{\"ha\":1303,\"x_min\":36,\"x_max\":1231,\"o\":\"m 1231 343 q 1125 89 1231 178 q 821 0 1019 0 l 517 0 l 610 439 l 336 439 l 243 0 l 36 0 l 245 991 l 453 991 l 372 611 l 644 611 l 726 991 l 933 991 l 852 611 l 911 611 q 1149 542 1067 611 q 1231 343 1231 473 m 760 172 l 846 172 q 976 213 930 172 q 1021 329 1021 254 q 890 439 1021 439 l 817 439 l 760 172 z \"},\"Ћ\":{\"ha\":1031,\"x_min\":114,\"x_max\":939,\"o\":\"m 732 374 q 707 438 732 420 q 631 457 682 457 l 484 457 l 386 0 l 179 0 l 353 817 l 114 817 l 151 991 l 829 991 l 791 817 l 559 817 l 521 632 l 673 632 q 872 571 806 632 q 939 401 939 510 q 924 283 939 359 l 867 0 l 657 0 l 725 319 q 732 374 732 353 z \"},\"Ќ\":{\"ha\":827,\"x_min\":36,\"x_max\":954,\"o\":\"m 760 0 l 530 0 l 346 488 l 243 0 l 36 0 l 245 991 l 453 991 l 354 528 l 721 991 l 954 991 l 559 501 l 760 0 m 476 1088 q 627 1293 530 1147 l 854 1293 l 854 1282 q 749 1178 823 1244 q 618 1071 676 1113 l 476 1071 l 476 1088 z \"},\"Ў\":{\"ha\":831,\"x_min\":21,\"x_max\":958,\"o\":\"m 164 -14 q 21 8 80 -14 l 21 189 q 155 163 76 163 q 213 174 188 163 q 259 208 238 186 q 314 285 281 230 l 121 991 l 329 991 l 433 564 q 453 461 449 500 q 498 562 484 536 l 732 991 l 958 991 l 550 293 q 411 88 460 140 q 303 11 361 36 q 164 -14 245 -14 m 884 1314 q 818 1173 861 1223 q 703 1097 774 1122 q 528 1071 631 1071 q 319 1123 392 1071 q 247 1282 247 1175 q 250 1314 247 1298 l 431 1314 l 429 1296 l 429 1282 q 545 1187 429 1187 q 648 1217 612 1187 q 700 1314 684 1247 l 884 1314 z \"},\"Џ\":{\"ha\":965,\"x_min\":36,\"x_max\":972,\"o\":\"m 245 991 l 454 991 l 281 175 l 593 175 l 766 991 l 972 991 l 762 0 l 503 0 l 440 -289 l 235 -289 l 297 0 l 36 0 l 245 991 z \"},\"А\":{\"ha\":872,\"x_min\":-83,\"x_max\":789,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 z \"},\"Б\":{\"ha\":822,\"x_min\":36,\"x_max\":803,\"o\":\"m 415 611 q 662 540 576 611 q 747 334 747 469 q 640 86 747 173 q 330 0 533 0 l 36 0 l 245 991 l 803 991 l 766 819 l 414 819 l 370 611 l 415 611 m 345 172 q 488 212 439 172 q 538 323 538 252 q 407 439 538 439 l 334 439 l 277 172 l 345 172 z \"},\"В\":{\"ha\":861,\"x_min\":36,\"x_max\":848,\"o\":\"m 534 991 q 769 936 690 991 q 848 771 848 881 q 792 603 848 669 q 632 515 736 537 l 632 511 q 740 446 700 494 q 781 323 781 398 q 677 84 781 168 q 390 0 573 0 l 36 0 l 245 991 l 534 991 m 370 599 l 471 599 q 594 632 553 599 q 635 726 635 665 q 519 819 635 819 l 416 819 l 370 599 m 279 174 l 401 174 q 526 213 481 174 q 571 322 571 252 q 447 432 571 432 l 335 432 l 279 174 z \"},\"Г\":{\"ha\":699,\"x_min\":36,\"x_max\":798,\"o\":\"m 240 0 l 36 0 l 245 991 l 798 991 l 761 819 l 414 819 l 240 0 z \"},\"Д\":{\"ha\":1000,\"x_min\":-134,\"x_max\":954,\"o\":\"m -36 175 l 52 175 q 260 543 168 342 q 435 991 353 743 l 954 991 l 781 175 l 907 175 l 808 -289 l 603 -289 l 665 0 l 134 0 l 71 -289 l -134 -289 l -36 175 m 570 817 q 281 175 424 399 l 568 175 l 705 817 l 570 817 z \"},\"Е\":{\"ha\":753,\"x_min\":36,\"x_max\":800,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 z \"},\"Ж\":{\"ha\":1204,\"x_min\":-85,\"x_max\":1317,\"o\":\"m 335 529 l 146 991 l 351 991 l 532 528 l 631 991 l 829 991 l 730 528 l 1095 991 l 1317 991 l 922 501 l 1122 0 l 908 0 l 722 488 l 619 0 l 421 0 l 524 486 l 147 0 l -85 0 l 335 529 z \"},\"З\":{\"ha\":828,\"x_min\":28,\"x_max\":814,\"o\":\"m 814 775 q 740 594 814 661 q 532 519 665 528 l 532 517 q 685 448 629 505 q 742 302 742 391 q 633 68 742 151 q 315 -14 524 -14 q 151 -1 221 -14 q 28 40 81 11 l 28 218 q 298 151 151 151 q 472 192 414 151 q 530 311 530 233 q 478 404 530 374 q 314 433 426 433 l 218 433 l 253 597 l 339 597 q 599 733 599 597 q 567 810 599 782 q 471 838 534 838 q 227 754 355 838 l 153 896 q 335 982 250 958 q 522 1006 420 1006 q 673 976 606 1006 q 777 893 740 946 q 814 775 814 840 z \"},\"И\":{\"ha\":1048,\"x_min\":36,\"x_max\":1055,\"o\":\"m 286 283 l 804 991 l 1055 991 l 846 0 l 659 0 q 756 463 722 302 q 814 720 790 623 l 808 721 l 290 0 l 36 0 l 245 991 l 436 991 l 336 522 q 279 283 292 331 l 286 283 z \"},\"Й\":{\"ha\":1048,\"x_min\":36,\"x_max\":1055,\"o\":\"m 286 283 l 804 991 l 1055 991 l 846 0 l 659 0 q 756 463 722 302 q 814 720 790 623 l 808 721 l 290 0 l 36 0 l 245 991 l 436 991 l 336 522 q 279 283 292 331 l 286 283 m 1005 1314 q 939 1173 982 1223 q 823 1097 895 1122 q 648 1071 751 1071 q 440 1123 513 1071 q 368 1282 368 1175 q 371 1314 368 1298 l 551 1314 l 550 1296 l 550 1282 q 665 1187 550 1187 q 769 1217 732 1187 q 821 1314 805 1247 l 1005 1314 z \"},\"К\":{\"ha\":827,\"x_min\":36,\"x_max\":954,\"o\":\"m 760 0 l 530 0 l 346 488 l 243 0 l 36 0 l 245 991 l 453 991 l 354 528 l 721 991 l 954 991 l 559 501 l 760 0 z \"},\"Л\":{\"ha\":965,\"x_min\":-41,\"x_max\":972,\"o\":\"m 545 817 q 435 425 491 600 q 330 158 380 251 q 219 26 280 66 q 56 -14 157 -14 q -41 3 1 -14 l -41 175 q 26 161 -5 161 q 99 183 71 161 q 155 252 127 204 q 217 399 182 299 q 297 651 253 499 q 389 991 340 803 l 972 991 l 761 0 l 555 0 l 729 817 l 545 817 z \"},\"М\":{\"ha\":1222,\"x_min\":36,\"x_max\":1229,\"o\":\"m 568 250 l 942 991 l 1229 991 l 1019 0 l 829 0 l 928 469 q 999 768 964 637 l 996 768 l 610 0 l 419 0 l 378 768 l 375 768 q 349 612 368 709 q 222 0 331 515 l 36 0 l 245 991 l 519 991 l 566 250 l 568 250 z \"},\"Н\":{\"ha\":972,\"x_min\":36,\"x_max\":979,\"o\":\"m 770 0 l 562 0 l 653 428 l 334 428 l 243 0 l 36 0 l 245 991 l 453 991 l 371 603 l 690 603 l 772 991 l 979 991 l 770 0 z \"},\"О\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 z \"},\"П\":{\"ha\":965,\"x_min\":36,\"x_max\":972,\"o\":\"m 762 0 l 555 0 l 729 817 l 416 817 l 243 0 l 36 0 l 245 991 l 972 991 l 762 0 z \"},\"Р\":{\"ha\":806,\"x_min\":36,\"x_max\":807,\"o\":\"m 354 525 l 392 525 q 544 572 488 525 q 599 697 599 618 q 467 819 599 819 l 416 819 l 354 525 m 807 703 q 692 446 807 539 q 375 353 577 353 l 317 353 l 243 0 l 36 0 l 245 991 l 475 991 q 723 919 639 991 q 807 703 807 847 z \"},\"С\":{\"ha\":850,\"x_min\":83,\"x_max\":905,\"o\":\"m 614 832 q 453 777 524 832 q 338 615 381 722 q 294 386 294 509 q 341 218 294 273 q 489 163 387 163 q 718 215 588 163 l 718 39 q 447 -14 583 -14 q 179 88 275 -14 q 83 375 83 189 q 154 702 83 553 q 342 929 224 852 q 614 1007 460 1007 q 764 992 699 1007 q 905 936 830 977 l 825 766 q 707 819 753 806 q 614 832 660 832 z \"},\"Т\":{\"ha\":737,\"x_min\":114,\"x_max\":836,\"o\":\"m 387 0 l 180 0 l 353 817 l 114 817 l 151 991 l 836 991 l 799 817 l 559 817 l 387 0 z \"},\"У\":{\"ha\":831,\"x_min\":21,\"x_max\":958,\"o\":\"m 164 -14 q 21 8 80 -14 l 21 189 q 155 163 76 163 q 213 174 188 163 q 259 208 238 186 q 314 285 281 230 l 121 991 l 329 991 l 433 564 q 453 461 449 500 q 498 562 484 536 l 732 991 l 958 991 l 550 293 q 411 88 460 140 q 303 11 361 36 q 164 -14 245 -14 z \"},\"Ф\":{\"ha\":1133,\"x_min\":83,\"x_max\":1090,\"o\":\"m 378 -14 l 411 138 q 238 184 311 145 q 124 297 164 224 q 83 468 83 370 q 210 767 83 659 q 570 884 336 875 l 595 1006 l 787 1006 l 762 884 q 1005 785 920 870 q 1090 557 1090 700 q 962 252 1090 362 q 604 139 833 142 l 571 -14 l 378 -14 m 639 301 q 821 377 758 309 q 884 557 884 444 q 844 674 884 631 q 728 720 804 717 l 639 301 m 534 720 q 355 647 420 713 q 290 467 290 581 q 330 347 290 391 q 446 301 370 304 l 534 720 z \"},\"Х\":{\"ha\":842,\"x_min\":-79,\"x_max\":950,\"o\":\"m 762 0 l 538 0 l 421 368 l 153 0 l -79 0 l 311 518 l 150 991 l 367 991 l 471 640 l 717 991 l 950 991 l 581 500 l 762 0 z \"},\"Ц\":{\"ha\":1018,\"x_min\":36,\"x_max\":972,\"o\":\"m 939 167 l 842 -289 l 636 -289 l 699 0 l 36 0 l 245 991 l 454 991 l 281 175 l 593 175 l 766 991 l 972 991 l 798 167 l 939 167 z \"},\"Ч\":{\"ha\":935,\"x_min\":125,\"x_max\":942,\"o\":\"m 525 0 l 606 380 q 370 322 479 322 q 191 380 256 322 q 125 541 125 437 q 134 619 125 579 l 210 991 l 416 991 l 343 642 q 336 586 336 610 q 440 497 336 497 q 640 547 529 497 l 734 991 l 942 991 l 732 0 l 525 0 z \"},\"Ш\":{\"ha\":1394,\"x_min\":36,\"x_max\":1401,\"o\":\"m 36 0 l 245 991 l 458 991 l 285 175 l 543 175 l 717 991 l 930 991 l 757 175 l 1015 175 l 1189 991 l 1401 991 l 1192 0 l 36 0 z \"},\"Щ\":{\"ha\":1447,\"x_min\":36,\"x_max\":1401,\"o\":\"m 1368 167 l 1271 -289 l 1065 -289 l 1128 0 l 36 0 l 245 991 l 458 991 l 285 175 l 543 175 l 717 991 l 930 991 l 757 175 l 1015 175 l 1189 991 l 1401 991 l 1226 167 l 1368 167 z \"},\"Ъ\":{\"ha\":966,\"x_min\":114,\"x_max\":895,\"o\":\"m 517 611 l 562 611 q 810 540 725 611 q 895 334 895 469 q 787 86 895 173 q 478 0 680 0 l 180 0 l 353 817 l 114 817 l 151 991 l 597 991 l 517 611 m 424 172 l 492 172 q 635 212 586 172 q 685 323 685 252 q 554 439 685 439 l 481 439 l 424 172 z \"},\"Ы\":{\"ha\":1187,\"x_min\":36,\"x_max\":1194,\"o\":\"m 985 0 l 772 0 l 982 991 l 1194 991 l 985 0 m 729 334 q 622 86 729 173 q 313 0 515 0 l 36 0 l 245 991 l 453 991 l 372 611 l 397 611 q 645 540 560 611 q 729 334 729 469 m 279 172 l 326 172 q 470 212 420 172 q 519 323 519 252 q 389 439 519 439 l 336 439 l 279 172 z \"},\"Ь\":{\"ha\":822,\"x_min\":36,\"x_max\":750,\"o\":\"m 750 334 q 643 86 750 173 q 334 0 536 0 l 36 0 l 245 991 l 453 991 l 372 611 l 418 611 q 665 540 581 611 q 750 334 750 469 m 279 172 l 347 172 q 491 212 441 172 q 541 323 541 252 q 410 439 541 439 l 336 439 l 279 172 z \"},\"Э\":{\"ha\":850,\"x_min\":18,\"x_max\":807,\"o\":\"m 264 161 q 452 223 378 161 q 567 414 526 286 l 201 414 l 237 586 l 595 586 l 596 603 l 596 621 q 421 832 596 832 q 335 823 377 832 q 203 779 292 814 l 149 946 q 447 1007 290 1007 q 714 908 622 1007 q 807 624 807 808 q 740 292 807 442 q 557 64 673 142 q 288 -14 441 -14 q 140 -1 205 -14 q 18 43 75 12 l 18 227 q 264 161 136 161 z \"},\"Ю\":{\"ha\":1397,\"x_min\":36,\"x_max\":1354,\"o\":\"m 1354 636 q 1295 296 1354 447 q 1125 66 1235 146 q 867 -14 1016 -14 q 611 86 703 -14 q 518 364 518 186 q 521 428 518 398 l 334 428 l 243 0 l 36 0 l 245 991 l 453 991 l 371 603 l 549 603 q 724 903 603 798 q 1011 1007 845 1007 q 1264 909 1175 1007 q 1354 636 1354 812 m 993 832 q 859 770 920 832 q 764 600 798 708 q 729 364 729 491 q 769 214 729 264 q 882 163 810 163 q 1015 222 954 163 q 1109 388 1075 281 q 1143 631 1143 494 q 1105 779 1143 725 q 993 832 1066 832 z \"},\"Я\":{\"ha\":851,\"x_min\":-85,\"x_max\":859,\"o\":\"m 443 380 l 161 0 l -85 0 l 264 446 q 161 545 191 492 q 131 671 131 598 q 235 907 131 822 q 529 991 339 991 l 859 991 l 648 0 l 441 0 l 522 380 l 443 380 m 615 819 l 524 819 q 392 781 437 819 q 347 667 347 742 q 384 582 347 613 q 485 551 421 551 l 558 551 l 615 819 z \"},\"а\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 z \"},\"б\":{\"ha\":812,\"x_min\":74,\"x_max\":860,\"o\":\"m 74 313 q 163 723 74 537 q 406 978 252 908 q 545 1019 454 1000 q 839 1065 636 1038 l 860 890 q 573 844 652 860 q 449 799 494 828 q 373 720 404 769 q 322 591 342 670 l 323 591 q 426 677 368 648 q 549 707 484 707 q 697 643 645 707 q 750 457 750 578 q 700 213 750 323 q 560 45 650 103 q 354 -14 470 -14 q 146 70 218 -14 q 74 313 74 153 m 374 154 q 457 195 418 154 q 520 307 496 236 q 545 450 545 378 q 467 554 545 554 q 383 524 429 554 q 297 437 338 493 q 281 306 281 359 q 374 154 281 154 z \"},\"в\":{\"ha\":796,\"x_min\":61,\"x_max\":755,\"o\":\"m 482 772 q 682 717 609 772 q 755 568 755 662 q 714 447 755 492 q 591 383 673 402 l 591 380 q 682 325 652 363 q 713 229 713 286 q 673 102 713 157 q 559 17 633 47 q 385 -14 485 -14 q 146 65 231 -14 q 61 293 61 144 q 113 539 61 430 q 261 711 165 649 q 482 772 357 772 m 267 322 l 265 301 l 265 279 q 296 169 265 208 q 387 129 327 129 q 476 158 445 129 q 507 233 507 187 q 474 300 507 278 q 366 322 441 322 l 267 322 m 473 625 q 368 581 416 625 q 294 463 321 537 l 431 463 q 522 486 490 463 q 554 557 554 510 q 532 607 554 589 q 473 625 509 625 z \"},\"г\":{\"ha\":665,\"x_min\":14,\"x_max\":631,\"o\":\"m 113 713 q 378 772 237 772 q 565 719 499 772 q 631 567 631 666 q 608 461 631 503 q 548 391 586 419 q 460 342 510 362 q 354 302 410 322 q 264 267 286 279 q 232 240 242 254 q 221 205 221 226 q 318 138 221 138 q 539 199 410 138 l 539 45 q 414 0 475 13 q 275 -14 353 -14 q 82 43 151 -14 q 14 201 14 100 q 37 307 14 264 q 99 377 61 349 q 184 423 136 405 q 278 457 231 441 q 387 498 367 487 q 416 525 406 510 q 425 561 425 540 q 343 619 425 619 q 163 568 266 619 l 113 713 z \"},\"д\":{\"ha\":835,\"x_min\":61,\"x_max\":790,\"o\":\"m 790 629 q 736 288 790 437 q 584 63 682 140 q 354 -14 487 -14 q 137 65 214 -14 q 61 286 61 144 q 102 509 61 412 q 218 660 143 606 q 389 713 293 713 q 579 589 514 713 l 583 589 l 585 613 l 585 633 q 543 838 585 774 q 406 903 500 903 q 268 875 334 903 l 225 1036 q 437 1069 311 1069 q 790 629 790 1069 m 366 153 q 487 229 437 153 q 559 452 537 304 q 516 526 546 496 q 437 555 486 555 q 313 480 359 555 q 267 279 267 406 q 292 186 267 220 q 366 153 318 153 z \"},\"е\":{\"ha\":774,\"x_min\":61,\"x_max\":739,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 z \"},\"ж\":{\"ha\":1333,\"x_min\":-14,\"x_max\":1348,\"o\":\"m 550 306 l 447 306 q 312 71 408 155 q 78 -14 215 -14 q -14 -5 26 -14 l 18 157 q 72 151 54 151 q 173 195 129 151 q 242 313 218 238 q 267 476 267 389 q 242 574 267 541 q 174 607 218 607 q 92 589 143 607 l 92 754 q 212 772 143 772 q 399 695 331 772 q 468 479 468 618 l 468 461 l 467 443 l 579 443 l 647 758 l 843 758 l 775 443 l 882 443 q 1019 685 920 597 q 1255 772 1118 772 q 1348 764 1303 772 l 1312 602 q 1258 607 1276 607 q 1119 515 1173 607 q 1064 282 1064 422 q 1088 184 1064 217 q 1157 151 1113 151 q 1239 170 1187 151 l 1239 4 q 1118 -14 1190 -14 q 930 62 998 -14 q 863 275 863 138 l 863 306 l 746 306 l 681 0 l 485 0 l 550 306 z \"},\"з\":{\"ha\":728,\"x_min\":17,\"x_max\":692,\"o\":\"m 314 467 q 448 487 409 467 q 488 553 488 507 q 465 602 488 584 q 383 619 441 619 q 279 604 336 619 q 170 566 222 589 l 121 714 q 419 772 273 772 q 621 724 550 772 q 692 585 692 676 q 649 467 692 514 q 515 396 606 420 l 515 392 q 644 239 644 354 q 547 52 644 117 q 269 -14 450 -14 q 132 0 201 -14 q 17 37 64 14 l 17 205 q 262 146 136 146 q 437 244 437 146 q 318 323 437 323 l 199 323 l 229 467 l 314 467 z \"},\"и\":{\"ha\":839,\"x_min\":75,\"x_max\":815,\"o\":\"m 178 758 l 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 125 42 174 -14 q 75 204 75 98 q 92 349 75 267 l 178 758 z \"},\"й\":{\"ha\":839,\"x_min\":75,\"x_max\":858,\"o\":\"m 178 758 l 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 125 42 174 -14 q 75 204 75 98 q 92 349 75 267 l 178 758 m 858 1084 q 791 944 835 994 q 676 867 748 893 q 501 842 604 842 q 293 893 366 842 q 220 1053 220 945 q 224 1084 220 1069 l 404 1084 l 403 1067 l 403 1053 q 518 958 403 958 q 622 988 585 958 q 673 1084 658 1018 l 858 1084 z \"},\"к\":{\"ha\":803,\"x_min\":25,\"x_max\":848,\"o\":\"m 615 758 l 848 758 l 524 378 l 711 0 l 482 0 l 309 370 l 229 0 l 25 0 l 187 758 l 392 758 l 317 406 l 615 758 z \"},\"л\":{\"ha\":854,\"x_min\":-40,\"x_max\":823,\"o\":\"m 669 0 l 465 0 l 593 600 q 550 606 566 606 q 474 584 505 606 q 418 516 444 563 q 345 323 393 469 q 298 192 321 254 q 244 85 275 131 q 170 13 214 39 q 61 -14 126 -14 q -40 3 1 -14 l -40 171 q 17 160 -15 160 q 78 196 51 160 q 130 307 104 231 q 237 583 199 512 q 320 694 275 654 q 431 753 366 734 q 589 772 496 772 q 712 762 648 772 q 823 733 777 751 l 669 0 z \"},\"м\":{\"ha\":1099,\"x_min\":16,\"x_max\":1076,\"o\":\"m 835 547 q 788 455 816 505 q 732 351 760 405 l 545 0 l 387 0 l 345 342 q 323 550 328 479 l 208 0 l 16 0 l 178 758 l 453 758 l 493 435 q 504 329 500 378 q 510 232 507 280 q 550 324 528 273 q 603 429 572 376 l 786 758 l 1076 758 l 917 0 l 718 0 l 835 547 z \"},\"н\":{\"ha\":856,\"x_min\":25,\"x_max\":832,\"o\":\"m 393 758 l 330 467 l 567 467 l 628 758 l 832 758 l 671 0 l 467 0 l 532 313 l 297 313 l 231 0 l 25 0 l 187 758 l 393 758 z \"},\"о\":{\"ha\":812,\"x_min\":61,\"x_max\":751,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 z \"},\"п\":{\"ha\":839,\"x_min\":25,\"x_max\":768,\"o\":\"m 663 0 l 458 0 l 551 443 q 562 524 562 489 q 489 607 562 607 q 376 530 427 607 q 296 314 325 452 l 229 0 l 25 0 l 186 758 l 342 758 l 328 618 l 332 618 q 572 772 431 772 q 717 716 666 772 q 768 554 768 659 q 753 432 768 505 l 663 0 z \"},\"р\":{\"ha\":827,\"x_min\":-46,\"x_max\":765,\"o\":\"m 551 772 q 708 700 650 772 q 765 496 765 627 q 719 247 765 366 q 591 57 672 127 q 414 -14 511 -14 q 317 12 357 -14 q 241 97 276 37 l 236 97 q 207 -103 228 -11 l 158 -334 l -46 -334 l 186 758 l 342 758 l 330 643 l 336 643 q 551 772 430 772 m 469 607 q 380 561 423 607 q 311 439 337 515 q 285 271 285 363 q 310 184 285 216 q 379 151 335 151 q 466 198 425 151 q 533 327 507 245 q 558 488 558 408 q 469 607 558 607 z \"},\"с\":{\"ha\":671,\"x_min\":61,\"x_max\":685,\"o\":\"m 343 -14 q 134 59 207 -14 q 61 265 61 132 q 112 527 61 409 q 254 708 162 644 q 463 772 345 772 q 685 724 586 772 l 623 568 q 551 595 586 584 q 471 607 515 607 q 367 564 413 607 q 294 445 320 520 q 268 282 268 369 q 299 184 268 217 q 385 151 330 151 q 480 167 436 151 q 571 207 524 183 l 571 40 q 343 -14 468 -14 z \"},\"т\":{\"ha\":1257,\"x_min\":25,\"x_max\":1186,\"o\":\"m 572 772 q 750 618 721 772 l 754 618 q 863 732 800 692 q 997 772 926 772 q 1138 715 1089 772 q 1186 554 1186 657 q 1171 432 1186 503 l 1080 0 l 876 0 l 970 443 q 981 524 981 489 q 914 607 981 607 q 801 531 852 607 q 721 315 751 455 l 656 0 l 452 0 l 545 443 q 555 524 555 489 q 489 607 555 607 q 376 530 427 607 q 296 314 325 452 l 229 0 l 25 0 l 186 758 l 342 758 l 328 618 l 332 618 q 572 772 431 772 z \"},\"у\":{\"ha\":721,\"x_min\":-96,\"x_max\":793,\"o\":\"m 69 758 l 269 758 l 307 407 q 317 208 317 324 l 321 208 q 351 289 334 243 q 395 393 367 336 l 571 758 l 793 758 l 332 -109 q 4 -334 212 -334 q -96 -321 -57 -334 l -96 -158 q -17 -167 -50 -167 q 83 -134 40 -167 q 163 -33 126 -102 l 180 0 l 69 758 z \"},\"ф\":{\"ha\":1060,\"x_min\":61,\"x_max\":999,\"o\":\"m 711 762 q 924 659 850 742 q 999 446 999 575 q 944 215 999 315 q 788 58 889 115 q 546 -12 688 2 l 481 -334 l 283 -334 l 354 -5 q 139 95 217 10 q 61 307 61 179 q 118 539 61 437 q 277 699 176 642 q 517 764 378 755 l 578 1055 l 772 1055 l 711 762 m 269 323 q 298 208 269 254 q 386 153 328 161 l 484 606 q 373 566 420 602 q 297 464 325 530 q 269 323 269 397 m 581 153 q 690 197 644 161 q 764 299 736 233 q 791 441 791 364 q 761 550 791 507 q 676 603 730 593 l 581 153 z \"},\"х\":{\"ha\":737,\"x_min\":-68,\"x_max\":806,\"o\":\"m 257 389 l 104 758 l 322 758 l 400 532 l 566 758 l 806 758 l 489 378 l 654 0 l 433 0 l 349 232 l 170 0 l -68 0 l 257 389 z \"},\"ц\":{\"ha\":861,\"x_min\":72,\"x_max\":815,\"o\":\"m 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 705 240 q 701 204 701 220 q 743 160 701 160 q 804 170 770 160 l 711 -272 l 522 -272 l 587 0 q 500 122 522 31 l 498 122 q 268 -14 402 -14 q 123 42 175 -14 q 72 204 72 98 q 92 349 72 250 l 178 758 l 382 758 z \"},\"ч\":{\"ha\":827,\"x_min\":111,\"x_max\":803,\"o\":\"m 165 758 l 370 758 l 328 561 q 317 481 317 515 q 338 416 317 438 q 397 395 359 395 q 507 461 464 395 q 581 672 550 528 l 599 758 l 803 758 l 642 0 l 437 0 l 481 205 l 510 328 l 505 328 q 307 232 418 232 q 163 290 216 232 q 111 450 111 349 q 131 595 111 504 l 165 758 z \"},\"ш\":{\"ha\":1257,\"x_min\":72,\"x_max\":1234,\"o\":\"m 807 758 l 714 315 q 703 235 703 268 q 770 151 703 151 q 883 229 833 151 q 962 444 933 307 l 1029 758 l 1234 758 l 1072 0 l 917 0 l 930 140 l 926 140 q 686 -14 828 -14 q 509 140 538 -14 l 504 140 q 261 -14 406 -14 q 121 43 171 -14 q 72 204 72 99 q 87 326 72 254 l 178 758 l 382 758 l 289 315 q 278 235 278 269 q 345 151 278 151 q 456 226 407 151 q 538 443 506 301 l 603 758 l 807 758 z \"},\"щ\":{\"ha\":1279,\"x_min\":72,\"x_max\":1234,\"o\":\"m 807 758 l 714 315 q 703 235 703 268 q 770 151 703 151 q 883 229 833 151 q 962 444 933 307 l 1029 758 l 1234 758 l 1124 240 q 1120 204 1120 220 q 1161 160 1120 160 q 1222 170 1189 160 l 1129 -272 l 940 -272 l 1006 0 q 918 125 936 32 l 917 125 q 686 -14 819 -14 q 509 140 538 -14 l 504 140 q 261 -14 406 -14 q 121 43 171 -14 q 72 204 72 99 q 87 326 72 254 l 178 758 l 382 758 l 289 315 q 278 235 278 269 q 345 151 278 151 q 456 226 407 151 q 538 443 506 301 l 603 758 l 807 758 z \"},\"ъ\":{\"ha\":936,\"x_min\":62,\"x_max\":859,\"o\":\"m 538 758 l 471 450 q 618 465 530 465 q 794 409 730 465 q 859 260 859 353 q 816 117 859 178 q 693 21 774 55 q 496 -14 612 -14 q 294 43 363 -14 q 225 208 225 99 q 241 330 225 256 l 301 603 l 62 603 l 96 758 l 538 758 m 428 215 q 454 151 428 174 q 525 129 479 129 q 618 159 583 129 q 653 239 653 189 q 551 322 653 322 q 443 310 504 322 q 433 262 438 288 q 428 215 428 235 z \"},\"ы\":{\"ha\":1116,\"x_min\":72,\"x_max\":1092,\"o\":\"m 383 758 l 317 450 q 454 465 383 465 q 608 410 549 465 q 667 264 667 354 q 628 119 667 182 q 514 22 589 57 q 336 -14 439 -14 q 72 207 72 -14 q 87 335 72 266 l 179 758 l 383 758 m 378 322 q 289 310 339 322 q 277 247 279 264 q 275 212 275 229 q 296 150 275 171 q 353 129 317 129 q 432 160 402 129 q 463 241 463 192 q 378 322 463 322 m 930 0 l 726 0 l 888 758 l 1092 758 l 930 0 z \"},\"ь\":{\"ha\":782,\"x_min\":71,\"x_max\":704,\"o\":\"m 317 450 q 464 465 375 465 q 640 409 576 465 q 704 260 704 353 q 662 116 704 178 q 539 21 620 55 q 342 -14 458 -14 q 140 43 210 -14 q 71 208 71 100 q 87 330 71 252 l 179 758 l 383 758 l 317 450 m 397 322 q 289 310 350 322 q 273 215 273 240 q 300 151 273 173 q 371 129 326 129 q 464 159 429 129 q 498 239 498 190 q 397 322 498 322 z \"},\"э\":{\"ha\":671,\"x_min\":21,\"x_max\":610,\"o\":\"m 332 772 q 537 693 464 772 q 610 468 610 614 q 561 214 610 323 q 418 46 511 105 q 195 -14 324 -14 q 21 24 92 -14 l 21 195 q 97 164 56 178 q 191 151 138 151 q 315 191 267 151 q 385 314 362 231 l 132 314 l 161 452 l 403 452 l 404 465 l 404 478 q 375 573 404 540 q 290 607 345 607 q 220 596 252 607 q 150 567 189 585 l 96 717 q 332 772 207 772 z \"},\"ю\":{\"ha\":1160,\"x_min\":25,\"x_max\":1099,\"o\":\"m 1099 472 q 1053 218 1099 329 q 921 47 1007 108 q 715 -14 834 -14 q 511 63 584 -14 q 437 277 437 140 l 437 313 l 297 313 l 231 0 l 25 0 l 187 758 l 393 758 l 330 467 l 461 467 q 593 692 500 612 q 822 772 687 772 q 1026 693 954 772 q 1099 472 1099 614 m 804 606 q 721 562 758 606 q 661 439 684 517 q 637 278 637 360 q 730 153 637 153 q 811 195 774 153 q 871 313 848 237 q 893 472 893 389 q 804 606 893 606 z \"},\"я\":{\"ha\":808,\"x_min\":-14,\"x_max\":783,\"o\":\"m 439 282 q 372 255 400 282 q 313 161 345 229 q 216 26 269 65 q 89 -14 164 -14 q -14 3 27 -14 l -14 171 q 39 160 14 160 q 85 175 67 160 q 117 214 103 191 l 138 248 q 245 342 181 322 q 139 501 139 386 q 225 690 139 622 q 467 758 312 758 l 783 758 l 624 0 l 419 0 l 481 282 l 439 282 m 464 612 q 379 583 410 612 q 347 504 347 553 q 371 444 347 467 q 447 421 395 421 l 510 421 l 550 612 l 464 612 z \"},\"ё\":{\"ha\":774,\"x_min\":61,\"x_max\":739,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 241 937 q 270 1017 241 990 q 351 1044 298 1044 q 441 971 441 1044 q 414 892 441 922 q 332 863 388 863 q 241 937 241 863 m 513 937 q 542 1017 513 990 q 623 1044 570 1044 q 690 1025 667 1044 q 713 971 713 1006 q 687 892 713 922 q 605 863 660 863 q 513 937 513 863 z \"},\"ђ\":{\"ha\":839,\"x_min\":25,\"x_max\":760,\"o\":\"m 431 946 l 633 946 l 604 811 l 403 811 q 347 615 377 684 l 353 615 q 445 699 395 668 q 564 730 496 730 q 709 673 659 730 q 760 513 760 616 q 745 390 760 459 l 646 -79 q 550 -272 618 -210 q 371 -334 481 -334 q 253 -317 300 -334 l 253 -153 q 330 -167 294 -167 q 403 -139 372 -167 q 447 -52 435 -112 l 543 401 q 554 482 554 448 q 482 566 554 566 q 369 489 420 566 q 289 272 319 412 l 229 0 l 25 0 l 196 811 l 87 811 l 117 946 l 225 946 l 249 1055 l 453 1055 l 431 946 z \"},\"ѓ\":{\"ha\":665,\"x_min\":14,\"x_max\":707,\"o\":\"m 113 713 q 378 772 237 772 q 565 719 499 772 q 631 567 631 666 q 608 461 631 503 q 548 391 586 419 q 460 342 510 362 q 354 302 410 322 q 264 267 286 279 q 232 240 242 254 q 221 205 221 226 q 318 138 221 138 q 539 199 410 138 l 539 45 q 414 0 475 13 q 275 -14 353 -14 q 82 43 151 -14 q 14 201 14 100 q 37 307 14 264 q 99 377 61 349 q 184 423 136 405 q 278 457 231 441 q 387 498 367 487 q 416 525 406 510 q 425 561 425 540 q 343 619 425 619 q 163 568 266 619 l 113 713 m 329 859 q 479 1064 382 918 l 707 1064 l 707 1053 q 602 949 675 1015 q 471 842 529 884 l 329 842 l 329 859 z \"},\"є\":{\"ha\":671,\"x_min\":61,\"x_max\":685,\"o\":\"m 343 -14 q 134 60 208 -14 q 61 267 61 133 q 112 533 61 416 q 254 711 163 650 q 463 772 344 772 q 685 724 586 772 l 623 568 q 551 595 586 584 q 471 607 515 607 q 362 568 409 607 q 292 452 315 529 l 541 452 l 511 314 l 268 314 l 267 298 l 267 282 q 385 151 267 151 q 480 167 436 151 q 571 207 524 183 l 571 40 q 343 -14 468 -14 z \"},\"ѕ\":{\"ha\":657,\"x_min\":16,\"x_max\":629,\"o\":\"m 562 250 q 478 55 562 123 q 243 -14 393 -14 q 116 -3 170 -14 q 16 31 62 7 l 16 199 q 232 138 122 138 q 321 160 286 138 q 355 220 355 182 q 330 272 355 249 q 241 330 305 295 q 127 422 159 376 q 94 530 94 468 q 169 709 94 646 q 383 772 244 772 q 629 708 519 772 l 562 562 q 387 619 467 619 q 325 602 349 619 q 301 555 301 585 q 323 509 301 529 q 404 458 345 489 q 525 366 488 416 q 562 250 562 315 z \"},\"і\":{\"ha\":412,\"x_min\":25,\"x_max\":443,\"o\":\"m 218 936 q 251 1025 218 995 q 342 1055 283 1055 q 417 1034 391 1055 q 443 974 443 1013 q 413 886 443 920 q 321 852 383 852 q 218 936 218 852 m 229 0 l 25 0 l 186 758 l 390 758 l 229 0 z \"},\"ї\":{\"ha\":412,\"x_min\":25,\"x_max\":558,\"o\":\"m 229 0 l 25 0 l 186 758 l 390 758 l 229 0 m 85 937 q 114 1017 85 990 q 195 1044 143 1044 q 286 971 286 1044 q 259 892 286 922 q 177 863 233 863 q 85 937 85 863 m 358 937 q 387 1017 358 990 q 468 1044 415 1044 q 535 1025 512 1044 q 558 971 558 1006 q 531 892 558 922 q 450 863 505 863 q 358 937 358 863 z \"},\"ј\":{\"ha\":412,\"x_min\":-179,\"x_max\":444,\"o\":\"m -61 -334 q -179 -317 -132 -334 l -179 -153 q -102 -167 -138 -167 q 16 -52 -9 -167 l 187 758 l 392 758 l 212 -82 q -61 -334 160 -334 m 220 936 q 252 1025 220 995 q 343 1055 284 1055 q 418 1034 393 1055 q 444 974 444 1013 q 414 886 444 920 q 322 852 385 852 q 220 936 220 852 z \"},\"љ\":{\"ha\":1198,\"x_min\":-40,\"x_max\":1125,\"o\":\"m 737 450 q 885 465 810 465 q 1061 409 997 465 q 1125 260 1125 353 q 1083 116 1125 178 q 960 21 1041 55 q 762 -14 879 -14 q 561 43 630 -14 q 492 208 492 99 q 509 330 492 258 l 570 603 l 539 606 q 464 584 494 606 q 409 516 433 562 q 339 323 385 471 q 255 107 290 166 q 173 17 220 48 q 57 -14 125 -14 q 2 -9 22 -14 q -40 3 -18 -5 l -40 171 q 17 160 -15 160 q 78 195 52 160 q 127 306 104 230 l 157 397 q 260 639 212 568 q 377 741 308 710 q 553 772 446 772 q 799 733 692 772 l 737 450 m 818 322 q 710 310 771 322 q 695 236 696 248 q 694 215 694 224 q 720 151 694 174 q 791 129 746 129 q 885 159 850 129 q 920 239 920 189 q 818 322 920 322 z \"},\"њ\":{\"ha\":1198,\"x_min\":33,\"x_max\":1125,\"o\":\"m 737 450 q 885 465 816 465 q 1061 409 997 465 q 1125 260 1125 353 q 1083 116 1125 178 q 960 21 1041 55 q 762 -14 879 -14 q 561 43 630 -14 q 492 208 492 99 q 505 313 492 250 l 306 313 l 239 0 l 33 0 l 196 758 l 401 758 l 339 467 l 539 467 l 600 758 l 804 758 l 737 450 m 818 322 q 710 310 771 322 q 695 236 696 248 q 694 215 694 224 q 720 151 694 174 q 791 129 746 129 q 885 159 850 129 q 920 239 920 189 q 818 322 920 322 z \"},\"ћ\":{\"ha\":839,\"x_min\":25,\"x_max\":760,\"o\":\"m 663 0 l 458 0 l 543 401 q 554 482 554 448 q 482 566 554 566 q 368 487 419 566 q 288 272 317 409 l 229 0 l 25 0 l 197 811 l 87 811 l 117 946 l 225 946 l 249 1055 l 453 1055 l 431 946 l 633 946 l 604 811 l 401 811 q 347 615 376 700 l 353 615 q 445 699 395 668 q 564 730 496 730 q 709 673 659 730 q 760 513 760 616 q 745 390 760 459 l 663 0 z \"},\"ќ\":{\"ha\":803,\"x_min\":25,\"x_max\":848,\"o\":\"m 615 758 l 848 758 l 524 378 l 711 0 l 482 0 l 309 370 l 229 0 l 25 0 l 187 758 l 392 758 l 317 406 l 615 758 m 423 859 q 574 1064 477 918 l 801 1064 l 801 1053 q 696 949 770 1015 q 565 842 623 884 l 423 842 l 423 859 z \"},\"ў\":{\"ha\":721,\"x_min\":-96,\"x_max\":793,\"o\":\"m 69 758 l 269 758 l 307 407 q 317 208 317 324 l 321 208 q 351 289 334 243 q 395 393 367 336 l 571 758 l 793 758 l 332 -109 q 4 -334 212 -334 q -96 -321 -57 -334 l -96 -158 q -17 -167 -50 -167 q 83 -134 40 -167 q 163 -33 126 -102 l 180 0 l 69 758 m 784 1084 q 718 944 761 994 q 602 867 674 893 q 427 842 530 842 q 219 893 292 842 q 146 1053 146 945 q 150 1084 146 1069 l 330 1084 l 329 1067 l 329 1053 q 444 958 329 958 q 548 988 511 958 q 600 1084 584 1018 l 784 1084 z \"},\"џ\":{\"ha\":839,\"x_min\":72,\"x_max\":815,\"o\":\"m 404 -28 l 437 -28 l 372 -334 l 182 -334 l 233 -100 l 404 -28 m 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 123 42 175 -14 q 72 204 72 98 q 92 349 72 250 l 178 758 l 382 758 z \"},\"Ґ\":{\"ha\":699,\"x_min\":36,\"x_max\":840,\"o\":\"m 611 991 l 656 1202 l 840 1202 l 761 819 l 414 819 l 240 0 l 36 0 l 245 991 l 611 991 z \"},\"ґ\":{\"ha\":643,\"x_min\":25,\"x_max\":730,\"o\":\"m 652 590 l 354 590 l 229 0 l 25 0 l 186 758 l 498 758 l 542 965 l 730 965 l 652 590 z \"},\"Ẁ\":{\"ha\":1242,\"x_min\":125,\"x_max\":1372,\"o\":\"m 682 690 q 604 488 651 591 l 385 0 l 155 0 l 125 991 l 319 991 l 323 450 q 321 333 323 415 q 314 215 318 251 l 318 215 q 363 337 333 258 q 404 436 394 416 l 654 991 l 838 991 l 852 399 q 846 215 852 300 l 850 215 q 939 452 879 302 l 1162 991 l 1372 991 l 933 0 l 699 0 l 684 489 l 682 583 q 685 690 682 643 l 682 690 m 832 1071 l 707 1071 q 613 1175 659 1118 q 543 1279 568 1232 l 543 1293 l 754 1293 q 832 1088 779 1193 l 832 1071 z \"},\"ẁ\":{\"ha\":1095,\"x_min\":85,\"x_max\":1165,\"o\":\"m 581 583 q 497 367 538 463 l 339 0 l 119 0 l 85 758 l 275 758 l 278 422 l 275 309 l 271 193 l 273 193 q 283 221 277 207 q 317 314 288 236 q 349 395 347 392 l 505 758 l 728 758 l 728 395 q 721 193 728 298 l 725 193 l 744 248 q 808 422 793 389 l 957 758 l 1165 758 l 806 0 l 582 0 l 578 353 q 585 583 578 458 l 581 583 m 711 842 l 587 842 q 493 946 538 888 q 422 1050 447 1003 l 422 1064 l 633 1064 q 711 859 658 964 l 711 842 z \"},\"Ẃ\":{\"ha\":1242,\"x_min\":125,\"x_max\":1372,\"o\":\"m 682 690 q 604 488 651 591 l 385 0 l 155 0 l 125 991 l 319 991 l 323 450 q 321 333 323 415 q 314 215 318 251 l 318 215 q 363 337 333 258 q 404 436 394 416 l 654 991 l 838 991 l 852 399 q 846 215 852 300 l 850 215 q 939 452 879 302 l 1162 991 l 1372 991 l 933 0 l 699 0 l 684 489 l 682 583 q 685 690 682 643 l 682 690 m 647 1088 q 798 1293 701 1147 l 1025 1293 l 1025 1282 q 920 1178 994 1244 q 789 1071 847 1113 l 647 1071 l 647 1088 z \"},\"ẃ\":{\"ha\":1095,\"x_min\":85,\"x_max\":1165,\"o\":\"m 581 583 q 497 367 538 463 l 339 0 l 119 0 l 85 758 l 275 758 l 278 422 l 275 309 l 271 193 l 273 193 q 283 221 277 207 q 317 314 288 236 q 349 395 347 392 l 505 758 l 728 758 l 728 395 q 721 193 728 298 l 725 193 l 744 248 q 808 422 793 389 l 957 758 l 1165 758 l 806 0 l 582 0 l 578 353 q 585 583 578 458 l 581 583 m 541 859 q 692 1064 595 918 l 919 1064 l 919 1053 q 814 949 888 1015 q 683 842 741 884 l 541 842 l 541 859 z \"},\"Ẅ\":{\"ha\":1242,\"x_min\":125,\"x_max\":1372,\"o\":\"m 682 690 q 604 488 651 591 l 385 0 l 155 0 l 125 991 l 319 991 l 323 450 q 321 333 323 415 q 314 215 318 251 l 318 215 q 363 337 333 258 q 404 436 394 416 l 654 991 l 838 991 l 852 399 q 846 215 852 300 l 850 215 q 939 452 879 302 l 1162 991 l 1372 991 l 933 0 l 699 0 l 684 489 l 682 583 q 685 690 682 643 l 682 690 m 528 1166 q 556 1246 528 1219 q 637 1274 585 1274 q 728 1200 728 1274 q 701 1121 728 1151 q 619 1092 675 1092 q 528 1166 528 1092 m 800 1166 q 829 1246 800 1219 q 910 1274 857 1274 q 977 1255 954 1274 q 1000 1200 1000 1236 q 974 1121 1000 1151 q 892 1092 947 1092 q 800 1166 800 1092 z \"},\"ẅ\":{\"ha\":1095,\"x_min\":85,\"x_max\":1165,\"o\":\"m 581 583 q 497 367 538 463 l 339 0 l 119 0 l 85 758 l 275 758 l 278 422 l 275 309 l 271 193 l 273 193 q 283 221 277 207 q 317 314 288 236 q 349 395 347 392 l 505 758 l 728 758 l 728 395 q 721 193 728 298 l 725 193 l 744 248 q 808 422 793 389 l 957 758 l 1165 758 l 806 0 l 582 0 l 578 353 q 585 583 578 458 l 581 583 m 397 937 q 426 1017 397 990 q 507 1044 454 1044 q 597 971 597 1044 q 570 892 597 922 q 488 863 544 863 q 397 937 397 863 m 669 937 q 698 1017 669 990 q 779 1044 726 1044 q 846 1025 823 1044 q 869 971 869 1006 q 843 892 869 922 q 761 863 816 863 q 669 937 669 863 z \"},\"Ỳ\":{\"ha\":783,\"x_min\":126,\"x_max\":911,\"o\":\"m 425 590 l 679 991 l 911 991 l 492 379 l 411 0 l 205 0 l 286 379 l 126 991 l 338 991 l 425 590 m 587 1071 l 462 1071 q 368 1175 414 1118 q 298 1279 322 1232 l 298 1293 l 509 1293 q 587 1088 533 1193 l 587 1071 z \"},\"ỳ\":{\"ha\":721,\"x_min\":-96,\"x_max\":793,\"o\":\"m 69 758 l 269 758 l 307 407 q 317 208 317 324 l 321 208 q 351 289 334 243 q 395 393 367 336 l 571 758 l 793 758 l 332 -109 q 4 -334 212 -334 q -96 -321 -57 -334 l -96 -158 q -17 -167 -50 -167 q 83 -134 40 -167 q 163 -33 126 -102 l 180 0 l 69 758 m 512 842 l 387 842 q 293 946 339 888 q 223 1050 248 1003 l 223 1064 l 434 1064 q 512 859 458 964 l 512 842 z \"},\"–\":{\"ha\":667,\"x_min\":28,\"x_max\":639,\"o\":\"m 28 296 l 61 452 l 639 452 l 606 296 l 28 296 z \"},\"—\":{\"ha\":1333,\"x_min\":28,\"x_max\":1305,\"o\":\"m 28 296 l 61 452 l 1305 452 l 1272 296 l 28 296 z \"},\"―\":{\"ha\":1333,\"x_min\":28,\"x_max\":1305,\"o\":\"m 28 296 l 61 452 l 1305 452 l 1272 296 l 28 296 z \"},\"‗\":{\"ha\":555,\"x_min\":-144,\"x_max\":471,\"o\":\"m 450 -125 l -106 -125 l -86 -31 l 471 -31 l 450 -125 m 413 -313 l -144 -313 l -123 -218 l 434 -218 l 413 -313 z \"},\"‘\":{\"ha\":298,\"x_min\":78,\"x_max\":408,\"o\":\"m 83 652 l 78 667 q 256 991 148 821 l 408 991 q 277 652 347 847 l 83 652 z \"},\"’\":{\"ha\":298,\"x_min\":72,\"x_max\":403,\"o\":\"m 397 991 l 403 977 q 225 652 333 823 l 72 652 q 204 991 132 791 l 397 991 z \"},\"‚\":{\"ha\":386,\"x_min\":-69,\"x_max\":261,\"o\":\"m 256 161 l 261 146 q 83 -179 191 -8 l -69 -179 q 62 161 -9 -39 l 256 161 z \"},\"‛\":{\"ha\":298,\"x_min\":151,\"x_max\":346,\"o\":\"m 342 991 q 339 850 339 921 q 346 652 339 748 l 204 652 q 151 977 159 834 l 160 991 l 342 991 z \"},\"“\":{\"ha\":602,\"x_min\":78,\"x_max\":711,\"o\":\"m 386 652 l 380 667 q 558 991 450 821 l 711 991 q 579 652 646 838 l 386 652 m 83 652 l 78 667 q 256 991 148 821 l 408 991 q 277 652 347 847 l 83 652 z \"},\"”\":{\"ha\":602,\"x_min\":72,\"x_max\":705,\"o\":\"m 397 991 l 403 977 q 225 652 333 823 l 72 652 q 204 991 132 791 l 397 991 m 700 991 l 705 977 q 528 652 635 823 l 375 652 q 407 727 391 688 q 507 991 422 766 l 700 991 z \"},\"„\":{\"ha\":690,\"x_min\":-69,\"x_max\":566,\"o\":\"m 256 161 l 261 146 q 83 -179 191 -8 l -69 -179 q 62 161 -9 -39 l 256 161 m 559 161 l 566 146 q 387 -179 498 -4 l 235 -179 q 268 -99 251 -140 q 367 161 285 -57 l 559 161 z \"},\"†\":{\"ha\":703,\"x_min\":129,\"x_max\":703,\"o\":\"m 668 629 l 457 650 l 354 0 l 163 0 l 336 648 l 129 629 l 164 793 l 364 774 l 387 1055 l 579 1055 l 484 774 l 703 793 l 668 629 z \"},\"‡\":{\"ha\":717,\"x_min\":40,\"x_max\":717,\"o\":\"m 407 379 l 627 399 l 591 235 l 380 254 l 363 0 l 170 0 l 260 254 l 40 235 l 75 399 l 286 379 l 289 533 l 350 676 l 131 657 l 165 821 l 376 802 l 395 1055 l 587 1055 l 497 802 l 717 821 l 682 657 l 471 676 l 471 533 l 407 379 z \"},\"•\":{\"ha\":501,\"x_min\":71,\"x_max\":471,\"o\":\"m 71 465 q 99 597 71 537 q 181 689 128 656 q 304 722 233 722 q 428 677 386 722 q 471 547 471 631 q 409 359 471 427 q 240 292 347 292 q 116 337 161 292 q 71 465 71 382 z \"},\"…\":{\"ha\":1157,\"x_min\":17,\"x_max\":1018,\"o\":\"m 17 78 q 53 176 17 139 q 155 212 90 212 q 229 186 201 212 q 257 114 257 161 q 220 18 257 55 q 122 -18 182 -18 q 45 7 73 -18 q 17 78 17 33 m 397 78 q 434 176 397 139 q 536 212 470 212 q 610 186 582 212 q 637 114 637 161 q 600 18 637 55 q 503 -18 563 -18 q 425 7 453 -18 q 397 78 397 33 m 778 78 q 814 176 778 139 q 916 212 850 212 q 990 186 962 212 q 1018 114 1018 161 q 981 18 1018 55 q 883 -18 943 -18 q 806 7 833 -18 q 778 78 778 33 z \"},\"‰\":{\"ha\":1691,\"x_min\":78,\"x_max\":1642,\"o\":\"m 351 864 q 276 777 309 864 q 244 589 244 690 q 282 524 244 524 q 358 612 326 524 q 390 799 390 701 q 351 864 390 864 m 557 790 q 519 580 557 677 q 416 433 481 482 q 269 383 352 383 q 126 440 175 383 q 78 600 78 496 q 116 811 78 715 q 216 957 153 908 q 363 1006 279 1006 q 506 951 456 1006 q 557 790 557 897 m 1054 991 l 319 0 l 157 0 l 895 991 l 1054 991 m 1436 468 q 1385 430 1410 468 q 1345 324 1360 392 q 1329 193 1329 256 q 1367 127 1329 127 q 1443 216 1411 127 q 1475 403 1475 305 q 1436 468 1475 468 m 1642 400 q 1604 187 1642 287 q 1503 38 1567 87 q 1358 -12 1440 -12 q 1212 41 1261 -12 q 1162 192 1162 94 q 1198 411 1162 313 q 1299 559 1234 509 q 1447 610 1363 610 q 1591 556 1540 610 q 1642 400 1642 503 m 933 468 q 882 430 907 468 q 842 326 858 392 q 827 193 827 259 q 864 127 827 127 q 916 165 892 127 q 957 270 941 202 q 972 403 972 337 q 933 468 972 468 m 1139 400 q 1102 188 1139 287 q 1002 38 1065 88 q 856 -12 938 -12 q 709 41 758 -12 q 660 192 660 94 q 696 411 660 312 q 796 559 732 509 q 945 610 861 610 q 1088 556 1038 610 q 1139 400 1139 503 z \"},\"′\":{\"ha\":354,\"x_min\":136,\"x_max\":372,\"o\":\"m 372 991 l 269 633 l 136 633 l 184 991 l 372 991 z \"},\"″\":{\"ha\":629,\"x_min\":136,\"x_max\":647,\"o\":\"m 372 991 l 269 633 l 136 633 l 184 991 l 372 991 m 647 991 l 545 633 l 410 633 l 460 991 l 647 991 z \"},\"‹\":{\"ha\":450,\"x_min\":49,\"x_max\":450,\"o\":\"m 49 386 l 321 700 l 450 595 l 261 368 l 353 131 l 186 61 l 49 374 l 49 386 z \"},\"›\":{\"ha\":450,\"x_min\":0,\"x_max\":401,\"o\":\"m 401 363 l 129 49 l 0 154 l 189 380 l 97 618 l 264 688 l 401 375 l 401 363 z \"},\"‼\":{\"ha\":779,\"x_min\":17,\"x_max\":821,\"o\":\"m 265 329 l 102 329 l 208 991 l 439 991 l 265 329 m 17 78 q 53 176 17 139 q 155 212 90 212 q 229 186 201 212 q 257 114 257 161 q 220 18 257 55 q 122 -18 182 -18 q 45 7 73 -18 q 17 78 17 33 m 647 329 l 484 329 l 590 991 l 821 991 l 647 329 m 399 78 q 435 176 399 139 q 537 212 471 212 q 611 186 583 212 q 639 114 639 161 q 602 18 639 55 q 504 -18 564 -18 q 427 7 454 -18 q 399 78 399 33 z \"},\"⁄\":{\"ha\":174,\"x_min\":-361,\"x_max\":536,\"o\":\"m 536 991 l -199 0 l -361 0 l 376 991 l 536 991 z \"},\"ⁿ\":{\"ha\":538,\"x_min\":90,\"x_max\":581,\"o\":\"m 374 518 l 431 790 q 436 835 436 812 q 392 885 436 885 q 320 838 351 885 q 271 707 289 791 l 229 518 l 90 518 l 191 991 l 306 991 l 294 909 q 447 1003 362 1003 q 547 965 513 1003 q 581 864 581 928 q 575 810 581 833 l 515 518 l 374 518 z \"},\"₣\":{\"ha\":765,\"x_min\":0,\"x_max\":821,\"o\":\"m 325 298 l 504 298 l 479 178 l 300 178 l 264 0 l 60 0 l 97 178 l 0 178 l 25 298 l 122 298 l 269 991 l 821 991 l 785 819 l 437 819 l 389 591 l 713 591 l 675 419 l 351 419 l 325 298 z \"},\"₤\":{\"ha\":765,\"x_min\":-8,\"x_max\":842,\"o\":\"m 252 644 l 269 733 q 379 937 297 867 q 591 1007 462 1007 q 842 949 724 1007 l 765 791 q 604 838 669 838 q 522 811 555 838 q 475 721 488 785 l 458 644 l 661 644 l 635 525 l 433 525 l 416 447 l 618 447 l 593 326 l 390 326 q 257 176 361 223 l 703 176 l 665 0 l -8 0 l 25 167 q 131 227 94 189 q 184 326 168 264 l 54 326 l 79 447 l 210 447 l 227 525 l 96 525 l 122 644 l 252 644 z \"},\"₧\":{\"ha\":1189,\"x_min\":39,\"x_max\":1173,\"o\":\"m 345 525 l 379 525 q 528 575 475 525 q 582 714 582 625 q 549 792 582 765 q 453 819 517 819 l 407 819 l 345 525 m 783 718 q 672 449 783 546 q 364 353 560 353 l 309 353 l 233 0 l 39 0 l 250 991 l 465 991 q 700 920 617 991 q 783 718 783 848 m 986 138 q 1034 145 1012 138 q 1084 165 1055 153 l 1084 22 q 930 -14 1014 -14 q 793 30 842 -14 q 743 151 743 73 q 755 241 743 183 l 798 432 l 722 432 l 737 504 l 843 582 l 926 734 l 1043 734 l 1008 574 l 1173 574 l 1141 432 l 978 432 l 933 224 q 929 189 929 206 q 945 151 929 165 q 986 138 960 138 z \"},\"€\":{\"ha\":765,\"x_min\":28,\"x_max\":844,\"o\":\"m 610 839 q 490 788 544 839 q 399 644 437 738 l 635 644 l 608 525 l 364 525 q 347 447 357 502 l 550 447 l 525 326 l 335 326 q 365 203 335 245 q 465 161 395 161 q 657 204 555 161 l 657 29 q 433 -14 572 -14 q 131 326 131 -14 l 28 326 l 53 447 l 139 447 q 154 525 145 492 l 69 525 l 96 644 l 187 644 q 357 911 246 815 q 611 1007 468 1007 q 732 991 679 1007 q 844 937 786 976 l 760 786 q 671 829 701 819 q 610 839 641 839 z \"},\"℅\":{\"ha\":1063,\"x_min\":83,\"x_max\":996,\"o\":\"m 289 510 q 153 560 202 510 q 104 694 104 610 q 173 916 104 829 q 355 1003 241 1003 q 496 975 429 1003 l 458 868 q 361 892 401 892 q 301 865 327 892 q 260 793 275 838 q 245 705 245 749 q 264 643 245 665 q 317 621 282 621 q 360 626 339 621 q 424 653 380 631 l 424 543 q 289 510 359 510 m 981 991 l 245 0 l 83 0 l 821 991 l 981 991 m 996 286 q 927 68 996 151 q 741 -14 859 -14 q 606 36 656 -14 q 557 174 557 86 q 626 395 557 311 q 812 479 695 479 q 947 428 899 479 q 996 286 996 377 m 802 368 q 749 341 772 368 q 712 266 726 313 q 699 172 699 218 q 713 116 699 136 q 753 97 727 97 q 824 155 795 97 q 852 296 852 213 q 802 368 852 368 z \"},\"ℓ\":{\"ha\":694,\"x_min\":28,\"x_max\":644,\"o\":\"m 422 129 q 479 162 457 129 q 504 265 500 196 l 644 265 q 578 52 637 116 q 400 -12 519 -12 q 217 58 283 -12 q 151 261 151 128 l 151 347 q 28 314 74 325 l 28 447 q 151 484 94 465 l 151 762 q 211 945 151 885 q 399 1004 270 1004 q 564 946 503 1004 q 624 785 624 887 q 597 644 624 705 q 517 534 571 583 q 350 428 463 486 l 350 254 q 422 129 350 129 m 446 781 q 399 875 446 875 q 360 849 370 875 q 350 781 350 823 l 350 574 q 446 781 446 627 z \"},\"№\":{\"ha\":1360,\"x_min\":17,\"x_max\":1318,\"o\":\"m 715 0 l 511 0 l 339 704 l 336 704 q 317 577 332 671 q 289 427 301 482 l 199 0 l 17 0 l 227 991 l 431 991 l 604 283 l 606 283 q 652 559 621 417 l 743 991 l 925 991 l 715 0 m 817 0 l 843 127 l 1243 127 l 1217 0 l 817 0 m 1318 485 q 1287 333 1318 403 q 1198 225 1255 264 q 1063 186 1141 186 q 927 235 976 186 q 879 370 879 283 q 912 532 879 458 q 1003 642 946 605 q 1136 679 1061 679 q 1269 627 1219 679 q 1318 485 1318 575 m 1178 497 q 1166 548 1178 528 q 1128 568 1154 568 q 1075 542 1099 568 q 1036 464 1051 515 q 1021 364 1021 413 q 1071 297 1021 297 q 1123 322 1099 297 q 1162 400 1147 348 q 1178 497 1178 452 z \"},\"™\":{\"ha\":1040,\"x_min\":72,\"x_max\":1039,\"o\":\"m 319 503 l 205 503 l 205 890 l 72 890 l 72 991 l 454 991 l 454 890 l 319 890 l 319 503 m 710 503 l 597 861 l 593 861 l 596 786 l 596 503 l 485 503 l 485 991 l 653 991 l 761 646 l 876 991 l 1039 991 l 1039 503 l 925 503 l 925 779 l 928 861 l 924 861 l 806 503 l 710 503 z \"},\"Ω\":{\"ha\":1006,\"x_min\":-41,\"x_max\":964,\"o\":\"m 578 832 q 443 789 503 832 q 345 662 382 747 q 307 482 307 578 q 333 308 307 378 q 412 187 359 238 l 372 0 l -41 0 l -5 176 l 248 176 q 139 302 179 219 q 98 488 98 385 q 161 760 98 639 q 336 944 224 881 q 593 1007 447 1007 q 865 913 766 1007 q 964 654 964 820 q 890 365 964 488 q 681 176 817 243 l 928 176 l 890 0 l 450 0 l 490 187 q 753 629 753 341 q 707 780 753 728 q 578 832 662 832 z \"},\"℮\":{\"ha\":860,\"x_min\":74,\"x_max\":793,\"o\":\"m 433 -24 q 245 26 327 -24 q 118 164 163 76 q 74 359 74 253 q 117 555 74 469 q 245 692 160 642 q 433 743 330 743 q 619 695 536 743 q 747 559 701 647 q 793 359 793 471 l 232 359 l 232 118 q 321 58 265 82 q 433 35 378 35 q 584 70 523 35 q 701 193 646 105 l 750 165 q 610 18 684 60 q 433 -24 536 -24 m 636 418 l 636 606 q 547 664 602 642 q 432 686 492 686 q 232 607 315 686 l 232 418 l 636 418 z \"},\"⅛\":{\"ha\":1223,\"x_min\":66,\"x_max\":1136,\"o\":\"m 939 606 q 1084 568 1033 606 q 1136 465 1136 530 q 1102 369 1136 405 q 1008 312 1068 334 q 1079 254 1052 288 q 1105 172 1105 221 q 1038 33 1105 83 q 855 -16 971 -16 q 702 27 759 -16 q 644 142 644 71 q 685 247 644 206 q 800 313 726 288 q 746 367 765 337 q 726 438 726 396 q 786 559 726 513 q 939 606 846 606 m 887 246 q 801 153 801 216 q 819 108 801 125 q 867 91 837 91 q 922 112 902 91 q 943 163 943 134 q 928 212 943 193 q 887 246 913 231 m 937 499 q 897 482 913 499 q 880 438 880 465 q 924 372 880 400 q 987 450 987 399 q 973 486 987 473 q 937 499 959 499 m 336 991 l 477 991 l 351 397 l 184 397 l 241 667 q 278 807 257 741 q 224 766 267 797 l 135 711 l 66 823 l 336 991 m 1017 991 l 282 0 l 120 0 l 857 991 l 1017 991 z \"},\"⅜\":{\"ha\":1223,\"x_min\":62,\"x_max\":1190,\"o\":\"m 551 861 q 517 763 551 802 q 404 703 482 723 l 404 700 q 509 581 509 677 q 436 439 509 492 q 243 386 363 386 q 144 396 192 386 q 62 424 96 407 l 62 554 q 235 505 147 505 q 319 526 286 505 q 353 586 353 547 q 335 628 353 611 q 275 646 317 646 l 189 646 l 212 754 l 273 754 q 363 773 330 754 q 396 831 396 792 q 378 871 396 858 q 330 885 361 885 q 203 840 272 885 l 147 942 q 359 1004 243 1004 q 499 967 448 1004 q 551 861 551 929 m 1085 991 l 350 0 l 188 0 l 925 991 l 1085 991 m 993 606 q 1139 568 1087 606 q 1190 465 1190 530 q 1156 369 1190 405 q 1062 312 1122 334 q 1133 254 1106 288 q 1160 172 1160 221 q 1093 33 1160 83 q 909 -16 1025 -16 q 756 27 813 -16 q 699 142 699 71 q 739 247 699 206 q 854 313 780 288 q 800 367 819 337 q 781 438 781 396 q 840 559 781 513 q 993 606 900 606 m 941 246 q 855 153 855 216 q 873 108 855 125 q 921 91 891 91 q 977 112 956 91 q 997 163 997 134 q 982 212 997 193 q 941 246 968 231 m 991 499 q 951 482 968 499 q 935 438 935 465 q 978 372 935 400 q 1042 450 1042 399 q 1027 486 1042 473 q 991 499 1013 499 z \"},\"⅝\":{\"ha\":1223,\"x_min\":69,\"x_max\":1179,\"o\":\"m 337 781 q 462 735 414 781 q 511 618 511 690 q 437 449 511 513 q 241 386 363 386 q 69 422 132 386 l 69 546 q 146 513 104 525 q 227 501 188 501 q 320 528 287 501 q 354 602 354 554 q 265 676 354 676 q 175 663 222 676 l 123 708 l 204 991 l 562 991 l 534 867 l 294 867 l 265 772 q 337 781 290 781 m 1074 991 l 339 0 l 177 0 l 914 991 l 1074 991 m 982 606 q 1128 568 1076 606 q 1179 465 1179 530 q 1145 369 1179 405 q 1051 312 1112 334 q 1122 254 1095 288 q 1149 172 1149 221 q 1082 33 1149 83 q 899 -16 1015 -16 q 745 27 802 -16 q 688 142 688 71 q 728 247 688 206 q 843 313 769 288 q 789 367 808 337 q 770 438 770 396 q 829 559 770 513 q 982 606 889 606 m 930 246 q 844 153 844 216 q 862 108 844 125 q 910 91 880 91 q 966 112 945 91 q 986 163 986 134 q 971 212 986 193 q 930 246 957 231 m 981 499 q 940 482 957 499 q 924 438 924 465 q 967 372 924 400 q 1031 450 1031 399 q 1017 486 1031 473 q 981 499 1002 499 z \"},\"⅞\":{\"ha\":1223,\"x_min\":100,\"x_max\":1137,\"o\":\"m 100 397 l 414 867 l 139 867 l 165 991 l 612 991 l 591 890 l 275 397 l 100 397 m 1019 991 l 283 0 l 121 0 l 859 991 l 1019 991 m 940 606 q 1086 568 1034 606 q 1137 465 1137 530 q 1103 369 1137 405 q 1009 312 1069 334 q 1080 254 1053 288 q 1107 172 1107 221 q 1040 33 1107 83 q 857 -16 972 -16 q 703 27 760 -16 q 646 142 646 71 q 686 247 646 206 q 801 313 727 288 q 747 367 766 337 q 728 438 728 396 q 787 559 728 513 q 940 606 847 606 m 888 246 q 802 153 802 216 q 820 108 802 125 q 868 91 838 91 q 924 112 903 91 q 944 163 944 134 q 929 212 944 193 q 888 246 915 231 m 939 499 q 898 482 915 499 q 882 438 882 465 q 925 372 882 400 q 989 450 989 399 q 975 486 989 473 q 939 499 960 499 z \"},\"∂\":{\"ha\":807,\"x_min\":52,\"x_max\":772,\"o\":\"m 772 624 q 715 294 772 446 q 558 65 657 143 q 329 -14 458 -14 q 123 58 194 -14 q 52 271 52 130 q 100 491 52 386 q 228 650 149 597 q 410 704 308 704 q 559 659 503 704 q 514 795 552 754 q 407 836 477 836 q 222 775 314 836 l 222 950 q 450 1006 326 1006 q 689 909 605 1006 q 772 624 772 812 m 340 151 q 467 241 411 151 q 549 486 522 330 q 508 532 535 513 q 444 550 480 550 q 358 513 397 550 q 294 404 319 477 q 269 254 269 330 q 340 151 269 151 z \"},\"∆\":{\"ha\":840,\"x_min\":-36,\"x_max\":761,\"o\":\"m 427 996 l 665 996 l 761 118 l 734 0 l -36 0 l -12 122 l 427 996 m 510 796 q 471 700 499 759 l 216 175 l 567 175 l 515 689 q 510 796 510 754 z \"},\"∏\":{\"ha\":1029,\"x_min\":131,\"x_max\":935,\"o\":\"m 720 -310 l 720 817 l 346 817 l 346 -310 l 131 -310 l 131 991 l 935 991 l 935 -310 l 720 -310 z \"},\"∑\":{\"ha\":876,\"x_min\":83,\"x_max\":925,\"o\":\"m 83 -310 l 83 -195 l 473 371 l 94 879 l 94 991 l 885 991 l 885 821 l 372 821 l 707 375 l 355 -138 l 925 -138 l 925 -310 l 83 -310 z \"},\"−\":{\"ha\":765,\"x_min\":74,\"x_max\":720,\"o\":\"m 74 415 l 74 564 l 720 564 l 720 415 l 74 415 z \"},\"√\":{\"ha\":762,\"x_min\":66,\"x_max\":907,\"o\":\"m 492 -9 l 368 -9 l 186 490 l 66 490 l 66 635 l 288 635 l 427 250 l 758 1192 l 907 1192 l 492 -9 z \"},\"∞\":{\"ha\":982,\"x_min\":90,\"x_max\":920,\"o\":\"m 920 486 q 858 323 920 390 q 704 257 796 257 q 501 376 585 257 q 410 292 460 322 q 309 261 361 261 q 151 323 212 261 q 90 490 90 386 q 152 653 90 588 q 309 718 213 718 q 505 600 429 718 q 704 715 590 715 q 859 653 799 715 q 920 486 920 591 m 315 399 q 428 490 375 399 q 314 582 377 582 q 252 555 275 582 q 229 489 229 529 q 253 424 229 448 q 315 399 276 399 m 694 578 q 581 488 635 578 q 696 395 635 395 q 758 422 735 395 q 781 488 781 450 q 756 553 781 528 q 694 578 732 578 z \"},\"∫\":{\"ha\":572,\"x_min\":0,\"x_max\":572,\"o\":\"m 465 882 q 410 857 431 882 q 390 789 390 833 l 390 -77 q 323 -269 390 -203 q 132 -334 257 -334 q 0 -306 58 -334 l 0 -134 q 107 -160 62 -160 q 182 -64 182 -160 l 182 799 q 248 990 182 924 q 440 1055 313 1055 q 572 1028 514 1055 l 572 856 q 465 882 512 882 z \"},\"≈\":{\"ha\":765,\"x_min\":74,\"x_max\":720,\"o\":\"m 232 589 q 156 568 197 589 q 74 507 115 547 l 74 664 q 248 737 142 737 q 321 729 288 737 q 421 694 355 722 q 496 667 465 676 q 561 657 528 657 q 637 678 595 657 q 720 739 678 699 l 720 582 q 546 509 650 509 q 472 516 506 509 q 372 551 438 524 q 292 581 319 574 q 232 589 264 589 m 232 318 q 156 298 197 318 q 74 236 115 277 l 74 393 q 248 467 143 467 q 321 459 288 467 q 421 424 355 451 q 499 394 471 403 q 561 386 528 386 q 720 468 634 386 l 720 311 q 546 237 650 237 q 467 247 503 237 q 372 281 431 256 q 292 311 319 303 q 232 318 264 318 z \"},\"≠\":{\"ha\":765,\"x_min\":74,\"x_max\":720,\"o\":\"m 380 283 l 294 97 l 158 154 l 218 283 l 74 283 l 74 432 l 288 432 l 342 547 l 74 547 l 74 694 l 410 694 l 498 885 l 635 827 l 572 694 l 720 694 l 720 547 l 504 547 l 450 432 l 720 432 l 720 283 l 380 283 z \"},\"≤\":{\"ha\":765,\"x_min\":74,\"x_max\":721,\"o\":\"m 74 0 l 74 149 l 720 149 l 720 0 l 74 0 m 721 179 l 75 476 l 75 574 l 721 909 l 721 747 l 285 532 l 721 342 l 721 179 z \"},\"≥\":{\"ha\":765,\"x_min\":74,\"x_max\":720,\"o\":\"m 74 0 l 74 149 l 720 149 l 720 0 l 74 0 m 74 342 l 510 532 l 74 747 l 74 909 l 720 574 l 720 476 l 74 179 l 74 342 z \"},\"◊\":{\"ha\":810,\"x_min\":77,\"x_max\":765,\"o\":\"m 765 498 l 460 0 l 382 0 l 77 498 l 382 999 l 460 999 l 765 498 m 586 498 l 421 777 l 256 498 l 421 221 l 586 498 z \"},\"ﬁ\":{\"ha\":917,\"x_min\":-149,\"x_max\":947,\"o\":\"m -31 -334 q -149 -317 -101 -334 l -149 -153 q -71 -167 -107 -167 q 2 -140 -29 -167 q 46 -52 33 -113 l 184 603 l 74 603 l 94 701 l 218 758 l 231 815 q 325 1003 258 944 q 510 1063 391 1063 q 669 1029 599 1063 l 615 878 q 525 899 568 899 q 463 871 486 899 q 431 800 439 844 l 422 758 l 571 758 l 538 603 l 389 603 l 243 -82 q -31 -334 191 -334 m 722 936 q 754 1025 722 995 q 846 1055 787 1055 q 921 1034 895 1055 q 947 974 947 1013 q 917 886 947 920 q 825 852 887 852 q 722 936 722 852 m 733 0 l 529 0 l 690 758 l 894 758 l 733 0 z \"},\"ﬂ\":{\"ha\":917,\"x_min\":-149,\"x_max\":957,\"o\":\"m -31 -334 q -149 -317 -101 -334 l -149 -153 q -71 -167 -107 -167 q 2 -140 -29 -167 q 46 -52 33 -113 l 184 603 l 74 603 l 94 701 l 218 758 l 231 815 q 325 1003 258 944 q 510 1063 391 1063 q 669 1029 599 1063 l 615 878 q 525 899 568 899 q 463 871 486 899 q 431 800 439 844 l 422 758 l 571 758 l 538 603 l 389 603 l 243 -82 q -31 -334 191 -334 m 733 0 l 529 0 l 753 1055 l 957 1055 l 733 0 z \"},\"ȷ\":{\"ha\":412,\"x_min\":-178,\"x_max\":393,\"o\":\"m -60 -334 q -178 -317 -130 -334 l -178 -153 q -100 -167 -136 -167 q -27 -140 -58 -167 q 17 -52 4 -113 l 189 758 l 393 758 l 214 -82 q -60 -334 161 -334 z \"},\"⁰\":{\"ha\":526,\"x_min\":66,\"x_max\":546,\"o\":\"m 340 864 q 266 777 298 864 q 233 589 233 690 q 271 524 233 524 q 347 612 315 524 q 379 799 379 701 q 340 864 379 864 m 546 796 q 510 582 546 676 q 409 435 475 487 q 258 383 344 383 q 118 437 170 383 q 66 587 66 491 q 102 809 66 711 q 201 956 138 907 q 351 1006 264 1006 q 495 952 444 1006 q 546 796 546 899 z \"},\"⁴\":{\"ha\":526,\"x_min\":32,\"x_max\":551,\"o\":\"m 526 500 l 446 500 l 424 397 l 262 397 l 285 500 l 32 500 l 53 618 l 375 996 l 551 996 l 469 614 l 550 614 l 526 500 m 309 614 l 348 770 l 363 821 q 334 781 354 807 q 191 614 313 755 l 309 614 z \"},\"⁵\":{\"ha\":526,\"x_min\":64,\"x_max\":557,\"o\":\"m 332 781 q 457 735 408 781 q 505 618 505 690 q 431 449 505 513 q 236 386 357 386 q 64 422 127 386 l 64 546 q 140 513 98 525 q 221 501 182 501 q 315 528 281 501 q 349 602 349 554 q 260 676 349 676 q 170 663 217 676 l 118 708 l 199 991 l 557 991 l 529 867 l 289 867 l 260 772 q 332 781 284 781 z \"},\"⁶\":{\"ha\":526,\"x_min\":61,\"x_max\":545,\"o\":\"m 225 725 q 358 785 279 785 q 470 743 429 785 q 511 627 511 701 q 444 454 511 522 q 268 386 377 386 q 112 444 163 386 q 61 606 61 503 q 108 815 61 723 q 238 956 155 908 q 437 1004 322 1004 q 496 1000 462 1004 q 545 990 531 995 l 515 867 q 418 882 477 882 q 293 841 344 882 q 221 725 242 801 l 225 725 m 271 503 q 337 533 312 503 q 363 612 363 564 q 346 664 363 645 q 300 682 328 682 q 234 656 258 682 q 210 581 210 630 q 225 525 210 547 q 271 503 241 503 z \"},\"⁷\":{\"ha\":526,\"x_min\":83,\"x_max\":595,\"o\":\"m 83 397 l 397 867 l 122 867 l 149 991 l 595 991 l 574 890 l 258 397 l 83 397 z \"},\"⁸\":{\"ha\":526,\"x_min\":56,\"x_max\":547,\"o\":\"m 350 1006 q 496 968 444 1006 q 547 864 547 930 q 513 769 547 804 q 419 711 479 733 q 490 654 463 687 q 517 571 517 621 q 450 433 517 482 q 267 383 382 383 q 113 427 170 383 q 56 542 56 471 q 96 646 56 606 q 211 713 137 687 q 157 766 176 736 q 138 838 138 795 q 197 959 138 912 q 350 1006 257 1006 m 298 646 q 212 553 212 616 q 230 507 212 524 q 278 490 248 490 q 334 512 313 490 q 354 562 354 533 q 339 611 354 592 q 298 646 325 630 m 349 899 q 308 882 325 899 q 292 838 292 865 q 335 771 292 800 q 399 850 399 799 q 385 886 399 873 q 349 899 370 899 z \"},\"⁹\":{\"ha\":526,\"x_min\":61,\"x_max\":536,\"o\":\"m 536 793 q 491 576 536 669 q 360 435 446 484 q 160 386 275 386 q 61 399 100 386 l 61 525 q 111 513 80 517 q 164 509 142 509 q 299 546 247 509 q 378 667 352 583 q 239 606 317 606 q 127 647 168 606 q 86 764 86 689 q 153 937 86 870 q 329 1004 220 1004 q 483 950 429 1004 q 536 793 536 895 m 326 888 q 261 858 287 888 q 236 781 236 827 q 253 730 236 748 q 298 711 270 711 q 364 737 339 711 q 389 814 389 762 q 374 867 389 846 q 326 888 359 888 z \"},\" \":{\"ha\":694,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":1389,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":694,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":1389,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":463,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":347,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":232,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":777,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":396,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":278,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\" \":{\"ha\":139,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\"​\":{\"ha\":0,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\"﻿\":{\"ha\":0,\"x_min\":0,\"x_max\":0,\"o\":\"\"},\"￼\":{\"ha\":1389,\"x_min\":57,\"x_max\":1346,\"o\":\"m 57 823 l 57 1029 l 262 1029 l 262 954 l 132 954 l 132 823 l 57 823 m 1140 954 l 1140 1029 l 1346 1029 l 1346 823 l 1272 823 l 1272 954 l 1140 954 m 57 -260 l 57 -54 l 132 -54 l 132 -186 l 262 -186 l 262 -260 l 57 -260 m 1140 -260 l 1140 -186 l 1272 -186 l 1272 -54 l 1346 -54 l 1346 -260 l 1140 -260 m 875 -260 l 875 -186 l 1060 -186 l 1060 -260 l 875 -260 m 345 -260 l 345 -186 l 528 -186 l 528 -260 l 345 -260 m 345 954 l 345 1029 l 528 1029 l 528 954 l 345 954 m 1346 26 l 1272 26 l 1272 210 l 1346 210 l 1346 26 m 1346 558 l 1272 558 l 1272 742 l 1346 742 l 1346 558 m 610 -260 l 610 -186 l 794 -186 l 794 -260 l 610 -260 m 132 26 l 57 26 l 57 210 l 132 210 l 132 26 m 610 954 l 610 1029 l 794 1029 l 794 954 l 610 954 m 875 954 l 875 1029 l 1060 1029 l 1060 954 l 875 954 m 132 292 l 57 292 l 57 476 l 132 476 l 132 292 m 132 558 l 57 558 l 57 742 l 132 742 l 132 558 m 1346 292 l 1272 292 l 1272 476 l 1346 476 l 1346 292 m 586 427 q 540 275 586 328 q 408 222 494 222 q 276 275 322 222 q 231 427 231 328 q 276 578 231 526 q 408 631 322 631 q 540 578 494 631 q 586 427 586 526 m 317 427 q 408 293 317 293 q 500 427 500 293 q 408 559 500 559 q 317 427 317 559 m 643 625 l 760 625 q 871 603 833 625 q 909 524 909 580 q 894 467 909 490 q 848 439 878 444 l 848 436 q 905 404 888 427 q 921 343 921 381 q 884 258 921 288 q 783 228 847 228 l 643 228 l 643 625 m 726 468 l 771 468 q 814 479 802 468 q 827 513 827 491 q 812 546 827 536 q 766 555 798 555 l 726 555 l 726 468 m 726 401 l 726 297 l 777 297 q 822 312 810 297 q 835 351 835 326 q 774 401 835 401 l 726 401 m 1011 224 q 957 231 976 224 l 957 300 q 1003 294 986 294 q 1061 353 1061 294 l 1061 625 l 1146 625 l 1146 355 q 1111 257 1146 291 q 1011 224 1075 224 z \"},\"�\":{\"ha\":1389,\"x_min\":57,\"x_max\":1331,\"o\":\"m 693 1055 l 1331 419 l 693 -216 l 57 419 l 693 1055 m 737 249 l 737 281 q 752 337 737 315 q 811 392 767 359 q 906 490 881 448 q 930 593 930 533 q 867 736 930 684 q 692 789 804 789 q 575 770 638 789 q 464 722 512 751 l 519 602 q 689 656 628 656 q 753 636 732 656 q 774 585 774 616 q 757 523 774 549 q 692 461 741 498 q 615 377 635 415 q 595 289 595 339 l 595 249 l 737 249 m 576 62 q 601 -5 576 20 q 672 -29 625 -29 q 742 -4 717 -29 q 766 62 766 20 q 742 131 766 106 q 672 155 718 155 q 600 131 623 155 q 576 62 576 106 z \"},\"ǰ\":{\"ha\":412,\"x_min\":-178,\"x_max\":614,\"o\":\"m -60 -334 q -178 -317 -130 -334 l -178 -153 q -100 -167 -136 -167 q -27 -140 -58 -167 q 17 -52 4 -113 l 189 758 l 393 758 l 214 -82 q -60 -334 161 -334 m 66 1064 l 200 1064 q 310 950 243 1028 q 467 1064 388 1014 l 614 1064 l 614 1047 q 414 842 471 913 l 185 842 q 135 938 170 878 q 66 1047 100 998 l 66 1064 z \"},\"ʼ\":{\"ha\":298,\"x_min\":72,\"x_max\":403,\"o\":\"m 397 991 l 403 977 q 225 652 333 823 l 72 652 q 204 991 132 791 l 397 991 z \"},\"ϑ\":{\"ha\":962,\"x_min\":79,\"x_max\":990,\"o\":\"m 507 803 q 553 708 507 743 q 684 672 600 674 q 688 746 688 706 q 663 871 688 828 q 596 914 639 914 q 529 883 551 914 q 507 803 507 852 m 867 517 q 767 209 830 323 q 613 40 704 94 q 401 -14 522 -14 q 210 39 280 -14 q 140 182 140 91 q 161 292 140 229 q 178 364 178 344 q 139 403 178 403 q 79 386 110 403 l 79 532 q 232 562 158 562 q 339 528 301 562 q 376 432 376 494 q 353 302 376 382 q 335 216 335 246 q 419 147 335 147 q 562 237 502 147 q 661 514 621 327 q 470 556 551 519 q 348 655 390 593 q 306 794 306 717 q 387 995 306 921 q 607 1069 469 1069 q 818 979 745 1069 q 890 721 890 889 l 890 696 l 889 672 l 990 672 l 957 517 l 867 517 z \"},\"ϒ\":{\"ha\":799,\"x_min\":125,\"x_max\":917,\"o\":\"m 424 590 l 469 673 q 647 934 576 868 q 807 1000 718 1000 q 917 982 863 1000 l 879 825 q 832 835 858 835 q 749 781 792 835 q 489 372 656 667 l 410 0 l 204 0 l 285 379 l 125 991 l 336 991 l 424 590 z \"},\"ϖ\":{\"ha\":1303,\"x_min\":64,\"x_max\":1329,\"o\":\"m 375 -14 q 201 58 262 -14 q 139 258 139 130 q 169 438 139 345 q 249 603 199 532 l 64 603 l 83 703 l 216 758 l 1329 758 l 1297 603 l 1132 603 q 1143 468 1143 543 q 1095 219 1143 334 q 966 45 1046 104 q 787 -14 886 -14 q 668 19 714 -14 q 602 123 622 52 q 502 18 557 50 q 375 -14 447 -14 m 951 521 q 947 603 951 570 l 432 603 q 335 264 335 412 q 411 147 335 147 q 486 185 458 147 q 534 317 514 222 l 555 410 l 749 410 l 728 317 q 715 225 715 259 q 783 147 715 147 q 906 249 861 147 q 951 521 951 350 z \"},\"Ḿ\":{\"ha\":1222,\"x_min\":36,\"x_max\":1229,\"o\":\"m 568 250 l 942 991 l 1229 991 l 1019 0 l 829 0 l 928 469 q 999 768 964 637 l 996 768 l 610 0 l 419 0 l 378 768 l 375 768 q 349 612 368 709 q 222 0 331 515 l 36 0 l 245 991 l 519 991 l 566 250 l 568 250 m 629 1089 q 779 1295 682 1149 l 1006 1295 l 1006 1283 q 902 1180 975 1245 q 770 1072 829 1114 l 629 1072 l 629 1089 z \"},\"ḿ\":{\"ha\":1257,\"x_min\":25,\"x_max\":1186,\"o\":\"m 572 772 q 750 618 721 772 l 754 618 q 863 732 800 692 q 997 772 926 772 q 1138 715 1089 772 q 1186 554 1186 657 q 1171 432 1186 503 l 1080 0 l 876 0 l 970 443 q 981 524 981 489 q 914 607 981 607 q 801 531 852 607 q 721 315 751 455 l 656 0 l 452 0 l 545 443 q 555 524 555 489 q 489 607 555 607 q 376 530 427 607 q 296 314 325 452 l 229 0 l 25 0 l 186 758 l 342 758 l 328 618 l 332 618 q 572 772 431 772 m 640 859 q 791 1064 694 918 l 1018 1064 l 1018 1053 q 913 949 987 1015 q 782 842 840 884 l 640 842 l 640 859 z \"},\"Ḁ\":{\"ha\":872,\"x_min\":-83,\"x_max\":789,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 508 -244 q 460 -362 508 -317 q 336 -407 413 -407 q 214 -363 260 -407 q 168 -245 168 -319 q 214 -129 168 -172 q 336 -85 260 -85 q 459 -129 410 -85 q 508 -244 508 -173 m 401 -245 q 383 -198 401 -215 q 336 -180 364 -180 q 289 -198 307 -180 q 271 -245 271 -215 q 287 -294 271 -276 q 336 -311 303 -311 q 383 -294 364 -311 q 401 -245 401 -276 z \"},\"ḁ\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 489 -244 q 441 -362 489 -317 q 317 -407 394 -407 q 195 -363 241 -407 q 149 -245 149 -319 q 195 -129 149 -172 q 317 -85 241 -85 q 440 -129 391 -85 q 489 -244 489 -173 m 382 -245 q 364 -198 382 -215 q 317 -180 345 -180 q 270 -198 288 -180 q 252 -245 252 -215 q 268 -294 252 -276 q 317 -311 284 -311 q 364 -294 345 -311 q 382 -245 382 -276 z \"},\"Ὅ\":{\"ha\":1082,\"x_min\":-186,\"x_max\":1039,\"o\":\"m 1039 636 q 972 293 1039 444 q 788 64 905 141 q 519 -14 671 -14 q 249 86 346 -14 q 151 364 151 186 q 218 695 151 544 q 404 926 286 846 q 676 1007 522 1007 q 944 909 849 1007 q 1039 636 1039 812 m 659 832 q 509 770 577 832 q 401 600 440 708 q 362 364 362 491 q 407 214 362 264 q 534 163 452 163 q 684 222 616 163 q 789 389 751 281 q 827 631 827 496 q 783 780 827 727 q 659 832 739 832 m 26 789 q 123 993 67 871 l 300 993 l 300 979 q 130 771 219 863 l 26 771 l 26 789 m -186 844 q -135 947 -186 908 q 26 1004 -84 987 l 26 954 q -48 929 -21 943 q -75 889 -75 915 q -68 875 -75 880 q -52 865 -62 871 q -28 849 -37 858 q -19 821 -19 840 q -38 780 -19 795 q -94 765 -57 765 q -159 785 -132 765 q -186 844 -186 806 z \"},\"˳\":{\"ha\":463,\"x_min\":-69,\"x_max\":271,\"o\":\"m 271 -244 q 223 -362 271 -317 q 98 -407 176 -407 q -23 -363 22 -407 q -69 -245 -69 -319 q -23 -129 -69 -172 q 98 -85 22 -85 q 222 -129 173 -85 q 271 -244 271 -173 m 164 -245 q 145 -198 164 -215 q 98 -180 127 -180 q 52 -198 70 -180 q 33 -245 33 -215 q 50 -294 33 -276 q 98 -311 66 -311 q 145 -294 127 -311 q 164 -245 164 -276 z \"},\"ﬃ\":{\"ha\":1389,\"x_min\":-149,\"x_max\":1419,\"o\":\"m -31 -334 q -149 -317 -101 -334 l -149 -153 q -71 -167 -107 -167 q 2 -140 -29 -167 q 46 -52 33 -113 l 184 603 l 74 603 l 94 701 l 218 758 l 231 815 q 325 1003 258 944 q 510 1063 391 1063 q 669 1029 599 1063 l 615 878 q 525 899 568 899 q 463 871 486 899 q 431 800 439 844 l 422 758 l 690 758 l 703 815 q 797 1003 730 944 q 982 1063 863 1063 q 1141 1029 1071 1063 l 1088 878 q 997 899 1041 899 q 935 871 958 899 q 903 800 911 844 l 895 758 l 1043 758 l 1010 603 l 861 603 l 715 -82 q 441 -334 663 -334 q 323 -317 371 -334 l 323 -153 q 401 -167 365 -167 q 518 -52 494 -167 l 657 603 l 389 603 l 243 -82 q -31 -334 191 -334 m 1206 0 l 1002 0 l 1162 758 l 1367 758 l 1206 0 m 1194 936 q 1227 1025 1194 995 q 1318 1055 1259 1055 q 1394 1034 1368 1055 q 1419 974 1419 1013 q 1390 886 1419 920 q 1297 852 1360 852 q 1194 936 1194 852 z \"},\"ﬄ\":{\"ha\":1389,\"x_min\":-149,\"x_max\":1429,\"o\":\"m -31 -334 q -149 -317 -101 -334 l -149 -153 q -71 -167 -107 -167 q 2 -140 -29 -167 q 46 -52 33 -113 l 184 603 l 74 603 l 94 701 l 218 758 l 231 815 q 325 1003 258 944 q 510 1063 391 1063 q 669 1029 599 1063 l 615 878 q 525 899 568 899 q 463 871 486 899 q 431 800 439 844 l 422 758 l 690 758 l 703 815 q 797 1003 730 944 q 982 1063 863 1063 q 1141 1029 1071 1063 l 1088 878 q 997 899 1041 899 q 935 871 958 899 q 903 800 911 844 l 895 758 l 1043 758 l 1010 603 l 861 603 l 715 -82 q 441 -334 663 -334 q 323 -317 371 -334 l 323 -153 q 401 -167 365 -167 q 518 -52 494 -167 l 657 603 l 389 603 l 243 -82 q -31 -334 191 -334 m 1206 0 l 1002 0 l 1225 1055 l 1429 1055 l 1206 0 z \"},\"Ơ\":{\"ha\":1072,\"x_min\":83,\"x_max\":1219,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 909 867 816 1007 q 1007 1055 985 917 l 1213 1055 l 1219 1039 q 1124 860 1187 931 q 958 750 1061 789 q 971 636 971 693 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 z \"},\"ơ\":{\"ha\":893,\"x_min\":61,\"x_max\":1015,\"o\":\"m 464 772 q 690 673 612 772 q 765 739 736 692 q 808 872 793 785 l 1008 872 l 1015 856 q 920 667 983 734 q 742 559 857 600 q 751 472 751 525 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 z \"},\"Ư\":{\"ha\":1076,\"x_min\":96,\"x_max\":1280,\"o\":\"m 972 991 l 946 867 q 1026 925 998 883 q 1068 1055 1055 968 l 1274 1055 l 1280 1039 q 1147 824 1240 901 q 918 739 1054 748 l 836 350 q 688 78 798 170 q 404 -14 579 -14 q 178 63 260 -14 q 96 272 96 140 q 106 366 96 321 l 239 991 l 446 991 l 314 368 q 302 283 302 318 q 431 163 302 163 q 563 215 514 163 q 633 370 612 267 l 765 991 l 972 991 z \"},\"ư\":{\"ha\":987,\"x_min\":72,\"x_max\":1135,\"o\":\"m 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 799 682 q 857 712 833 691 q 894 766 880 733 q 922 871 909 799 l 1128 871 l 1135 854 q 1003 642 1095 718 q 772 554 911 565 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 123 42 175 -14 q 72 204 72 98 q 92 349 72 250 l 178 758 l 382 758 z \"},\"̀\":{\"ha\":0,\"x_min\":-532,\"x_max\":-243,\"o\":\"m -243 842 l -368 842 q -462 946 -416 888 q -532 1050 -508 1003 l -532 1064 l -321 1064 q -243 859 -297 964 l -243 842 z \"},\"́\":{\"ha\":0,\"x_min\":-402,\"x_max\":-24,\"o\":\"m -402 859 q -252 1064 -349 918 l -24 1064 l -24 1053 q -129 949 -56 1015 q -260 842 -202 884 l -402 842 l -402 859 z \"},\"̃\":{\"ha\":0,\"x_min\":-608,\"x_max\":-39,\"o\":\"m -234 842 q -293 853 -267 842 q -340 877 -318 864 q -381 902 -361 890 q -424 913 -401 913 q -461 894 -445 913 q -488 840 -478 875 l -608 840 q -417 1050 -568 1050 q -358 1039 -384 1050 q -309 1014 -332 1027 q -267 990 -287 1001 q -227 979 -248 979 q -187 997 -203 979 q -156 1051 -171 1014 l -39 1051 q -234 842 -84 842 z \"},\"̉\":{\"ha\":0,\"x_min\":-410,\"x_max\":-118,\"o\":\"m -118 1028 q -252 875 -118 916 l -265 827 l -389 827 l -379 926 q -304 955 -326 936 q -282 1003 -282 973 q -293 1029 -282 1019 q -325 1039 -304 1039 q -410 1025 -359 1039 l -410 1136 q -292 1153 -360 1153 q -163 1121 -209 1153 q -118 1028 -118 1088 z \"},\"̣\":{\"ha\":0,\"x_min\":-628,\"x_max\":-403,\"o\":\"m -628 -208 q -595 -119 -628 -150 q -504 -89 -563 -89 q -430 -110 -456 -89 q -403 -171 -403 -130 q -433 -258 -403 -225 q -525 -292 -463 -292 q -628 -208 -628 -292 z \"},\"Ѐ\":{\"ha\":753,\"x_min\":36,\"x_max\":800,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 614 1071 l 490 1071 q 396 1175 441 1118 q 326 1279 350 1232 l 326 1293 l 536 1293 q 614 1088 561 1193 l 614 1071 z \"},\"Ѝ\":{\"ha\":1048,\"x_min\":36,\"x_max\":1055,\"o\":\"m 286 283 l 804 991 l 1055 991 l 846 0 l 659 0 q 756 463 722 302 q 814 720 790 623 l 808 721 l 290 0 l 36 0 l 245 991 l 436 991 l 336 522 q 279 283 292 331 l 286 283 m 735 1071 l 610 1071 q 516 1175 562 1118 q 446 1279 471 1232 l 446 1293 l 657 1293 q 735 1088 682 1193 l 735 1071 z \"},\"ѐ\":{\"ha\":774,\"x_min\":61,\"x_max\":739,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 549 842 l 425 842 q 331 946 376 888 q 260 1050 285 1003 l 260 1064 l 471 1064 q 549 859 496 964 l 549 842 z \"},\"ѝ\":{\"ha\":839,\"x_min\":75,\"x_max\":815,\"o\":\"m 178 758 l 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 125 42 174 -14 q 75 204 75 98 q 92 349 75 267 l 178 758 m 573 842 l 448 842 q 354 946 400 888 q 284 1050 309 1003 l 284 1064 l 495 1064 q 573 859 519 964 l 573 842 z \"},\"Ѡ\":{\"ha\":1422,\"x_min\":87,\"x_max\":1378,\"o\":\"m 1050 838 q 985 824 1015 838 q 921 786 956 810 l 850 933 q 1084 1004 961 1004 q 1303 918 1227 1004 q 1378 668 1378 832 q 1316 314 1378 472 q 1149 71 1254 156 q 890 -14 1044 -14 q 654 111 722 -14 q 550 14 605 41 q 408 -14 495 -14 q 172 87 256 -14 q 87 366 87 187 q 212 820 87 635 q 557 1004 337 1004 q 676 984 623 1004 q 765 935 730 964 l 675 787 l 650 805 q 555 838 604 838 q 426 773 485 838 q 332 601 366 709 q 298 366 298 492 q 431 163 298 163 q 528 199 491 163 q 585 317 566 236 l 621 485 l 827 485 l 800 354 q 787 258 787 296 q 812 189 787 216 q 886 163 837 163 q 1030 223 968 163 q 1129 405 1092 283 q 1166 663 1166 526 q 1050 838 1166 838 z \"},\"ѡ\":{\"ha\":1153,\"x_min\":69,\"x_max\":1165,\"o\":\"m 164 0 l 69 758 l 269 758 l 309 351 q 318 184 314 294 l 504 518 l 482 758 l 679 758 l 701 311 q 705 184 705 236 q 855 428 798 295 q 956 758 913 562 l 1165 758 q 1019 332 1120 517 q 753 0 918 146 l 555 0 l 530 282 l 528 282 l 380 0 l 164 0 z \"},\"Ѣ\":{\"ha\":872,\"x_min\":83,\"x_max\":800,\"o\":\"m 800 334 q 693 86 800 173 q 383 0 586 0 l 86 0 l 249 762 l 83 762 l 117 918 l 281 918 l 310 1055 l 517 1055 l 488 918 l 685 918 l 652 762 l 454 762 l 422 611 l 468 611 q 715 540 629 611 q 800 334 800 469 m 329 172 l 397 172 q 541 212 492 172 q 590 323 590 252 q 460 439 590 439 l 386 439 l 329 172 z \"},\"ѣ\":{\"ha\":838,\"x_min\":41,\"x_max\":760,\"o\":\"m 602 603 l 406 603 l 372 450 q 519 465 431 465 q 695 409 631 465 q 760 260 760 353 q 718 116 760 178 q 594 21 675 55 q 397 -14 513 -14 q 196 43 265 -14 q 126 208 126 100 q 143 334 126 254 l 201 603 l 41 603 l 74 758 l 236 758 l 265 895 l 469 895 l 439 758 l 633 758 l 602 603 m 453 322 q 345 310 406 322 q 329 215 329 240 q 355 151 329 173 q 427 129 382 129 q 519 159 485 129 q 554 239 554 190 q 453 322 554 322 z \"},\"Ѥ\":{\"ha\":1232,\"x_min\":36,\"x_max\":1287,\"o\":\"m 996 832 q 827 772 901 832 q 715 603 753 711 l 1075 603 l 1039 431 l 681 431 q 676 372 676 407 q 723 217 676 271 q 854 163 770 163 q 958 174 905 163 q 1100 215 1011 184 l 1100 39 q 825 -14 973 -14 q 559 88 653 -14 q 465 370 465 189 l 468 428 l 334 428 l 243 0 l 36 0 l 245 991 l 453 991 l 371 603 l 498 603 q 685 900 554 793 q 996 1007 815 1007 q 1147 990 1078 1007 q 1287 936 1217 974 l 1207 766 q 996 832 1093 832 z \"},\"ѥ\":{\"ha\":1042,\"x_min\":25,\"x_max\":1055,\"o\":\"m 714 -14 q 505 60 578 -14 q 432 267 432 133 q 435 314 432 292 l 297 314 l 231 0 l 25 0 l 187 758 l 393 758 l 330 467 l 460 467 q 603 692 505 611 q 833 772 702 772 q 1055 724 956 772 l 993 568 q 922 595 957 583 q 842 607 886 607 q 742 570 787 607 q 671 467 697 533 l 914 467 l 882 314 l 639 314 l 637 298 l 637 282 q 669 184 637 217 q 755 151 701 151 q 839 163 797 151 q 942 207 880 175 l 942 40 q 714 -14 838 -14 z \"},\"Ѧ\":{\"ha\":929,\"x_min\":-83,\"x_max\":846,\"o\":\"m 489 0 l 298 0 l 390 428 l 358 428 l 135 0 l -83 0 l 465 996 l 718 996 l 846 0 l 654 0 l 608 428 l 575 428 l 489 0 m 590 589 q 567 839 572 753 q 447 589 531 755 l 590 589 z \"},\"ѧ\":{\"ha\":806,\"x_min\":-85,\"x_max\":734,\"o\":\"m 607 758 l 734 0 l 546 0 l 507 286 l 482 286 l 428 0 l 244 0 l 310 286 l 282 286 l 123 0 l -85 0 l 361 758 l 607 758 m 490 427 q 464 623 471 554 l 364 427 l 490 427 z \"},\"Ѩ\":{\"ha\":1283,\"x_min\":36,\"x_max\":1200,\"o\":\"m 1008 0 l 962 428 l 929 428 l 843 0 l 653 0 l 745 428 l 713 428 l 489 0 l 271 0 l 505 428 l 328 428 l 237 0 l 36 0 l 245 991 l 447 991 l 366 603 l 603 603 l 819 996 l 1072 996 l 1200 0 l 1008 0 m 802 589 l 945 589 q 921 839 926 736 q 802 589 892 772 z \"},\"ѩ\":{\"ha\":1161,\"x_min\":25,\"x_max\":1090,\"o\":\"m 859 313 l 842 313 l 783 0 l 600 0 l 671 313 l 652 313 l 479 0 l 271 0 l 454 313 l 275 313 l 208 0 l 25 0 l 186 758 l 371 758 l 309 467 l 545 467 l 717 758 l 962 758 l 1090 0 l 901 0 l 859 313 m 840 467 l 819 623 l 741 467 l 840 467 z \"},\"Ѫ\":{\"ha\":1014,\"x_min\":-58,\"x_max\":1042,\"o\":\"m -58 0 l 113 367 q 217 513 159 465 q 371 578 275 560 l 220 899 l 239 991 l 1042 991 l 1023 895 l 725 568 q 845 481 807 544 q 892 301 884 419 l 914 0 l 711 0 l 696 309 q 676 402 692 374 q 629 431 661 431 l 624 431 l 539 0 l 329 0 l 418 431 l 412 431 q 346 404 375 431 q 289 313 316 377 l 157 0 l -58 0 m 551 597 l 728 817 l 453 817 l 551 597 z \"},\"ѫ\":{\"ha\":804,\"x_min\":-69,\"x_max\":825,\"o\":\"m -69 0 l 56 252 q 144 379 97 336 q 273 440 191 422 l 140 688 l 155 758 l 825 758 l 811 688 l 571 437 q 653 370 625 416 q 694 216 681 324 l 720 0 l 547 0 l 532 208 q 516 279 528 258 q 484 306 505 301 l 421 0 l 240 0 l 310 309 q 259 288 278 307 q 222 231 240 269 l 114 0 l -69 0 m 421 461 l 547 618 l 350 618 l 421 461 z \"},\"Ѭ\":{\"ha\":1368,\"x_min\":36,\"x_max\":1396,\"o\":\"m 905 597 l 1080 817 l 807 817 l 905 597 m 893 0 l 684 0 l 772 431 l 766 431 q 701 405 728 431 q 646 315 673 378 l 511 0 l 296 0 l 440 310 q 514 428 474 385 l 334 428 l 243 0 l 36 0 l 245 991 l 453 991 l 371 603 l 715 603 l 574 899 l 593 991 l 1396 991 l 1378 895 l 1079 568 q 1174 512 1143 543 q 1223 432 1206 481 q 1246 301 1240 382 l 1268 0 l 1065 0 l 1050 309 q 1031 402 1046 374 q 983 431 1015 431 l 978 431 l 893 0 z \"},\"ѭ\":{\"ha\":1150,\"x_min\":25,\"x_max\":1171,\"o\":\"m 277 0 l 387 225 q 450 313 416 285 l 275 313 l 208 0 l 25 0 l 186 758 l 371 758 l 309 467 l 606 467 l 486 688 l 501 758 l 1171 758 l 1157 688 l 917 437 q 1000 368 973 416 q 1040 216 1027 321 l 1065 0 l 893 0 l 878 208 q 862 279 874 257 q 829 306 850 301 l 766 0 l 586 0 l 656 309 q 605 288 624 307 q 568 231 586 269 l 460 0 l 277 0 m 766 461 l 893 618 l 696 618 l 766 461 z \"},\"Ѯ\":{\"ha\":828,\"x_min\":-54,\"x_max\":814,\"o\":\"m 814 775 q 740 594 814 661 q 532 519 665 528 l 532 517 q 686 448 631 505 q 742 302 742 391 q 702 149 742 213 q 575 46 661 85 q 330 -12 488 7 q 210 -32 241 -23 q 164 -55 178 -41 q 150 -89 150 -68 q 231 -139 150 -139 q 338 -136 279 -139 q 435 -132 397 -132 q 538 -160 517 -132 l 538 -315 q 502 -296 527 -304 q 439 -288 477 -288 l 186 -293 q 10 -241 74 -293 q -54 -100 -54 -190 q -22 29 -54 -20 q 83 107 11 77 q 304 160 155 138 q 436 191 387 172 q 508 239 486 211 q 530 315 530 268 q 479 405 530 377 q 314 433 428 433 l 218 433 l 253 597 l 339 597 q 599 733 599 597 q 567 810 599 782 q 471 838 534 838 q 227 754 355 838 l 153 896 q 271 959 211 933 q 406 997 331 985 q 302 1168 372 1067 l 302 1185 l 415 1185 q 519 1067 488 1109 q 606 1153 574 1127 q 672 1191 639 1178 q 745 1204 705 1204 q 814 1193 785 1204 l 814 1092 q 765 1099 791 1099 q 708 1076 740 1099 q 621 994 675 1053 q 761 912 709 972 q 814 775 814 853 z \"},\"ѯ\":{\"ha\":728,\"x_min\":-62,\"x_max\":722,\"o\":\"m 318 467 q 451 487 414 467 q 488 553 488 507 q 465 602 488 584 q 383 619 441 619 q 279 604 336 619 q 170 566 222 589 l 121 714 q 296 762 216 749 q 211 900 268 817 l 211 917 l 323 917 q 428 799 396 841 q 515 885 483 860 q 582 923 547 909 q 653 936 616 936 q 722 925 695 936 l 722 823 q 673 831 697 831 q 623 814 649 831 q 554 755 596 798 q 692 585 692 713 q 649 467 692 514 q 515 396 606 420 l 515 392 q 644 239 644 354 q 604 107 644 159 q 484 26 564 56 q 248 -20 405 -3 q 143 -43 172 -28 q 114 -87 114 -58 q 138 -128 114 -117 q 204 -139 162 -139 q 299 -136 251 -139 q 392 -132 348 -132 q 460 -139 438 -132 q 493 -160 483 -146 l 493 -315 q 456 -296 481 -304 q 395 -288 430 -288 q 280 -290 336 -288 q 161 -293 224 -293 q -6 -240 50 -293 q -62 -96 -62 -188 q 8 65 -62 7 q 229 140 78 123 q 363 163 324 151 q 420 195 402 175 q 437 249 437 215 q 408 304 437 284 q 318 323 378 323 l 199 323 l 229 467 l 318 467 z \"},\"Ѱ\":{\"ha\":1133,\"x_min\":121,\"x_max\":1185,\"o\":\"m 656 294 l 642 294 l 579 0 l 386 0 l 450 294 l 440 294 q 205 365 290 294 q 121 559 121 435 q 136 693 121 620 l 200 991 l 400 991 l 332 667 q 322 587 322 621 q 360 493 322 521 q 473 465 397 465 l 485 465 l 596 991 l 789 991 l 677 465 l 689 465 q 840 512 789 465 q 914 664 891 559 l 983 991 l 1185 991 l 1109 640 q 656 294 1036 294 z \"},\"ѱ\":{\"ha\":1122,\"x_min\":81,\"x_max\":1061,\"o\":\"m 794 1054 l 602 146 q 796 314 734 168 q 857 758 857 461 l 1061 758 q 1008 318 1061 476 q 846 77 956 159 q 567 -20 737 -5 l 500 -334 l 304 -334 l 371 -20 q 155 62 229 -5 q 81 244 81 129 q 92 346 81 292 l 179 758 l 382 758 l 294 340 q 285 258 285 299 q 316 176 285 206 q 406 143 347 146 l 599 1054 l 794 1054 z \"},\"Ѳ\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 467 163 q 626 231 554 163 q 733 421 698 299 l 296 421 q 293 364 293 402 q 339 214 293 264 q 467 163 385 163 m 591 832 q 441 770 510 832 q 330 596 372 708 l 760 596 l 761 631 q 717 779 761 725 q 591 832 673 832 z \"},\"ѳ\":{\"ha\":812,\"x_min\":61,\"x_max\":751,\"o\":\"m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 368 149 q 463 191 420 149 q 528 310 505 233 l 264 310 l 262 290 l 262 277 q 290 182 262 215 q 368 149 317 149 m 449 611 q 356 569 398 611 q 290 453 315 528 l 550 453 l 550 472 q 524 575 550 540 q 449 611 498 611 z \"},\"Ѵ\":{\"ha\":903,\"x_min\":125,\"x_max\":999,\"o\":\"m 364 207 q 402 309 377 246 q 439 395 427 372 l 595 721 q 697 901 657 850 q 784 976 737 951 q 896 1000 831 1000 q 999 981 951 1000 l 999 812 q 933 825 964 825 q 859 795 890 825 q 794 697 829 764 l 437 0 l 211 0 l 125 991 l 325 991 l 359 416 q 363 295 363 350 q 359 207 363 249 l 364 207 z \"},\"ѵ\":{\"ha\":758,\"x_min\":69,\"x_max\":807,\"o\":\"m 309 210 q 371 355 330 270 l 464 546 q 543 681 509 639 q 620 744 578 724 q 718 764 661 764 q 807 746 769 764 l 807 585 q 753 597 779 597 q 708 581 729 597 q 672 537 688 565 q 382 0 657 509 l 163 0 l 69 758 l 269 758 l 302 329 l 305 250 l 304 210 l 309 210 z \"},\"Ѷ\":{\"ha\":903,\"x_min\":125,\"x_max\":999,\"o\":\"m 364 207 q 402 309 377 246 q 439 395 427 372 l 595 721 q 697 901 657 850 q 784 976 737 951 q 896 1000 831 1000 q 999 981 951 1000 l 999 812 q 933 825 964 825 q 859 795 890 825 q 794 697 829 764 l 437 0 l 211 0 l 125 991 l 325 991 l 359 416 q 363 295 363 350 q 359 207 363 249 l 364 207 m 393 1071 q 299 1175 345 1118 q 229 1279 254 1232 l 229 1293 l 421 1293 q 499 1088 447 1187 l 499 1071 l 393 1071 m 652 1071 q 558 1175 604 1118 q 488 1279 512 1232 l 488 1293 l 680 1293 q 757 1088 705 1190 l 757 1071 l 652 1071 z \"},\"ѷ\":{\"ha\":758,\"x_min\":69,\"x_max\":807,\"o\":\"m 309 210 q 371 355 330 270 l 464 546 q 543 681 509 639 q 620 744 578 724 q 718 764 661 764 q 807 746 769 764 l 807 585 q 753 597 779 597 q 708 581 729 597 q 672 537 688 565 q 382 0 657 509 l 163 0 l 69 758 l 269 758 l 302 329 l 305 250 l 304 210 l 309 210 m 281 842 q 187 946 233 888 q 117 1050 141 1003 l 117 1064 l 309 1064 q 387 859 334 958 l 387 842 l 281 842 m 539 842 q 445 946 491 888 q 375 1050 399 1003 l 375 1064 l 567 1064 q 644 859 592 961 l 644 842 l 539 842 z \"},\"Ѹ\":{\"ha\":1724,\"x_min\":83,\"x_max\":1796,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 1072 758 l 1272 758 l 1310 407 q 1320 208 1320 324 l 1324 208 q 1354 289 1337 243 q 1398 393 1370 336 l 1574 758 l 1796 758 l 1335 -109 q 1007 -334 1215 -334 q 907 -321 946 -334 l 907 -158 q 986 -167 954 -167 q 1086 -134 1043 -167 q 1166 -33 1129 -102 l 1183 0 l 1072 758 z \"},\"ѹ\":{\"ha\":1474,\"x_min\":61,\"x_max\":1546,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 822 758 l 1022 758 l 1060 407 q 1069 208 1069 324 l 1074 208 q 1103 289 1087 243 q 1147 393 1120 336 l 1324 758 l 1546 758 l 1084 -109 q 757 -334 964 -334 q 657 -321 696 -334 l 657 -158 q 736 -167 703 -167 q 836 -134 793 -167 q 916 -33 879 -102 l 933 0 l 822 758 z \"},\"Ѻ\":{\"ha\":1051,\"x_min\":83,\"x_max\":1008,\"o\":\"m 1008 599 q 953 303 1008 436 q 798 91 898 170 q 566 -7 699 12 q 534 -65 557 -45 q 468 -85 512 -85 q 405 -64 427 -85 q 383 -5 383 -43 q 161 130 239 22 q 83 404 83 238 q 141 691 83 559 q 298 902 198 823 q 529 1000 397 981 q 561 1056 538 1037 q 628 1075 584 1075 q 690 1055 668 1075 q 713 999 711 1036 q 930 869 852 972 q 1008 599 1008 765 m 498 222 q 575 178 552 222 q 738 326 677 214 q 798 593 798 438 q 769 732 798 675 q 686 815 741 790 q 596 768 652 768 q 517 817 538 768 q 355 665 415 779 q 294 408 294 551 q 325 258 294 316 q 410 178 355 201 q 498 222 446 222 z \"},\"ѻ\":{\"ha\":879,\"x_min\":61,\"x_max\":818,\"o\":\"m 818 446 q 728 140 818 260 q 475 -7 638 20 q 385 -75 458 -75 q 328 -57 348 -75 q 306 -5 307 -38 q 126 100 192 18 q 61 306 61 182 q 154 617 61 495 q 410 765 246 740 q 494 817 429 817 q 571 765 557 817 q 752 659 686 743 q 818 446 818 574 m 612 446 q 554 586 612 550 q 468 530 525 530 q 392 583 411 530 q 301 474 335 550 q 267 306 267 397 q 330 168 267 203 q 365 200 346 189 q 412 211 384 211 q 485 168 465 211 q 578 271 544 196 q 612 446 612 345 z \"},\"Ѽ\":{\"ha\":1422,\"x_min\":87,\"x_max\":1378,\"o\":\"m 1139 1402 l 1111 1271 l 1076 1271 q 987 1282 1028 1271 q 910 1308 945 1294 q 845 1333 875 1321 q 789 1344 815 1344 q 742 1327 760 1344 q 715 1270 725 1310 l 585 1270 q 647 1430 594 1375 q 789 1485 701 1485 q 871 1472 831 1485 q 951 1443 911 1459 q 1031 1415 991 1428 q 1116 1402 1072 1402 l 1139 1402 m 935 1190 q 881 1066 935 1114 q 714 1013 827 1019 l 714 1075 q 784 1101 763 1084 q 806 1146 806 1118 q 800 1163 806 1158 q 781 1174 793 1168 q 753 1192 764 1182 q 743 1225 743 1202 q 765 1272 743 1255 q 828 1289 786 1289 q 905 1262 876 1289 q 935 1190 935 1234 m 1050 838 q 985 824 1015 838 q 921 786 956 810 l 850 933 q 1084 1004 961 1004 q 1303 918 1227 1004 q 1378 668 1378 832 q 1317 306 1378 460 q 1146 69 1256 151 q 890 -14 1036 -14 q 749 13 806 -14 q 650 90 692 39 q 535 9 591 32 q 408 -14 479 -14 q 172 87 256 -14 q 87 366 87 187 q 144 700 87 554 q 308 925 201 845 q 557 1004 414 1004 q 676 984 623 1004 q 765 935 730 964 l 675 787 l 650 805 q 555 838 604 838 q 429 777 488 838 q 334 605 370 716 q 298 366 298 494 q 437 163 298 163 q 560 201 496 163 q 685 315 623 239 q 740 226 713 256 q 803 180 766 197 q 886 163 840 163 q 1029 228 966 163 q 1129 410 1093 293 q 1166 663 1166 526 q 1050 838 1166 838 z \"},\"ѽ\":{\"ha\":1160,\"x_min\":61,\"x_max\":1099,\"o\":\"m 721 -14 q 526 61 597 -14 q 326 -14 435 -14 q 129 63 197 -14 q 61 285 61 139 q 110 542 61 427 q 242 715 159 658 q 437 772 326 772 q 603 730 534 772 l 545 591 q 454 619 504 619 q 361 578 404 619 q 292 461 317 536 q 267 292 267 387 q 370 140 267 140 q 450 162 408 140 q 546 236 492 183 q 697 140 606 140 q 839 237 785 140 q 893 481 893 333 q 871 587 893 554 q 806 619 848 619 q 707 591 766 619 l 667 730 q 851 772 756 772 q 1036 697 973 772 q 1099 481 1099 623 q 1050 219 1099 336 q 917 44 1002 102 q 721 -14 831 -14 m 985 1189 l 957 1057 l 922 1057 q 832 1069 873 1057 q 756 1094 791 1080 q 691 1119 721 1107 q 635 1131 661 1131 q 588 1113 606 1131 q 561 1055 570 1095 l 431 1055 q 493 1216 440 1161 q 635 1271 547 1271 q 717 1258 677 1271 q 797 1230 757 1245 q 877 1202 837 1215 q 961 1189 918 1189 l 985 1189 m 781 977 q 724 850 781 896 q 559 799 667 804 l 559 861 q 630 887 609 871 q 652 932 652 903 q 645 949 652 943 q 627 960 639 954 q 599 978 610 968 q 589 1011 589 988 q 673 1075 589 1075 q 751 1047 722 1075 q 781 977 781 1019 z \"},\"Ѿ\":{\"ha\":1422,\"x_min\":87,\"x_max\":1378,\"o\":\"m 1050 838 q 985 824 1015 838 q 921 786 956 810 l 850 933 q 1084 1004 961 1004 q 1303 918 1227 1004 q 1378 668 1378 832 q 1316 314 1378 472 q 1149 71 1254 156 q 890 -14 1044 -14 q 654 111 722 -14 q 550 14 605 41 q 408 -14 495 -14 q 172 87 256 -14 q 87 366 87 187 q 212 820 87 635 q 557 1004 337 1004 q 676 984 623 1004 q 765 935 730 964 l 675 787 l 650 805 q 555 838 604 838 q 426 773 485 838 q 332 601 366 709 q 298 366 298 492 q 431 163 298 163 q 528 199 491 163 q 585 317 566 236 l 621 485 l 827 485 l 800 354 q 787 258 787 296 q 812 189 787 216 q 886 163 837 163 q 1030 223 968 163 q 1129 405 1092 283 q 1166 663 1166 526 q 1050 838 1166 838 m 1145 1260 l 1132 1200 l 1054 1083 l 1007 1083 l 989 1153 l 900 1153 l 854 1083 l 807 1083 l 789 1153 l 700 1153 l 654 1083 l 607 1083 l 579 1200 l 591 1260 l 1145 1260 z \"},\"ѿ\":{\"ha\":1153,\"x_min\":69,\"x_max\":1165,\"o\":\"m 164 0 l 69 758 l 269 758 l 309 351 q 318 184 314 294 l 504 518 l 482 758 l 679 758 l 701 311 q 705 184 705 236 q 855 428 798 295 q 956 758 913 562 l 1165 758 q 1019 332 1120 517 q 753 0 918 146 l 555 0 l 530 282 l 528 282 l 380 0 l 164 0 m 951 1025 l 939 965 l 861 848 l 814 848 l 798 918 l 708 918 l 661 848 l 614 848 l 597 918 l 509 918 l 461 848 l 414 848 l 387 965 l 400 1025 l 951 1025 z \"},\"Ҁ\":{\"ha\":850,\"x_min\":83,\"x_max\":905,\"o\":\"m 614 832 q 450 775 522 832 q 336 608 378 718 q 294 372 294 498 q 341 215 294 267 q 486 163 389 163 q 660 187 561 163 l 550 -334 l 343 -334 l 412 -12 q 169 97 255 -3 q 83 370 83 197 q 153 700 83 549 q 341 929 223 850 q 614 1007 459 1007 q 766 990 696 1007 q 905 936 835 974 l 825 766 q 725 813 777 794 q 614 832 673 832 z \"},\"ҁ\":{\"ha\":671,\"x_min\":61,\"x_max\":685,\"o\":\"m 416 -334 l 212 -334 l 285 -11 q 120 75 179 3 q 61 265 61 148 q 112 527 61 409 q 254 708 162 644 q 463 772 345 772 q 685 724 586 772 l 623 568 q 551 595 586 584 q 471 607 515 607 q 367 564 413 607 q 294 445 320 520 q 268 282 268 369 q 387 151 268 151 q 526 182 455 151 l 416 -334 z \"},\"҂\":{\"ha\":846,\"x_min\":71,\"x_max\":777,\"o\":\"m 399 293 l 591 180 l 543 97 l 350 208 l 228 -4 l 140 46 l 262 260 l 71 371 l 118 454 l 313 343 l 447 578 l 254 689 l 302 774 l 496 663 l 619 875 l 705 825 l 582 611 l 777 500 l 726 416 l 534 528 l 399 293 z \"},\"҃\":{\"ha\":743,\"x_min\":204,\"x_max\":743,\"o\":\"m 354 842 q 271 778 331 778 q 221 798 238 778 q 204 848 204 818 q 229 916 204 889 q 296 943 253 943 l 595 943 q 676 1007 616 1007 q 727 989 711 1007 q 743 942 743 971 q 719 869 743 897 q 653 842 694 842 l 354 842 z \"},\"҄\":{\"ha\":771,\"x_min\":216,\"x_max\":750,\"o\":\"m 260 974 q 435 1015 338 974 q 593 1055 532 1055 q 708 1015 666 1055 q 750 899 750 974 q 745 840 750 865 l 621 840 l 623 861 q 570 916 623 916 q 511 904 541 916 q 443 879 481 892 q 357 853 405 865 q 245 842 309 842 l 216 842 l 244 974 l 260 974 z \"},\"҅\":{\"ha\":770,\"x_min\":408,\"x_max\":614,\"o\":\"m 408 977 q 444 1065 408 1029 q 536 1101 479 1101 q 595 1083 577 1101 q 614 1039 614 1065 q 602 1006 614 1019 q 566 981 591 992 q 539 964 549 973 q 529 937 529 955 q 591 884 529 899 l 591 827 q 458 873 507 832 q 408 977 408 914 z \"},\"҆\":{\"ha\":770,\"x_min\":387,\"x_max\":616,\"o\":\"m 616 1003 q 387 825 616 837 l 387 888 q 462 913 437 897 q 488 958 488 930 q 481 975 488 970 q 463 986 475 981 q 435 1004 446 994 q 425 1038 425 1015 q 510 1101 425 1101 q 587 1074 558 1101 q 616 1003 616 1046 z \"},\"҈\":{\"ha\":1373,\"x_min\":28,\"x_max\":1346,\"o\":\"m 679 966 q 780 932 742 966 q 823 835 819 898 l 770 835 q 746 880 766 865 q 679 895 726 895 q 609 881 626 895 q 589 835 592 867 l 538 835 q 679 966 545 966 m 679 -85 q 780 -119 741 -85 q 823 -216 819 -154 l 770 -216 q 746 -172 766 -186 q 679 -157 726 -157 q 609 -171 626 -157 q 589 -216 592 -184 l 538 -216 q 575 -120 541 -156 q 679 -85 609 -85 m 1072 104 q 1174 70 1135 104 q 1217 -28 1213 35 l 1162 -28 q 1139 17 1159 3 q 1072 32 1118 32 q 1002 19 1019 32 q 982 -28 985 5 l 930 -28 q 968 69 934 33 q 1072 104 1002 104 m 290 104 q 392 70 353 104 q 435 -28 431 35 l 380 -28 q 357 17 377 3 q 290 32 336 32 q 220 19 237 32 q 200 -28 203 5 l 149 -28 q 186 69 152 33 q 290 104 220 104 m 1072 774 q 1174 739 1135 774 q 1217 642 1213 705 l 1162 642 q 1139 687 1159 672 q 1072 701 1118 701 q 1002 688 1019 701 q 982 642 985 675 l 930 642 q 968 738 934 703 q 1072 774 1002 774 m 290 774 q 392 739 353 774 q 435 642 431 705 l 380 642 q 357 687 377 672 q 290 701 336 701 q 220 688 237 701 q 200 642 203 675 l 149 642 q 186 738 152 703 q 290 774 220 774 m 1202 443 q 1303 408 1264 443 q 1346 311 1342 372 l 1292 311 q 1268 356 1289 341 q 1202 371 1248 371 q 1132 357 1149 371 q 1111 311 1114 344 l 1060 311 q 1202 443 1067 443 m 170 443 q 271 408 232 443 q 314 311 310 374 l 260 311 q 236 356 256 342 q 170 371 216 371 q 100 358 117 371 q 79 311 83 345 l 28 311 q 65 408 31 372 q 170 443 100 443 z \"},\"҉\":{\"ha\":1328,\"x_min\":28,\"x_max\":1300,\"o\":\"m 739 -33 q 704 -143 728 -78 q 656 -261 680 -208 l 590 -261 q 637 -24 626 -111 l 732 -24 l 739 -33 m 590 783 q 628 899 603 831 q 673 1011 652 967 l 739 1011 q 692 774 704 862 l 597 774 l 590 783 m 1072 449 q 1188 411 1120 436 q 1300 366 1256 387 l 1300 300 q 1063 347 1150 336 l 1063 441 l 1072 449 m 256 300 q 146 335 211 311 q 28 383 81 359 l 28 449 q 265 401 178 413 l 265 307 l 256 300 m 1120 804 l 1166 758 q 965 624 1046 684 l 899 690 l 900 701 q 1010 758 945 728 q 1120 804 1074 787 m 208 -83 l 161 -37 q 363 97 281 37 l 429 31 l 428 20 q 208 -83 323 -41 m 220 815 l 265 863 q 400 661 349 728 l 334 595 l 322 596 q 220 815 267 691 m 1107 -96 l 1061 -143 q 996 -43 1040 -109 q 926 58 952 23 l 993 125 l 1004 123 q 1061 11 1031 77 q 1107 -96 1092 -55 z \"},\"Ҋ\":{\"ha\":1140,\"x_min\":36,\"x_max\":1090,\"o\":\"m 245 991 l 436 991 l 336 522 q 279 283 292 331 l 286 283 l 804 991 l 1055 991 l 884 180 l 1090 180 l 879 -289 l 644 -289 l 822 0 l 659 0 q 756 463 722 302 q 814 720 790 623 l 808 721 l 290 0 l 36 0 l 245 991 m 1019 1310 q 953 1169 996 1219 q 838 1093 909 1118 q 663 1067 766 1067 q 454 1119 527 1067 q 382 1278 382 1171 q 385 1310 382 1295 l 566 1310 l 564 1278 q 679 1183 564 1183 q 783 1214 747 1183 q 835 1310 820 1245 l 1019 1310 z \"},\"ҋ\":{\"ha\":873,\"x_min\":72,\"x_max\":859,\"o\":\"m 486 0 l 500 122 l 498 122 q 268 -14 402 -14 q 123 42 175 -14 q 72 204 72 98 q 92 349 72 250 l 178 758 l 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 686 151 l 857 151 l 672 -272 l 467 -272 l 614 0 l 486 0 m 859 1084 q 738 897 825 953 q 501 842 652 842 q 294 894 366 842 q 221 1053 221 946 q 224 1084 221 1069 l 404 1084 l 403 1067 l 403 1053 q 518 958 403 958 q 622 988 585 958 q 673 1084 658 1018 l 859 1084 z \"},\"Ҍ\":{\"ha\":822,\"x_min\":36,\"x_max\":750,\"o\":\"m 750 334 q 643 86 750 173 q 334 0 536 0 l 36 0 l 189 717 l 87 717 l 125 889 l 224 889 l 245 991 l 453 991 l 431 889 l 599 889 l 561 717 l 395 717 l 372 611 l 418 611 q 665 540 581 611 q 750 334 750 469 m 279 172 l 347 172 q 491 212 441 172 q 541 323 541 252 q 410 439 541 439 l 336 439 l 279 172 z \"},\"ҍ\":{\"ha\":785,\"x_min\":78,\"x_max\":711,\"o\":\"m 421 904 l 627 904 l 599 770 l 392 770 l 323 450 q 471 465 383 465 q 647 409 583 465 q 711 260 711 353 q 669 117 711 178 q 546 21 627 55 q 349 -14 465 -14 q 147 43 216 -14 q 78 208 78 99 q 94 330 78 256 l 189 770 l 82 770 l 110 904 l 218 904 l 250 1055 l 454 1055 l 421 904 m 404 322 q 296 310 357 322 q 286 262 291 288 q 281 215 281 235 q 307 151 281 174 q 378 129 332 129 q 471 159 436 129 q 505 239 505 190 q 404 322 505 322 z \"},\"Ҏ\":{\"ha\":806,\"x_min\":36,\"x_max\":807,\"o\":\"m 807 703 q 766 532 807 606 q 646 414 724 458 l 688 326 l 570 271 l 524 368 q 375 353 454 353 l 317 353 l 243 0 l 36 0 l 245 991 l 475 991 q 723 919 639 991 q 807 703 807 847 m 354 525 l 392 525 q 449 529 421 525 l 414 606 l 529 661 l 562 590 q 599 697 599 633 q 467 819 599 819 l 416 819 l 354 525 z \"},\"ҏ\":{\"ha\":827,\"x_min\":-46,\"x_max\":765,\"o\":\"m 551 772 q 708 700 650 772 q 765 496 765 627 q 712 230 765 356 q 571 40 659 103 l 608 -46 l 490 -102 l 449 -12 l 414 -14 q 317 12 357 -14 q 241 97 276 37 l 236 97 q 207 -103 228 -11 l 158 -334 l -46 -334 l 186 758 l 342 758 l 330 643 l 336 643 q 551 772 430 772 m 469 607 q 380 563 422 607 q 311 437 338 519 q 285 271 285 355 q 308 180 285 210 q 364 151 332 151 l 372 151 l 335 233 l 450 289 l 484 218 q 538 342 519 269 q 558 488 558 414 q 469 607 558 607 z \"},\"Ғ\":{\"ha\":699,\"x_min\":20,\"x_max\":798,\"o\":\"m 363 576 l 572 576 l 534 404 l 325 404 l 240 0 l 36 0 l 122 404 l 20 404 l 57 576 l 158 576 l 245 991 l 798 991 l 761 819 l 414 819 l 363 576 z \"},\"ғ\":{\"ha\":643,\"x_min\":-8,\"x_max\":688,\"o\":\"m 688 758 l 652 590 l 354 590 l 322 443 l 500 443 l 467 283 l 289 283 l 229 0 l 25 0 l 86 283 l -8 283 l 25 443 l 119 443 l 186 758 l 688 758 z \"},\"Ҕ\":{\"ha\":925,\"x_min\":36,\"x_max\":807,\"o\":\"m 406 379 q 319 371 356 379 l 240 0 l 36 0 l 245 991 l 798 991 l 761 819 l 414 819 l 355 542 q 469 555 410 555 q 650 507 572 555 q 768 373 729 458 q 807 174 807 288 q 750 -100 807 22 q 593 -284 694 -222 q 364 -347 493 -347 q 167 -314 250 -347 l 167 -138 q 350 -172 254 -172 q 528 -82 460 -172 q 596 151 596 8 q 547 321 596 263 q 406 379 498 379 z \"},\"ҕ\":{\"ha\":796,\"x_min\":25,\"x_max\":688,\"o\":\"m 665 125 q 616 -125 665 -17 q 476 -287 566 -234 q 264 -340 386 -340 q 107 -311 163 -340 l 107 -127 q 257 -164 172 -164 q 406 -91 353 -164 q 458 110 458 -18 q 428 228 458 186 q 339 269 398 269 q 283 260 307 269 l 229 0 l 25 0 l 186 758 l 688 758 l 652 590 l 354 590 l 318 422 q 407 435 353 435 q 597 352 528 435 q 665 125 665 269 z \"},\"Җ\":{\"ha\":1276,\"x_min\":-85,\"x_max\":1317,\"o\":\"m 908 0 l 722 488 l 619 0 l 421 0 l 524 486 l 147 0 l -85 0 l 335 529 l 146 991 l 351 991 l 532 528 l 631 991 l 829 991 l 730 528 l 1095 991 l 1317 991 l 922 501 l 1055 167 l 1197 167 l 1100 -289 l 895 -289 l 957 0 l 908 0 z \"},\"җ\":{\"ha\":1333,\"x_min\":-14,\"x_max\":1348,\"o\":\"m 212 772 q 399 695 331 772 q 468 479 468 618 l 468 461 l 467 443 l 579 443 l 647 758 l 843 758 l 775 443 l 882 443 q 1019 685 920 597 q 1255 772 1118 772 q 1348 764 1303 772 l 1312 602 q 1258 607 1276 607 q 1119 515 1173 607 q 1064 282 1064 422 q 1090 184 1064 217 q 1164 151 1117 151 q 1274 174 1219 151 l 1181 -272 l 991 -272 l 1054 -7 q 913 84 963 12 q 863 275 863 157 l 863 306 l 746 306 l 681 0 l 485 0 l 550 306 l 447 306 q 312 71 408 155 q 78 -14 215 -14 q -14 -5 26 -14 l 18 157 q 72 151 54 151 q 173 195 129 151 q 242 313 218 238 q 267 476 267 389 q 242 574 267 541 q 174 607 218 607 q 92 589 143 607 l 92 754 q 212 772 143 772 z \"},\"Ҙ\":{\"ha\":828,\"x_min\":28,\"x_max\":814,\"o\":\"m 814 775 q 740 594 814 661 q 532 519 665 528 l 532 517 q 685 448 629 505 q 742 302 742 391 q 633 68 742 151 q 315 -14 524 -14 q 151 -1 221 -14 q 28 40 81 11 l 28 218 q 298 151 151 151 q 472 192 414 151 q 530 311 530 233 q 478 404 530 374 q 314 433 426 433 l 218 433 l 253 597 l 339 597 q 599 733 599 597 q 567 810 599 782 q 471 838 534 838 q 227 754 355 838 l 153 896 q 335 982 250 958 q 522 1006 420 1006 q 673 976 606 1006 q 777 893 740 946 q 814 775 814 840 m 247 -210 q 321 -140 321 -210 q 304 -72 321 -104 q 257 0 288 -39 l 379 0 q 465 -172 465 -80 q 414 -292 465 -250 q 275 -334 363 -334 q 171 -317 212 -334 l 171 -195 q 247 -210 210 -210 z \"},\"ҙ\":{\"ha\":728,\"x_min\":17,\"x_max\":692,\"o\":\"m 314 467 q 448 487 409 467 q 488 553 488 507 q 465 602 488 584 q 383 619 441 619 q 279 604 336 619 q 170 566 222 589 l 121 714 q 419 772 273 772 q 621 724 550 772 q 692 585 692 676 q 649 467 692 514 q 515 396 606 420 l 515 392 q 644 239 644 354 q 547 52 644 117 q 269 -14 450 -14 q 132 0 201 -14 q 17 37 64 14 l 17 205 q 262 146 136 146 q 437 244 437 146 q 318 323 437 323 l 199 323 l 229 467 l 314 467 m 200 -210 q 274 -140 274 -210 q 257 -72 274 -104 q 210 0 241 -39 l 332 0 q 418 -172 418 -80 q 368 -292 418 -250 q 228 -334 317 -334 q 124 -317 165 -334 l 124 -195 q 200 -210 163 -210 z \"},\"Қ\":{\"ha\":954,\"x_min\":36,\"x_max\":954,\"o\":\"m 694 167 l 892 167 l 794 -289 l 589 -289 l 652 0 l 530 0 l 346 488 l 243 0 l 36 0 l 245 991 l 453 991 l 354 528 l 721 991 l 954 991 l 559 501 l 694 167 z \"},\"қ\":{\"ha\":850,\"x_min\":25,\"x_max\":848,\"o\":\"m 615 758 l 848 758 l 524 378 l 627 170 l 793 170 l 700 -272 l 511 -272 l 576 0 l 482 0 l 309 370 l 229 0 l 25 0 l 187 758 l 392 758 l 317 406 l 615 758 z \"},\"Ҝ\":{\"ha\":827,\"x_min\":36,\"x_max\":974,\"o\":\"m 760 0 l 539 0 l 456 227 l 439 131 l 342 131 l 400 411 l 318 354 l 243 0 l 36 0 l 245 991 l 453 991 l 354 528 l 453 653 l 504 896 l 602 896 l 581 800 l 741 991 l 974 991 l 558 503 l 760 0 z \"},\"ҝ\":{\"ha\":817,\"x_min\":61,\"x_max\":885,\"o\":\"m 265 0 l 61 0 l 224 758 l 428 758 l 353 406 l 411 473 l 457 688 l 547 688 l 530 611 l 657 758 l 885 758 l 561 382 l 559 374 l 747 0 l 524 0 l 439 180 l 415 61 l 323 61 l 376 302 l 345 371 l 265 0 z \"},\"Ҟ\":{\"ha\":851,\"x_min\":36,\"x_max\":989,\"o\":\"m 774 0 l 545 0 l 401 401 l 317 354 l 243 0 l 36 0 l 191 728 l 103 728 l 139 900 l 227 900 l 245 991 l 453 991 l 433 900 l 524 900 l 488 728 l 396 728 l 350 515 l 745 991 l 989 991 l 576 510 l 774 0 z \"},\"ҟ\":{\"ha\":789,\"x_min\":25,\"x_max\":857,\"o\":\"m 118 946 l 227 946 l 249 1055 l 453 1055 l 429 946 l 636 946 l 607 811 l 400 811 l 353 585 q 314 437 335 503 l 318 437 l 624 758 l 857 758 l 519 416 l 713 0 l 485 0 l 361 285 l 279 236 l 229 0 l 25 0 l 197 811 l 89 811 l 118 946 z \"},\"Ҡ\":{\"ha\":951,\"x_min\":114,\"x_max\":1079,\"o\":\"m 885 0 l 656 0 l 471 488 l 368 0 l 161 0 l 334 817 l 114 817 l 150 991 l 578 991 l 479 528 l 846 991 l 1079 991 l 685 501 l 885 0 z \"},\"ҡ\":{\"ha\":900,\"x_min\":50,\"x_max\":968,\"o\":\"m 734 758 l 968 758 l 643 378 l 831 0 l 602 0 l 428 370 l 349 0 l 144 0 l 273 603 l 50 603 l 83 758 l 511 758 l 436 406 l 734 758 z \"},\"Ң\":{\"ha\":1064,\"x_min\":36,\"x_max\":997,\"o\":\"m 804 167 l 997 167 l 900 -289 l 694 -289 l 757 0 l 562 0 l 653 428 l 334 428 l 243 0 l 36 0 l 245 991 l 453 991 l 371 603 l 690 603 l 772 991 l 979 991 l 804 167 z \"},\"ң\":{\"ha\":917,\"x_min\":25,\"x_max\":860,\"o\":\"m 393 758 l 330 467 l 567 467 l 628 758 l 832 758 l 707 170 l 860 170 l 766 -272 l 578 -272 l 642 0 l 467 0 l 532 313 l 297 313 l 231 0 l 25 0 l 187 758 l 393 758 z \"},\"Ҥ\":{\"ha\":1069,\"x_min\":36,\"x_max\":1189,\"o\":\"m 942 817 l 770 0 l 562 0 l 653 428 l 334 428 l 243 0 l 36 0 l 245 991 l 453 991 l 371 603 l 690 603 l 772 991 l 1189 991 l 1153 817 l 942 817 z \"},\"ҥ\":{\"ha\":987,\"x_min\":25,\"x_max\":1064,\"o\":\"m 393 758 l 330 467 l 567 467 l 628 758 l 1064 758 l 1031 603 l 799 603 l 671 0 l 467 0 l 532 313 l 297 313 l 231 0 l 25 0 l 187 758 l 393 758 z \"},\"Ҧ\":{\"ha\":1434,\"x_min\":36,\"x_max\":1315,\"o\":\"m 864 542 q 978 555 913 555 q 1158 507 1079 555 q 1276 372 1236 458 q 1315 174 1315 287 q 1259 -97 1315 24 q 1104 -283 1203 -219 q 875 -347 1004 -347 q 675 -314 758 -347 l 675 -138 q 859 -172 762 -172 q 1036 -82 968 -172 q 1104 151 1104 7 q 1055 320 1104 262 q 914 379 1006 379 q 828 371 862 379 l 749 0 l 543 0 l 717 817 l 416 817 l 243 0 l 36 0 l 245 991 l 958 991 l 864 542 z \"},\"ҧ\":{\"ha\":1200,\"x_min\":25,\"x_max\":1093,\"o\":\"m 818 758 l 746 422 q 835 435 781 435 q 1025 352 956 435 q 1093 125 1093 269 q 1044 -125 1093 -17 q 904 -287 994 -234 q 692 -340 814 -340 q 534 -311 593 -340 l 534 -127 q 685 -164 601 -164 q 833 -91 781 -164 q 886 110 886 -18 q 856 228 886 187 q 766 269 825 269 q 711 260 735 269 l 657 0 l 453 0 l 579 603 l 358 603 l 231 0 l 25 0 l 187 758 l 818 758 z \"},\"Ҩ\":{\"ha\":1014,\"x_min\":83,\"x_max\":958,\"o\":\"m 958 533 q 905 301 958 412 q 762 117 852 191 q 812 109 779 109 q 907 126 855 109 l 907 -39 q 854 -52 888 -46 q 786 -57 820 -57 q 600 8 677 -57 q 452 -14 535 -14 q 182 85 280 -14 q 83 359 83 184 q 151 695 83 543 q 335 927 218 847 q 606 1007 452 1007 q 775 977 697 1007 l 718 814 q 606 835 663 835 q 447 776 517 835 q 336 605 377 717 q 294 364 294 492 q 340 213 294 267 q 465 158 386 158 l 473 158 q 431 361 431 239 q 469 576 431 484 q 577 720 507 669 q 736 770 647 770 q 900 708 842 770 q 958 533 958 646 m 640 222 q 734 366 697 274 q 771 543 771 458 q 729 612 771 612 q 650 537 682 612 q 618 343 618 462 q 640 222 618 277 z \"},\"ҩ\":{\"ha\":851,\"x_min\":61,\"x_max\":790,\"o\":\"m 790 380 q 749 218 790 298 q 647 100 708 139 q 685 96 662 96 q 765 110 727 96 l 765 -32 q 660 -49 718 -49 q 493 12 566 -49 q 343 -14 428 -14 q 134 68 208 -14 q 61 294 61 149 q 113 546 61 435 q 256 715 165 657 q 469 772 347 772 q 551 764 510 772 q 614 746 592 755 l 566 597 q 476 611 522 611 q 367 572 414 611 q 293 456 320 532 q 267 296 267 380 q 295 180 267 218 q 370 142 323 142 l 386 142 q 362 210 371 167 q 353 286 353 252 q 418 494 353 418 q 595 571 483 571 q 739 522 688 571 q 790 380 790 472 m 539 183 q 600 271 576 213 q 624 380 624 329 q 615 418 624 404 q 590 432 607 432 q 539 388 558 432 q 519 285 519 344 q 525 231 519 260 q 539 183 530 201 z \"},\"Ҫ\":{\"ha\":850,\"x_min\":83,\"x_max\":905,\"o\":\"m 614 832 q 453 777 524 832 q 338 615 381 722 q 294 386 294 509 q 341 218 294 273 q 489 163 387 163 q 718 215 588 163 l 718 39 q 447 -14 583 -14 q 179 88 275 -14 q 83 375 83 189 q 154 702 83 553 q 342 929 224 852 q 614 1007 460 1007 q 764 992 699 1007 q 905 936 830 977 l 825 766 q 707 819 753 806 q 614 832 660 832 m 337 -210 q 411 -140 411 -210 q 394 -72 411 -104 q 347 0 378 -39 l 469 0 q 555 -172 555 -80 q 505 -292 555 -250 q 365 -334 454 -334 q 261 -317 302 -334 l 261 -195 q 337 -210 300 -210 z \"},\"ҫ\":{\"ha\":671,\"x_min\":61,\"x_max\":685,\"o\":\"m 343 -14 q 134 59 207 -14 q 61 265 61 132 q 112 527 61 409 q 254 708 162 644 q 463 772 345 772 q 685 724 586 772 l 623 568 q 551 595 586 584 q 471 607 515 607 q 367 564 413 607 q 294 445 320 520 q 268 282 268 369 q 299 184 268 217 q 385 151 330 151 q 480 167 436 151 q 571 207 524 183 l 571 40 q 343 -14 468 -14 m 247 -210 q 321 -140 321 -210 q 304 -72 321 -104 q 257 0 288 -39 l 379 0 q 465 -172 465 -80 q 414 -292 465 -250 q 275 -334 363 -334 q 171 -317 212 -334 l 171 -195 q 247 -210 210 -210 z \"},\"Ҭ\":{\"ha\":737,\"x_min\":114,\"x_max\":836,\"o\":\"m 180 0 l 353 817 l 114 817 l 151 991 l 836 991 l 799 817 l 559 817 l 422 167 l 615 167 l 518 -289 l 313 -289 l 375 0 l 180 0 z \"},\"ҭ\":{\"ha\":1286,\"x_min\":25,\"x_max\":1229,\"o\":\"m 572 772 q 750 618 721 772 l 754 618 q 863 732 800 692 q 997 772 926 772 q 1138 715 1089 772 q 1186 554 1186 657 q 1171 433 1186 504 l 1131 240 q 1126 204 1126 220 q 1168 160 1126 160 q 1229 170 1196 160 l 1136 -272 l 947 -272 l 1013 0 q 917 151 917 33 q 926 237 917 193 l 970 443 q 981 524 981 489 q 914 607 981 607 q 801 531 852 607 q 721 315 751 455 l 656 0 l 452 0 l 545 443 q 555 524 555 489 q 489 607 555 607 q 376 530 427 607 q 296 314 325 452 l 229 0 l 25 0 l 186 758 l 342 758 l 328 618 l 332 618 q 572 772 431 772 z \"},\"Ү\":{\"ha\":783,\"x_min\":126,\"x_max\":911,\"o\":\"m 425 590 l 679 991 l 911 991 l 492 379 l 411 0 l 205 0 l 286 379 l 126 991 l 338 991 l 425 590 z \"},\"ү\":{\"ha\":711,\"x_min\":69,\"x_max\":791,\"o\":\"m 310 210 q 371 355 336 287 l 572 758 l 791 758 l 378 0 l 307 -334 l 96 -334 l 167 0 l 69 758 l 269 758 l 302 330 q 306 210 306 275 l 310 210 z \"},\"Ұ\":{\"ha\":783,\"x_min\":52,\"x_max\":911,\"o\":\"m 425 590 l 679 991 l 911 991 l 492 379 l 488 358 l 688 358 l 652 183 l 450 183 l 411 0 l 205 0 l 244 183 l 52 183 l 87 358 l 282 358 l 286 379 l 126 991 l 338 991 l 425 590 z \"},\"ұ\":{\"ha\":711,\"x_min\":-41,\"x_max\":791,\"o\":\"m 307 207 q 371 355 332 281 l 572 758 l 791 758 l 378 0 l 564 0 l 530 -155 l 345 -155 l 307 -334 l 96 -334 l 134 -155 l -41 -155 l -8 0 l 167 0 l 69 758 l 269 758 l 300 361 q 302 207 302 322 l 307 207 z \"},\"Ҳ\":{\"ha\":960,\"x_min\":-79,\"x_max\":950,\"o\":\"m 538 0 l 421 368 l 153 0 l -79 0 l 311 518 l 150 991 l 367 991 l 471 640 l 717 991 l 950 991 l 581 500 l 701 167 l 880 167 l 783 -289 l 578 -289 l 640 0 l 538 0 z \"},\"ҳ\":{\"ha\":817,\"x_min\":-68,\"x_max\":806,\"o\":\"m 257 389 l 104 758 l 322 758 l 400 532 l 566 758 l 806 758 l 489 378 l 579 170 l 760 170 l 667 -272 l 478 -272 l 542 0 l 433 0 l 349 232 l 170 0 l -68 0 l 257 389 z \"},\"Ҵ\":{\"ha\":1162,\"x_min\":114,\"x_max\":1117,\"o\":\"m 1086 180 l 986 -289 l 781 -289 l 843 0 l 180 0 l 353 817 l 114 817 l 151 991 l 815 991 l 779 817 l 559 817 l 425 175 l 737 175 l 911 991 l 1117 991 l 945 180 l 1086 180 z \"},\"ҵ\":{\"ha\":947,\"x_min\":62,\"x_max\":901,\"o\":\"m 435 603 l 375 315 q 364 231 364 269 q 433 151 364 151 q 550 229 499 151 q 631 444 602 307 l 697 758 l 901 758 l 791 240 q 787 204 787 220 q 829 160 787 160 q 890 170 856 160 l 798 -272 l 608 -272 l 673 0 q 586 122 608 31 l 585 122 q 354 -14 488 -14 q 210 41 261 -14 q 158 195 158 96 q 178 347 158 256 l 232 603 l 62 603 l 96 758 l 636 758 l 603 603 l 435 603 z \"},\"Ҷ\":{\"ha\":1039,\"x_min\":125,\"x_max\":960,\"o\":\"m 525 0 l 606 380 q 370 322 479 322 q 191 380 256 322 q 125 541 125 437 q 134 619 125 579 l 210 991 l 416 991 l 343 642 q 336 586 336 610 q 440 497 336 497 q 640 547 529 497 l 734 991 l 942 991 l 766 167 l 960 167 l 863 -289 l 657 -289 l 720 0 l 525 0 z \"},\"ҷ\":{\"ha\":888,\"x_min\":111,\"x_max\":831,\"o\":\"m 437 0 l 481 205 l 510 328 l 505 328 q 307 232 418 232 q 163 290 216 232 q 111 450 111 349 q 131 595 111 504 l 165 758 l 370 758 l 328 561 q 317 481 317 515 q 338 416 317 438 q 397 395 359 395 q 507 461 464 395 q 581 672 550 528 l 599 758 l 803 758 l 677 170 l 831 170 l 737 -272 l 549 -272 l 614 0 l 437 0 z \"},\"Ҹ\":{\"ha\":935,\"x_min\":125,\"x_max\":942,\"o\":\"m 732 0 l 525 0 l 606 380 q 485 336 536 349 l 437 117 l 339 117 l 383 322 l 370 322 q 191 380 256 322 q 125 541 125 437 q 134 619 125 579 l 210 991 l 416 991 l 343 642 q 336 586 336 610 q 421 497 336 506 l 468 720 l 567 720 l 521 505 q 640 547 576 517 l 734 991 l 942 991 l 732 0 z \"},\"ҹ\":{\"ha\":839,\"x_min\":111,\"x_max\":815,\"o\":\"m 370 758 l 328 561 q 317 481 317 515 q 366 400 317 417 l 399 555 l 492 555 l 460 408 q 538 498 507 432 q 593 672 569 564 l 611 758 l 815 758 l 654 0 l 450 0 l 493 205 l 522 328 l 518 328 q 427 257 476 281 l 390 87 l 297 87 l 329 232 q 168 289 225 232 q 111 450 111 346 q 131 595 111 504 l 165 758 l 370 758 z \"},\"Һ\":{\"ha\":935,\"x_min\":36,\"x_max\":852,\"o\":\"m 245 991 l 453 991 l 372 611 q 608 669 499 669 q 787 612 722 669 q 852 452 852 554 q 844 372 852 416 l 768 0 l 561 0 l 635 350 q 642 406 642 381 q 538 494 642 494 q 338 444 449 494 l 243 0 l 36 0 l 245 991 z \"},\"һ\":{\"ha\":839,\"x_min\":25,\"x_max\":717,\"o\":\"m 663 0 l 458 0 l 500 197 q 511 278 511 245 q 490 342 511 321 q 431 364 469 364 q 321 297 364 364 q 248 86 278 231 l 229 0 l 25 0 l 186 758 l 390 758 l 347 553 l 318 431 l 322 431 q 521 526 409 526 q 665 468 612 526 q 717 309 717 410 q 697 164 717 262 l 663 0 z \"},\"Ҽ\":{\"ha\":1082,\"x_min\":41,\"x_max\":1082,\"o\":\"m 294 589 q 484 898 354 789 q 799 1007 614 1007 q 1008 940 935 1007 q 1082 751 1082 873 q 948 503 1082 587 q 553 419 814 419 l 481 419 l 479 404 l 479 386 q 527 218 479 273 q 673 163 575 163 q 917 214 783 163 l 917 39 q 639 -14 797 -14 q 365 86 461 -14 q 268 370 268 186 l 271 428 q 100 477 158 433 q 41 597 41 521 q 92 743 41 677 l 262 743 q 227 647 227 688 q 242 605 227 621 q 288 589 257 589 l 294 589 m 781 832 q 620 764 694 832 q 514 589 547 696 l 576 589 q 799 629 725 589 q 873 746 873 669 q 850 809 873 786 q 781 832 827 832 z \"},\"ҽ\":{\"ha\":918,\"x_min\":14,\"x_max\":884,\"o\":\"m 505 -14 q 284 63 363 -14 q 205 279 205 140 l 205 307 q 14 468 14 328 q 53 591 14 536 l 197 591 q 168 500 168 548 q 182 456 168 471 q 218 440 196 440 l 227 440 q 375 685 267 597 q 629 772 482 772 q 817 717 749 772 q 884 566 884 662 q 770 370 884 439 q 447 301 657 301 l 412 301 l 411 287 l 411 273 q 446 176 411 212 q 546 140 481 140 q 653 153 605 140 q 770 199 701 166 l 770 45 q 505 -14 653 -14 m 616 625 q 504 571 557 625 q 435 439 451 517 l 465 439 q 629 472 570 439 q 688 561 688 505 q 616 625 688 625 z \"},\"Ҿ\":{\"ha\":1082,\"x_min\":41,\"x_max\":1082,\"o\":\"m 781 832 q 620 764 694 832 q 514 589 547 696 l 576 589 q 799 629 725 589 q 873 746 873 669 q 850 809 873 786 q 781 832 827 832 m 41 597 q 92 743 41 677 l 262 743 q 227 647 227 688 q 242 605 227 621 q 288 589 257 589 l 294 589 q 488 900 358 792 q 799 1007 617 1007 q 1008 940 935 1007 q 1082 751 1082 873 q 948 503 1082 587 q 553 419 814 419 l 481 419 l 479 404 l 479 386 q 527 218 479 273 q 673 163 575 163 q 917 214 783 163 l 917 39 q 701 -11 826 -3 l 643 -289 l 437 -289 l 501 4 q 328 132 388 38 q 268 370 268 227 l 271 428 q 100 477 158 433 q 41 597 41 521 z \"},\"ҿ\":{\"ha\":918,\"x_min\":14,\"x_max\":884,\"o\":\"m 616 625 q 504 571 557 625 q 435 439 451 517 l 465 439 q 629 472 570 439 q 688 561 688 505 q 616 625 688 625 m 227 440 q 375 685 267 597 q 629 772 482 772 q 817 717 749 772 q 884 566 884 662 q 770 370 884 439 q 447 301 657 301 l 412 301 l 411 287 l 411 273 q 446 176 411 212 q 546 140 481 140 q 653 153 605 140 q 770 199 701 166 l 770 45 q 571 -11 680 -1 l 517 -272 l 328 -272 l 390 1 q 253 99 301 28 q 205 279 205 170 l 205 307 q 14 468 14 328 q 53 591 14 536 l 197 591 q 168 500 168 548 q 182 456 168 471 q 218 440 196 440 l 227 440 z \"},\"Ӂ\":{\"ha\":1204,\"x_min\":-85,\"x_max\":1317,\"o\":\"m 335 529 l 146 991 l 351 991 l 532 528 l 631 991 l 829 991 l 730 528 l 1095 991 l 1317 991 l 922 501 l 1122 0 l 908 0 l 722 488 l 619 0 l 421 0 l 524 486 l 147 0 l -85 0 l 335 529 m 1091 1314 q 1025 1173 1068 1223 q 909 1097 981 1122 q 734 1071 838 1071 q 526 1123 599 1071 q 454 1282 454 1175 q 457 1314 454 1298 l 637 1314 l 636 1296 l 636 1282 q 751 1187 636 1187 q 855 1217 819 1187 q 907 1314 891 1247 l 1091 1314 z \"},\"ӂ\":{\"ha\":1333,\"x_min\":-14,\"x_max\":1348,\"o\":\"m 550 306 l 447 306 q 312 71 408 155 q 78 -14 215 -14 q -14 -5 26 -14 l 18 157 q 72 151 54 151 q 173 195 129 151 q 242 313 218 238 q 267 476 267 389 q 242 574 267 541 q 174 607 218 607 q 92 589 143 607 l 92 754 q 212 772 143 772 q 399 695 331 772 q 468 479 468 618 l 468 461 l 467 443 l 579 443 l 647 758 l 843 758 l 775 443 l 882 443 q 1019 685 920 597 q 1255 772 1118 772 q 1348 764 1303 772 l 1312 602 q 1258 607 1276 607 q 1119 515 1173 607 q 1064 282 1064 422 q 1088 184 1064 217 q 1157 151 1113 151 q 1239 170 1187 151 l 1239 4 q 1118 -14 1190 -14 q 930 62 998 -14 q 863 275 863 138 l 863 306 l 746 306 l 681 0 l 485 0 l 550 306 m 1108 1084 q 1042 944 1085 994 q 926 867 998 893 q 751 842 854 842 q 543 893 616 842 q 471 1053 471 945 q 474 1084 471 1069 l 654 1084 l 653 1067 l 653 1053 q 768 958 653 958 q 872 988 836 958 q 924 1084 908 1018 l 1108 1084 z \"},\"Ӄ\":{\"ha\":961,\"x_min\":36,\"x_max\":954,\"o\":\"m 425 370 q 317 353 369 370 l 243 0 l 36 0 l 245 991 l 453 991 l 354 528 l 721 991 l 954 991 l 578 526 q 717 466 658 512 q 810 343 777 419 q 843 168 843 267 q 787 -100 843 21 q 632 -284 730 -220 q 400 -347 533 -347 q 203 -314 286 -347 l 203 -138 q 386 -172 286 -172 q 564 -82 496 -172 q 632 151 632 8 q 425 370 632 370 z \"},\"ӄ\":{\"ha\":860,\"x_min\":25,\"x_max\":848,\"o\":\"m 615 758 l 848 758 l 532 396 q 682 303 629 377 q 736 104 736 229 q 688 -128 736 -26 q 550 -285 640 -229 q 335 -340 459 -340 q 178 -311 241 -340 l 178 -127 q 328 -164 244 -164 q 475 -96 420 -164 q 529 94 529 -28 q 487 218 529 173 q 370 262 445 262 q 282 245 322 262 l 229 0 l 25 0 l 186 758 l 390 758 l 315 406 l 615 758 z \"},\"Ӆ\":{\"ha\":1055,\"x_min\":-41,\"x_max\":1006,\"o\":\"m 972 991 l 799 180 l 1006 180 l 794 -289 l 559 -289 l 737 0 l 555 0 l 729 817 l 545 817 q 435 425 491 600 q 330 158 380 251 q 219 26 280 66 q 56 -14 157 -14 q -41 3 1 -14 l -41 175 q 26 161 -5 161 q 99 183 71 161 q 155 252 127 204 q 217 399 182 299 q 297 651 253 499 q 389 991 340 803 l 972 991 z \"},\"ӆ\":{\"ha\":916,\"x_min\":-40,\"x_max\":873,\"o\":\"m 701 151 l 873 151 l 689 -272 l 484 -272 l 631 0 l 465 0 l 593 600 q 550 606 566 606 q 474 584 505 606 q 418 516 444 563 q 345 323 393 469 q 298 192 321 254 q 244 85 275 131 q 170 13 214 39 q 61 -14 126 -14 q -40 3 1 -14 l -40 171 q 17 160 -15 160 q 78 196 51 160 q 130 307 104 231 q 237 583 199 512 q 320 694 275 654 q 431 753 366 734 q 589 772 496 772 q 712 762 648 772 q 823 733 777 751 l 701 151 z \"},\"Ӈ\":{\"ha\":972,\"x_min\":36,\"x_max\":979,\"o\":\"m 368 -347 q 170 -314 253 -347 l 170 -129 q 354 -163 254 -163 q 500 -102 446 -163 q 581 85 554 -42 l 653 428 l 334 428 l 243 0 l 36 0 l 245 991 l 453 991 l 371 603 l 690 603 l 772 991 l 979 991 l 778 39 q 637 -252 736 -157 q 368 -347 538 -347 z \"},\"ӈ\":{\"ha\":856,\"x_min\":25,\"x_max\":832,\"o\":\"m 393 758 l 330 467 l 567 467 l 628 758 l 832 758 l 671 0 q 551 -255 635 -169 q 323 -340 467 -340 q 149 -301 218 -340 l 149 -123 q 301 -164 226 -164 q 408 -120 368 -164 q 472 26 449 -77 l 532 313 l 297 313 l 231 0 l 25 0 l 187 758 l 393 758 z \"},\"Ӊ\":{\"ha\":1064,\"x_min\":36,\"x_max\":1014,\"o\":\"m 562 0 l 653 428 l 334 428 l 243 0 l 36 0 l 245 991 l 453 991 l 371 603 l 690 603 l 772 991 l 979 991 l 807 180 l 1014 180 l 803 -289 l 568 -289 l 746 0 l 562 0 z \"},\"ӊ\":{\"ha\":917,\"x_min\":25,\"x_max\":875,\"o\":\"m 467 0 l 532 313 l 297 313 l 231 0 l 25 0 l 187 758 l 393 758 l 330 467 l 567 467 l 628 758 l 832 758 l 703 151 l 875 151 l 690 -272 l 485 -272 l 632 0 l 467 0 z \"},\"Ӌ\":{\"ha\":935,\"x_min\":125,\"x_max\":942,\"o\":\"m 538 0 l 476 -289 l 271 -289 l 371 167 l 559 167 l 606 380 q 370 322 479 322 q 191 380 256 322 q 125 541 125 437 q 134 619 125 579 l 210 991 l 416 991 l 343 642 q 336 586 336 610 q 440 497 336 497 q 640 547 529 497 l 734 991 l 942 991 l 732 0 l 538 0 z \"},\"ӌ\":{\"ha\":827,\"x_min\":111,\"x_max\":803,\"o\":\"m 370 758 l 328 561 q 317 481 317 515 q 338 416 317 438 q 397 395 359 395 q 507 461 464 395 q 581 672 550 528 l 599 758 l 803 758 l 642 0 l 450 0 l 393 -272 l 204 -272 l 307 170 l 472 170 l 481 207 q 496 277 486 237 q 510 328 506 317 l 505 328 q 307 232 418 232 q 163 290 216 232 q 111 450 111 349 q 131 595 111 504 l 165 758 l 370 758 z \"},\"Ӎ\":{\"ha\":1314,\"x_min\":36,\"x_max\":1264,\"o\":\"m 419 0 l 378 768 l 375 768 q 350 617 368 720 q 319 461 332 515 l 222 0 l 36 0 l 245 991 l 519 991 l 566 250 l 568 250 l 942 991 l 1229 991 l 1057 180 l 1264 180 l 1053 -289 l 818 -289 l 996 0 l 829 0 l 928 469 q 999 768 967 651 l 996 768 l 610 0 l 419 0 z \"},\"ӎ\":{\"ha\":1162,\"x_min\":16,\"x_max\":1121,\"o\":\"m 718 0 l 835 547 q 788 455 816 505 q 732 351 760 405 l 545 0 l 387 0 l 345 342 q 323 550 328 479 l 208 0 l 16 0 l 178 758 l 453 758 l 493 435 q 504 329 500 378 q 510 232 507 280 q 603 429 570 370 l 786 758 l 1076 758 l 949 151 l 1121 151 l 936 -272 l 730 -272 l 878 0 l 718 0 z \"},\"Ӑ\":{\"ha\":872,\"x_min\":-83,\"x_max\":932,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 932 1314 q 865 1173 909 1223 q 750 1097 822 1122 q 575 1071 678 1071 q 367 1123 439 1071 q 294 1282 294 1175 q 298 1314 294 1298 l 478 1314 l 477 1296 l 477 1282 q 592 1187 477 1187 q 695 1217 659 1187 q 747 1314 732 1247 l 932 1314 z \"},\"ӑ\":{\"ha\":825,\"x_min\":61,\"x_max\":866,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 866 1084 q 800 944 843 994 q 684 867 756 893 q 509 842 612 842 q 301 893 374 842 q 229 1053 229 945 q 232 1084 229 1069 l 412 1084 l 411 1067 l 411 1053 q 526 958 411 958 q 630 988 593 958 q 682 1084 666 1018 l 866 1084 z \"},\"Ӓ\":{\"ha\":872,\"x_min\":-83,\"x_max\":819,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 346 1166 q 375 1246 346 1219 q 456 1274 404 1274 q 546 1200 546 1274 q 519 1121 546 1151 q 437 1092 493 1092 q 346 1166 346 1092 m 618 1166 q 647 1246 618 1219 q 728 1274 675 1274 q 795 1255 772 1274 q 819 1200 819 1236 q 792 1121 819 1151 q 710 1092 765 1092 q 618 1166 618 1092 z \"},\"ӓ\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 271 937 q 299 1017 271 990 q 380 1044 328 1044 q 471 971 471 1044 q 444 892 471 922 q 362 863 418 863 q 271 937 271 863 m 543 937 q 572 1017 543 990 q 653 1044 600 1044 q 720 1025 697 1044 q 743 971 743 1006 q 716 892 743 922 q 635 863 690 863 q 543 937 543 863 z \"},\"Ӕ\":{\"ha\":1243,\"x_min\":-83,\"x_max\":1291,\"o\":\"m 1080 0 l 526 0 l 576 236 l 288 236 l 139 0 l -83 0 l 542 991 l 1291 991 l 1254 819 l 907 819 l 861 602 l 1185 602 l 1147 429 l 823 429 l 770 174 l 1117 174 l 1080 0 m 614 412 l 700 819 l 646 819 l 399 412 l 614 412 z \"},\"ӕ\":{\"ha\":1211,\"x_min\":61,\"x_max\":1177,\"o\":\"m 818 -14 q 696 5 744 -14 q 616 64 648 23 l 606 0 l 478 0 l 488 98 l 484 98 q 384 13 435 39 q 271 -14 333 -14 q 116 60 172 -14 q 61 261 61 134 q 107 516 61 397 q 233 704 154 635 q 408 772 312 772 q 517 746 473 772 q 595 661 561 720 l 599 661 l 637 758 l 765 758 l 753 697 q 834 751 783 730 q 949 772 886 772 q 1116 716 1055 772 q 1177 566 1177 659 q 1063 370 1177 439 q 741 301 950 301 l 705 301 l 704 288 l 704 275 q 742 175 704 210 q 850 140 779 140 q 953 156 895 140 q 1063 199 1011 172 l 1063 45 q 818 -14 941 -14 m 351 151 q 442 197 400 151 q 509 322 484 243 q 534 488 534 401 q 512 574 534 542 q 443 607 490 607 q 356 560 397 607 q 292 434 315 513 q 268 271 268 355 q 290 182 268 214 q 351 151 312 151 m 909 625 q 797 571 850 625 q 728 439 744 517 l 758 439 q 922 472 863 439 q 981 561 981 505 q 909 625 981 625 z \"},\"Ӗ\":{\"ha\":753,\"x_min\":36,\"x_max\":879,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 879 1314 q 812 1173 856 1223 q 697 1097 769 1122 q 522 1071 625 1071 q 314 1123 387 1071 q 241 1282 241 1175 q 245 1314 241 1298 l 425 1314 l 424 1296 l 424 1282 q 539 1187 424 1187 q 643 1217 606 1187 q 694 1314 679 1247 l 879 1314 z \"},\"ӗ\":{\"ha\":774,\"x_min\":61,\"x_max\":848,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 848 1084 q 781 944 825 994 q 666 867 738 893 q 491 842 594 842 q 283 893 355 842 q 210 1053 210 945 q 214 1084 210 1069 l 394 1084 l 393 1067 l 393 1053 q 508 958 393 958 q 611 988 575 958 q 663 1084 648 1018 l 848 1084 z \"},\"Ә\":{\"ha\":917,\"x_min\":46,\"x_max\":873,\"o\":\"m 471 831 q 336 816 397 831 q 218 779 275 801 l 218 954 q 496 1007 340 1007 q 775 907 677 1007 q 873 618 873 806 q 805 294 873 444 q 617 65 736 144 q 347 -14 498 -14 q 125 53 203 -14 q 46 241 46 119 q 184 491 46 409 q 589 574 321 574 l 661 574 q 664 618 664 590 q 616 774 664 718 q 471 831 568 831 m 349 161 q 514 222 443 161 q 629 404 586 283 l 525 404 q 324 364 394 404 q 254 249 254 323 q 281 185 254 208 q 349 161 307 161 z \"},\"ә\":{\"ha\":774,\"x_min\":35,\"x_max\":713,\"o\":\"m 301 134 q 414 187 361 134 q 484 319 467 240 l 453 319 q 289 287 348 319 q 231 197 231 254 q 301 134 231 134 m 412 772 q 634 695 555 772 q 713 479 713 618 q 658 226 713 341 q 508 48 604 111 q 289 -14 412 -14 q 102 42 169 -14 q 35 193 35 97 q 148 388 35 319 q 471 457 260 457 l 505 457 l 507 485 q 472 582 507 547 q 372 618 437 618 q 265 605 313 618 q 149 559 217 592 l 149 714 q 280 760 218 747 q 412 772 341 772 z \"},\"Ӛ\":{\"ha\":917,\"x_min\":46,\"x_max\":873,\"o\":\"m 471 831 q 336 816 397 831 q 218 779 275 801 l 218 954 q 496 1007 340 1007 q 775 907 677 1007 q 873 618 873 806 q 805 294 873 444 q 617 65 736 144 q 347 -14 498 -14 q 125 53 203 -14 q 46 241 46 119 q 184 491 46 409 q 589 574 321 574 l 661 574 q 664 618 664 590 q 616 774 664 718 q 471 831 568 831 m 349 161 q 514 222 443 161 q 629 404 586 283 l 525 404 q 324 364 394 404 q 254 249 254 323 q 281 185 254 208 q 349 161 307 161 m 354 1166 q 383 1246 354 1219 q 464 1274 412 1274 q 554 1200 554 1274 q 528 1121 554 1151 q 446 1092 501 1092 q 354 1166 354 1092 m 627 1166 q 655 1246 627 1219 q 736 1274 684 1274 q 804 1255 781 1274 q 827 1200 827 1236 q 800 1121 827 1151 q 718 1092 773 1092 q 627 1166 627 1092 z \"},\"ӛ\":{\"ha\":774,\"x_min\":35,\"x_max\":715,\"o\":\"m 301 134 q 414 187 361 134 q 484 319 467 240 l 453 319 q 289 287 348 319 q 231 197 231 254 q 301 134 231 134 m 412 772 q 634 695 555 772 q 713 479 713 618 q 658 226 713 341 q 508 48 604 111 q 289 -14 412 -14 q 102 42 169 -14 q 35 193 35 97 q 148 388 35 319 q 471 457 260 457 l 505 457 l 507 485 q 472 582 507 547 q 372 618 437 618 q 265 605 313 618 q 149 559 217 592 l 149 714 q 280 760 218 747 q 412 772 341 772 m 242 937 q 271 1017 242 990 q 352 1044 300 1044 q 442 971 442 1044 q 416 892 442 922 q 334 863 389 863 q 242 937 242 863 m 515 937 q 543 1017 515 990 q 625 1044 572 1044 q 692 1025 669 1044 q 715 971 715 1006 q 688 892 715 922 q 606 863 661 863 q 515 937 515 863 z \"},\"Ӝ\":{\"ha\":1204,\"x_min\":-85,\"x_max\":1317,\"o\":\"m 335 529 l 146 991 l 351 991 l 532 528 l 631 991 l 829 991 l 730 528 l 1095 991 l 1317 991 l 922 501 l 1122 0 l 908 0 l 722 488 l 619 0 l 421 0 l 524 486 l 147 0 l -85 0 l 335 529 m 519 1166 q 548 1246 519 1219 q 629 1274 577 1274 q 720 1200 720 1274 q 693 1121 720 1151 q 611 1092 667 1092 q 519 1166 519 1092 m 792 1166 q 821 1246 792 1219 q 902 1274 849 1274 q 969 1255 946 1274 q 992 1200 992 1236 q 965 1121 992 1151 q 884 1092 939 1092 q 792 1166 792 1092 z \"},\"ӝ\":{\"ha\":1333,\"x_min\":-14,\"x_max\":1348,\"o\":\"m 550 306 l 447 306 q 312 71 408 155 q 78 -14 215 -14 q -14 -5 26 -14 l 18 157 q 72 151 54 151 q 173 195 129 151 q 242 313 218 238 q 267 476 267 389 q 242 574 267 541 q 174 607 218 607 q 92 589 143 607 l 92 754 q 212 772 143 772 q 399 695 331 772 q 468 479 468 618 l 468 461 l 467 443 l 579 443 l 647 758 l 843 758 l 775 443 l 882 443 q 1019 685 920 597 q 1255 772 1118 772 q 1348 764 1303 772 l 1312 602 q 1258 607 1276 607 q 1119 515 1173 607 q 1064 282 1064 422 q 1088 184 1064 217 q 1157 151 1113 151 q 1239 170 1187 151 l 1239 4 q 1118 -14 1190 -14 q 930 62 998 -14 q 863 275 863 138 l 863 306 l 746 306 l 681 0 l 485 0 l 550 306 m 540 937 q 569 1017 540 990 q 650 1044 597 1044 q 740 971 740 1044 q 713 892 740 922 q 631 863 687 863 q 540 937 540 863 m 812 937 q 841 1017 812 990 q 922 1044 869 1044 q 989 1025 966 1044 q 1013 971 1013 1006 q 986 892 1013 922 q 904 863 959 863 q 812 937 812 863 z \"},\"Ӟ\":{\"ha\":828,\"x_min\":28,\"x_max\":814,\"o\":\"m 814 775 q 740 594 814 661 q 532 519 665 528 l 532 517 q 685 448 629 505 q 742 302 742 391 q 633 68 742 151 q 315 -14 524 -14 q 151 -1 221 -14 q 28 40 81 11 l 28 218 q 298 151 151 151 q 472 192 414 151 q 530 311 530 233 q 478 404 530 374 q 314 433 426 433 l 218 433 l 253 597 l 339 597 q 599 733 599 597 q 567 810 599 782 q 471 838 534 838 q 227 754 355 838 l 153 896 q 335 982 250 958 q 522 1006 420 1006 q 673 976 606 1006 q 777 893 740 946 q 814 775 814 840 m 300 1166 q 329 1246 300 1219 q 410 1274 357 1274 q 500 1200 500 1274 q 473 1121 500 1151 q 391 1092 447 1092 q 300 1166 300 1092 m 572 1166 q 601 1246 572 1219 q 682 1274 629 1274 q 749 1255 726 1274 q 772 1200 772 1236 q 746 1121 772 1151 q 664 1092 719 1092 q 572 1166 572 1092 z \"},\"ӟ\":{\"ha\":728,\"x_min\":17,\"x_max\":692,\"o\":\"m 314 467 q 448 487 409 467 q 488 553 488 507 q 465 602 488 584 q 383 619 441 619 q 279 604 336 619 q 170 566 222 589 l 121 714 q 419 772 273 772 q 621 724 550 772 q 692 585 692 676 q 649 467 692 514 q 515 396 606 420 l 515 392 q 644 239 644 354 q 547 52 644 117 q 269 -14 450 -14 q 132 0 201 -14 q 17 37 64 14 l 17 205 q 262 146 136 146 q 437 244 437 146 q 318 323 437 323 l 199 323 l 229 467 l 314 467 m 220 937 q 249 1017 220 990 q 330 1044 277 1044 q 420 971 420 1044 q 393 892 420 922 q 311 863 367 863 q 220 937 220 863 m 492 937 q 521 1017 492 990 q 602 1044 549 1044 q 669 1025 646 1044 q 692 971 692 1006 q 666 892 692 922 q 584 863 639 863 q 492 937 492 863 z \"},\"Ӡ\":{\"ha\":771,\"x_min\":-3,\"x_max\":787,\"o\":\"m 440 572 q 621 496 556 559 q 685 321 685 432 q 573 74 685 162 q 261 -14 460 -14 q -3 40 97 -14 l -3 218 q 121 171 48 190 q 244 151 194 151 q 413 195 353 151 q 473 317 473 238 q 430 413 473 382 q 298 443 387 443 l 195 443 l 225 582 l 482 818 l 168 818 l 205 991 l 787 991 l 758 859 l 440 572 z \"},\"ӡ\":{\"ha\":760,\"x_min\":-61,\"x_max\":725,\"o\":\"m 441 600 l 113 600 l 146 758 l 725 758 l 697 625 l 371 321 q 554 240 487 310 q 621 62 621 171 q 568 -147 621 -56 q 418 -287 515 -238 q 195 -336 321 -336 q -61 -282 49 -336 l -61 -102 q 51 -147 -14 -129 q 170 -165 116 -165 q 344 -109 279 -165 q 408 43 408 -52 q 362 154 408 114 q 232 193 316 193 l 140 193 l 171 339 l 441 600 z \"},\"Ӣ\":{\"ha\":1048,\"x_min\":36,\"x_max\":1055,\"o\":\"m 286 283 l 804 991 l 1055 991 l 846 0 l 659 0 q 756 463 722 302 q 814 720 790 623 l 808 721 l 290 0 l 36 0 l 245 991 l 436 991 l 336 522 q 279 283 292 331 l 286 283 m 473 1214 l 893 1214 l 863 1071 l 443 1071 l 473 1214 z \"},\"ӣ\":{\"ha\":839,\"x_min\":75,\"x_max\":815,\"o\":\"m 178 758 l 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 125 42 174 -14 q 75 204 75 98 q 92 349 75 267 l 178 758 m 326 985 l 746 985 l 715 842 l 296 842 l 326 985 z \"},\"Ӥ\":{\"ha\":1048,\"x_min\":36,\"x_max\":1055,\"o\":\"m 286 283 l 804 991 l 1055 991 l 846 0 l 659 0 q 756 463 722 302 q 814 720 790 623 l 808 721 l 290 0 l 36 0 l 245 991 l 436 991 l 336 522 q 279 283 292 331 l 286 283 m 433 1166 q 462 1246 433 1219 q 543 1274 491 1274 q 633 1200 633 1274 q 607 1121 633 1151 q 525 1092 581 1092 q 433 1166 433 1092 m 706 1166 q 734 1246 706 1219 q 816 1274 763 1274 q 883 1255 860 1274 q 906 1200 906 1236 q 879 1121 906 1151 q 798 1092 852 1092 q 706 1166 706 1092 z \"},\"ӥ\":{\"ha\":839,\"x_min\":75,\"x_max\":815,\"o\":\"m 178 758 l 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 125 42 174 -14 q 75 204 75 98 q 92 349 75 267 l 178 758 m 279 937 q 308 1017 279 990 q 389 1044 336 1044 q 479 971 479 1044 q 452 892 479 922 q 370 863 426 863 q 279 937 279 863 m 551 937 q 580 1017 551 990 q 661 1044 608 1044 q 728 1025 705 1044 q 751 971 751 1006 q 725 892 751 922 q 643 863 698 863 q 551 937 551 863 z \"},\"Ӧ\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 397 1166 q 426 1246 397 1219 q 507 1274 454 1274 q 597 1200 597 1274 q 570 1121 597 1151 q 488 1092 544 1092 q 397 1166 397 1092 m 669 1166 q 698 1246 669 1219 q 779 1274 726 1274 q 846 1255 823 1274 q 869 1200 869 1236 q 843 1121 869 1151 q 761 1092 816 1092 q 669 1166 669 1092 z \"},\"ӧ\":{\"ha\":812,\"x_min\":61,\"x_max\":751,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 254 937 q 283 1017 254 990 q 364 1044 312 1044 q 454 971 454 1044 q 428 892 454 922 q 346 863 401 863 q 254 937 254 863 m 527 937 q 555 1017 527 990 q 637 1044 584 1044 q 704 1025 681 1044 q 727 971 727 1006 q 700 892 727 922 q 618 863 673 863 q 527 937 527 863 z \"},\"Ө\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 467 163 q 626 231 554 163 q 733 421 698 299 l 296 421 q 293 364 293 402 q 339 214 293 264 q 467 163 385 163 m 591 832 q 441 770 510 832 q 330 596 372 708 l 760 596 l 761 631 q 717 779 761 725 q 591 832 673 832 z \"},\"ө\":{\"ha\":812,\"x_min\":61,\"x_max\":751,\"o\":\"m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 368 149 q 463 191 420 149 q 528 310 505 233 l 264 310 l 262 290 l 262 277 q 290 182 262 215 q 368 149 317 149 m 449 611 q 356 569 398 611 q 290 453 315 528 l 550 453 l 550 472 q 524 575 550 540 q 449 611 498 611 z \"},\"Ӫ\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 467 163 q 626 231 554 163 q 733 421 698 299 l 296 421 q 293 364 293 402 q 339 214 293 264 q 467 163 385 163 m 591 832 q 441 770 510 832 q 330 596 372 708 l 760 596 l 761 631 q 717 779 761 725 q 591 832 673 832 m 397 1166 q 426 1246 397 1219 q 507 1274 454 1274 q 597 1200 597 1274 q 570 1121 597 1151 q 488 1092 544 1092 q 397 1166 397 1092 m 669 1166 q 698 1246 669 1219 q 779 1274 726 1274 q 846 1255 823 1274 q 869 1200 869 1236 q 843 1121 869 1151 q 761 1092 816 1092 q 669 1166 669 1092 z \"},\"ӫ\":{\"ha\":812,\"x_min\":61,\"x_max\":751,\"o\":\"m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 368 149 q 463 191 420 149 q 528 310 505 233 l 264 310 l 262 290 l 262 277 q 290 182 262 215 q 368 149 317 149 m 449 611 q 356 569 398 611 q 290 453 315 528 l 550 453 l 550 472 q 524 575 550 540 q 449 611 498 611 m 254 937 q 283 1017 254 990 q 364 1044 312 1044 q 454 971 454 1044 q 428 892 454 922 q 346 863 401 863 q 254 937 254 863 m 527 937 q 555 1017 527 990 q 637 1044 584 1044 q 704 1025 681 1044 q 727 971 727 1006 q 700 892 727 922 q 618 863 673 863 q 527 937 527 863 z \"},\"Ӭ\":{\"ha\":850,\"x_min\":18,\"x_max\":807,\"o\":\"m 264 161 q 452 223 378 161 q 567 414 526 286 l 201 414 l 237 586 l 595 586 l 596 603 l 596 621 q 421 832 596 832 q 335 823 377 832 q 203 779 292 814 l 149 946 q 447 1007 290 1007 q 714 908 622 1007 q 807 624 807 808 q 740 292 807 442 q 557 64 673 142 q 288 -14 441 -14 q 140 -1 205 -14 q 18 43 75 12 l 18 227 q 264 161 136 161 m 269 1166 q 298 1246 269 1219 q 379 1274 327 1274 q 469 1200 469 1274 q 443 1121 469 1151 q 361 1092 416 1092 q 269 1166 269 1092 m 542 1166 q 570 1246 542 1219 q 652 1274 599 1274 q 719 1255 696 1274 q 742 1200 742 1236 q 715 1121 742 1151 q 633 1092 688 1092 q 542 1166 542 1092 z \"},\"ӭ\":{\"ha\":671,\"x_min\":21,\"x_max\":622,\"o\":\"m 332 772 q 537 693 464 772 q 610 468 610 614 q 561 214 610 323 q 418 46 511 105 q 195 -14 324 -14 q 21 24 92 -14 l 21 195 q 97 164 56 178 q 191 151 138 151 q 315 191 267 151 q 385 314 362 231 l 132 314 l 161 452 l 403 452 l 404 465 l 404 478 q 375 573 404 540 q 290 607 345 607 q 220 596 252 607 q 150 567 189 585 l 96 717 q 332 772 207 772 m 149 937 q 178 1017 149 990 q 259 1044 207 1044 q 349 971 349 1044 q 323 892 349 922 q 241 863 296 863 q 149 937 149 863 m 422 937 q 450 1017 422 990 q 532 1044 479 1044 q 599 1025 576 1044 q 622 971 622 1006 q 595 892 622 922 q 513 863 568 863 q 422 937 422 863 z \"},\"Ӯ\":{\"ha\":831,\"x_min\":21,\"x_max\":958,\"o\":\"m 164 -14 q 21 8 80 -14 l 21 189 q 155 163 76 163 q 213 174 188 163 q 259 208 238 186 q 314 285 281 230 l 121 991 l 329 991 l 433 564 q 453 461 449 500 q 498 562 484 536 l 732 991 l 958 991 l 550 293 q 411 88 460 140 q 303 11 361 36 q 164 -14 245 -14 m 366 1214 l 785 1214 l 755 1071 l 335 1071 l 366 1214 z \"},\"ӯ\":{\"ha\":721,\"x_min\":-96,\"x_max\":793,\"o\":\"m 69 758 l 269 758 l 307 407 q 317 208 317 324 l 321 208 q 351 289 334 243 q 395 393 367 336 l 571 758 l 793 758 l 332 -109 q 4 -334 212 -334 q -96 -321 -57 -334 l -96 -158 q -17 -167 -50 -167 q 83 -134 40 -167 q 163 -33 126 -102 l 180 0 l 69 758 m 256 985 l 676 985 l 646 842 l 226 842 l 256 985 z \"},\"Ӱ\":{\"ha\":831,\"x_min\":21,\"x_max\":958,\"o\":\"m 164 -14 q 21 8 80 -14 l 21 189 q 155 163 76 163 q 213 174 188 163 q 259 208 238 186 q 314 285 281 230 l 121 991 l 329 991 l 433 564 q 453 461 449 500 q 498 562 484 536 l 732 991 l 958 991 l 550 293 q 411 88 460 140 q 303 11 361 36 q 164 -14 245 -14 m 302 1166 q 331 1246 302 1219 q 412 1274 360 1274 q 503 1200 503 1274 q 476 1121 503 1151 q 394 1092 450 1092 q 302 1166 302 1092 m 575 1166 q 604 1246 575 1219 q 685 1274 632 1274 q 752 1255 729 1274 q 775 1200 775 1236 q 748 1121 775 1151 q 667 1092 722 1092 q 575 1166 575 1092 z \"},\"ӱ\":{\"ha\":721,\"x_min\":-96,\"x_max\":793,\"o\":\"m 69 758 l 269 758 l 307 407 q 317 208 317 324 l 321 208 q 351 289 334 243 q 395 393 367 336 l 571 758 l 793 758 l 332 -109 q 4 -334 212 -334 q -96 -321 -57 -334 l -96 -158 q -17 -167 -50 -167 q 83 -134 40 -167 q 163 -33 126 -102 l 180 0 l 69 758 m 205 937 q 234 1017 205 990 q 315 1044 262 1044 q 405 971 405 1044 q 378 892 405 922 q 296 863 352 863 q 205 937 205 863 m 477 937 q 506 1017 477 990 q 587 1044 534 1044 q 654 1025 631 1044 q 677 971 677 1006 q 651 892 677 922 q 569 863 624 863 q 477 937 477 863 z \"},\"Ӳ\":{\"ha\":831,\"x_min\":21,\"x_max\":958,\"o\":\"m 164 -14 q 21 8 80 -14 l 21 189 q 155 163 76 163 q 213 174 188 163 q 259 208 238 186 q 314 285 281 230 l 121 991 l 329 991 l 433 564 q 453 461 449 500 q 498 562 484 536 l 732 991 l 958 991 l 550 293 q 411 88 460 140 q 303 11 361 36 q 164 -14 245 -14 m 323 1088 q 479 1293 400 1175 l 686 1293 l 686 1282 q 583 1182 657 1246 q 444 1071 509 1118 l 323 1071 l 323 1088 m 592 1088 q 749 1293 669 1175 l 956 1293 l 956 1282 q 852 1182 926 1246 q 713 1071 778 1118 l 592 1071 l 592 1088 z \"},\"ӳ\":{\"ha\":721,\"x_min\":-96,\"x_max\":839,\"o\":\"m 69 758 l 269 758 l 307 407 q 317 208 317 324 l 321 208 q 351 289 334 243 q 395 393 367 336 l 571 758 l 793 758 l 332 -109 q 4 -334 212 -334 q -96 -321 -57 -334 l -96 -158 q -17 -167 -50 -167 q 83 -134 40 -167 q 163 -33 126 -102 l 180 0 l 69 758 m 206 859 q 363 1064 283 945 l 570 1064 l 570 1053 q 466 952 541 1017 q 327 842 392 888 l 206 842 l 206 859 m 475 859 q 632 1064 553 945 l 839 1064 l 839 1053 q 735 952 810 1017 q 596 842 661 888 l 475 842 l 475 859 z \"},\"Ӵ\":{\"ha\":935,\"x_min\":125,\"x_max\":942,\"o\":\"m 525 0 l 606 380 q 370 322 479 322 q 191 380 256 322 q 125 541 125 437 q 134 619 125 579 l 210 991 l 416 991 l 343 642 q 336 586 336 610 q 440 497 336 497 q 640 547 529 497 l 734 991 l 942 991 l 732 0 l 525 0 m 362 1166 q 391 1246 362 1219 q 472 1274 420 1274 q 562 1200 562 1274 q 536 1121 562 1151 q 454 1092 509 1092 q 362 1166 362 1092 m 635 1166 q 663 1246 635 1219 q 745 1274 692 1274 q 812 1255 789 1274 q 835 1200 835 1236 q 808 1121 835 1151 q 726 1092 781 1092 q 635 1166 635 1092 z \"},\"ӵ\":{\"ha\":827,\"x_min\":111,\"x_max\":803,\"o\":\"m 165 758 l 370 758 l 328 561 q 317 481 317 515 q 338 416 317 438 q 397 395 359 395 q 507 461 464 395 q 581 672 550 528 l 599 758 l 803 758 l 642 0 l 437 0 l 481 205 l 510 328 l 505 328 q 307 232 418 232 q 163 290 216 232 q 111 450 111 349 q 131 595 111 504 l 165 758 m 273 937 q 302 1017 273 990 q 383 1044 331 1044 q 473 971 473 1044 q 447 892 473 922 q 365 863 420 863 q 273 937 273 863 m 546 937 q 574 1017 546 990 q 656 1044 603 1044 q 723 1025 700 1044 q 746 971 746 1006 q 719 892 746 922 q 637 863 692 863 q 546 937 546 863 z \"},\"Ӷ\":{\"ha\":699,\"x_min\":36,\"x_max\":798,\"o\":\"m 36 0 l 245 991 l 798 991 l 761 819 l 414 819 l 275 167 l 468 167 l 371 -289 l 165 -289 l 228 0 l 36 0 z \"},\"ӷ\":{\"ha\":643,\"x_min\":25,\"x_max\":686,\"o\":\"m 25 0 l 186 758 l 686 758 l 652 590 l 354 590 l 265 170 l 418 170 l 325 -272 l 136 -272 l 201 0 l 25 0 z \"},\"Ӹ\":{\"ha\":1187,\"x_min\":36,\"x_max\":1194,\"o\":\"m 985 0 l 772 0 l 982 991 l 1194 991 l 985 0 m 729 334 q 622 86 729 173 q 313 0 515 0 l 36 0 l 245 991 l 453 991 l 372 611 l 397 611 q 645 540 560 611 q 729 334 729 469 m 279 172 l 326 172 q 470 212 420 172 q 519 323 519 252 q 389 439 519 439 l 336 439 l 279 172 m 498 1166 q 527 1246 498 1219 q 608 1274 556 1274 q 699 1200 699 1274 q 672 1121 699 1151 q 590 1092 646 1092 q 498 1166 498 1092 m 771 1166 q 800 1246 771 1219 q 881 1274 828 1274 q 948 1255 925 1274 q 971 1200 971 1236 q 944 1121 971 1151 q 863 1092 918 1092 q 771 1166 771 1092 z \"},\"ӹ\":{\"ha\":1116,\"x_min\":72,\"x_max\":1092,\"o\":\"m 383 758 l 317 450 q 454 465 383 465 q 608 410 549 465 q 667 264 667 354 q 628 119 667 182 q 514 22 589 57 q 336 -14 439 -14 q 72 207 72 -14 q 87 335 72 266 l 179 758 l 383 758 m 378 322 q 289 310 339 322 q 277 247 279 264 q 275 212 275 229 q 296 150 275 171 q 353 129 317 129 q 432 160 402 129 q 463 241 463 192 q 378 322 463 322 m 930 0 l 726 0 l 888 758 l 1092 758 l 930 0 m 410 937 q 438 1017 410 990 q 519 1044 467 1044 q 610 971 610 1044 q 583 892 610 922 q 501 863 557 863 q 410 937 410 863 m 682 937 q 711 1017 682 990 q 792 1044 739 1044 q 859 1025 836 1044 q 882 971 882 1006 q 856 892 882 922 q 774 863 829 863 q 682 937 682 863 z \"},\"Ӻ\":{\"ha\":699,\"x_min\":20,\"x_max\":798,\"o\":\"m 160 -336 q 40 -318 89 -336 l 40 -155 q 118 -170 77 -170 q 190 -141 163 -170 q 228 -54 216 -113 l 239 0 l 36 0 l 122 404 l 20 404 l 57 576 l 158 576 l 245 991 l 798 991 l 761 819 l 414 819 l 363 576 l 572 576 l 534 404 l 325 404 l 283 205 l 485 205 l 425 -85 q 335 -275 399 -214 q 160 -336 272 -336 z \"},\"ӻ\":{\"ha\":643,\"x_min\":-8,\"x_max\":688,\"o\":\"m 149 -336 q 29 -318 78 -336 l 29 -155 q 107 -170 66 -170 q 178 -141 153 -170 q 216 -54 204 -113 l 228 0 l 25 0 l 86 283 l -8 283 l 25 443 l 119 443 l 186 758 l 688 758 l 652 590 l 354 590 l 322 443 l 500 443 l 467 283 l 289 283 l 267 178 l 467 178 l 414 -85 q 323 -276 387 -216 q 149 -336 260 -336 z \"},\"Ӽ\":{\"ha\":960,\"x_min\":-79,\"x_max\":950,\"o\":\"m 564 -336 q 444 -318 493 -336 l 444 -155 q 522 -170 481 -170 q 594 -141 568 -170 q 632 -54 620 -113 l 643 0 l 538 0 l 421 368 l 153 0 l -79 0 l 311 518 l 150 991 l 367 991 l 471 640 l 717 991 l 950 991 l 581 500 l 688 205 l 889 205 l 829 -85 q 739 -275 803 -214 q 564 -336 675 -336 z \"},\"ӽ\":{\"ha\":832,\"x_min\":-68,\"x_max\":806,\"o\":\"m 458 -336 q 339 -318 388 -336 l 339 -155 q 416 -170 376 -170 q 488 -141 462 -170 q 526 -54 514 -113 l 538 0 l 433 0 l 349 232 l 170 0 l -68 0 l 257 389 l 104 758 l 322 758 l 400 532 l 566 758 l 806 758 l 489 378 l 576 178 l 777 178 l 724 -85 q 633 -276 697 -216 q 458 -336 570 -336 z \"},\"Ӿ\":{\"ha\":842,\"x_min\":-79,\"x_max\":950,\"o\":\"m 608 419 l 762 0 l 538 0 l 421 368 l 153 0 l -79 0 l 237 419 l 82 419 l 118 591 l 288 591 l 150 991 l 367 991 l 471 640 l 717 991 l 950 991 l 647 591 l 814 591 l 778 419 l 608 419 z \"},\"ӿ\":{\"ha\":737,\"x_min\":-68,\"x_max\":806,\"o\":\"m 189 306 l 60 306 l 93 461 l 228 461 l 104 758 l 322 758 l 400 532 l 566 758 l 806 758 l 557 461 l 692 461 l 659 306 l 519 306 l 654 0 l 433 0 l 349 232 l 170 0 l -68 0 l 189 306 z \"},\"Ԁ\":{\"ha\":806,\"x_min\":41,\"x_max\":812,\"o\":\"m 41 281 q 152 524 41 436 q 457 611 262 611 l 526 611 l 606 991 l 812 991 l 603 0 l 372 0 q 126 72 211 0 q 41 281 41 144 m 489 439 l 437 439 q 299 401 347 439 q 250 288 250 363 q 285 200 250 229 q 382 172 320 172 l 432 172 l 489 439 z \"},\"ԁ\":{\"ha\":825,\"x_min\":61,\"x_max\":864,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 262 61 132 q 110 516 61 395 q 237 705 158 637 q 412 772 317 772 q 508 747 468 772 q 585 661 549 722 l 590 661 l 591 680 q 608 812 595 755 l 660 1055 l 864 1055 l 640 0 l 485 0 l 494 98 l 492 98 q 391 13 444 39 q 275 -14 338 -14 m 361 151 q 448 198 406 151 q 516 321 490 244 q 542 488 542 399 q 516 574 542 542 q 447 607 491 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 361 151 268 151 z \"},\"Ԃ\":{\"ha\":1200,\"x_min\":41,\"x_max\":1124,\"o\":\"m 1124 575 l 1057 258 q 947 52 1026 117 q 730 -14 867 -14 q 606 9 663 -14 q 522 74 549 32 q 411 5 460 23 q 302 -12 362 -12 q 111 55 180 -12 q 41 240 41 122 q 93 437 41 352 q 241 566 145 522 q 461 611 336 611 l 526 611 l 607 991 l 812 991 l 663 283 q 657 239 657 260 q 679 180 657 200 q 737 160 700 160 q 813 195 785 160 q 857 306 842 229 l 914 575 l 1124 575 m 489 439 l 453 439 q 303 392 357 439 q 249 260 249 345 q 274 184 249 209 q 340 160 300 160 q 453 267 429 160 l 489 439 z \"},\"ԃ\":{\"ha\":1215,\"x_min\":61,\"x_max\":1137,\"o\":\"m 549 102 q 314 -14 454 -14 q 124 61 188 -14 q 61 271 61 135 q 108 522 61 399 q 233 708 155 644 q 404 772 311 772 q 585 661 519 772 l 590 661 q 592 703 590 677 q 599 759 595 728 q 660 1055 604 790 l 864 1055 l 701 289 q 694 231 694 255 q 716 172 694 193 q 772 151 738 151 q 850 185 823 151 q 895 306 876 218 l 930 475 l 1137 475 l 1092 258 q 986 52 1061 117 q 782 -14 910 -14 q 645 16 704 -14 q 557 102 587 45 l 549 102 m 364 151 q 454 197 414 151 q 518 323 494 243 q 542 488 542 404 q 519 574 542 542 q 447 607 496 607 q 359 563 400 607 q 293 438 319 519 q 268 271 268 358 q 294 181 268 211 q 364 151 319 151 z \"},\"Ԅ\":{\"ha\":1194,\"x_min\":134,\"x_max\":1118,\"o\":\"m 741 772 q 679 605 741 675 q 503 507 616 535 l 503 504 q 616 441 577 484 q 656 323 656 398 l 653 239 q 736 160 653 160 q 808 193 781 160 q 851 306 835 225 l 908 575 l 1118 575 l 1051 258 q 942 52 1021 117 q 721 -14 863 -14 q 520 45 590 -14 q 450 214 450 104 q 454 266 450 239 q 457 322 457 292 q 420 405 457 376 q 310 433 383 433 l 154 433 l 186 582 l 293 582 q 465 622 404 582 q 525 741 525 663 q 497 810 525 783 q 416 836 470 836 q 211 765 321 836 l 134 908 q 461 1006 275 1006 q 664 941 588 1006 q 741 772 741 876 z \"},\"ԅ\":{\"ha\":1133,\"x_min\":93,\"x_max\":1055,\"o\":\"m 612 252 l 612 224 q 634 169 612 187 q 690 151 656 151 q 766 182 740 151 q 807 283 792 212 l 848 475 l 1055 475 l 1010 258 q 903 53 981 120 q 685 -14 825 -14 q 487 41 557 -14 q 416 196 416 96 l 416 224 q 385 300 416 277 q 269 323 354 323 l 171 323 l 201 467 l 290 467 q 426 486 388 467 q 464 553 464 506 q 439 604 464 589 q 359 619 414 619 q 252 604 312 619 q 142 566 192 588 l 93 714 q 387 772 243 772 q 589 724 518 772 q 660 585 660 676 q 618 467 660 513 q 488 396 576 420 l 488 392 q 612 252 612 369 z \"},\"Ԇ\":{\"ha\":913,\"x_min\":89,\"x_max\":833,\"o\":\"m 393 0 l 447 248 q 458 321 458 290 q 310 435 458 435 l 154 435 l 189 597 l 275 597 q 534 733 534 597 q 503 810 534 782 q 407 838 471 838 q 163 754 292 838 l 89 896 q 271 982 186 958 q 458 1006 356 1006 q 609 976 542 1006 q 713 893 676 946 q 750 775 750 840 q 676 594 750 661 q 468 519 602 528 l 468 517 q 613 458 560 507 q 667 328 667 408 q 663 280 667 307 q 642 167 660 254 l 833 167 l 736 -289 l 530 -289 l 593 0 l 393 0 z \"},\"ԇ\":{\"ha\":838,\"x_min\":121,\"x_max\":781,\"o\":\"m 399 0 l 436 170 q 446 235 446 216 q 414 303 446 283 q 318 323 382 323 l 199 323 l 229 467 l 314 467 q 448 487 409 467 q 488 553 488 507 q 465 602 488 584 q 383 619 441 619 q 279 604 336 619 q 170 566 222 589 l 121 714 q 419 772 273 772 q 621 724 550 772 q 692 585 692 676 q 648 465 692 511 q 515 396 605 418 l 515 392 q 640 254 640 357 q 628 170 640 229 l 781 170 l 688 -272 l 498 -272 l 564 0 l 399 0 z \"},\"Ԉ\":{\"ha\":1360,\"x_min\":-41,\"x_max\":1283,\"o\":\"m 972 991 l 827 301 q 817 237 817 260 q 837 181 817 203 q 897 160 857 160 q 972 195 944 160 q 1017 306 1001 229 l 1074 575 l 1283 575 l 1217 258 q 1108 53 1187 119 q 890 -14 1029 -14 q 683 46 757 -14 q 610 215 610 106 q 627 334 610 257 l 729 817 l 545 817 q 435 425 491 600 q 330 158 380 251 q 219 26 280 66 q 56 -14 157 -14 q -41 3 1 -14 l -41 175 q 26 161 -5 161 q 99 183 71 161 q 155 252 127 204 q 217 399 182 299 q 297 651 253 499 q 389 991 340 803 l 972 991 z \"},\"ԉ\":{\"ha\":1244,\"x_min\":-40,\"x_max\":1166,\"o\":\"m 724 231 q 745 172 724 193 q 802 151 767 151 q 879 185 852 151 q 924 306 905 218 l 960 475 l 1166 475 l 1121 258 q 1012 52 1090 118 q 794 -14 934 -14 q 590 46 661 -14 q 518 212 518 105 q 526 289 518 249 l 593 600 q 550 606 566 606 q 474 584 505 606 q 418 516 444 563 q 345 323 393 469 q 298 192 321 254 q 244 85 275 131 q 170 13 214 39 q 61 -14 126 -14 q -40 3 1 -14 l -40 171 q 17 160 -15 160 q 78 196 51 160 q 130 307 104 231 q 237 583 199 512 q 320 694 275 654 q 431 753 366 734 q 589 772 496 772 q 712 762 648 772 q 823 733 777 751 l 730 289 q 724 231 724 255 z \"},\"Ԋ\":{\"ha\":1367,\"x_min\":36,\"x_max\":1291,\"o\":\"m 979 991 l 833 301 q 823 237 823 260 q 844 181 823 203 q 904 160 864 160 q 979 195 951 160 q 1023 306 1008 229 l 1080 575 l 1291 575 l 1223 258 q 1115 53 1194 119 q 897 -14 1036 -14 q 693 47 767 -14 q 619 220 619 109 q 625 287 619 250 q 653 428 631 323 l 334 428 l 243 0 l 36 0 l 245 991 l 453 991 l 371 603 l 690 603 l 772 991 l 979 991 z \"},\"ԋ\":{\"ha\":1247,\"x_min\":25,\"x_max\":1169,\"o\":\"m 393 758 l 330 467 l 567 467 l 628 758 l 832 758 l 733 296 q 726 235 726 260 q 749 179 726 198 q 808 160 772 160 q 881 193 854 160 q 926 306 909 225 l 962 475 l 1169 475 l 1124 258 q 1015 52 1093 118 q 798 -14 937 -14 q 593 45 666 -14 q 521 212 521 104 q 529 289 521 249 l 533 313 l 297 313 l 231 0 l 25 0 l 187 758 l 393 758 z \"},\"Ԍ\":{\"ha\":1022,\"x_min\":83,\"x_max\":978,\"o\":\"m 511 557 l 978 557 l 954 433 q 794 91 908 196 q 473 -14 680 -14 q 186 90 288 -14 q 83 376 83 193 q 157 701 83 554 q 360 928 230 848 q 660 1007 490 1007 q 942 940 821 1007 l 864 770 q 747 818 795 806 q 648 829 699 829 q 468 772 548 829 q 341 610 387 715 q 294 380 294 505 q 486 161 294 161 q 639 217 579 161 q 721 382 699 273 l 473 382 l 511 557 z \"},\"ԍ\":{\"ha\":876,\"x_min\":61,\"x_max\":818,\"o\":\"m 433 449 l 818 449 l 796 342 q 659 74 758 161 q 385 -14 559 -14 q 146 65 232 -14 q 61 288 61 143 q 117 542 61 431 q 277 712 173 652 q 519 772 380 772 q 659 755 593 772 q 771 713 725 739 l 697 557 q 515 606 609 606 q 334 519 402 606 q 267 289 267 433 q 302 186 267 223 q 399 150 337 150 q 516 186 470 150 q 578 294 562 222 l 401 294 l 433 449 z \"},\"Ԏ\":{\"ha\":983,\"x_min\":114,\"x_max\":907,\"o\":\"m 114 817 l 151 991 l 844 991 l 807 817 l 558 817 l 450 301 q 440 237 440 260 q 460 181 440 203 q 521 160 481 160 q 596 195 568 160 q 640 306 625 229 l 697 575 l 907 575 l 840 258 q 732 53 811 119 q 514 -14 652 -14 q 307 46 380 -14 q 233 215 233 106 q 250 334 233 257 l 354 817 l 114 817 z \"},\"ԏ\":{\"ha\":935,\"x_min\":64,\"x_max\":857,\"o\":\"m 414 231 q 435 172 414 193 q 492 151 457 151 q 569 185 543 151 q 614 306 595 218 l 650 475 l 857 475 l 811 258 q 703 53 782 119 q 485 -14 623 -14 q 282 46 354 -14 q 210 216 210 106 q 228 342 210 263 l 285 603 l 64 603 l 96 758 l 745 758 l 711 603 l 486 603 l 421 289 q 414 231 414 252 z \"},\"Ԑ\":{\"ha\":819,\"x_min\":46,\"x_max\":865,\"o\":\"m 545 1006 q 705 985 631 1006 q 865 909 780 964 l 770 757 q 666 810 726 789 q 536 832 606 832 q 423 800 465 832 q 382 715 382 768 q 430 626 382 654 q 578 597 478 597 l 672 597 l 637 433 l 554 433 q 331 394 400 433 q 262 277 262 354 q 309 188 262 214 q 439 161 355 161 q 573 179 502 161 q 697 227 644 197 l 697 45 q 392 -14 571 -14 q 138 54 231 -14 q 46 243 46 122 q 119 431 46 362 q 342 521 193 499 l 342 524 q 178 726 178 572 q 279 931 178 857 q 545 1006 381 1006 z \"},\"ԑ\":{\"ha\":713,\"x_min\":26,\"x_max\":726,\"o\":\"m 517 323 l 416 323 q 288 297 335 323 q 241 225 241 271 q 272 166 241 187 q 361 146 302 146 q 480 160 423 146 q 600 207 536 174 l 600 40 q 328 -14 492 -14 q 107 39 188 -14 q 26 186 26 92 q 249 397 26 361 l 249 401 q 165 461 195 422 q 136 547 136 499 q 220 713 136 654 q 453 772 303 772 q 726 714 619 772 l 664 564 q 554 607 602 595 q 458 619 507 619 q 357 597 393 619 q 322 534 322 576 q 355 483 322 499 q 456 467 388 467 l 547 467 l 517 323 z \"},\"Ԓ\":{\"ha\":1078,\"x_min\":-41,\"x_max\":1007,\"o\":\"m 972 991 l 804 205 l 1007 205 l 947 -85 q 858 -275 921 -214 q 682 -336 794 -336 q 562 -318 611 -336 l 562 -155 q 640 -170 600 -170 q 712 -141 686 -170 q 750 -54 738 -113 l 761 0 l 555 0 l 729 817 l 545 817 q 435 425 491 600 q 330 158 380 251 q 219 26 280 66 q 56 -14 157 -14 q -41 3 1 -14 l -41 175 q 26 161 -5 161 q 99 183 71 161 q 155 252 127 204 q 217 399 182 299 q 297 651 253 499 q 389 991 340 803 l 972 991 z \"},\"ԓ\":{\"ha\":962,\"x_min\":-40,\"x_max\":907,\"o\":\"m 707 178 l 907 178 l 854 -85 q 764 -275 828 -214 q 589 -336 700 -336 q 469 -318 518 -336 l 469 -155 q 547 -170 507 -170 q 619 -141 593 -170 q 657 -54 645 -113 l 668 0 l 465 0 l 593 600 q 550 606 566 606 q 474 584 505 606 q 418 516 444 563 q 345 323 393 469 q 298 192 321 254 q 244 85 275 131 q 170 13 214 39 q 61 -14 126 -14 q -40 3 1 -14 l -40 171 q 17 160 -15 160 q 78 196 51 160 q 130 307 104 231 q 237 583 199 512 q 320 694 275 654 q 431 753 366 734 q 589 772 496 772 q 712 762 648 772 q 823 733 777 751 l 707 178 z \"},\"Ạ\":{\"ha\":872,\"x_min\":-83,\"x_max\":789,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 224 -208 q 257 -119 224 -150 q 349 -89 290 -89 q 423 -110 396 -89 q 450 -171 450 -130 q 420 -258 450 -225 q 328 -292 390 -292 q 224 -208 224 -292 z \"},\"ạ\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 214 -208 q 246 -119 214 -150 q 338 -89 279 -89 q 412 -110 385 -89 q 439 -171 439 -130 q 409 -258 439 -225 q 317 -292 379 -292 q 214 -208 214 -292 z \"},\"Ả\":{\"ha\":872,\"x_min\":-83,\"x_max\":789,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 768 1257 q 635 1104 768 1145 l 621 1056 l 498 1056 l 507 1156 q 582 1184 560 1165 q 604 1232 604 1202 q 593 1258 604 1249 q 562 1268 583 1268 q 477 1254 527 1268 l 477 1365 q 595 1382 526 1382 q 723 1350 677 1382 q 768 1257 768 1318 z \"},\"ả\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 701 1028 q 568 875 701 916 l 554 827 l 431 827 l 440 926 q 515 955 493 936 q 537 1003 537 973 q 526 1029 537 1019 q 494 1039 515 1039 q 410 1025 460 1039 l 410 1136 q 528 1153 459 1153 q 656 1121 610 1153 q 701 1028 701 1088 z \"},\"Ấ\":{\"ha\":872,\"x_min\":-83,\"x_max\":1061,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 694 1071 q 591 1178 644 1116 q 444 1071 530 1126 l 306 1071 l 306 1086 l 351 1129 q 493 1279 448 1221 l 709 1279 q 821 1086 749 1187 l 821 1071 l 694 1071 m 782 1203 l 782 1215 q 893 1357 814 1248 l 1061 1357 l 1061 1350 q 990 1283 1044 1330 q 888 1203 936 1236 l 782 1203 z \"},\"ấ\":{\"ha\":825,\"x_min\":61,\"x_max\":975,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 608 842 q 505 949 557 886 q 357 842 444 897 l 220 842 l 220 857 l 264 900 q 407 1050 361 992 l 623 1050 q 735 857 663 958 l 735 842 l 608 842 m 696 974 l 696 986 q 807 1128 728 1019 l 975 1128 l 975 1121 q 904 1054 958 1101 q 802 974 850 1006 l 696 974 z \"},\"Ầ\":{\"ha\":872,\"x_min\":-83,\"x_max\":821,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 694 1071 q 591 1178 644 1116 q 444 1071 530 1126 l 306 1071 l 306 1086 l 351 1129 q 493 1279 448 1221 l 709 1279 q 821 1086 749 1187 l 821 1071 l 694 1071 m 295 1204 q 221 1281 255 1241 q 174 1349 187 1322 l 174 1358 l 331 1358 q 388 1215 347 1294 l 388 1204 l 295 1204 z \"},\"ầ\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 623 842 q 519 949 572 886 q 372 842 458 897 l 235 842 l 235 857 l 279 900 q 422 1050 376 992 l 637 1050 q 750 857 678 958 l 750 842 l 623 842 m 224 975 q 150 1052 184 1012 q 102 1120 116 1093 l 102 1129 l 260 1129 q 317 986 275 1065 l 317 975 l 224 975 z \"},\"Ẩ\":{\"ha\":872,\"x_min\":-83,\"x_max\":994,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 994 1341 q 889 1236 994 1260 l 880 1200 l 796 1200 l 806 1279 q 892 1331 892 1283 q 854 1356 892 1356 q 798 1346 825 1356 l 798 1428 q 877 1439 829 1439 q 963 1412 932 1439 q 994 1341 994 1385 m 694 1071 q 591 1178 644 1116 q 444 1071 530 1126 l 306 1071 l 306 1086 l 351 1129 q 493 1279 448 1221 l 709 1279 q 821 1086 749 1187 l 821 1071 l 694 1071 z \"},\"ẩ\":{\"ha\":825,\"x_min\":61,\"x_max\":920,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 920 1112 q 815 1007 920 1031 l 806 971 l 722 971 l 732 1050 q 818 1101 818 1054 q 781 1126 818 1126 q 724 1117 751 1126 l 724 1198 q 803 1210 755 1210 q 889 1183 858 1210 q 920 1112 920 1156 m 621 842 q 517 949 570 886 q 370 842 456 897 l 232 842 l 232 857 l 277 900 q 419 1050 374 992 l 635 1050 q 747 857 675 958 l 747 842 l 621 842 z \"},\"Ẫ\":{\"ha\":872,\"x_min\":-83,\"x_max\":856,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 514 1346 q 477 1330 489 1346 q 458 1291 466 1314 l 367 1291 q 421 1413 380 1373 q 517 1454 462 1454 q 597 1437 559 1454 q 647 1415 635 1421 q 707 1398 677 1398 q 744 1412 731 1398 q 767 1455 756 1425 l 856 1455 q 705 1291 820 1291 q 657 1296 680 1291 q 599 1320 635 1301 q 544 1343 557 1339 q 514 1346 530 1346 m 694 1071 q 585 1164 613 1136 l 444 1071 l 306 1071 l 306 1086 l 350 1127 q 488 1265 447 1213 l 703 1265 q 791 1127 728 1210 l 821 1086 l 821 1071 l 694 1071 z \"},\"ẫ\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 437 1117 q 401 1101 412 1117 q 382 1061 389 1085 l 290 1061 q 344 1184 303 1143 q 440 1225 385 1225 q 520 1208 482 1225 q 570 1185 559 1192 q 631 1169 600 1169 q 667 1182 654 1169 q 690 1226 680 1196 l 779 1226 q 628 1061 743 1061 q 581 1067 603 1061 q 522 1090 559 1072 q 467 1114 481 1110 q 437 1117 453 1117 m 618 842 q 509 935 536 907 l 367 842 l 229 842 l 229 857 l 273 898 q 411 1036 370 984 l 627 1036 q 715 898 651 981 l 745 857 l 745 842 l 618 842 z \"},\"Ậ\":{\"ha\":872,\"x_min\":-83,\"x_max\":838,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 838 1071 l 703 1071 q 593 1185 661 1107 q 436 1071 522 1125 l 289 1071 l 289 1088 q 393 1187 332 1126 q 489 1293 454 1249 l 718 1293 q 768 1197 733 1257 q 838 1088 804 1137 l 838 1071 m 224 -208 q 257 -119 224 -150 q 349 -89 290 -89 q 423 -110 396 -89 q 450 -171 450 -130 q 420 -258 450 -225 q 328 -292 390 -292 q 224 -208 224 -292 z \"},\"ậ\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 755 842 l 621 842 q 511 956 578 878 q 353 842 439 896 l 206 842 l 206 859 q 310 958 249 897 q 406 1064 371 1019 l 635 1064 q 686 967 650 1027 q 755 859 721 907 l 755 842 m 214 -208 q 246 -119 214 -150 q 338 -89 279 -89 q 412 -110 385 -89 q 439 -171 439 -130 q 409 -258 439 -225 q 317 -292 379 -292 q 214 -208 214 -292 z \"},\"Ắ\":{\"ha\":872,\"x_min\":-83,\"x_max\":836,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 836 1300 q 742 1130 813 1189 q 564 1071 671 1071 q 411 1120 465 1071 q 358 1263 358 1170 q 361 1300 358 1284 l 458 1300 l 458 1288 q 574 1185 458 1185 q 734 1300 690 1185 l 836 1300 m 513 1247 l 513 1260 q 625 1402 556 1303 l 772 1402 l 772 1394 q 701 1327 755 1374 q 598 1247 646 1280 l 513 1247 z \"},\"ắ\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 779 1071 q 685 901 756 960 q 507 842 614 842 q 354 891 408 842 q 301 1034 301 941 q 304 1071 301 1055 l 401 1071 l 401 1059 q 517 956 401 956 q 677 1071 633 956 l 779 1071 m 456 1018 l 456 1031 q 568 1173 499 1074 l 715 1173 l 715 1165 q 644 1098 698 1145 q 541 1018 589 1050 l 456 1018 z \"},\"Ằ\":{\"ha\":872,\"x_min\":-83,\"x_max\":844,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 844 1300 q 750 1130 821 1189 q 571 1071 679 1071 q 419 1120 472 1071 q 366 1263 366 1170 q 368 1300 366 1284 l 466 1300 l 466 1288 q 581 1185 466 1185 q 742 1300 697 1185 l 844 1300 m 581 1247 q 460 1392 496 1325 l 460 1402 l 603 1402 q 660 1259 622 1330 l 660 1247 l 581 1247 z \"},\"ằ\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 778 1071 q 684 901 755 960 q 505 842 613 842 q 353 891 406 842 q 300 1034 300 941 q 302 1071 300 1055 l 400 1071 l 400 1059 q 515 956 400 956 q 676 1071 631 956 l 778 1071 m 515 1018 q 394 1162 430 1096 l 394 1173 l 537 1173 q 594 1029 556 1101 l 594 1018 l 515 1018 z \"},\"Ẳ\":{\"ha\":872,\"x_min\":-83,\"x_max\":836,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 836 1300 q 742 1130 813 1189 q 564 1071 671 1071 q 411 1120 465 1071 q 358 1263 358 1170 q 361 1300 358 1284 l 458 1300 l 458 1288 q 574 1185 458 1185 q 734 1300 690 1185 l 836 1300 m 699 1364 q 676 1302 699 1327 q 607 1267 653 1276 l 598 1238 l 528 1238 l 536 1312 q 590 1328 572 1318 q 607 1360 607 1339 q 576 1379 607 1379 q 526 1371 548 1379 l 526 1439 q 595 1449 555 1449 q 671 1425 644 1449 q 699 1364 699 1402 z \"},\"ẳ\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 777 1071 q 683 901 753 960 q 504 842 612 842 q 352 891 405 842 q 298 1034 298 941 q 301 1071 298 1055 l 399 1071 l 399 1059 q 514 956 399 956 q 675 1071 630 956 l 777 1071 m 639 1135 q 616 1073 639 1098 q 547 1038 593 1047 l 538 1008 l 468 1008 l 476 1083 q 530 1099 513 1088 q 547 1131 547 1109 q 517 1150 547 1150 q 467 1141 488 1150 l 467 1210 q 536 1219 495 1219 q 612 1196 585 1219 q 639 1135 639 1173 z \"},\"Ẵ\":{\"ha\":872,\"x_min\":-83,\"x_max\":851,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 830 1272 q 738 1123 807 1175 q 564 1071 669 1071 q 409 1115 465 1071 q 354 1239 354 1159 q 357 1272 354 1257 l 454 1272 l 453 1263 q 574 1185 453 1185 q 670 1204 633 1185 q 730 1272 707 1223 l 830 1272 m 513 1356 q 457 1304 471 1356 l 366 1304 q 421 1417 381 1380 q 515 1454 460 1454 q 580 1444 551 1454 q 642 1417 608 1435 q 705 1397 680 1397 q 742 1413 729 1397 q 764 1455 755 1428 l 851 1455 q 701 1304 815 1304 q 652 1310 673 1304 q 595 1333 631 1316 q 554 1351 570 1346 q 513 1356 538 1356 z \"},\"ẵ\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 766 1043 q 674 893 743 945 q 500 842 605 842 q 346 886 401 842 q 290 1010 290 930 q 293 1043 290 1028 l 390 1043 l 389 1034 q 510 956 389 956 q 606 975 570 956 q 667 1043 643 994 l 766 1043 m 450 1126 q 393 1075 408 1126 l 302 1075 q 357 1188 317 1151 q 452 1225 397 1225 q 516 1215 488 1225 q 578 1188 545 1206 q 642 1168 616 1168 q 679 1183 665 1168 q 700 1226 692 1199 l 787 1226 q 637 1075 751 1075 q 589 1081 610 1075 q 532 1104 568 1086 q 490 1122 507 1117 q 450 1126 474 1126 z \"},\"Ặ\":{\"ha\":872,\"x_min\":-83,\"x_max\":840,\"o\":\"m 571 236 l 250 236 l 134 0 l -83 0 l 436 996 l 689 996 l 789 0 l 587 0 l 571 236 m 561 412 l 543 650 q 536 821 536 739 l 536 846 q 463 673 507 764 l 335 412 l 561 412 m 840 1300 q 574 1071 803 1071 q 412 1120 470 1071 q 354 1255 354 1170 q 358 1300 354 1281 l 476 1300 q 501 1236 476 1256 q 581 1215 526 1215 q 667 1234 633 1215 q 712 1300 701 1252 l 840 1300 m 224 -208 q 257 -119 224 -150 q 349 -89 290 -89 q 423 -110 396 -89 q 450 -171 450 -130 q 420 -258 450 -225 q 328 -292 390 -292 q 224 -208 224 -292 z \"},\"ặ\":{\"ha\":825,\"x_min\":61,\"x_max\":802,\"o\":\"m 275 -14 q 118 59 176 -14 q 61 261 61 131 q 110 517 61 395 q 238 706 159 639 q 412 772 317 772 q 526 744 478 772 q 600 661 574 715 l 606 661 l 644 758 l 802 758 l 640 0 l 485 0 l 494 98 l 492 98 q 275 -14 401 -14 m 355 151 q 446 197 402 151 q 515 320 489 242 q 542 496 542 397 q 516 575 542 544 q 447 607 490 607 q 359 558 401 607 q 293 429 317 509 q 268 271 268 349 q 291 181 268 211 q 355 151 313 151 m 782 1071 q 515 842 745 842 q 354 891 412 842 q 296 1026 296 941 q 300 1071 296 1052 l 418 1071 q 443 1006 418 1027 q 522 986 467 986 q 609 1004 575 986 q 654 1071 642 1023 l 782 1071 m 214 -208 q 246 -119 214 -150 q 338 -89 279 -89 q 412 -110 385 -89 q 439 -171 439 -130 q 409 -258 439 -225 q 317 -292 379 -292 q 214 -208 214 -292 z \"},\"Ẹ\":{\"ha\":753,\"x_min\":36,\"x_max\":800,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 175 -208 q 208 -119 175 -150 q 299 -89 240 -89 q 373 -110 347 -89 q 400 -171 400 -130 q 370 -258 400 -225 q 278 -292 340 -292 q 175 -208 175 -292 z \"},\"ẹ\":{\"ha\":774,\"x_min\":61,\"x_max\":739,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 191 -208 q 224 -119 191 -150 q 315 -89 256 -89 q 390 -110 363 -89 q 416 -171 416 -130 q 387 -258 416 -225 q 294 -292 357 -292 q 191 -208 191 -292 z \"},\"Ẻ\":{\"ha\":753,\"x_min\":36,\"x_max\":800,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 721 1257 q 587 1104 721 1145 l 574 1056 l 450 1056 l 460 1156 q 535 1184 513 1165 q 557 1232 557 1202 q 546 1258 557 1249 q 514 1268 535 1268 q 429 1254 479 1268 l 429 1365 q 547 1382 479 1382 q 675 1350 630 1382 q 721 1257 721 1318 z \"},\"ẻ\":{\"ha\":774,\"x_min\":61,\"x_max\":739,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 681 1028 q 547 875 681 916 l 534 827 l 410 827 l 420 926 q 495 955 473 936 q 517 1003 517 973 q 506 1029 517 1019 q 474 1039 495 1039 q 389 1025 439 1039 l 389 1136 q 507 1153 439 1153 q 635 1121 590 1153 q 681 1028 681 1088 z \"},\"Ẽ\":{\"ha\":753,\"x_min\":36,\"x_max\":835,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 640 1071 q 582 1082 607 1071 q 534 1106 556 1093 q 493 1131 513 1120 q 450 1142 473 1142 q 413 1123 429 1142 q 387 1069 396 1104 l 267 1069 q 457 1279 307 1279 q 516 1268 490 1279 q 565 1243 543 1257 q 607 1219 587 1230 q 648 1208 627 1208 q 687 1226 671 1208 q 718 1280 703 1243 l 835 1280 q 640 1071 790 1071 z \"},\"ẽ\":{\"ha\":774,\"x_min\":61,\"x_max\":787,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 593 842 q 534 853 559 842 q 487 877 509 864 q 445 902 465 890 q 403 913 425 913 q 365 894 382 913 q 339 840 349 875 l 219 840 q 410 1050 259 1050 q 469 1039 443 1050 q 517 1014 495 1027 q 559 990 540 1001 q 600 979 579 979 q 640 997 623 979 q 671 1051 656 1014 l 787 1051 q 593 842 743 842 z \"},\"Ế\":{\"ha\":753,\"x_min\":36,\"x_max\":1025,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 658 1071 q 554 1178 607 1116 q 407 1071 493 1126 l 269 1071 l 269 1086 l 314 1129 q 456 1279 411 1221 l 672 1279 q 785 1086 713 1187 l 785 1071 l 658 1071 m 745 1203 l 745 1215 q 857 1357 778 1248 l 1025 1357 l 1025 1350 q 954 1283 1008 1330 q 851 1203 899 1236 l 745 1203 z \"},\"ế\":{\"ha\":774,\"x_min\":61,\"x_max\":966,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 600 842 q 496 949 549 886 q 349 842 435 897 l 211 842 l 211 857 l 256 900 q 398 1050 353 992 l 614 1050 q 726 857 654 958 l 726 842 l 600 842 m 687 974 l 687 986 q 798 1128 720 1019 l 966 1128 l 966 1121 q 895 1054 949 1101 q 793 974 841 1006 l 687 974 z \"},\"Ề\":{\"ha\":753,\"x_min\":36,\"x_max\":800,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 658 1071 q 554 1178 607 1116 q 407 1071 493 1126 l 269 1071 l 269 1086 l 314 1129 q 456 1279 411 1221 l 672 1279 q 785 1086 713 1187 l 785 1071 l 658 1071 m 258 1204 q 184 1281 218 1241 q 137 1349 151 1322 l 137 1358 l 294 1358 q 351 1215 310 1294 l 351 1204 l 258 1204 z \"},\"ề\":{\"ha\":774,\"x_min\":61,\"x_max\":739,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 600 842 q 496 949 549 886 q 349 842 435 897 l 211 842 l 211 857 l 256 900 q 398 1050 353 992 l 614 1050 q 726 857 654 958 l 726 842 l 600 842 m 200 975 q 126 1052 160 1012 q 79 1120 92 1093 l 79 1129 l 236 1129 q 293 986 252 1065 l 293 975 l 200 975 z \"},\"Ể\":{\"ha\":753,\"x_min\":36,\"x_max\":957,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 957 1341 q 852 1236 957 1260 l 843 1200 l 760 1200 l 769 1279 q 855 1331 855 1283 q 818 1356 855 1356 q 761 1346 788 1356 l 761 1428 q 840 1439 793 1439 q 926 1412 895 1439 q 957 1341 957 1385 m 658 1071 q 554 1178 607 1116 q 407 1071 493 1126 l 269 1071 l 269 1086 l 314 1129 q 456 1279 411 1221 l 672 1279 q 785 1086 713 1187 l 785 1071 l 658 1071 z \"},\"ể\":{\"ha\":774,\"x_min\":61,\"x_max\":899,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 899 1112 q 794 1007 899 1031 l 785 971 l 701 971 l 711 1050 q 797 1101 797 1054 q 760 1126 797 1126 q 703 1117 730 1126 l 703 1198 q 782 1210 734 1210 q 868 1183 837 1210 q 899 1112 899 1156 m 600 842 q 496 949 549 886 q 349 842 435 897 l 211 842 l 211 857 l 256 900 q 398 1050 353 992 l 614 1050 q 726 857 654 958 l 726 842 l 600 842 z \"},\"Ễ\":{\"ha\":753,\"x_min\":36,\"x_max\":819,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 477 1346 q 441 1330 452 1346 q 422 1291 429 1314 l 330 1291 q 384 1413 343 1373 q 480 1454 425 1454 q 561 1437 522 1454 q 610 1415 599 1421 q 671 1398 640 1398 q 707 1412 694 1398 q 730 1455 720 1425 l 819 1455 q 668 1291 783 1291 q 621 1296 643 1291 q 562 1320 599 1301 q 507 1343 521 1339 q 477 1346 493 1346 m 658 1071 q 549 1164 576 1136 l 407 1071 l 269 1071 l 269 1086 l 313 1127 q 451 1265 410 1213 l 667 1265 q 755 1127 691 1210 l 785 1086 l 785 1071 l 658 1071 z \"},\"ễ\":{\"ha\":774,\"x_min\":61,\"x_max\":761,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 419 1117 q 382 1101 394 1117 q 363 1061 371 1085 l 272 1061 q 326 1184 285 1143 q 422 1225 367 1225 q 502 1208 464 1225 q 552 1185 541 1192 q 612 1169 582 1169 q 649 1182 636 1169 q 672 1226 661 1196 l 761 1226 q 610 1061 725 1061 q 563 1067 585 1061 q 504 1090 541 1072 q 449 1114 463 1110 q 419 1117 435 1117 m 600 842 q 490 935 518 907 l 349 842 l 211 842 l 211 857 l 255 898 q 393 1036 352 984 l 608 1036 q 696 898 633 981 l 726 857 l 726 842 l 600 842 z \"},\"Ệ\":{\"ha\":753,\"x_min\":36,\"x_max\":800,\"o\":\"m 590 0 l 36 0 l 245 991 l 800 991 l 764 819 l 416 819 l 371 602 l 694 602 l 657 429 l 334 429 l 279 174 l 627 174 l 590 0 m 798 1071 l 664 1071 q 554 1185 621 1107 q 397 1071 483 1125 l 250 1071 l 250 1088 q 353 1187 292 1126 q 450 1293 414 1249 l 679 1293 q 729 1197 694 1257 q 798 1088 764 1137 l 798 1071 m 175 -208 q 208 -119 175 -150 q 299 -89 240 -89 q 373 -110 347 -89 q 400 -171 400 -130 q 370 -258 400 -225 q 278 -292 340 -292 q 175 -208 175 -292 z \"},\"ệ\":{\"ha\":774,\"x_min\":61,\"x_max\":742,\"o\":\"m 472 625 q 359 571 412 625 q 290 439 307 517 l 321 439 q 485 472 426 439 q 543 561 543 505 q 472 625 543 625 m 361 -14 q 140 63 218 -14 q 61 279 61 140 q 117 535 61 420 q 269 712 173 651 q 485 772 364 772 q 672 717 605 772 q 739 566 739 662 q 626 370 739 439 q 302 301 513 301 l 268 301 l 267 287 l 267 273 q 301 176 267 212 q 401 140 336 140 q 509 153 460 140 q 625 199 557 166 l 625 45 q 361 -14 509 -14 m 742 842 l 608 842 q 498 956 565 878 q 340 842 427 896 l 193 842 l 193 859 q 297 958 236 897 q 393 1064 358 1019 l 623 1064 q 673 967 637 1027 q 742 859 708 907 l 742 842 m 191 -208 q 224 -119 191 -150 q 315 -89 256 -89 q 390 -110 363 -89 q 416 -171 416 -130 q 387 -258 416 -225 q 294 -292 357 -292 q 191 -208 191 -292 z \"},\"ỉ\":{\"ha\":412,\"x_min\":25,\"x_max\":505,\"o\":\"m 229 0 l 25 0 l 186 758 l 390 758 l 229 0 m 505 1028 q 371 875 505 916 l 357 827 l 234 827 l 243 926 q 318 955 296 936 q 340 1003 340 973 q 330 1029 340 1019 q 298 1039 319 1039 q 213 1025 263 1039 l 213 1136 q 331 1153 262 1153 q 459 1121 414 1153 q 505 1028 505 1088 z \"},\"ị\":{\"ha\":412,\"x_min\":-22,\"x_max\":443,\"o\":\"m 218 936 q 251 1025 218 995 q 342 1055 283 1055 q 417 1034 391 1055 q 443 974 443 1013 q 413 886 443 920 q 321 852 383 852 q 218 936 218 852 m 229 0 l 25 0 l 186 758 l 390 758 l 229 0 m -22 -208 q 10 -119 -22 -150 q 102 -89 43 -89 q 176 -110 149 -89 q 203 -171 203 -130 q 173 -258 203 -225 q 81 -292 143 -292 q -22 -208 -22 -292 z \"},\"Ọ\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 294 -208 q 327 -119 294 -150 q 418 -89 359 -89 q 493 -110 466 -89 q 519 -171 519 -130 q 490 -258 519 -225 q 397 -292 460 -292 q 294 -208 294 -292 z \"},\"ọ\":{\"ha\":812,\"x_min\":61,\"x_max\":751,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 208 -208 q 241 -119 208 -150 q 332 -89 273 -89 q 407 -110 380 -89 q 433 -171 433 -130 q 404 -258 433 -225 q 311 -292 374 -292 q 208 -208 208 -292 z \"},\"Ỏ\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 836 1257 q 703 1104 836 1145 l 689 1056 l 566 1056 l 575 1156 q 650 1184 628 1165 q 672 1232 672 1202 q 661 1258 672 1249 q 629 1268 650 1268 q 545 1254 595 1268 l 545 1365 q 663 1382 594 1382 q 791 1350 745 1382 q 836 1257 836 1318 z \"},\"ỏ\":{\"ha\":812,\"x_min\":61,\"x_max\":751,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 678 1028 q 545 875 678 916 l 531 827 l 408 827 l 417 926 q 492 955 470 936 q 514 1003 514 973 q 503 1029 514 1019 q 471 1039 492 1039 q 387 1025 437 1039 l 387 1136 q 505 1153 436 1153 q 633 1121 587 1153 q 678 1028 678 1088 z \"},\"Ố\":{\"ha\":1014,\"x_min\":83,\"x_max\":1114,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 747 1071 q 643 1178 696 1116 q 496 1071 582 1126 l 358 1071 l 358 1086 l 403 1129 q 545 1279 500 1221 l 761 1279 q 873 1086 802 1187 l 873 1071 l 747 1071 m 834 1203 l 834 1215 q 945 1357 867 1248 l 1114 1357 l 1114 1350 q 1042 1283 1097 1330 q 940 1203 988 1236 l 834 1203 z \"},\"ố\":{\"ha\":812,\"x_min\":61,\"x_max\":977,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 610 842 q 506 949 559 886 q 359 842 445 897 l 221 842 l 221 857 l 266 900 q 408 1050 363 992 l 624 1050 q 736 857 665 958 l 736 842 l 610 842 m 697 974 l 697 986 q 808 1128 730 1019 l 977 1128 l 977 1121 q 905 1054 960 1101 q 803 974 851 1006 l 697 974 z \"},\"Ồ\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 747 1071 q 643 1178 696 1116 q 496 1071 582 1126 l 358 1071 l 358 1086 l 403 1129 q 545 1279 500 1221 l 761 1279 q 873 1086 802 1187 l 873 1071 l 747 1071 m 347 1204 q 273 1281 307 1241 q 226 1349 239 1322 l 226 1358 l 383 1358 q 440 1215 399 1294 l 440 1204 l 347 1204 z \"},\"ồ\":{\"ha\":812,\"x_min\":61,\"x_max\":751,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 610 842 q 506 949 559 886 q 359 842 445 897 l 221 842 l 221 857 l 266 900 q 408 1050 363 992 l 624 1050 q 736 857 665 958 l 736 842 l 610 842 m 210 975 q 136 1052 170 1012 q 89 1120 102 1093 l 89 1129 l 246 1129 q 303 986 262 1065 l 303 975 l 210 975 z \"},\"Ổ\":{\"ha\":1014,\"x_min\":83,\"x_max\":1046,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 1046 1341 q 941 1236 1046 1260 l 932 1200 l 848 1200 l 858 1279 q 944 1331 944 1283 q 907 1356 944 1356 q 850 1346 877 1356 l 850 1428 q 929 1439 882 1439 q 1015 1412 984 1439 q 1046 1341 1046 1385 m 747 1071 q 643 1178 696 1116 q 496 1071 582 1126 l 358 1071 l 358 1086 l 403 1129 q 545 1279 500 1221 l 761 1279 q 873 1086 802 1187 l 873 1071 l 747 1071 z \"},\"ổ\":{\"ha\":812,\"x_min\":61,\"x_max\":909,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 909 1112 q 804 1007 909 1031 l 795 971 l 711 971 l 721 1050 q 807 1101 807 1054 q 770 1126 807 1126 q 713 1117 740 1126 l 713 1198 q 792 1210 745 1210 q 878 1183 847 1210 q 909 1112 909 1156 m 610 842 q 506 949 559 886 q 359 842 445 897 l 221 842 l 221 857 l 266 900 q 408 1050 363 992 l 624 1050 q 736 857 665 958 l 736 842 l 610 842 z \"},\"Ỗ\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 566 1346 q 530 1330 541 1346 q 511 1291 518 1314 l 419 1291 q 473 1413 432 1373 q 569 1454 514 1454 q 649 1437 611 1454 q 699 1415 688 1421 q 760 1398 729 1398 q 796 1412 783 1398 q 819 1455 808 1425 l 908 1455 q 757 1291 872 1291 q 710 1296 732 1291 q 651 1320 688 1301 q 596 1343 610 1339 q 566 1346 582 1346 m 747 1071 q 637 1164 665 1136 l 496 1071 l 358 1071 l 358 1086 l 402 1127 q 540 1265 499 1213 l 755 1265 q 844 1127 780 1210 l 873 1086 l 873 1071 l 747 1071 z \"},\"ỗ\":{\"ha\":812,\"x_min\":61,\"x_max\":771,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 429 1117 q 393 1101 404 1117 q 374 1061 381 1085 l 282 1061 q 336 1184 295 1143 q 432 1225 377 1225 q 512 1208 474 1225 q 562 1185 551 1192 q 623 1169 592 1169 q 659 1182 646 1169 q 682 1226 671 1196 l 771 1226 q 620 1061 735 1061 q 573 1067 595 1061 q 514 1090 551 1072 q 459 1114 473 1110 q 429 1117 445 1117 m 610 842 q 500 935 528 907 l 359 842 l 221 842 l 221 857 l 265 898 q 403 1036 362 984 l 618 1036 q 707 898 643 981 l 736 857 l 736 842 l 610 842 z \"},\"Ộ\":{\"ha\":1014,\"x_min\":83,\"x_max\":971,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 876 909 781 1007 q 971 636 971 812 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 887 1071 l 753 1071 q 643 1185 710 1107 q 486 1071 572 1125 l 338 1071 l 338 1088 q 442 1187 381 1126 q 538 1293 503 1249 l 768 1293 q 818 1197 783 1257 q 887 1088 853 1137 l 887 1071 m 294 -208 q 327 -119 294 -150 q 418 -89 359 -89 q 493 -110 466 -89 q 519 -171 519 -130 q 490 -258 519 -225 q 397 -292 460 -292 q 294 -208 294 -292 z \"},\"ộ\":{\"ha\":812,\"x_min\":61,\"x_max\":752,\"o\":\"m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 751 472 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 q 674 692 597 772 q 751 472 751 612 m 752 842 l 618 842 q 508 956 575 878 q 351 842 437 896 l 203 842 l 203 859 q 307 958 246 897 q 404 1064 368 1019 l 633 1064 q 683 967 648 1027 q 752 859 718 907 l 752 842 m 208 -208 q 241 -119 208 -150 q 332 -89 273 -89 q 407 -110 380 -89 q 433 -171 433 -130 q 404 -258 433 -225 q 311 -292 374 -292 q 208 -208 208 -292 z \"},\"Ớ\":{\"ha\":1072,\"x_min\":83,\"x_max\":1219,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 909 867 816 1007 q 1007 1055 985 917 l 1213 1055 l 1219 1039 q 1124 860 1187 931 q 958 750 1061 789 q 971 636 971 693 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 511 1088 q 661 1293 564 1147 l 888 1293 l 888 1282 q 784 1178 857 1244 q 652 1071 711 1113 l 511 1071 l 511 1088 z \"},\"ớ\":{\"ha\":893,\"x_min\":61,\"x_max\":1015,\"o\":\"m 464 772 q 690 673 612 772 q 765 739 736 692 q 808 872 793 785 l 1008 872 l 1015 856 q 920 667 983 734 q 742 559 857 600 q 751 472 751 525 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 376 859 q 527 1064 430 918 l 754 1064 l 754 1053 q 650 949 723 1015 q 518 842 576 884 l 376 842 l 376 859 z \"},\"Ờ\":{\"ha\":1072,\"x_min\":83,\"x_max\":1219,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 909 867 816 1007 q 1007 1055 985 917 l 1213 1055 l 1219 1039 q 1124 860 1187 931 q 958 750 1061 789 q 971 636 971 693 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 714 1071 l 589 1071 q 495 1175 541 1118 q 425 1279 450 1232 l 425 1293 l 636 1293 q 714 1088 661 1193 l 714 1071 z \"},\"ờ\":{\"ha\":893,\"x_min\":61,\"x_max\":1015,\"o\":\"m 464 772 q 690 673 612 772 q 765 739 736 692 q 808 872 793 785 l 1008 872 l 1015 856 q 920 667 983 734 q 742 559 857 600 q 751 472 751 525 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 568 842 l 443 842 q 349 946 395 888 q 279 1050 303 1003 l 279 1064 l 490 1064 q 568 859 514 964 l 568 842 z \"},\"Ở\":{\"ha\":1072,\"x_min\":83,\"x_max\":1219,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 909 867 816 1007 q 1007 1055 985 917 l 1213 1055 l 1219 1039 q 1124 860 1187 931 q 958 750 1061 789 q 971 636 971 693 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 836 1257 q 703 1104 836 1145 l 689 1056 l 566 1056 l 575 1156 q 650 1184 628 1165 q 672 1232 672 1202 q 661 1258 672 1249 q 629 1268 650 1268 q 545 1254 595 1268 l 545 1365 q 663 1382 594 1382 q 791 1350 745 1382 q 836 1257 836 1318 z \"},\"ở\":{\"ha\":893,\"x_min\":61,\"x_max\":1015,\"o\":\"m 464 772 q 690 673 612 772 q 765 739 736 692 q 808 872 793 785 l 1008 872 l 1015 856 q 920 667 983 734 q 742 559 857 600 q 751 472 751 525 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 678 1028 q 545 875 678 916 l 531 827 l 408 827 l 417 926 q 492 955 470 936 q 514 1003 514 973 q 503 1029 514 1019 q 471 1039 492 1039 q 387 1025 437 1039 l 387 1136 q 505 1153 436 1153 q 633 1121 587 1153 q 678 1028 678 1088 z \"},\"Ỡ\":{\"ha\":1072,\"x_min\":83,\"x_max\":1219,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 909 867 816 1007 q 1007 1055 985 917 l 1213 1055 l 1219 1039 q 1124 860 1187 931 q 958 750 1061 789 q 971 636 971 693 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 726 1071 q 668 1082 693 1071 q 621 1106 642 1093 q 579 1131 599 1120 q 536 1142 559 1142 q 499 1123 515 1142 q 473 1069 482 1104 l 353 1069 q 543 1279 393 1279 q 603 1268 576 1279 q 651 1243 629 1257 q 693 1219 673 1230 q 734 1208 713 1208 q 773 1226 757 1208 q 804 1280 789 1243 l 921 1280 q 726 1071 876 1071 z \"},\"ỡ\":{\"ha\":893,\"x_min\":61,\"x_max\":1015,\"o\":\"m 464 772 q 690 673 612 772 q 765 739 736 692 q 808 872 793 785 l 1008 872 l 1015 856 q 920 667 983 734 q 742 559 857 600 q 751 472 751 525 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 580 842 q 521 853 547 842 q 474 877 496 864 q 432 902 452 890 q 390 913 412 913 q 352 894 369 913 q 326 840 336 875 l 206 840 q 397 1050 246 1050 q 456 1039 430 1050 q 505 1014 482 1027 q 547 990 527 1001 q 587 979 566 979 q 627 997 610 979 q 658 1051 643 1014 l 774 1051 q 580 842 730 842 z \"},\"Ợ\":{\"ha\":1072,\"x_min\":83,\"x_max\":1219,\"o\":\"m 971 636 q 904 293 971 444 q 720 64 837 141 q 452 -14 604 -14 q 181 86 278 -14 q 83 364 83 186 q 151 695 83 544 q 336 926 218 846 q 608 1007 454 1007 q 909 867 816 1007 q 1007 1055 985 917 l 1213 1055 l 1219 1039 q 1124 860 1187 931 q 958 750 1061 789 q 971 636 971 693 m 591 832 q 441 770 509 832 q 333 600 372 708 q 294 364 294 491 q 339 214 294 264 q 467 163 385 163 q 616 222 549 163 q 722 389 684 281 q 760 631 760 496 q 715 780 760 727 q 591 832 671 832 m 294 -208 q 327 -119 294 -150 q 418 -89 359 -89 q 493 -110 466 -89 q 519 -171 519 -130 q 490 -258 519 -225 q 397 -292 460 -292 q 294 -208 294 -292 z \"},\"ợ\":{\"ha\":893,\"x_min\":61,\"x_max\":1015,\"o\":\"m 464 772 q 690 673 612 772 q 765 739 736 692 q 808 872 793 785 l 1008 872 l 1015 856 q 920 667 983 734 q 742 559 857 600 q 751 472 751 525 q 704 218 751 329 q 566 47 656 108 q 351 -14 475 -14 q 140 66 219 -14 q 61 278 61 146 q 110 535 61 422 q 250 710 158 648 q 464 772 341 772 m 546 472 q 449 606 546 606 q 358 564 398 606 q 292 443 317 523 q 267 278 267 363 q 368 153 267 153 q 460 194 419 153 q 523 310 500 236 q 546 472 546 385 m 208 -208 q 241 -119 208 -150 q 332 -89 273 -89 q 407 -110 380 -89 q 433 -171 433 -130 q 404 -258 433 -225 q 311 -292 374 -292 q 208 -208 208 -292 z \"},\"Ụ\":{\"ha\":960,\"x_min\":96,\"x_max\":972,\"o\":\"m 972 991 l 836 350 q 688 78 798 170 q 404 -14 579 -14 q 178 63 260 -14 q 96 272 96 140 q 106 366 96 321 l 239 991 l 446 991 l 314 368 q 302 283 302 318 q 431 163 302 163 q 563 215 514 163 q 633 370 612 267 l 765 991 l 972 991 m 273 -208 q 306 -119 273 -150 q 397 -89 338 -89 q 472 -110 445 -89 q 498 -171 498 -130 q 469 -258 498 -225 q 376 -292 439 -292 q 273 -208 273 -292 z \"},\"ụ\":{\"ha\":839,\"x_min\":75,\"x_max\":815,\"o\":\"m 178 758 l 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 125 42 174 -14 q 75 204 75 98 q 92 349 75 267 l 178 758 m 220 -208 q 253 -119 220 -150 q 345 -89 286 -89 q 419 -110 392 -89 q 446 -171 446 -130 q 416 -258 446 -225 q 323 -292 386 -292 q 220 -208 220 -292 z \"},\"Ủ\":{\"ha\":960,\"x_min\":96,\"x_max\":972,\"o\":\"m 972 991 l 836 350 q 688 78 798 170 q 404 -14 579 -14 q 178 63 260 -14 q 96 272 96 140 q 106 366 96 321 l 239 991 l 446 991 l 314 368 q 302 283 302 318 q 431 163 302 163 q 563 215 514 163 q 633 370 612 267 l 765 991 l 972 991 m 815 1257 q 682 1104 815 1145 l 668 1056 l 545 1056 l 554 1156 q 629 1184 607 1165 q 651 1232 651 1202 q 640 1258 651 1249 q 608 1268 629 1268 q 524 1254 574 1268 l 524 1365 q 642 1382 573 1382 q 770 1350 724 1382 q 815 1257 815 1318 z \"},\"ủ\":{\"ha\":839,\"x_min\":75,\"x_max\":815,\"o\":\"m 178 758 l 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 125 42 174 -14 q 75 204 75 98 q 92 349 75 267 l 178 758 m 704 1028 q 570 875 704 916 l 557 827 l 433 827 l 443 926 q 518 955 496 936 q 540 1003 540 973 q 529 1029 540 1019 q 497 1039 518 1039 q 412 1025 463 1039 l 412 1136 q 530 1153 462 1153 q 659 1121 613 1153 q 704 1028 704 1088 z \"},\"Ứ\":{\"ha\":1076,\"x_min\":96,\"x_max\":1280,\"o\":\"m 972 991 l 946 867 q 1026 925 998 883 q 1068 1055 1055 968 l 1274 1055 l 1280 1039 q 1147 824 1240 901 q 918 739 1054 748 l 836 350 q 688 78 798 170 q 404 -14 579 -14 q 178 63 260 -14 q 96 272 96 140 q 106 366 96 321 l 239 991 l 446 991 l 314 368 q 302 283 302 318 q 431 163 302 163 q 563 215 514 163 q 633 370 612 267 l 765 991 l 972 991 m 513 1088 q 664 1293 567 1147 l 891 1293 l 891 1282 q 787 1178 860 1244 q 655 1071 713 1113 l 513 1071 l 513 1088 z \"},\"ứ\":{\"ha\":987,\"x_min\":72,\"x_max\":1135,\"o\":\"m 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 799 682 q 857 712 833 691 q 894 766 880 733 q 922 871 909 799 l 1128 871 l 1135 854 q 1003 642 1095 718 q 772 554 911 565 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 123 42 175 -14 q 72 204 72 98 q 92 349 72 250 l 178 758 l 382 758 m 404 859 q 555 1064 458 918 l 782 1064 l 782 1053 q 677 949 751 1015 q 546 842 604 884 l 404 842 l 404 859 z \"},\"Ừ\":{\"ha\":1076,\"x_min\":96,\"x_max\":1280,\"o\":\"m 972 991 l 946 867 q 1026 925 998 883 q 1068 1055 1055 968 l 1274 1055 l 1280 1039 q 1147 824 1240 901 q 918 739 1054 748 l 836 350 q 688 78 798 170 q 404 -14 579 -14 q 178 63 260 -14 q 96 272 96 140 q 106 366 96 321 l 239 991 l 446 991 l 314 368 q 302 283 302 318 q 431 163 302 163 q 563 215 514 163 q 633 370 612 267 l 765 991 l 972 991 m 680 1071 l 555 1071 q 461 1175 507 1118 q 391 1279 415 1232 l 391 1293 l 602 1293 q 680 1088 626 1193 l 680 1071 z \"},\"ừ\":{\"ha\":987,\"x_min\":72,\"x_max\":1135,\"o\":\"m 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 799 682 q 857 712 833 691 q 894 766 880 733 q 922 871 909 799 l 1128 871 l 1135 854 q 1003 642 1095 718 q 772 554 911 565 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 123 42 175 -14 q 72 204 72 98 q 92 349 72 250 l 178 758 l 382 758 m 573 842 l 448 842 q 354 946 400 888 q 284 1050 309 1003 l 284 1064 l 495 1064 q 573 859 519 964 l 573 842 z \"},\"Ử\":{\"ha\":1076,\"x_min\":96,\"x_max\":1280,\"o\":\"m 972 991 l 946 867 q 1026 925 998 883 q 1068 1055 1055 968 l 1274 1055 l 1280 1039 q 1147 824 1240 901 q 918 739 1054 748 l 836 350 q 688 78 798 170 q 404 -14 579 -14 q 178 63 260 -14 q 96 272 96 140 q 106 366 96 321 l 239 991 l 446 991 l 314 368 q 302 283 302 318 q 431 163 302 163 q 563 215 514 163 q 633 370 612 267 l 765 991 l 972 991 m 815 1257 q 682 1104 815 1145 l 668 1056 l 545 1056 l 554 1156 q 629 1184 607 1165 q 651 1232 651 1202 q 640 1258 651 1249 q 608 1268 629 1268 q 524 1254 574 1268 l 524 1365 q 642 1382 573 1382 q 770 1350 724 1382 q 815 1257 815 1318 z \"},\"ử\":{\"ha\":987,\"x_min\":72,\"x_max\":1135,\"o\":\"m 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 799 682 q 857 712 833 691 q 894 766 880 733 q 922 871 909 799 l 1128 871 l 1135 854 q 1003 642 1095 718 q 772 554 911 565 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 123 42 175 -14 q 72 204 72 98 q 92 349 72 250 l 178 758 l 382 758 m 704 1028 q 570 875 704 916 l 557 827 l 433 827 l 443 926 q 518 955 496 936 q 540 1003 540 973 q 529 1029 540 1019 q 497 1039 518 1039 q 412 1025 463 1039 l 412 1136 q 530 1153 462 1153 q 659 1121 613 1153 q 704 1028 704 1088 z \"},\"Ữ\":{\"ha\":1076,\"x_min\":96,\"x_max\":1280,\"o\":\"m 972 991 l 946 867 q 1026 925 998 883 q 1068 1055 1055 968 l 1274 1055 l 1280 1039 q 1147 824 1240 901 q 918 739 1054 748 l 836 350 q 688 78 798 170 q 404 -14 579 -14 q 178 63 260 -14 q 96 272 96 140 q 106 366 96 321 l 239 991 l 446 991 l 314 368 q 302 283 302 318 q 431 163 302 163 q 563 215 514 163 q 633 370 612 267 l 765 991 l 972 991 m 720 1071 q 661 1082 686 1071 q 614 1106 635 1093 q 572 1131 592 1120 q 530 1142 552 1142 q 492 1123 509 1142 q 466 1069 475 1104 l 346 1069 q 536 1279 386 1279 q 596 1268 570 1279 q 644 1243 622 1257 q 686 1219 667 1230 q 727 1208 706 1208 q 766 1226 750 1208 q 798 1280 783 1243 l 914 1280 q 720 1071 869 1071 z \"},\"ữ\":{\"ha\":987,\"x_min\":72,\"x_max\":1135,\"o\":\"m 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 799 682 q 857 712 833 691 q 894 766 880 733 q 922 871 909 799 l 1128 871 l 1135 854 q 1003 642 1095 718 q 772 554 911 565 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 123 42 175 -14 q 72 204 72 98 q 92 349 72 250 l 178 758 l 382 758 m 621 842 q 562 853 587 842 q 515 877 536 864 q 473 902 493 890 q 431 913 453 913 q 393 894 410 913 q 367 840 376 875 l 247 840 q 437 1050 287 1050 q 497 1039 471 1050 q 545 1014 523 1027 q 587 990 568 1001 q 628 979 607 979 q 667 997 651 979 q 699 1051 684 1014 l 815 1051 q 621 842 770 842 z \"},\"Ự\":{\"ha\":1076,\"x_min\":96,\"x_max\":1280,\"o\":\"m 972 991 l 946 867 q 1026 925 998 883 q 1068 1055 1055 968 l 1274 1055 l 1280 1039 q 1147 824 1240 901 q 918 739 1054 748 l 836 350 q 688 78 798 170 q 404 -14 579 -14 q 178 63 260 -14 q 96 272 96 140 q 106 366 96 321 l 239 991 l 446 991 l 314 368 q 302 283 302 318 q 431 163 302 163 q 563 215 514 163 q 633 370 612 267 l 765 991 l 972 991 m 273 -208 q 306 -119 273 -150 q 397 -89 338 -89 q 472 -110 445 -89 q 498 -171 498 -130 q 469 -258 498 -225 q 376 -292 439 -292 q 273 -208 273 -292 z \"},\"ự\":{\"ha\":987,\"x_min\":72,\"x_max\":1135,\"o\":\"m 382 758 l 289 315 q 278 235 278 269 q 351 151 278 151 q 465 229 414 151 q 545 444 515 306 l 611 758 l 815 758 l 799 682 q 857 712 833 691 q 894 766 880 733 q 922 871 909 799 l 1128 871 l 1135 854 q 1003 642 1095 718 q 772 554 911 565 l 654 0 l 498 0 l 513 140 l 509 140 q 268 -14 410 -14 q 123 42 175 -14 q 72 204 72 98 q 92 349 72 250 l 178 758 l 382 758 m 220 -208 q 253 -119 220 -150 q 345 -89 286 -89 q 419 -110 392 -89 q 446 -171 446 -130 q 416 -258 446 -225 q 323 -292 386 -292 q 220 -208 220 -292 z \"},\"Ỵ\":{\"ha\":783,\"x_min\":126,\"x_max\":911,\"o\":\"m 425 590 l 679 991 l 911 991 l 492 379 l 411 0 l 205 0 l 286 379 l 126 991 l 338 991 l 425 590 m 161 -208 q 193 -119 161 -150 q 285 -89 226 -89 q 359 -110 332 -89 q 386 -171 386 -130 q 356 -258 386 -225 q 264 -292 326 -292 q 161 -208 161 -292 z \"},\"ỵ\":{\"ha\":721,\"x_min\":-96,\"x_max\":793,\"o\":\"m 69 758 l 269 758 l 307 407 q 317 208 317 324 l 321 208 q 351 289 334 243 q 395 393 367 336 l 571 758 l 793 758 l 332 -109 q 4 -334 212 -334 q -96 -321 -57 -334 l -96 -158 q -17 -167 -50 -167 q 83 -134 40 -167 q 163 -33 126 -102 l 180 0 l 69 758 m 393 -208 q 425 -119 393 -150 q 517 -89 458 -89 q 591 -110 564 -89 q 618 -171 618 -130 q 588 -258 618 -225 q 496 -292 558 -292 q 393 -208 393 -292 z \"},\"Ỷ\":{\"ha\":783,\"x_min\":126,\"x_max\":911,\"o\":\"m 425 590 l 679 991 l 911 991 l 492 379 l 411 0 l 205 0 l 286 379 l 126 991 l 338 991 l 425 590 m 694 1257 q 561 1104 694 1145 l 547 1056 l 424 1056 l 433 1156 q 508 1184 486 1165 q 530 1232 530 1202 q 519 1258 530 1249 q 488 1268 509 1268 q 403 1254 453 1268 l 403 1365 q 521 1382 452 1382 q 649 1350 604 1382 q 694 1257 694 1318 z \"},\"ỷ\":{\"ha\":721,\"x_min\":-96,\"x_max\":793,\"o\":\"m 69 758 l 269 758 l 307 407 q 317 208 317 324 l 321 208 q 351 289 334 243 q 395 393 367 336 l 571 758 l 793 758 l 332 -109 q 4 -334 212 -334 q -96 -321 -57 -334 l -96 -158 q -17 -167 -50 -167 q 83 -134 40 -167 q 163 -33 126 -102 l 180 0 l 69 758 m 625 1028 q 492 875 625 916 l 478 827 l 355 827 l 364 926 q 439 955 417 936 q 461 1003 461 973 q 450 1029 461 1019 q 418 1039 439 1039 q 334 1025 384 1039 l 334 1136 q 452 1153 383 1153 q 580 1121 534 1153 q 625 1028 625 1088 z \"},\"Ỹ\":{\"ha\":783,\"x_min\":126,\"x_max\":911,\"o\":\"m 425 590 l 679 991 l 911 991 l 492 379 l 411 0 l 205 0 l 286 379 l 126 991 l 338 991 l 425 590 m 615 1071 q 556 1082 582 1071 q 509 1106 531 1093 q 468 1131 488 1120 q 425 1142 448 1142 q 388 1123 404 1142 q 361 1069 371 1104 l 241 1069 q 432 1279 281 1279 q 491 1268 465 1279 q 540 1243 517 1257 q 582 1219 562 1230 q 623 1208 602 1208 q 662 1226 646 1208 q 693 1280 678 1243 l 810 1280 q 615 1071 765 1071 z \"},\"ỹ\":{\"ha\":721,\"x_min\":-96,\"x_max\":793,\"o\":\"m 69 758 l 269 758 l 307 407 q 317 208 317 324 l 321 208 q 351 289 334 243 q 395 393 367 336 l 571 758 l 793 758 l 332 -109 q 4 -334 212 -334 q -96 -321 -57 -334 l -96 -158 q -17 -167 -50 -167 q 83 -134 40 -167 q 163 -33 126 -102 l 180 0 l 69 758 m 536 842 q 478 853 503 842 q 431 877 452 864 q 389 902 409 890 q 347 913 369 913 q 309 894 326 913 q 283 840 292 875 l 163 840 q 353 1050 203 1050 q 413 1039 387 1050 q 461 1014 439 1027 q 503 990 484 1001 q 544 979 523 979 q 583 997 567 979 q 614 1051 600 1014 l 731 1051 q 536 842 686 842 z \"},\"₫\":{\"ha\":825,\"x_min\":37,\"x_max\":945,\"o\":\"m 404 730 q 506 707 464 730 q 579 629 549 684 l 585 629 q 588 684 585 648 q 608 811 592 721 l 408 811 l 436 946 l 636 946 l 660 1055 l 864 1055 l 840 946 l 945 946 l 917 811 l 811 811 l 640 0 l 485 0 l 494 98 l 492 98 q 390 12 439 37 q 282 -14 340 -14 q 120 58 179 -14 q 61 262 61 130 q 109 498 61 385 q 233 671 156 612 q 404 730 309 730 m 364 151 q 450 192 410 151 q 515 308 489 232 q 541 457 541 384 q 518 536 541 506 q 447 566 496 566 q 357 524 399 566 q 292 414 316 483 q 268 271 268 346 q 294 181 268 211 q 364 151 319 151 m 593 -220 l 37 -220 l 57 -125 l 614 -125 l 593 -220 z \"},\"̏\":{\"ha\":0,\"x_min\":-629,\"x_max\":-102,\"o\":\"m -465 842 q -559 946 -513 888 q -629 1050 -605 1003 l -629 1064 l -437 1064 q -359 859 -412 958 l -359 842 l -465 842 m -207 842 q -301 946 -255 888 q -371 1050 -347 1003 l -371 1064 l -179 1064 q -102 859 -154 961 l -102 842 l -207 842 z \"},\"ﬀ\":{\"ha\":990,\"x_min\":-149,\"x_max\":1141,\"o\":\"m -31 -334 q -149 -317 -101 -334 l -149 -153 q -71 -167 -107 -167 q 2 -140 -29 -167 q 46 -52 33 -113 l 184 603 l 74 603 l 94 701 l 218 758 l 231 815 q 325 1003 258 944 q 510 1063 391 1063 q 669 1029 599 1063 l 615 878 q 525 899 568 899 q 463 871 486 899 q 431 800 439 844 l 422 758 l 690 758 l 703 815 q 797 1003 730 944 q 982 1063 863 1063 q 1141 1029 1071 1063 l 1088 878 q 997 899 1041 899 q 935 871 958 899 q 903 800 911 844 l 895 758 l 1043 758 l 1010 603 l 861 603 l 715 -82 q 441 -334 663 -334 q 323 -317 371 -334 l 323 -153 q 401 -167 365 -167 q 518 -52 494 -167 l 657 603 l 389 603 l 243 -82 q -31 -334 191 -334 z \"},\"℠\":{\"ha\":1021,\"x_min\":107,\"x_max\":1010,\"o\":\"m 415 642 q 368 535 415 574 q 241 497 321 497 q 107 526 167 497 l 107 624 q 244 587 185 587 q 291 601 275 587 q 307 637 307 614 q 295 669 307 656 q 258 694 283 682 l 224 711 q 134 779 157 745 q 110 859 110 813 q 153 960 110 922 q 273 999 197 999 q 414 964 338 999 l 379 879 q 321 903 341 897 q 273 908 300 908 q 218 863 218 908 q 234 825 218 841 q 297 787 250 810 q 391 722 367 753 q 415 642 415 690 m 681 503 l 568 861 l 564 861 l 567 786 l 567 503 l 456 503 l 456 991 l 624 991 l 732 646 l 847 991 l 1010 991 l 1010 503 l 896 503 l 896 779 l 899 861 l 895 861 l 777 503 l 681 503 z \"},\"Ţ\":{\"ha\":737,\"x_min\":96,\"x_max\":836,\"o\":\"m 387 0 l 180 0 l 353 817 l 114 817 l 151 991 l 836 991 l 799 817 l 559 817 l 387 0 m 414 -170 q 357 -291 414 -248 q 199 -334 301 -334 q 96 -318 140 -334 l 96 -204 q 180 -220 138 -220 q 250 -164 250 -220 q 229 -126 250 -141 q 154 -104 208 -111 l 219 0 l 345 0 l 318 -49 q 414 -170 414 -82 z \"},\"ţ\":{\"ha\":570,\"x_min\":58,\"x_max\":596,\"o\":\"m 349 151 q 458 175 393 151 l 458 22 q 278 -14 383 -14 q 129 29 176 -14 q 81 161 81 72 q 89 237 81 195 l 167 603 l 64 603 l 83 703 l 216 760 l 306 920 l 437 920 l 404 758 l 596 758 l 562 603 l 371 603 l 293 237 q 289 201 289 217 q 349 151 289 151 m 376 -170 q 320 -291 376 -248 q 161 -334 264 -334 q 58 -318 103 -334 l 58 -204 q 143 -220 101 -220 q 212 -164 212 -220 q 191 -126 212 -141 q 117 -104 170 -111 l 182 0 l 307 0 l 281 -49 q 376 -170 376 -82 z \"},\"I\":{\"ha\":447,\"x_min\":36,\"x_max\":454,\"o\":\"m 36 0 l 248 991 l 454 991 l 243 0 l 36 0 z \"},\"Ì\":{\"ha\":447,\"x_min\":36,\"x_max\":454,\"o\":\"m 36 0 l 248 991 l 454 991 l 243 0 l 36 0 m 452 1071 l 328 1071 q 234 1175 279 1118 q 163 1279 188 1232 l 163 1293 l 374 1293 q 452 1088 399 1193 l 452 1071 z \"},\"Í\":{\"ha\":447,\"x_min\":36,\"x_max\":659,\"o\":\"m 36 0 l 248 991 l 454 991 l 243 0 l 36 0 m 281 1088 q 431 1293 334 1147 l 659 1293 l 659 1282 q 554 1178 627 1244 q 422 1071 481 1113 l 281 1071 l 281 1088 z \"},\"Î\":{\"ha\":447,\"x_min\":36,\"x_max\":635,\"o\":\"m 36 0 l 248 991 l 454 991 l 243 0 l 36 0 m 635 1071 l 501 1071 q 391 1185 458 1107 q 234 1071 320 1125 l 87 1071 l 87 1088 q 191 1187 130 1126 q 287 1293 252 1249 l 516 1293 q 566 1197 531 1257 q 635 1088 602 1137 l 635 1071 z \"},\"Ï\":{\"ha\":447,\"x_min\":36,\"x_max\":623,\"o\":\"m 36 0 l 248 991 l 454 991 l 243 0 l 36 0 m 151 1166 q 179 1246 151 1219 q 260 1274 208 1274 q 351 1200 351 1274 q 324 1121 351 1151 q 242 1092 298 1092 q 151 1166 151 1092 m 423 1166 q 452 1246 423 1219 q 533 1274 480 1274 q 600 1255 577 1274 q 623 1200 623 1236 q 596 1121 623 1151 q 515 1092 570 1092 q 423 1166 423 1092 z \"},\"Ĩ\":{\"ha\":447,\"x_min\":36,\"x_max\":662,\"o\":\"m 36 0 l 248 991 l 454 991 l 243 0 l 36 0 m 467 1071 q 409 1082 434 1071 q 361 1106 383 1093 q 320 1131 340 1120 q 277 1142 300 1142 q 240 1123 256 1142 q 214 1069 223 1104 l 94 1069 q 284 1279 134 1279 q 343 1268 317 1279 q 392 1243 370 1257 q 434 1219 414 1230 q 475 1208 454 1208 q 514 1226 498 1208 q 545 1280 530 1243 l 662 1280 q 467 1071 617 1071 z \"},\"Ī\":{\"ha\":447,\"x_min\":36,\"x_max\":606,\"o\":\"m 36 0 l 248 991 l 454 991 l 243 0 l 36 0 m 186 1214 l 606 1214 l 576 1071 l 156 1071 l 186 1214 z \"},\"Ĭ\":{\"ha\":447,\"x_min\":36,\"x_max\":640,\"o\":\"m 36 0 l 248 991 l 454 991 l 243 0 l 36 0 m 640 1300 q 373 1071 602 1071 q 211 1120 269 1071 q 153 1255 153 1170 q 157 1300 153 1281 l 275 1300 q 300 1236 275 1256 q 380 1215 325 1215 q 466 1234 433 1215 q 511 1300 500 1252 l 640 1300 z \"},\"Į\":{\"ha\":447,\"x_min\":-49,\"x_max\":454,\"o\":\"m 36 0 l 248 991 l 454 991 l 243 0 l 36 0 m 232 0 q 127 -100 151 -65 q 102 -170 102 -136 q 113 -199 102 -189 q 143 -210 124 -210 q 212 -197 173 -210 l 212 -317 q 101 -334 155 -334 q -8 -297 32 -334 q -49 -201 -49 -261 q -17 -99 -49 -146 q 97 0 16 -52 l 232 0 z \"},\"İ\":{\"ha\":447,\"x_min\":36,\"x_max\":503,\"o\":\"m 36 0 l 248 991 l 454 991 l 243 0 l 36 0 m 278 1165 q 310 1254 278 1224 q 401 1284 342 1284 q 477 1263 451 1284 q 503 1203 503 1242 q 473 1115 503 1149 q 380 1082 443 1082 q 278 1165 278 1082 z \"},\"Ĳ\":{\"ha\":907,\"x_min\":36,\"x_max\":915,\"o\":\"m 36 0 l 248 991 l 454 991 l 243 0 l 36 0 m 355 -292 q 229 -273 292 -292 l 229 -102 q 340 -115 288 -115 q 449 -74 407 -115 q 509 56 490 -33 l 708 991 l 915 991 l 709 26 q 590 -216 674 -140 q 355 -292 507 -292 z \"},\"Ί\":{\"ha\":546,\"x_min\":23,\"x_max\":553,\"o\":\"m 134 0 l 346 991 l 553 991 l 341 0 l 134 0 m 23 791 q 125 1034 75 895 l 317 1034 l 317 1018 q 145 770 236 884 l 23 770 l 23 791 z \"},\"Ι\":{\"ha\":447,\"x_min\":36,\"x_max\":454,\"o\":\"m 36 0 l 248 991 l 454 991 l 243 0 l 36 0 z \"},\"Ϊ\":{\"ha\":447,\"x_min\":36,\"x_max\":623,\"o\":\"m 36 0 l 248 991 l 454 991 l 243 0 l 36 0 m 151 1166 q 179 1246 151 1219 q 260 1274 208 1274 q 351 1200 351 1274 q 324 1121 351 1151 q 242 1092 298 1092 q 151 1166 151 1092 m 423 1166 q 452 1246 423 1219 q 533 1274 480 1274 q 600 1255 577 1274 q 623 1200 623 1236 q 596 1121 623 1151 q 515 1092 570 1092 q 423 1166 423 1092 z \"},\"І\":{\"ha\":447,\"x_min\":36,\"x_max\":454,\"o\":\"m 36 0 l 248 991 l 454 991 l 243 0 l 36 0 z \"},\"Ї\":{\"ha\":447,\"x_min\":36,\"x_max\":623,\"o\":\"m 36 0 l 248 991 l 454 991 l 243 0 l 36 0 m 151 1166 q 179 1246 151 1219 q 260 1274 208 1274 q 351 1200 351 1274 q 324 1121 351 1151 q 242 1092 298 1092 q 151 1166 151 1092 m 423 1166 q 452 1246 423 1219 q 533 1274 480 1274 q 600 1255 577 1274 q 623 1200 623 1236 q 596 1121 623 1151 q 515 1092 570 1092 q 423 1166 423 1092 z \"},\"Ӏ\":{\"ha\":447,\"x_min\":36,\"x_max\":454,\"o\":\"m 36 0 l 248 991 l 454 991 l 243 0 l 36 0 z \"},\"ӏ\":{\"ha\":447,\"x_min\":36,\"x_max\":454,\"o\":\"m 36 0 l 248 991 l 454 991 l 243 0 l 36 0 z \"},\"Ỉ\":{\"ha\":447,\"x_min\":36,\"x_max\":561,\"o\":\"m 36 0 l 248 991 l 454 991 l 243 0 l 36 0 m 561 1257 q 427 1104 561 1145 l 414 1056 l 290 1056 l 300 1156 q 375 1184 353 1165 q 397 1232 397 1202 q 386 1258 397 1249 q 354 1268 375 1268 q 269 1254 319 1268 l 269 1365 q 387 1382 319 1382 q 515 1350 470 1382 q 561 1257 561 1318 z \"},\"Ị\":{\"ha\":447,\"x_min\":-10,\"x_max\":454,\"o\":\"m 36 0 l 248 991 l 454 991 l 243 0 l 36 0 m -10 -208 q 22 -119 -10 -150 q 114 -89 55 -89 q 188 -110 161 -89 q 215 -171 215 -130 q 185 -258 215 -225 q 93 -292 155 -292 q -10 -208 -10 -292 z \"}},\"familyName\":\"Open Sans\",\"ascender\":1485,\"descender\":-407,\"underlinePosition\":-104,\"underlineThickness\":69,\"boundingBox\":{\"yMin\":-407,\"xMin\":-713,\"yMax\":1485,\"xMax\":1796},\"resolution\":1000,\"original_font_information\":{\"format\":0,\"copyright\":\"Digitized data copyright © 2010-2011, Google Corporation.\",\"fontFamily\":\"Open Sans\",\"fontSubfamily\":\"Bold Italic\",\"uniqueID\":\"1.10;1ASC;OpenSans-BoldItalic\",\"fullName\":\"Open Sans Bold Italic\",\"version\":\"Version 1.10\",\"postScriptName\":\"OpenSans-BoldItalic\",\"trademark\":\"Open Sans is a trademark of Google and may be registered in certain jurisdictions.\",\"manufacturer\":\"Ascender Corporation\",\"manufacturerURL\":\"http://www.ascendercorp.com/\",\"designerURL\":\"http://www.ascendercorp.com/typedesigners.html\",\"licence\":\"Licensed under the Apache License, Version 2.0\",\"licenceURL\":\"http://www.apache.org/licenses/LICENSE-2.0\"},\"cssFontWeight\":\"bold\",\"cssFontStyle\":\"italic\"}");

/***/ }),

/***/ "./src/board.ts":
/*!**********************!*\
  !*** ./src/board.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Board = exports.Tile = void 0;
var three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
var TWEEN = __webpack_require__(/*! @tweenjs/tween.js */ "./node_modules/@tweenjs/tween.js/dist/tween.esm.js");
/**
 * 타일 요소
 */
var Tile = /** @class */ (function () {
    function Tile(w, h, level) {
        this.tileW = w;
        this.tileH = h;
        this.level = level;
    }
    return Tile;
}());
exports.Tile = Tile;
/**
 * 타일 방향
 */
var TileFacingAngleData = /** @class */ (function () {
    function TileFacingAngleData(dir, angle) {
        this.direction = dir.clone();
        this.angle = angle;
    }
    return TileFacingAngleData;
}());
/**
 * 게임판 관리 클래스
 */
var Board = /** @class */ (function () {
    /**
     * 생성자
     */
    function Board(scene, modelMgr, camera, camControl, scoreMgr, soundMgr, gameTimer) {
        this.scene = scene;
        this.modelMgr = modelMgr;
        this.camera = camera;
        this.camControl = camControl;
        this.scoreMgr = scoreMgr;
        this.soundMgr = soundMgr;
        this.gameTimer = gameTimer;
        this.tileSize = 10;
        this.pickPlates = [];
        this.floorPlates = [];
        this.mapWidth = -1;
        this.mapHeight = -1;
        this.prevPickPlate = null;
        this.matSelect = new three_1.MeshPhongMaterial({ color: 0xffff00 });
        this.matNormal = new three_1.MeshPhongMaterial({ color: 0xcccccc });
        this.boardBounding = new three_1.Box3().makeEmpty();
        // 카메라 향한 타일 회전 처리 관련
        this.isTileFacingToCamera = false;
        this.tileFacingAngleArray = [];
        this.tileFacingAngleArray.push(new TileFacingAngleData(new three_1.Vector3(1, 0, 0), Math.PI * -0.5));
        this.tileFacingAngleArray.push(new TileFacingAngleData(new three_1.Vector3(-1, 0, 0), Math.PI * 0.5));
        this.tileFacingAngleArray.push(new TileFacingAngleData(new three_1.Vector3(0, 0, 1), Math.PI));
        this.tileFacingAngleArray.push(new TileFacingAngleData(new three_1.Vector3(0, 0, -1), 0));
        this.prevFacingIndex = null;
        // 픽킹용 바닥판
        var geometry = new three_1.BoxBufferGeometry(this.tileSize, 1, this.tileSize, 1, 1, 1);
        var material = new three_1.MeshBasicMaterial();
        this.plateBase = new three_1.Mesh(geometry, material);
    }
    /**
     * 리소스 메모리 해제
     */
    Board.prototype.dispose = function () {
        // 픽킹용 바닥판 제거
        for (var i = 0; i < this.pickPlates.length; i++) {
            this.pickPlates[i] = null;
        }
        this.pickPlates = [];
        // 생성되어 있는 타일 제거
        for (var w = 0; w < this.mapWidth; w++) {
            for (var h = 0; h < this.mapHeight; h++) {
                var mapData = this.map[w][h];
                if (mapData.object) {
                    this.scene.remove(mapData.object);
                    mapData.object.geometry.dispose();
                    if (mapData.object.material instanceof Array) {
                        for (var m = 0; m < mapData.object.material.length; m++) {
                            mapData.object.material[m].dispose();
                        }
                    }
                    else {
                        mapData.object.material.dispose();
                    }
                }
            }
        }
        // 바닥판 제거
        for (var i = 0; i < this.floorPlates.length; i++) {
            var plate = this.floorPlates[i];
            this.scene.remove(plate);
            plate.geometry.dispose();
            if (plate.material instanceof Array) {
                for (var m = 0; m < plate.material.length; m++) {
                    plate.material[m].dispose();
                }
            }
            else {
                plate.material.dispose();
            }
        }
        // 커튼(게임판 옆면) 제거
        if (this.curtain) {
            this.scene.remove(this.curtain);
            this.curtain.geometry.dispose();
            this.curtain.material.dispose();
            this.curtain = null;
        }
        this.boardBounding.makeEmpty();
    };
    /**
     * 맵 생성
     * @param width 맵 가로 타일개수
     * @param height 맵 세로 타일개수
     */
    Board.prototype.createMap = function (width, height) {
        this.dispose();
        this.mapWidth = width;
        this.mapHeight = height;
        // 랜덤 맵타일 레벨당 개수
        // 5, 3, 1, 1, 1, 1, 1, 1, 1
        var levelStorage = [9, 8, 7, 6, 5, 4, 3, 2, 2, 2, 1, 1, 1, 1, 1];
        var levelStorageTile = [];
        var levelMap = [];
        for (var w = 0; w < this.mapWidth; w++) {
            for (var h = 0; h < this.mapHeight; h++) {
                levelMap.push({ w: w, h: h });
            }
        }
        for (var l = 0; l < levelStorage.length; l++) {
            var level = levelStorage[l];
            var index = three_1.Math.randInt(0, levelMap.length - 1);
            levelStorageTile.push({
                w: levelMap[index].w,
                h: levelMap[index].h,
                level: level
            });
            levelMap.splice(index, 1);
        }
        // 가로세로 개수만큼 초기화
        this.map = [];
        for (var w = 0; w < width; w++) {
            this.map[w] = [];
            for (var h = 0; h < height; h++) {
                var level = this.findMatchedLevel(w, h, levelStorageTile);
                this.map[w][h] = new Tile(w, h, level);
                // 바닥판생성, 0레벨 판으로 깔린다.
                var model = this.modelMgr.getModelByLevelNumber(0);
                model.position.x = w * this.tileSize;
                model.position.z = h * this.tileSize;
                this.scene.add(model);
                this.floorPlates.push(model);
                // 픽킹용 패널
                var plate = this.plateBase.clone();
                plate.name = w + '_' + h + '/plate';
                plate.position.copy(model.position);
                plate.updateMatrixWorld(true);
                plate.userData['linkedTile'] = this.map[w][h];
                this.pickPlates.push(plate);
            }
        }
        // 타일 레벨에 따른 메시 생성
        for (var w = 0; w < width; w++) {
            for (var h = 0; h < height; h++) {
                var mapData = this.map[w][h];
                var model = this.modelMgr.getModelByLevelNumber(mapData.level);
                if (model) {
                    mapData.object = model;
                    mapData.object.position.x = w * this.tileSize;
                    mapData.object.position.z = h * this.tileSize;
                    this.scene.add(mapData.object);
                }
            }
        }
        // 바운딩을 계산하여 카메라를 이동시킨다.
        var bounding = new three_1.Box3();
        bounding.makeEmpty();
        for (var i = 0; i < this.pickPlates.length; i++) {
            bounding.expandByObject(this.pickPlates[i]);
        }
        var sphere = new three_1.Sphere();
        bounding.getBoundingSphere(sphere);
        this.scoreMgr.sphere = sphere.clone();
        this.gameTimer.sphere = sphere.clone();
        this.tileHolder.boardSphere = sphere.clone();
        this.gameStarter.boardSphere = sphere.clone();
        this.camControl.target = sphere.center;
        this.camControl.object.position.set(sphere.center.x, sphere.center.y + sphere.radius, sphere.center.z + sphere.radius);
        this.camControl.object.lookAt(sphere.center);
        this.camControl.update();
        this.camControl.minDistance = sphere.radius;
        this.camControl.maxDistance = sphere.radius * 2;
        // 바닥판옆면을 가리기 위한 커튼 설치
        var curtainHeight = 50;
        var boundingSize = new three_1.Vector3(), boundingCenter = new three_1.Vector3();
        bounding.getSize(boundingSize);
        bounding.getCenter(boundingCenter);
        var curtainGeometry = new three_1.BoxBufferGeometry(boundingSize.x, curtainHeight, boundingSize.z);
        var curtainMaterial = new three_1.MeshPhongMaterial({
            color: 0xcccccc
        });
        this.curtain = new three_1.Mesh(curtainGeometry, curtainMaterial);
        this.curtain.position.x = boundingCenter.x;
        this.curtain.position.y = -(boundingSize.y * 0.25) - (curtainHeight * 0.5);
        this.curtain.position.z = boundingCenter.z;
        this.scene.add(this.curtain);
        // 바운딩 저장
        this.boardBounding.copy(bounding);
    };
    /**
     * w,h에 매칭되는 타일 레벨 반환
     */
    Board.prototype.findMatchedLevel = function (w, h, levelStorageTile) {
        var result = 0;
        for (var i = 0; i < levelStorageTile.length; i++) {
            if (levelStorageTile[i].w === w && levelStorageTile[i].h === h) {
                result = levelStorageTile[i].level;
                levelStorageTile.splice(i, 1);
                break;
            }
        }
        return result;
    };
    /**
     * 대상타일 기준으로 3타일 매치가 성사되는지 체크한다.
     * @param tile 타일 객체
     * @param comboRatio 콤보 배율
     */
    Board.prototype.checkTriple = function (tile, comboRatio) {
        var _this = this;
        if (tile.level === 0) {
            return;
        }
        var matched = [tile];
        // 대상타일 기준 상하좌우체크
        // 상단
        var topTile = (tile.tileH > 0) ? this.map[tile.tileW][tile.tileH - 1] : null;
        if (topTile && topTile.level === tile.level) {
            if (matched.indexOf(topTile) === -1) {
                matched.push(topTile);
            }
        }
        // 하단
        var bottomTile = (tile.tileH < this.mapHeight - 1) ? this.map[tile.tileW][tile.tileH + 1] : null;
        if (bottomTile && bottomTile.level === tile.level) {
            if (matched.indexOf(bottomTile) === -1) {
                matched.push(bottomTile);
            }
        }
        // 좌측
        var leftTile = (tile.tileW > 0) ? this.map[tile.tileW - 1][tile.tileH] : null;
        if (leftTile && leftTile.level === tile.level) {
            if (matched.indexOf(leftTile) === -1) {
                matched.push(leftTile);
            }
        }
        // 우측
        var rightTile = (tile.tileW < this.mapWidth - 1) ? this.map[tile.tileW + 1][tile.tileH] : null;
        if (rightTile && rightTile.level === tile.level) {
            if (matched.indexOf(rightTile) === -1) {
                matched.push(rightTile);
            }
        }
        // 좌상단타일은 상단이나 좌측타일이 같을경우만 처리
        var leftTopTile = (tile.tileW > 0 && tile.tileH > 0) ? this.map[tile.tileW - 1][tile.tileH - 1] : null;
        if (leftTopTile && leftTopTile.level === tile.level) {
            if (leftTopTile.level === topTile.level || leftTopTile.level === leftTile.level) {
                if (matched.indexOf(leftTopTile) === -1) {
                    matched.push(leftTopTile);
                }
            }
        }
        // 우상단타일은 상단이나 우측 타일이 같을 경우만 처리
        var rightTopTile = (tile.tileW < this.mapWidth - 1 && tile.tileH > 0) ? this.map[tile.tileW + 1][tile.tileH - 1] : null;
        if (rightTopTile && rightTopTile.level === tile.level) {
            if (rightTopTile.level === topTile.level || rightTopTile.level === rightTile.level) {
                if (matched.indexOf(rightTopTile) === -1) {
                    matched.push(rightTopTile);
                }
            }
        }
        // 좌하단타일은 좌측이나 하단 타일이 같을 경우만
        var leftBottomTile = (tile.tileW > 0 && tile.tileH < this.mapHeight - 1) ? this.map[tile.tileW - 1][tile.tileH + 1] : null;
        if (leftBottomTile && leftBottomTile.level === tile.level) {
            if (leftBottomTile.level === leftTile.level || leftBottomTile.level === bottomTile.level) {
                if (matched.indexOf(leftBottomTile) === -1) {
                    matched.push(leftBottomTile);
                }
            }
        }
        // 우하단타일은 우측이나 하단 타일이 같을 경우만
        var rightBottomTile = (tile.tileW < this.mapWidth - 1 && tile.tileH < this.mapHeight - 1) ? this.map[tile.tileW + 1][tile.tileH + 1] : null;
        if (rightBottomTile && rightBottomTile.level === tile.level) {
            if (rightBottomTile.level === rightTile.level || rightBottomTile.level === bottomTile.level) {
                if (matched.indexOf(rightBottomTile) === -1) {
                    matched.push(rightBottomTile);
                }
            }
        }
        // 대상타일 기준 상하좌우 2간격 거리 체크
        var topDoubleTile = (tile.tileH - 1 > 0) ? this.map[tile.tileW][tile.tileH - 2] : null;
        if (topDoubleTile && topDoubleTile.level === tile.level && topDoubleTile.level === topTile.level) {
            if (matched.indexOf(topDoubleTile) === -1) {
                matched.push(topDoubleTile);
            }
        }
        var bottomDoubleTile = (tile.tileH + 1 < this.mapHeight - 1) ? this.map[tile.tileW][tile.tileH + 2] : null;
        if (bottomDoubleTile && bottomDoubleTile.level === tile.level && bottomDoubleTile.level === bottomTile.level) {
            if (matched.indexOf(bottomDoubleTile) === -1) {
                matched.push(bottomDoubleTile);
            }
        }
        var leftDoubleTile = (tile.tileW - 1 > 0) ? this.map[tile.tileW - 2][tile.tileH] : null;
        if (leftDoubleTile && leftDoubleTile.level === tile.level && leftDoubleTile.level === leftTile.level) {
            if (matched.indexOf(leftDoubleTile) === -1) {
                matched.push(leftDoubleTile);
            }
        }
        var rightDoubleTile = (tile.tileW + 1 < this.mapWidth - 1) ? this.map[tile.tileW + 2][tile.tileH] : null;
        if (rightDoubleTile && rightDoubleTile.level === tile.level && rightDoubleTile.level === rightTile.level) {
            if (matched.indexOf(rightDoubleTile) === -1) {
                matched.push(rightDoubleTile);
            }
        }
        // 매치된 타일 처리
        if (matched.length >= 3) {
            this.soundMgr.playSound('Score');
            var newLevelNumber_1 = tile.level;
            newLevelNumber_1++;
            var zeroTile = this.modelMgr.getModelByLevelNumber(0);
            var levelUpTileSource_1 = this.modelMgr.getModelByLevelNumber(newLevelNumber_1);
            if (levelUpTileSource_1) { // 레벨업 타일이 있다면 다른 타일들을 제거하고 새 타일로 교체함
                var _loop_1 = function (i) {
                    if (matched[i].tileW === tile.tileW && matched[i].tileH === tile.tileH) {
                        // 대상타일은 제거후 생성
                        levelUpTileSource_1.position.copy(matched[i].object.position);
                        // 제거하면서 점수 처리
                        this_1.scoreMgr.addScore(matched[i], comboRatio);
                        this_1.deleteTileObject(matched[i].object, tile, function () {
                            // 대상타일 제거가 완료되면 레벨업 타일을 생성
                            levelUpTileSource_1.position.y = -30;
                            _this.scene.add(levelUpTileSource_1);
                            // 생성 애니메이션 처리
                            new TWEEN.default.Tween(levelUpTileSource_1.position)
                                .to({
                                y: 0
                            }, 250)
                                .easing(TWEEN.default.Easing.Quadratic.Out)
                                .onComplete(function () {
                                matched[i].object = levelUpTileSource_1;
                                matched[i].level = newLevelNumber_1;
                                // 매치된 타일처리후에 매치된것이 있을수 있으므로
                                _this.checkTriple(matched[i], comboRatio + 1);
                            })
                                .start();
                        });
                    }
                    else {
                        // 대상타일이 아닌것은 0레벨 타일로 교체
                        var emptyTile = zeroTile;
                        emptyTile.position.copy(matched[i].object.position);
                        this_1.scene.add(emptyTile);
                        // 제거하면서 점수 처리
                        this_1.scoreMgr.addScore(matched[i], comboRatio);
                        this_1.deleteTileObject(matched[i].object, tile);
                        matched[i].object = emptyTile;
                        matched[i].level = 0;
                    }
                };
                var this_1 = this;
                // 제거
                for (var i = 0; i < matched.length; i++) {
                    _loop_1(i);
                }
            }
            else { // 최대레벨이 3매치가 성사되었다면
                // 매치된 타일 전체를 제거하고, 빈타일로 만든다.
                for (var i = 0; i < matched.length; i++) {
                    var emptyTile = zeroTile;
                    emptyTile.position.copy(matched[i].object.position);
                    this.scene.add(emptyTile);
                    // 제거하면서 점수 처리
                    this.scoreMgr.addScore(matched[i], comboRatio);
                    this.deleteTileObject(matched[i].object, tile);
                    matched[i].object = emptyTile;
                    matched[i].level = 0;
                }
            }
        }
    };
    /**
     * 제거 대상 타일 객체를 애니메이션을 적용하여 제거한다.
     * @param target 제거 대상
     * @param tile 애니메이션 목표 대상 타일
     */
    Board.prototype.deleteTileObject = function (target, tile, onComplete) {
        var _this = this;
        // 투명 처리를 할것이므로 재질을 복제처리한다.
        if (target.material instanceof Array) {
            for (var i = 0; i < target.material.length; i++) {
                var clonedMaterial = target.material[i];
                clonedMaterial.transparent = true;
            }
        }
        else {
            var clonedMaterial = target.material;
            clonedMaterial.transparent = true;
        }
        // 애니메이션 처리
        new TWEEN.default.Tween({
            opacity: 1.0
        }).to({
            opacity: 0.0
        }, 250)
            .easing(TWEEN.default.Easing.Quadratic.Out)
            .onUpdate(function (data) {
            // 재질투명도 조절
            if (target.material instanceof Array) {
                for (var i = 0; i < target.material.length; i++) {
                    var material = target.material[i];
                    material.opacity = data.opacity;
                }
            }
            else {
                target.material.opacity = data.opacity;
            }
        })
            .onComplete(function (data) {
            // 애니메이션이 완료되면 씬에서 제거하고 재질의 메모리를 해제
            _this.scene.remove(target);
            if (target.material instanceof Array) {
                for (var i = 0; i < target.material.length; i++) {
                    var material = target.material[i];
                    material.dispose();
                }
            }
            else {
                target.material.dispose();
            }
            if (onComplete) {
                onComplete();
            }
        })
            .start();
    };
    /**
     * 보드판 업데이트 처리
     */
    Board.prototype.update = function (deltaTime) {
        if (this.isTileFacingToCamera) {
            // 보드판 중심점 취득
            var boardCenter = new three_1.Vector3();
            this.boardBounding.getCenter(boardCenter);
            // 보드판 중심점을 기준으로하는 평면 생성
            var plane = new three_1.Plane().setFromNormalAndCoplanarPoint(new three_1.Vector3(0, 1, 0), boardCenter);
            // 카메라 위치점을 생성한 평면에 투영
            var projCamPoint = new three_1.Vector3();
            plane.projectPoint(this.camera.position, projCamPoint);
            // 카메라에서 보드판 중심점을 향하는 방향 계산
            var dirToCenter = new three_1.Vector3().subVectors(boardCenter, projCamPoint);
            dirToCenter.normalize();
            // 각도 데이터배열에서 가장 가까운 각도를 가지는 데이터를 찾음
            var closestIndex = -1;
            var prevAngle = Number.MAX_VALUE;
            for (var i = 0; i < this.tileFacingAngleArray.length; i++) {
                var currData = this.tileFacingAngleArray[i];
                var currAngle = dirToCenter.angleTo(currData.direction);
                if (currAngle < prevAngle) {
                    prevAngle = currAngle;
                    closestIndex = i;
                }
            }
            // 찾은 데이터 인덱스가 이전프레임에서 계산된 인덱스와 다르다면 각 타일의 회전값 설정
            if (this.prevFacingIndex !== closestIndex) {
                var angleData = this.tileFacingAngleArray[closestIndex];
                for (var w = 0; w < this.mapWidth; w++) {
                    for (var h = 0; h < this.mapHeight; h++) {
                        var tile = this.map[w][h];
                        if (tile.level > 0) {
                            tile.object.rotation.y = angleData.angle;
                        }
                    }
                }
                this.prevFacingIndex = closestIndex;
            }
        }
    };
    /**
     * 타일홀더 인스턴스 설정
     */
    Board.prototype.setTileHolder = function (holder) {
        this.tileHolder = holder;
    };
    /**
     * 게임 스타터 인스턴스 설정
     */
    Board.prototype.setGameStarter = function (starter) {
        this.gameStarter = starter;
    };
    /**
     * 지정된 레벨에 해당하는 타일 개수 반환
     * @param level 타일레벨
     */
    Board.prototype.getTileCountByLevel = function (level) {
        var count = 0;
        for (var w = 0; w < this.mapWidth; w++) {
            for (var h = 0; h < this.mapHeight; h++) {
                var tile = this.map[w][h];
                if (tile.level === level) {
                    count++;
                }
            }
        }
        return count;
    };
    return Board;
}());
exports.Board = Board;


/***/ }),

/***/ "./src/core.ts":
/*!*********************!*\
  !*** ./src/core.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Core = void 0;
var three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
var OrbitControls_1 = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls */ "./node_modules/three/examples/jsm/controls/OrbitControls.js");
var board_1 = __webpack_require__(/*! ./board */ "./src/board.ts");
var model_1 = __webpack_require__(/*! ./model */ "./src/model.ts");
var gamelogic_1 = __webpack_require__(/*! ./gamelogic */ "./src/gamelogic.ts");
var score_1 = __webpack_require__(/*! ./score */ "./src/score.ts");
var TWEEN = __webpack_require__(/*! @tweenjs/tween.js */ "./node_modules/@tweenjs/tween.js/dist/tween.esm.js");
var soundManager_1 = __webpack_require__(/*! ./soundManager */ "./src/soundManager.ts");
var tileHolder_1 = __webpack_require__(/*! ./tileHolder */ "./src/tileHolder.ts");
var gameStarter_1 = __webpack_require__(/*! ./gameStarter */ "./src/gameStarter.ts");
var gameTimer_1 = __webpack_require__(/*! ./gameTimer */ "./src/gameTimer.ts");
/**
 * 엔진 코어
 */
var Core = /** @class */ (function () {
    /**
     * 생성자
     */
    function Core(onReady) {
        this.clock = new three_1.Clock();
        // 렌더러 생성
        this.renderer = new three_1.WebGLRenderer({
            antialias: true
        });
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.gammaInput = true;
        this.renderer.gammaOutput = true;
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = three_1.PCFSoftShadowMap;
        document.body.appendChild(this.renderer.domElement);
        // 씬객체
        this.scene = new three_1.Scene();
        this.scene.background = new three_1.Color(0xcccccc);
        // 라이트
        this.hemiLight = new three_1.HemisphereLight(0xffffff, 0xffffff, 0.6);
        this.hemiLight.color.setHSL(0.6, 1, 0.6);
        this.hemiLight.groundColor.setHSL(0.095, 1, 0.75);
        this.hemiLight.position.set(0, 50, 0);
        this.scene.add(this.hemiLight);
        this.dirLight = new three_1.DirectionalLight(0xffffff, 0.6);
        this.dirLight.color.setHSL(0.1, 1, 0.95);
        this.dirLight.position.set(1, 1.75, -1);
        this.dirLight.position.multiplyScalar(30);
        this.scene.add(this.dirLight);
        // 디렉셔널 라이트 그림자 설정
        var shadowMapDist = 100;
        this.dirLight.castShadow = true;
        this.dirLight.shadow.mapSize.width = 1024;
        this.dirLight.shadow.mapSize.height = 1024;
        this.dirLight.shadow.camera.left = -shadowMapDist;
        this.dirLight.shadow.camera.right = shadowMapDist;
        this.dirLight.shadow.camera.top = shadowMapDist;
        this.dirLight.shadow.camera.bottom = -shadowMapDist;
        this.dirLight.shadow.camera.far = 3500;
        this.dirLight.shadow.bias = -0.00001;
        // 카메라
        this.camera = new three_1.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.5, 1000);
        this.camera.position.set(0, 50, -50);
        this.camera.lookAt(0, 0, 0);
        // 카메라 컨트롤러
        this.control = new OrbitControls_1.OrbitControls(this.camera, this.renderer.domElement);
        this.control.enableDamping = true;
        this.control.dampingFactor = 0.05;
        this.control.enableKeys = false;
        this.control.screenSpacePanning = false;
        this.control.rotateSpeed = 0.5;
        this.control.enablePan = false;
        this.control.minPolarAngle = Math.PI * 0.1;
        this.control.maxPolarAngle = Math.PI * 0.5;
        this.control.autoRotate = true;
        this.control.enabled = false;
        // 창크기변경 이벤트 등록
        window.addEventListener('resize', this.onResize.bind(this), false);
        var scope = this;
        // 모델 인스턴스
        this.model = new model_1.ModelManager(this.scene, function () {
            // 게임 타이머
            scope.gameTimer = new gameTimer_1.GameTimer(scope.scene, scope.camera, scope.control);
            // 사운드 관리자
            scope.soundMgr = new soundManager_1.SoundManager(scope.camera);
            // 스코어 객체
            scope.scoreMgr = new score_1.ScoreManager(scope.scene, scope.camera, scope.control);
            // 게임판 인스턴스
            scope.board = new board_1.Board(scope.scene, scope.model, scope.camera, scope.control, scope.scoreMgr, scope.soundMgr, scope.gameTimer);
            // 게임로직
            scope.gameLogic = new gamelogic_1.GameLogic(scope.scene, scope.camera, scope.control, scope.board, scope.model, scope.scoreMgr, scope.soundMgr, scope.gameTimer);
            // 타일 홀딩
            scope.tileHolder = new tileHolder_1.TileHolder(scope.scene, scope.camera, scope.control, scope.model);
            scope.gameLogic.setTileHolder(scope.tileHolder);
            scope.board.setTileHolder(scope.tileHolder);
            scope.tileHolder.setVisible(false);
            scope.scoreMgr.setVisible(false);
            scope.gameTimer.setVisible(false);
            scope.gameTimer.setGameLogic(scope.gameLogic);
            // 게임 스타터
            scope.gameStarter = new gameStarter_1.GameStarter(scope.scene, scope.camera, scope.control, function () {
                scope.control.autoRotate = false;
                scope.control.enabled = true;
                scope.tileHolder.setVisible(true);
                scope.scoreMgr.setVisible(true);
                scope.gameTimer.setVisible(true);
                scope.gameTimer.isPlaying = true;
                scope.soundMgr.playSound('BGM');
                scope.gameLogic.createCursor();
                scope.gameLogic.enable();
            });
            scope.board.setGameStarter(scope.gameStarter);
            if (onReady) {
                onReady();
            }
            // 렌더링 루프 시작
            scope.render();
        });
    }
    /**
     * 창크기변경 이벤트
     */
    Core.prototype.onResize = function () {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    };
    /**
     * 렌더링 루프
     */
    Core.prototype.render = function () {
        requestAnimationFrame(this.render.bind(this));
        var deltaTime = this.clock.getDelta();
        TWEEN.default.update();
        this.gameStarter.update(deltaTime);
        this.tileHolder.update(deltaTime);
        this.scoreMgr.update(deltaTime);
        this.board.update(deltaTime);
        this.gameTimer.update(deltaTime);
        this.control.update();
        this.renderer.render(this.scene, this.camera);
    };
    /**
     * 메모리 해제
     */
    Core.prototype.dispose = function () {
        this.board.dispose();
        this.gameLogic.disposeCursor();
    };
    /**
     * 게임 생성
     * @param mapWidth 맵 가로 너비
     * @param mapHeight 맵 세로 너비
     */
    Core.prototype.createGame = function (mapWidth, mapHeight) {
        this.dispose();
        this.board.createMap(mapWidth, mapHeight);
        //this.gameLogic.createCursor();
    };
    return Core;
}());
exports.Core = Core;


/***/ }),

/***/ "./src/entry.ts":
/*!**********************!*\
  !*** ./src/entry.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(/*! ./core */ "./src/core.ts");
//export { Core };
window.onload = function () {
    var app = new core_1.Core(function () {
        app.createGame(10, 10);
    });
};


/***/ }),

/***/ "./src/gameStarter.ts":
/*!****************************!*\
  !*** ./src/gameStarter.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.GameStarter = void 0;
var three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
var FontData_Bold_Italic = __webpack_require__(/*! ./Open_Sans_Bold_Italic.json */ "./src/Open_Sans_Bold_Italic.json");
/**
 * 게임 시작 처리 클래스
 */
var GameStarter = /** @class */ (function () {
    /**
     * 생성자
     */
    function GameStarter(scene, camera, control, onStart) {
        this.scene = scene;
        this.camera = camera;
        this.control = control;
        this.onStart = onStart;
        // 폰트관련 초기화 처리
        var fontLoader = new three_1.FontLoader();
        this.fontData = fontLoader.parse(FontData_Bold_Italic);
        // 문자열 geometry 생성
        var geometry = new three_1.TextBufferGeometry('Game Start', {
            font: this.fontData,
            size: 10,
            height: 5
        });
        geometry.computeBoundingBox();
        var size = new three_1.Vector3();
        geometry.boundingBox.getSize(size);
        geometry.translate(size.x * -0.5, size.y * -0.5, size.z * -0.5);
        var material = new three_1.MeshPhongMaterial({ color: 0x00ff00 });
        this.text = new three_1.Mesh(geometry, material);
        this.scene.add(this.text);
        // 픽킹시 가시화할 텍스트 밑줄 객체
        var underLineGeometry = new three_1.BoxBufferGeometry(size.x, 2, 5);
        this.underLine = new three_1.Mesh(underLineGeometry, material);
        this.text.add(this.underLine);
        this.underLine.position.set(0, (size.y * -0.5) - 1.5, 0);
        this.underLine.visible = false;
        // 픽킹요소 초기화
        this.rayCast = new three_1.Raycaster();
        this.mousePos = new three_1.Vector2();
        this.mouseDownPos = new three_1.Vector2();
        // 픽킹관련 포인터 이벤트 등록
        this.pointerDownBinder = this.onPointerDown.bind(this);
        this.pointerMoveBinder = this.onPointerMove.bind(this);
        this.pointerUpBinder = this.onPointerUp.bind(this);
        window.addEventListener('pointerdown', this.pointerDownBinder, false);
        window.addEventListener('pointermove', this.pointerMoveBinder, false);
        window.addEventListener('pointerup', this.pointerUpBinder, false);
    }
    /**
     * 업데이트
     */
    GameStarter.prototype.update = function (deltaTime) {
        var camForward = new three_1.Vector3();
        this.camera.getWorldDirection(camForward);
        var target = this.control.target.clone();
        target.addScaledVector(camForward, this.boardSphere.radius);
        var plane = new three_1.Plane().setFromNormalAndCoplanarPoint(new three_1.Vector3(0, 1, 0), this.boardSphere.center);
        var project = new three_1.Vector3();
        plane.projectPoint(target, project);
        var direction = new three_1.Vector3().subVectors(project, this.control.target);
        direction.normalize();
        var result = this.control.target.clone();
        result.addScaledVector(direction, this.boardSphere.radius + 15);
        //result.y += 20;
        this.text.position.copy(result);
        this.text.lookAt(this.control.target);
        this.pickSphere = new three_1.Sphere();
        new three_1.Box3().setFromObject(this.text).getBoundingSphere(this.pickSphere);
    };
    /**
     * 포인터 다운 이벤트 처리
     * @param event 마우스 이벤트
     */
    GameStarter.prototype.onPointerDown = function (event) {
        if (event.button === 0) { // 좌클릭, 1-터치
            this.mouseDownPos.x = event.screenX;
            this.mouseDownPos.y = event.screenY;
        }
    };
    /**
     * 포인터 이동 이벤트 처리
     */
    GameStarter.prototype.onPointerMove = function (event) {
        if (this.pickSphere) {
            // ray 계산
            this.mousePos.x = (event.clientX / window.innerWidth) * 2 - 1;
            this.mousePos.y = -(event.clientY / window.innerHeight) * 2 + 1;
            this.rayCast.setFromCamera(this.mousePos, this.camera);
            // 보드판에 픽킹 처리를 한다.
            //const intersects = this.rayCast.intersectObjects([this.text]);            
            //if( intersects && intersects.length > 0 ) {
            var target = new three_1.Vector3();
            if (this.rayCast.ray.intersectSphere(this.pickSphere, target)) {
                this.underLine.visible = true;
            }
            else {
                this.underLine.visible = false;
            }
        }
        else {
            this.underLine.visible = false;
        }
    };
    /**
     * 포인터 업 이벤트
     * @param event 포인터 이벤트
     */
    GameStarter.prototype.onPointerUp = function (event) {
        if (event.button === 0) {
            // 마우스 좌클릭의 경우 화면회전도 겸하므로
            // 포인터 다운 좌표와 업좌표사이 거리가 5.0픽셀 이하인경우 처리
            var currPointerUpPos = new three_1.Vector2(event.screenX, event.screenY);
            if (currPointerUpPos.distanceTo(this.mouseDownPos) < 5.0) {
                if (this.underLine.visible) {
                    // 포인터 이벤트 제거
                    window.removeEventListener('pointerdown', this.pointerDownBinder);
                    window.removeEventListener('pointermove', this.pointerMoveBinder);
                    window.removeEventListener('pointerup', this.pointerUpBinder);
                    // 텍스트 숨기기
                    this.text.visible = false;
                    // 콜백 호출
                    this.onStart();
                }
            }
        }
    };
    return GameStarter;
}());
exports.GameStarter = GameStarter;


/***/ }),

/***/ "./src/gameTimer.ts":
/*!**************************!*\
  !*** ./src/gameTimer.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.GameTimer = void 0;
var three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
var FontData_Bold_Italic = __webpack_require__(/*! ./Open_Sans_Bold_Italic.json */ "./src/Open_Sans_Bold_Italic.json");
/**
 * 게임 시간 표시
 */
var GameTimer = /** @class */ (function () {
    /**
     * 생성자
     */
    function GameTimer(scene, camera, control) {
        var _this = this;
        this.scene = scene;
        this.camera = camera;
        this.control = control;
        this.remainTime = 300;
        this.timeCheck = 0;
        this.isPlaying = false;
        // 폰트 데이터
        var fontLoader = new three_1.FontLoader();
        this.fontData = fontLoader.parse(FontData_Bold_Italic);
        // geometry 생성
        this.longestInterval = 0;
        this.geometries = {};
        var textList = ['Time:', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        textList.forEach(function (text, i) {
            var geometry = new three_1.TextBufferGeometry(text, {
                font: _this.fontData,
                size: 2.5,
                height: 2
            });
            // geometry의 바운딩을 계산하여 중점으로 이동
            geometry.computeBoundingBox();
            var size = new three_1.Vector3();
            geometry.boundingBox.getSize(size);
            geometry.translate(size.x * -0.5, size.y * -0.5, size.z * -0.5);
            _this.geometries[text] = geometry;
            if (0 < i) {
                _this.longestInterval = Math.max(_this.longestInterval, size.x);
            }
        });
        // 공유재질
        this.sharedMaterial = new three_1.MeshPhongMaterial({
            color: 0x00ff00,
            specular: 0x00ff00,
            shininess: 100
        });
        // 루트 그룹
        this.rootGroup = new three_1.Group();
        this.scene.add(this.rootGroup);
        // 시간표시 가시화 객체 업데이트
        this.updateTimeMesh();
        this.initGameOverText();
    }
    /**
     * 게임 오버 텍스트 표시
     */
    GameTimer.prototype.initGameOverText = function () {
        var geometry = new three_1.TextBufferGeometry('GameOver', {
            font: this.fontData,
            size: 10,
            height: 2
        });
        // geometry의 바운딩을 계산하여 중점으로 이동
        geometry.computeBoundingBox();
        var size = new three_1.Vector3();
        geometry.boundingBox.getSize(size);
        geometry.translate(size.x * -0.5, size.y * -0.5, size.z * -0.5);
        var material = new three_1.MeshPhongMaterial({
            color: 0xff0000,
            specular: 0xff0000,
            shininess: 100
        });
        this.gameOverText = new three_1.Mesh(geometry, material);
        this.scene.add(this.gameOverText);
        this.gameOverText.visible = false;
    };
    /**
     * 시간표시 가시화 객체 업데이트
     */
    GameTimer.prototype.updateTimeMesh = function () {
        // 이전 가시화 객체 제거
        var childCount = this.rootGroup.children.length;
        for (var c = 0; c < childCount; c++) {
            var child = this.rootGroup.children[0];
            this.rootGroup.remove(child);
        }
        // 'Time:' 객체
        var mesh = new three_1.Mesh(this.geometries['Time:'], this.sharedMaterial);
        this.rootGroup.add(mesh);
        mesh.position.set(0, 0, 0);
        // Time 바운딩 계산
        var bBox = this.geometries['Time:'].boundingBox.clone();
        var center = new three_1.Vector3(), size = new three_1.Vector3();
        bBox.getCenter(center);
        bBox.getSize(size);
        // 공백처리
        var whiteSpace = new three_1.Vector3();
        this.geometries['0'].boundingBox.getSize(whiteSpace);
        // 남은 시간을 문자화하고 0번째부터 n번째까지 가시화 객체로 생성
        var strTime = this.remainTime.toString();
        for (var i = 0; i < strTime.length; i++) {
            // 생성
            mesh = new three_1.Mesh(this.geometries[strTime[i]], this.sharedMaterial);
            this.rootGroup.add(mesh);
            // 위치 설정
            mesh.position.x = center.x + (size.x * 0.5) + whiteSpace.x + (this.longestInterval * i);
            bBox.expandByObject(mesh);
        }
        // 위치 조정
        var minX = Number.MAX_VALUE, maxX = Number.MIN_VALUE, halfX = null;
        for (var i = 1; i < this.rootGroup.children.length; i++) {
            var child = this.rootGroup.children[i];
            var currBox = child.geometry.boundingBox.clone();
            currBox.translate(child.position);
            minX = Math.min(minX, currBox.min.x);
            maxX = Math.max(maxX, currBox.max.x);
        }
        halfX = (maxX - minX) * 0.5;
        for (var i = 0; i < this.rootGroup.children.length; i++) {
            var child = this.rootGroup.children[i];
            child.translateX(-halfX);
        }
    };
    /**
     * 업데이트
     */
    GameTimer.prototype.update = function (deltaTime) {
        if (this.sphere) {
            var camForward = new three_1.Vector3();
            this.camera.getWorldDirection(camForward);
            var target = this.control.target.clone();
            target.addScaledVector(camForward, this.sphere.radius);
            var plane = new three_1.Plane().setFromNormalAndCoplanarPoint(new three_1.Vector3(0, 1, 0), this.sphere.center);
            var project = new three_1.Vector3();
            plane.projectPoint(target, project);
            var direction = new three_1.Vector3().subVectors(project, this.control.target);
            direction.normalize();
            var result = this.control.target.clone();
            result.addScaledVector(direction, this.sphere.radius + 10);
            result.y -= 2.5;
            this.rootGroup.position.copy(result);
            this.rootGroup.lookAt(this.control.target);
            if (this.isPlaying) {
                this.timeCheck += deltaTime;
                if (this.timeCheck >= 1.0) {
                    this.timeCheck = 0;
                    this.remainTime--;
                    if (this.remainTime >= 0) {
                        this.updateTimeMesh();
                    }
                    else {
                        // 게임 오버 처리
                        this.isPlaying = false;
                        this.gameLogic.doGameOver();
                    }
                    // 시간 색상 처리
                    if (this.remainTime <= 30) {
                        this.sharedMaterial.color = new three_1.Color(0xff0000);
                    }
                    else if (this.remainTime <= 60) {
                        this.sharedMaterial.color = new three_1.Color(0xffad3a);
                    }
                    else {
                        this.sharedMaterial.color = new three_1.Color(0x00ff00);
                    }
                }
            }
            if (this.gameOverText && this.gameOverText.visible) {
                this.gameOverText.position.copy(result);
                this.gameOverText.position.y += 25;
                this.gameOverText.lookAt(this.control.target);
            }
        }
    };
    /**
     * 가시화 설정
     */
    GameTimer.prototype.setVisible = function (isVisible) {
        this.rootGroup.visible = isVisible;
    };
    /**
     * 게임로직 인스턴스 설정
     */
    GameTimer.prototype.setGameLogic = function (logic) {
        this.gameLogic = logic;
    };
    /**
     * 시간표시 관련 리셋 처리
     */
    GameTimer.prototype.reset = function () {
        this.isPlaying = true;
        this.remainTime = 300;
        this.timeCheck = 0;
        this.gameOverText.visible = false;
    };
    return GameTimer;
}());
exports.GameTimer = GameTimer;


/***/ }),

/***/ "./src/gamelogic.ts":
/*!**************************!*\
  !*** ./src/gamelogic.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.GameLogic = void 0;
var three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
var TWEEN = __webpack_require__(/*! @tweenjs/tween.js */ "./node_modules/@tweenjs/tween.js/dist/tween.esm.js");
var GameLogic = /** @class */ (function () {
    /**
     * 생성자
     */
    function GameLogic(scene, camera, control, board, modelMgr, scoreMgr, soundMgr, gameTimer) {
        this.scene = scene;
        this.camera = camera;
        this.control = control;
        this.board = board;
        this.modelMgr = modelMgr;
        this.scoreMgr = scoreMgr;
        this.soundMgr = soundMgr;
        this.gameTimer = gameTimer;
        this.isSpawning = false;
        // 픽킹요소 초기화
        this.rayCast = new three_1.Raycaster();
        this.mousePos = new three_1.Vector2();
        this.mouseDownPos = new three_1.Vector2();
        this.pointerDownBinder = this.onPointerDown.bind(this);
        this.pointerMoveBinder = this.onPointerMove.bind(this);
        this.pointerUpBinder = this.onPointerUp.bind(this);
        this.restartPointerUpBinder = this.restartPointerUp.bind(this);
    }
    /**
     * 기능 활성화
     */
    GameLogic.prototype.enable = function () {
        window.addEventListener('pointerdown', this.pointerDownBinder, false);
        window.addEventListener('pointermove', this.pointerMoveBinder, false);
        window.addEventListener('pointerup', this.pointerUpBinder, false);
    };
    /**
     * 기능 비활성화
     */
    GameLogic.prototype.disable = function () {
        this.disposeCursor();
        window.removeEventListener('pointerdown', this.pointerDownBinder);
        window.removeEventListener('pointermove', this.pointerMoveBinder);
        window.removeEventListener('pointerup', this.pointerUpBinder);
    };
    /**
     * 포인터 다운 이벤트 처리
     * @param event 마우스 이벤트
     */
    GameLogic.prototype.onPointerDown = function (event) {
        if (event.button === 0) { // 좌클릭, 1-터치
            this.mouseDownPos.x = event.screenX;
            this.mouseDownPos.y = event.screenY;
        }
    };
    /**
     * 포인터 이동 이벤트 처리
     */
    GameLogic.prototype.onPointerMove = function (event) {
        // ray 계산
        this.mousePos.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mousePos.y = -(event.clientY / window.innerHeight) * 2 + 1;
        this.rayCast.setFromCamera(this.mousePos, this.camera);
        // 보드판에 픽킹 처리를 한다.
        var intersects = this.rayCast.intersectObjects(this.board.pickPlates);
        if (intersects && intersects.length > 0 && !this.isSpawning) {
            var pickObject = intersects[0].object;
            var tile = pickObject.userData['linkedTile'];
            if (tile.level === 0) {
                if (this.cursor) {
                    this.cursor.position.copy(pickObject.position);
                    this.cursor.userData['pickedTile'] = tile;
                    this.scene.add(this.cursor);
                }
            }
            else {
                if (this.cursor) {
                    this.cursor.userData['pickedTile'] = null;
                    this.cursor.position.copy(pickObject.position);
                    this.scene.add(this.cursor);
                    this.scene.remove(this.cursor);
                }
            }
        }
        else {
            if (this.cursor) {
                this.cursor.userData['pickedTile'] = null;
                this.scene.remove(this.cursor);
            }
        }
        // 홀더 마우스 오버 처리
        this.tileHolder.pickTest(this.rayCast);
    };
    /**
     * 포인터 업 이벤트
     * @param event 포인터 이벤트
     */
    GameLogic.prototype.onPointerUp = function (event) {
        var _this = this;
        if (event.button === 0) {
            // 마우스 좌클릭의 경우 화면회전도 겸하므로
            // 포인터 다운 좌표와 업좌표사이 거리가 5.0픽셀 이하인경우 처리
            var currPointerUpPos = new three_1.Vector2(event.screenX, event.screenY);
            if (currPointerUpPos.distanceTo(this.mouseDownPos) < 5.0) {
                // 홀드 기능이 먼저 작동되었는지 체크
                if (this.tileHolder.pickTest(this.rayCast)) {
                    // 타일에 홀드할 타일레벨 설정
                    var prevLevel = this.tileHolder.setHoldTile(this.cursor.userData['level']);
                    // 새 커서 생성
                    this.createCursor(prevLevel);
                }
                else if (this.cursor && this.cursor.userData['pickedTile'] && this.cursor.userData['pickedTile'].level === 0) {
                    var targetTile_1 = this.cursor.userData['pickedTile'];
                    // 타일의 레벨을 커서객체 레벨로 설정
                    targetTile_1.level = this.cursor.userData['level'];
                    // 커서객체 메모리해제
                    var cloneObject = this.cursor.userData['sourceObject'];
                    cloneObject.position.copy(this.cursor.position);
                    this.scene.add(cloneObject);
                    this.disposeCursor();
                    // 타일에 설정되어있던 이전 타일 객체를 제거하고 복제한 새 모델을 할당
                    this.scene.remove(targetTile_1.object);
                    targetTile_1.object = cloneObject;
                    // 애니메이션 처리
                    this.isSpawning = true;
                    targetTile_1.object.position.y = -30;
                    new TWEEN.default.Tween(targetTile_1.object.position)
                        .to({
                        y: 0
                    }, 500)
                        .easing(TWEEN.default.Easing.Quadratic.Out)
                        .onComplete(function () {
                        // 3타일 매치 체크
                        _this.board.checkTriple(targetTile_1, 1);
                        _this.createCursor();
                        _this.onPointerMove(event);
                        _this.isSpawning = false;
                        // 게임오버 체크
                        _this.checkGameOver();
                    })
                        .start();
                    // 사운드재생
                    this.soundMgr.playSound('CreateBuilding');
                }
            }
        }
    };
    /**
     * 커서 객체 생성
     */
    GameLogic.prototype.createCursor = function (level) {
        var _this = this;
        if (!level) {
            //level = 1;//
            //level = this.getRandomTileNumber([40.0, 30.0, 20.0, 10.0]) + 1;
            level = this.getRandomTileNumber([30, 20, 14, 12, 10, 6, 4, 3, 1]) + 1;
        }
        var sourceObject = this.modelMgr.getModelByLevelNumber(level);
        // 원본 객체의 정보를 통해 새 객체 생성
        if (sourceObject) {
            this.disposeCursor();
            this.cursor = new three_1.Object3D();
            this.cursor.name = 'Cursor';
            sourceObject.traverse(function (child) {
                if (child instanceof three_1.Mesh) {
                    var cursorMaterial = null;
                    if (child.material instanceof Array) {
                        cursorMaterial = [];
                        for (var m = 0; m < child.material.length; m++) {
                            var matCursor = child.material[m].clone();
                            matCursor.transparent = true;
                            matCursor.opacity = 0.5;
                            cursorMaterial.push(matCursor);
                        }
                    }
                    else {
                        cursorMaterial = child.material.clone();
                        cursorMaterial.transparent = true;
                        cursorMaterial.opacity = 0.5;
                    }
                    var mesh = new three_1.Mesh(child.geometry, cursorMaterial);
                    _this.cursor.add(mesh);
                }
            });
            this.scene.add(this.cursor);
            this.cursor.userData['sourceObject'] = sourceObject;
            this.cursor.userData['level'] = level;
        }
    };
    /**
     * 확률을 적용하여 랜덤 타일 번호를 계산한다.
     * https://docs.unity3d.com/kr/530/Manual/RandomNumbers.html
     */
    GameLogic.prototype.getRandomTileNumber = function (ratios) {
        var total = 0;
        for (var i = 0; i < ratios.length; i++) {
            total += ratios[i];
        }
        var randomPoint = this.getRandomRange(0.0, 1.0) * total;
        for (var i = 0; i < ratios.length; i++) {
            if (randomPoint < ratios[i]) {
                return i;
            }
            else {
                randomPoint -= ratios[i];
            }
        }
        return ratios.length - 1;
    };
    /**
     * 최소, 최대를 포함하여 최소~최대사이의 난수 반환
     * @param min 최소
     * @param max 최대
     */
    GameLogic.prototype.getRandomRange = function (min, max) {
        return Math.random() * (max - min) + min;
    };
    /**
     * 커서 객체 메모리 해제
     */
    GameLogic.prototype.disposeCursor = function () {
        if (this.cursor) {
            this.scene.remove(this.cursor);
            this.cursor.traverse(function (child) {
                if (child instanceof three_1.Mesh) {
                    child.geometry.dispose();
                    if (child.material instanceof Array) {
                        for (var m = 0; m < child.material.length; m++) {
                            child.material[m].dispose();
                        }
                    }
                    else {
                        child.material.dispose();
                    }
                }
            });
        }
    };
    /**
     * 타일 홀더 인스턴스 설정
     */
    GameLogic.prototype.setTileHolder = function (holder) {
        this.tileHolder = holder;
    };
    /**
     * 게임오버 체크
     */
    GameLogic.prototype.checkGameOver = function () {
        var zeroCount = this.board.getTileCountByLevel(0);
        if (zeroCount === 0) {
            this.doGameOver();
        }
    };
    /**
     * 게임오버 처리
     */
    GameLogic.prototype.doGameOver = function () {
        this.control.autoRotate = true;
        this.control.enabled = false;
        // 홀드 텍스트 숨기기
        this.tileHolder.setVisible(false);
        // 하이스코어 업데이트
        this.scoreMgr.saveHighScore();
        // 시간 중지
        this.gameTimer.isPlaying = false;
        this.gameTimer.gameOverText.visible = true;
        this.disable();
        window.addEventListener('pointerup', this.restartPointerUpBinder, false);
    };
    /**
     * 재시작관련 포인터 처리
     */
    GameLogic.prototype.restartPointerUp = function (event) {
        if (confirm('Restart Game?')) {
            window.removeEventListener('pointerup', this.restartPointerUpBinder);
            this.control.autoRotate = false;
            this.control.enabled = true;
            this.tileHolder.disposeHolderObject();
            this.tileHolder.setVisible(true);
            this.gameTimer.reset();
            this.scoreMgr.setScore(0);
            // 보드판 초기화
            this.board.createMap(this.board.mapWidth, this.board.mapHeight);
            this.createCursor();
            this.enable();
        }
    };
    return GameLogic;
}());
exports.GameLogic = GameLogic;


/***/ }),

/***/ "./src/model.ts":
/*!**********************!*\
  !*** ./src/model.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ModelManager = void 0;
var three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
var MTLLoader_1 = __webpack_require__(/*! three/examples/jsm/loaders/MTLLoader */ "./node_modules/three/examples/jsm/loaders/MTLLoader.js");
var OBJLoader_1 = __webpack_require__(/*! three/examples/jsm/loaders/OBJLoader */ "./node_modules/three/examples/jsm/loaders/OBJLoader.js");
/**
 * 모델 관리 클래스
 */
var ModelManager = /** @class */ (function () {
    /**
     * 생성자
     */
    function ModelManager(scene, onReady) {
        this.scene = scene;
        this.models = {};
        // 건물 타일 로드
        var scope = this;
        new MTLLoader_1.MTLLoader().load('models/buildingtiles.mtl', function (materials) {
            materials.preload();
            new OBJLoader_1.OBJLoader().setMaterials(materials).load('models/buildingtiles.obj', function (object) {
                // 객체 그림자 On
                object.traverse(function (child) {
                    if (child instanceof three_1.Mesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                // 자식객체의 이름(레벨)을 분석하여 모델 스토리지에 저장
                for (var i = 0; i < object.children.length; i++) {
                    var child = object.children[i];
                    var name_1 = child.name.toLowerCase();
                    scope.models[name_1] = child;
                }
                if (onReady) {
                    onReady();
                }
            });
        });
    }
    /**
     * 레벨번호에 해당하는 모델을 반환
     * @param levelNo 레벨 번호
     */
    ModelManager.prototype.getModelByLevelNumber = function (levelNo) {
        var key = 'level' + levelNo;
        if (this.models.hasOwnProperty(key)) {
            // 모델의 Geometry와 Material정보로 새 Mesh를 생성하여 반환한다.
            if (this.models[key].material instanceof Array) {
                var source = this.models[key].material;
                var materials = [];
                for (var i = 0; i < source.length; i++) {
                    var material = new three_1.MeshPhongMaterial();
                    material.copy(source[i]);
                    materials.push(material);
                }
                var newMesh = new three_1.Mesh(this.models[key].geometry, materials);
                newMesh.castShadow = true;
                newMesh.receiveShadow = true;
                return newMesh;
            }
            else {
                var material = new three_1.MeshPhongMaterial();
                material.copy(this.models[key].material);
                var newMesh = new three_1.Mesh(this.models[key].geometry, material);
                newMesh.castShadow = true;
                newMesh.receiveShadow = true;
                return newMesh;
            }
        }
        else {
            return null;
        }
    };
    return ModelManager;
}());
exports.ModelManager = ModelManager;


/***/ }),

/***/ "./src/score.ts":
/*!**********************!*\
  !*** ./src/score.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ScoreManager = void 0;
var FontData_Bold_Italic = __webpack_require__(/*! ./Open_Sans_Bold_Italic.json */ "./src/Open_Sans_Bold_Italic.json");
var FontData_Bold = __webpack_require__(/*! ./Open_Sans_Bold.json */ "./src/Open_Sans_Bold.json");
var three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
var scorePopup_1 = __webpack_require__(/*! ./scorePopup */ "./src/scorePopup.ts");
/**
 * 점수 관리 클래스
 */
var ScoreManager = /** @class */ (function () {
    /**
     * 생성자
     */
    function ScoreManager(scene, camera, control) {
        var _this = this;
        this.scene = scene;
        this.camera = camera;
        this.control = control;
        this.score = 0;
        // localstorage에 저장되어 있는 하이스코어를 가져옴
        var storageHighScore = localStorage.getItem('highscore');
        if (!storageHighScore) { // 하이스코어가 없다면 처음실행한것이므로 기본값 설정
            localStorage.setItem('highscore', '0');
            this.highScore = 0;
        }
        else {
            this.highScore = parseInt(storageHighScore);
        }
        // 점수 테이블, 총 타일레벨은 10이지만 0레벨은 점수가 없으므로 9개만 세팅
        this.scoreTable = [];
        this.scoreTable.push(5);
        this.scoreTable.push(10);
        this.scoreTable.push(20);
        this.scoreTable.push(35);
        this.scoreTable.push(55);
        this.scoreTable.push(80);
        this.scoreTable.push(110);
        this.scoreTable.push(145);
        this.scoreTable.push(200);
        // 폰트 데이터를 로드하고 준비시킨다.
        var fontLoader = new three_1.FontLoader();
        this.fontData = fontLoader.parse(FontData_Bold_Italic);
        this.popupFontData = fontLoader.parse(FontData_Bold);
        // 사용할 텍스트 Geometry를 미리 생성해 놓는다.
        // 점수표시용
        this.resultScoreInterval = 0;
        var textList = ['Score:', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        this.geometries = {};
        textList.forEach(function (text, i) {
            var geometry = new three_1.TextBufferGeometry(text, {
                font: _this.fontData,
                size: 10,
                height: 2
            });
            // geometry의 바운딩을 계산하여 중점으로 이동
            geometry.computeBoundingBox();
            var size = new three_1.Vector3();
            geometry.boundingBox.getSize(size);
            geometry.translate(size.x * -0.5, size.y * -0.5, size.z * -0.5);
            _this.geometries[text] = geometry;
            if (0 < i) {
                _this.resultScoreInterval = Math.max(_this.resultScoreInterval, size.x);
            }
        });
        // 팝업 점수용
        var popupTextList = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'x'];
        this.popupGeometries = {};
        popupTextList.forEach(function (text) {
            var geometry = new three_1.TextBufferGeometry(text, {
                font: _this.popupFontData,
                size: 2,
                height: 1
            });
            // 중점
            geometry.computeBoundingBox();
            var size = new three_1.Vector3();
            geometry.boundingBox.getSize(size);
            geometry.translate(size.x * -0.5, size.y * -0.5, size.z * -0.5);
            // 콤보배율용 'x'는 좀더 작게 처리
            if (text === 'x') {
                geometry.scale(0.75, 0.75, 0.75);
            }
            _this.popupGeometries[text] = geometry;
        });
        // 팝업 효과 공유 재질
        this.sharedPopupMaterial = new three_1.MeshPhongMaterial({
            color: 0x996633,
            specular: 0x050505,
            shininess: 100
        });
        // 팝업 객체 리스트
        this.popupObjList = [];
        // 누적점수
        this.resultScoreSharedMaterial = new three_1.MeshPhongMaterial({ color: 0x0000ff });
        this.resultScoreRoot = new three_1.Group();
        this.scene.add(this.resultScoreRoot);
        this.updateScoreMesh();
        // 하이스코어
        this.highScoreRoot = new three_1.Group();
        this.scene.add(this.highScoreRoot);
        this.highScoreInterval = 0;
        var highScoreTextList = ['HighScore:', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        this.highScoreGeometries = {};
        highScoreTextList.forEach(function (text, i) {
            var geometry = new three_1.TextBufferGeometry(text, {
                font: _this.fontData,
                size: 3,
                height: 2
            });
            // geometry의 바운딩을 계산하여 중점으로 이동
            geometry.computeBoundingBox();
            var size = new three_1.Vector3();
            geometry.boundingBox.getSize(size);
            geometry.translate(size.x * -0.5, size.y * -0.5, size.z * -0.5);
            _this.highScoreGeometries[text] = geometry;
            if (0 < i) { // 문자 간격을 제일 큰 문자를 기준으로 처리
                _this.highScoreInterval = Math.max(_this.highScoreInterval, size.x);
            }
        });
        this.updateHighScoreMesh();
    }
    /**
     * 점수 관련 초기화
     */
    ScoreManager.prototype.reset = function () {
        this.score = 0;
    };
    /**
     * 지정된 숫자로 점수 설정
     * @param score 점수
     */
    ScoreManager.prototype.setScore = function (score) {
        this.score = score;
        this.updateScoreMesh();
    };
    /**
     * 타일레벨로 점수를 추가한다.
     * @param tile 레벨
     * @param comboRatio 콤보배율
     */
    ScoreManager.prototype.addScore = function (tile, comboRatio) {
        if (1 <= tile.level && tile.level <= 9) {
            var addScore = this.scoreTable[tile.level - 1];
            this.score += (addScore * comboRatio);
            // 팝업 효과 생성
            // 점수를 문자열로 변환하여 geometry 배열을 전달한다.
            var strScore = addScore.toString();
            var geometryArray = [];
            for (var i = 0; i < strScore.length; i++) {
                geometryArray.push(this.popupGeometries[strScore[i]]);
            }
            // 콤보 배율처리
            if (comboRatio > 1.0) {
                var strCombo = parseInt(comboRatio.toString()).toString();
                geometryArray.push(this.popupGeometries['x']);
                for (var i = 0; i < strCombo.length; i++) {
                    geometryArray.push(this.popupGeometries[strCombo[i]]);
                }
            }
            // 팝업효과 생성 위치 계산
            var box = new three_1.Box3().setFromObject(tile.object);
            var center = new three_1.Vector3(), size = new three_1.Vector3();
            box.getCenter(center);
            box.getSize(size);
            var spawnLocation = new three_1.Vector3();
            spawnLocation.copy(center);
            spawnLocation.y += (size.y * 0.5);
            // 팝업 효과 생성
            var popup = new scorePopup_1.ScorePopup(this.scene, geometryArray, this.sharedPopupMaterial, spawnLocation);
            this.popupObjList.push(popup);
            this.updateScoreMesh();
            if (this.score >= this.highScore) {
                this.highScore = this.score;
                this.saveHighScore();
                this.updateHighScoreMesh();
            }
        }
    };
    /**
     * 누적점수 가시화 객체를 업데이트 한다.
     */
    ScoreManager.prototype.updateScoreMesh = function () {
        // 이전 자식 객체 제거
        var childCount = this.resultScoreRoot.children.length;
        for (var i = 0; i < childCount; i++) {
            var child = this.resultScoreRoot.children[0];
            this.resultScoreRoot.remove(child);
        }
        // Score 객체 추가
        var mesh = new three_1.Mesh(this.geometries['Score:'], this.resultScoreSharedMaterial);
        this.resultScoreRoot.add(mesh);
        mesh.position.set(0, 0, 0);
        // Score 바운딩 계산
        var bBox = this.geometries['Score:'].boundingBox.clone();
        var scoreCenter = new three_1.Vector3(), scoreSize = new three_1.Vector3();
        bBox.getCenter(scoreCenter);
        bBox.getSize(scoreSize);
        // 시작지점 공백용사이즈를 '0'으로 계산
        var whiteSpaceSize = new three_1.Vector3();
        this.geometries['0'].boundingBox.getSize(whiteSpaceSize);
        // 점수 문자화를 하고 0번쨰부터 n번째까지 가시화 객체로 생성한다.
        var strScore = this.score.toString();
        for (var i = 0; i < strScore.length; i++) {
            // 생성
            mesh = new three_1.Mesh(this.geometries[strScore[i]], this.resultScoreSharedMaterial);
            this.resultScoreRoot.add(mesh);
            // 위치 설정
            mesh.position.x = scoreCenter.x + (scoreSize.x * 0.5) + whiteSpaceSize.x + (this.resultScoreInterval * i);
            bBox.expandByObject(mesh);
        }
        // 위치 조정
        var minX = Number.MAX_VALUE, maxX = Number.MIN_VALUE, halfX = null;
        for (var i = 1; i < this.resultScoreRoot.children.length; i++) {
            var child = this.resultScoreRoot.children[i];
            var currBox = child.geometry.boundingBox.clone();
            currBox.translate(child.position);
            minX = Math.min(minX, currBox.min.x);
            maxX = Math.max(maxX, currBox.max.x);
        }
        halfX = (maxX - minX) * 0.5;
        for (var i = 0; i < this.resultScoreRoot.children.length; i++) {
            var child = this.resultScoreRoot.children[i];
            child.translateX(-halfX);
        }
    };
    /**
     * 최대점수 가시화 객체를 업데이트 한다.
     */
    ScoreManager.prototype.updateHighScoreMesh = function () {
        // 이전 자식 객체 제거
        var childCount = this.highScoreRoot.children.length;
        for (var i = 0; i < childCount; i++) {
            var child = this.highScoreRoot.children[0];
            this.highScoreRoot.remove(child);
        }
        // Highscore 객체
        var mesh = new three_1.Mesh(this.highScoreGeometries['HighScore:'], this.resultScoreSharedMaterial);
        this.highScoreRoot.add(mesh);
        mesh.position.set(0, 0, 0);
        // highscore 바운딩 계산
        var bBox = this.highScoreGeometries['HighScore:'].boundingBox.clone();
        var scoreCenter = new three_1.Vector3(), scoreSize = new three_1.Vector3();
        bBox.getCenter(scoreCenter);
        bBox.getSize(scoreSize);
        // 시작지점 공백용사이즈를 '0'으로 계산
        var whiteSpaceSize = new three_1.Vector3();
        this.highScoreGeometries['0'].boundingBox.getSize(whiteSpaceSize);
        // 점수 문자화를 하고 0번쨰부터 n번째까지 가시화 객체로 생성한다.
        var strScore = this.highScore.toString();
        for (var i = 0; i < strScore.length; i++) {
            // 생성
            mesh = new three_1.Mesh(this.highScoreGeometries[strScore[i]], this.resultScoreSharedMaterial);
            this.highScoreRoot.add(mesh);
            // 위치 설정
            mesh.position.x = scoreCenter.x + (scoreSize.x * 0.5) + whiteSpaceSize.x + (this.highScoreInterval * i);
            mesh.position.y -= 1;
            bBox.expandByObject(mesh);
        }
        // 위치 조정
        var minX = Number.MAX_VALUE, maxX = Number.MIN_VALUE, halfX = null;
        for (var i = 1; i < this.highScoreRoot.children.length; i++) {
            var child = this.highScoreRoot.children[i];
            var currBox = child.geometry.boundingBox.clone();
            currBox.translate(child.position);
            minX = Math.min(minX, currBox.min.x);
            maxX = Math.max(maxX, currBox.max.x);
        }
        halfX = (maxX - minX) * 0.5;
        for (var i = 0; i < this.highScoreRoot.children.length; i++) {
            var child = this.highScoreRoot.children[i];
            child.translateX(-halfX);
        }
    };
    /**
     * 업데이트
     */
    ScoreManager.prototype.update = function (deltaTime) {
        if (this.sphere) {
            var camForward = new three_1.Vector3();
            this.camera.getWorldDirection(camForward);
            var target = this.control.target.clone();
            target.addScaledVector(camForward, this.sphere.radius);
            var plane = new three_1.Plane().setFromNormalAndCoplanarPoint(new three_1.Vector3(0, 1, 0), this.sphere.center);
            var project = new three_1.Vector3();
            plane.projectPoint(target, project);
            var direction = new three_1.Vector3().subVectors(project, this.control.target);
            direction.normalize();
            var result = this.control.target.clone();
            result.addScaledVector(direction, this.sphere.radius + 10);
            result.y += 10;
            this.resultScoreRoot.position.copy(result);
            this.resultScoreRoot.lookAt(this.control.target);
            this.highScoreRoot.position.copy(result);
            this.highScoreRoot.position.y -= 8;
            this.highScoreRoot.lookAt(this.control.target);
        }
        // 팝업 객체리스트를 역순으로 순회하며 애니메이션이 완료된 객체는 제거한다.
        var popupObjCount = this.popupObjList.length;
        for (var i = popupObjCount - 1; i >= 0; i--) {
            if (this.popupObjList[i].isDone) {
                this.popupObjList[i].dispose();
                this.popupObjList.splice(i, 1);
            }
        }
    };
    /**
     * 가시화 설정
     * @param isVisible 가시화 여부
     */
    ScoreManager.prototype.setVisible = function (isVisible) {
        this.resultScoreRoot.visible = isVisible;
        this.highScoreRoot.visible = isVisible;
    };
    /**
     * 하이스코어 저장
     */
    ScoreManager.prototype.saveHighScore = function () {
        localStorage.setItem('highscore', this.highScore.toString());
    };
    return ScoreManager;
}());
exports.ScoreManager = ScoreManager;


/***/ }),

/***/ "./src/scorePopup.ts":
/*!***************************!*\
  !*** ./src/scorePopup.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ScorePopup = void 0;
var three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
var TWEEN = __webpack_require__(/*! @tweenjs/tween.js */ "./node_modules/@tweenjs/tween.js/dist/tween.esm.js");
/**
 * 점수 팝업 효과 클래스
 */
var ScorePopup = /** @class */ (function () {
    /**
     * 생성자
     */
    function ScorePopup(scene, geometries, material, position) {
        this.scene = scene;
        this.isDone = false;
        // geometry 배열 개수만큼 객체 생성
        this.group = new three_1.Group();
        var prevBox = new three_1.Box3().makeEmpty();
        for (var i = 0; i < geometries.length; i++) {
            var mesh = new three_1.Mesh(geometries[i], material);
            if (prevBox.isEmpty()) {
                // 바운딩박스가 유효하지 않으면 현재 번째 바운딩 계산
                prevBox.setFromObject(mesh);
            }
            else {
                // 바운딩박스가 유효하면 이전 바운딩의 옆으로 이동                
                var prevCenter = new three_1.Vector3(), prevSize = new three_1.Vector3();
                prevBox.getCenter(prevCenter);
                prevBox.getSize(prevSize);
                var currBox = new three_1.Box3().setFromObject(mesh);
                var currCenter = new three_1.Vector3(), currSize = new three_1.Vector3();
                currBox.getCenter(currCenter);
                currBox.getSize(currSize);
                // 위치계산
                var targetX = 0;
                targetX = prevCenter.x + (prevSize.x * 0.5) + (currSize.x * 0.5);
                mesh.position.x = targetX;
                prevBox.setFromObject(mesh);
            }
            this.group.add(mesh);
        }
        // 자식 객체들 중점 이동
        var box = new three_1.Box3().setFromObject(this.group);
        var center = new three_1.Vector3();
        box.getCenter(center);
        for (var i = 0; i < this.group.children.length; i++) {
            var child = this.group.children[i];
            child.position.x -= center.x;
        }
        this.scene.add(this.group);
        this.group.position.copy(position);
        // 초기위치에서 +10정도까지 애니메이션 처리
        var targetHeight = this.group.position.y + 5;
        this.tween = new TWEEN.default.Tween(this.group.position)
            .to({
            y: targetHeight
        }, 500)
            .easing(TWEEN.default.Easing.Quadratic.Out)
            .onComplete(this.onAnimationComplete.bind(this))
            .start();
    }
    /**
     * 애니메이션 종료
     */
    ScorePopup.prototype.onAnimationComplete = function () {
        this.isDone = true;
    };
    /**
     * 메모리 해제
     */
    ScorePopup.prototype.dispose = function () {
        this.tween.stop();
        this.tween = null;
        this.scene.remove(this.group);
    };
    return ScorePopup;
}());
exports.ScorePopup = ScorePopup;


/***/ }),

/***/ "./src/soundManager.ts":
/*!*****************************!*\
  !*** ./src/soundManager.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SoundManager = void 0;
var three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/**
 * 사운드 관리자
 */
var SoundManager = /** @class */ (function () {
    /**
     * 생성자
     */
    function SoundManager(camera) {
        this.camera = camera;
        // 오디오 리스너 생성
        this.listener = new three_1.AudioListener();
        this.camera.add(this.listener);
        // 위치를 가지는 오디오는 아니므로 non-positional 오디오 생성
        var scope = this;
        this.sounds = {};
        var audioLoader = new three_1.AudioLoader();
        // 배경음악
        audioLoader.load('sounds/BGM.wav', function (buffer) {
            var sound = new three_1.Audio(scope.listener);
            sound.setBuffer(buffer);
            sound.setLoop(true); // 배경음은 반복재생
            sound.setVolume(0.25);
            scope.sounds['BGM'] = sound;
        }, null, function (err) {
            console.error(err);
        });
        // 건물 생성
        audioLoader.load('sounds/CreateBuilding.wav', function (buffer) {
            var sound = new three_1.Audio(scope.listener);
            sound.setBuffer(buffer);
            sound.setLoop(false);
            sound.setVolume(0.1);
            scope.sounds['CreateBuilding'] = sound;
        }, null, function (err) {
            console.error(err);
        });
        // 스코어취득
        audioLoader.load('sounds/Score.wav', function (buffer) {
            var sound = new three_1.Audio(scope.listener);
            sound.setBuffer(buffer);
            sound.setLoop(false);
            sound.setVolume(0.1);
            scope.sounds['Score'] = sound;
        }, null, function (err) {
            console.error(err);
        });
    }
    /**
     * 사운드재생
     * @param key 재생할 사운드 키값
     */
    SoundManager.prototype.playSound = function (key) {
        if (this.sounds.hasOwnProperty(key)) {
            this.sounds[key].play();
        }
    };
    return SoundManager;
}());
exports.SoundManager = SoundManager;


/***/ }),

/***/ "./src/tileHolder.ts":
/*!***************************!*\
  !*** ./src/tileHolder.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TileHolder = void 0;
var three_1 = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
var FontData_Bold_Italic = __webpack_require__(/*! ./Open_Sans_Bold_Italic.json */ "./src/Open_Sans_Bold_Italic.json");
/**
 * 타일 홀딩 기능
 */
var TileHolder = /** @class */ (function () {
    /**
     * 생성자
     * @param scene 씬 객체
     * @param camera 카메라
     * @param control 카메라 컨트롤러
     */
    function TileHolder(scene, camera, control, modelMgr) {
        this.scene = scene;
        this.camera = camera;
        this.control = control;
        this.modelMgr = modelMgr;
        this.rootGroup = new three_1.Group();
        this.scene.add(this.rootGroup);
        // 폰트관련 초기화 처리
        var fontLoader = new three_1.FontLoader();
        this.fontData = fontLoader.parse(FontData_Bold_Italic);
        // geometry 생성후 중점 이동
        this.geometry = new three_1.TextBufferGeometry('Hold:', {
            font: this.fontData,
            size: 8,
            height: 2
        });
        this.geometry.computeBoundingBox();
        var size = new three_1.Vector3();
        this.geometry.boundingBox.getSize(size);
        this.geometry.translate(size.x * -0.5, size.y * -0.5, size.z * -0.5);
        // 재질
        this.material = new three_1.MeshPhongMaterial({ color: 0x00ff00 });
        this.mesh = new three_1.Mesh(this.geometry, this.material);
        this.rootGroup.add(this.mesh);
        this.mesh.position.set(0, 0, 0);
        // 타일 홀더용 루트
        this.holderRoot = new three_1.Group();
        this.rootGroup.add(this.holderRoot);
        // 홀더 위치 설정
        var textBounding = new three_1.Box3().setFromObject(this.mesh);
        var textSize = new three_1.Vector3();
        textBounding.getSize(textSize);
        this.holderRoot.position.y -= 1;
        this.holderRoot.position.x = textSize.x * 0.5 + 10;
        // 언더라인
        var underLineGeometry = new three_1.BoxBufferGeometry(size.x, 2, 5);
        this.underLine = new three_1.Mesh(underLineGeometry, this.material);
        this.rootGroup.add(this.underLine);
        this.underLine.position.set(0, (size.y * -0.5) - 1.5, 0);
        this.underLine.visible = false;
    }
    /**
     * 위치 업데이트
     */
    TileHolder.prototype.update = function (deltaTime) {
        var camForward = new three_1.Vector3();
        this.camera.getWorldDirection(camForward);
        var target = this.control.target.clone();
        target.addScaledVector(camForward, this.boardSphere.radius);
        var plane = new three_1.Plane().setFromNormalAndCoplanarPoint(new three_1.Vector3(0, 1, 0), this.boardSphere.center);
        var project = new three_1.Vector3();
        plane.projectPoint(target, project);
        var direction = new three_1.Vector3().subVectors(project, this.control.target);
        direction.normalize();
        var result = this.control.target.clone();
        result.addScaledVector(direction, this.boardSphere.radius + 10);
        result.y += 20;
        this.rootGroup.position.copy(result);
        this.rootGroup.lookAt(this.control.target);
        this.holderPickSphere = new three_1.Sphere();
        new three_1.Box3().setFromObject(this.rootGroup).getBoundingSphere(this.holderPickSphere);
        if (this.holderObject) {
            this.holderObject.rotateY(Math.PI * deltaTime * 0.1);
        }
    };
    /**
     * 홀드 텍스트와 픽킹 처리
     */
    TileHolder.prototype.pickTest = function (rayCast) {
        // const intersects = rayCast.intersectObjects(this.rootGroup.children, true);
        // if( intersects && intersects.length > 0 ) {
        //     this.underLine.visible = true;
        //     return true;
        // } else {
        //     this.underLine.visible = false;
        //     return false;
        // }
        var dummy = new three_1.Vector3();
        if (rayCast.ray.intersectSphere(this.holderPickSphere, dummy)) {
            this.underLine.visible = true;
            return true;
        }
        else {
            this.underLine.visible = false;
            return false;
        }
    };
    /**
     * 타일 객체 홀드
     * @param level 타일 레벨
     * @returns 이전 타일 레벨
     */
    TileHolder.prototype.setHoldTile = function (level) {
        var _this = this;
        var prevHolderLevel = (this.holderObject) ? this.holderObject.userData['level'] : null;
        // 새 홀더 객체
        var sourceObject = this.modelMgr.getModelByLevelNumber(level);
        if (sourceObject) {
            // 이전에 생성되어 있던 홀더 객체 메모리 해제 처리
            if (this.holderObject) {
                this.disposeHolderObject();
            }
            this.holderObject = new three_1.Object3D();
            sourceObject.traverse(function (child) {
                if (child instanceof three_1.Mesh) {
                    var cursorMaterial = null;
                    if (child.material instanceof Array) {
                        cursorMaterial = [];
                        for (var m = 0; m < child.material.length; m++) {
                            var matCursor = child.material[m].clone();
                            cursorMaterial.push(matCursor);
                        }
                    }
                    else {
                        cursorMaterial = child.material.clone();
                    }
                    var mesh = new three_1.Mesh(child.geometry, cursorMaterial);
                    _this.holderObject.add(mesh);
                }
            });
            this.holderRoot.add(this.holderObject);
            this.holderObject.userData['level'] = level; // 타일 레벨 저장
        }
        return prevHolderLevel;
    };
    /**
     * 홀더 객체 메모리 해제
     */
    TileHolder.prototype.disposeHolderObject = function () {
        if (this.holderObject) {
            this.holderRoot.remove(this.holderObject);
            this.holderObject.traverse(function (child) {
                if (child instanceof three_1.Mesh) {
                    child.geometry.dispose();
                    if (child.material instanceof Array) {
                        for (var m = 0; m < child.material.length; m++) {
                            child.material[m].dispose();
                        }
                    }
                    else {
                        child.material.dispose();
                    }
                }
            });
            this.holderObject = null;
        }
    };
    /**
     * 객체 가시화 설정
     * @param isVisible 가시화 여부
     */
    TileHolder.prototype.setVisible = function (isVisible) {
        this.rootGroup.visible = isVisible;
    };
    return TileHolder;
}());
exports.TileHolder = TileHolder;


/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/entry.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./src/entry.ts */"./src/entry.ts");


/***/ })

/******/ });
//# sourceMappingURL=triplebuilder.js.map